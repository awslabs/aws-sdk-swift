// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessPointAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessPointAlreadyExists(accessPointId: \(Swift.String(describing: accessPointId)), errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension AccessPointAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessPointAlreadyExistsBody = try responseDecoder.decode(responseBody: data)
            self.accessPointId = output.accessPointId
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.accessPointId = nil
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the access point you are trying to create already exists, with the
///             creation token you provided in the request.
public struct AccessPointAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var accessPointId: Swift.String?
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        accessPointId: Swift.String? = nil,
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.accessPointId = accessPointId
        self.errorCode = errorCode
        self.message = message
    }
}

struct AccessPointAlreadyExistsBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
    public let accessPointId: Swift.String?
}

extension AccessPointAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointId = "AccessPointId"
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let accessPointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointId)
        accessPointId = accessPointIdDecoded
    }
}

extension EfsClientTypes.AccessPointDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointArn = "AccessPointArn"
        case accessPointId = "AccessPointId"
        case clientToken = "ClientToken"
        case fileSystemId = "FileSystemId"
        case lifeCycleState = "LifeCycleState"
        case name = "Name"
        case ownerId = "OwnerId"
        case posixUser = "PosixUser"
        case rootDirectory = "RootDirectory"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPointArn = accessPointArn {
            try encodeContainer.encode(accessPointArn, forKey: .accessPointArn)
        }
        if let accessPointId = accessPointId {
            try encodeContainer.encode(accessPointId, forKey: .accessPointId)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let lifeCycleState = lifeCycleState {
            try encodeContainer.encode(lifeCycleState.rawValue, forKey: .lifeCycleState)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let posixUser = posixUser {
            try encodeContainer.encode(posixUser, forKey: .posixUser)
        }
        if let rootDirectory = rootDirectory {
            try encodeContainer.encode(rootDirectory, forKey: .rootDirectory)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EfsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EfsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EfsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let accessPointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointId)
        accessPointId = accessPointIdDecoded
        let accessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let posixUserDecoded = try containerValues.decodeIfPresent(EfsClientTypes.PosixUser.self, forKey: .posixUser)
        posixUser = posixUserDecoded
        let rootDirectoryDecoded = try containerValues.decodeIfPresent(EfsClientTypes.RootDirectory.self, forKey: .rootDirectory)
        rootDirectory = rootDirectoryDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(EfsClientTypes.LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
    }
}

extension EfsClientTypes.AccessPointDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessPointDescription(accessPointArn: \(Swift.String(describing: accessPointArn)), accessPointId: \(Swift.String(describing: accessPointId)), clientToken: \(Swift.String(describing: clientToken)), fileSystemId: \(Swift.String(describing: fileSystemId)), lifeCycleState: \(Swift.String(describing: lifeCycleState)), name: \(Swift.String(describing: name)), ownerId: \(Swift.String(describing: ownerId)), posixUser: \(Swift.String(describing: posixUser)), rootDirectory: \(Swift.String(describing: rootDirectory)), tags: \(Swift.String(describing: tags)))"}
}

extension EfsClientTypes {
    /// Provides a description of an EFS file system access point.
    public struct AccessPointDescription: Swift.Equatable {
        /// The  unique Amazon Resource Name (ARN) associated with the access point.
        public let accessPointArn: Swift.String?
        /// The ID of the access point, assigned by Amazon EFS.
        public let accessPointId: Swift.String?
        /// The opaque string specified in the request to ensure idempotent creation.
        public let clientToken: Swift.String?
        /// The ID of the EFS file system that the access point applies to.
        public let fileSystemId: Swift.String?
        /// Identifies the lifecycle phase of the access point.
        public let lifeCycleState: EfsClientTypes.LifeCycleState?
        /// The name of the access point. This is the value of the Name tag.
        public let name: Swift.String?
        /// Identified the AWS account that owns the access point resource.
        public let ownerId: Swift.String?
        /// The full POSIX identity, including the user ID, group ID, and secondary group IDs on the access point that is used for all file operations by
        ///       NFS clients using the access point.
        public let posixUser: EfsClientTypes.PosixUser?
        /// The directory on the Amazon EFS file system that the access point exposes as the root directory to NFS clients using the access point.
        public let rootDirectory: EfsClientTypes.RootDirectory?
        /// The tags associated with the access point, presented as an array of Tag objects.
        public let tags: [EfsClientTypes.Tag]?

        public init (
            accessPointArn: Swift.String? = nil,
            accessPointId: Swift.String? = nil,
            clientToken: Swift.String? = nil,
            fileSystemId: Swift.String? = nil,
            lifeCycleState: EfsClientTypes.LifeCycleState? = nil,
            name: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            posixUser: EfsClientTypes.PosixUser? = nil,
            rootDirectory: EfsClientTypes.RootDirectory? = nil,
            tags: [EfsClientTypes.Tag]? = nil
        )
        {
            self.accessPointArn = accessPointArn
            self.accessPointId = accessPointId
            self.clientToken = clientToken
            self.fileSystemId = fileSystemId
            self.lifeCycleState = lifeCycleState
            self.name = name
            self.ownerId = ownerId
            self.posixUser = posixUser
            self.rootDirectory = rootDirectory
            self.tags = tags
        }
    }

}

extension AccessPointLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessPointLimitExceeded(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension AccessPointLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessPointLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the AWS account has already created the maximum number of access points
///             allowed per file system.
public struct AccessPointLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct AccessPointLimitExceededBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension AccessPointLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessPointNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessPointNotFound(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension AccessPointNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessPointNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the specified AccessPointId value doesn't exist in the
///             requester's AWS account.
public struct AccessPointNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct AccessPointNotFoundBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension AccessPointNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AvailabilityZonesMismatch: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AvailabilityZonesMismatch(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension AvailabilityZonesMismatch {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AvailabilityZonesMismatchBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the Availability Zone that was specified for a mount target is different from the Availability Zone that was specified for One Zone storage classes.
///             For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/availability-durability.html">Regional and One Zone storage redundancy.
public struct AvailabilityZonesMismatch: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct AvailabilityZonesMismatchBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension AvailabilityZonesMismatchBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EfsClientTypes.BackupPolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(EfsClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension EfsClientTypes.BackupPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupPolicy(status: \(Swift.String(describing: status)))"}
}

extension EfsClientTypes {
    /// The backup policy for the file system used to create automatic daily backups. If status has a value of
    ///       ENABLED, the file system is being automatically backed up. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/awsbackup.html#automatic-backups">Automatic backups.
    public struct BackupPolicy: Swift.Equatable {
        /// Describes the status of the file system's backup policy.
        ///
        ///
        ///
        ///
        ///                      ENABLED
        ///                    - EFS is automatically backing up the file system.
        ///
        ///
        ///
        ///
        ///                      ENABLING
        ///                    - EFS is turning on automatic backups for the file system.
        ///
        ///
        ///
        ///
        ///                      DISABLED
        ///                    - automatic back ups are turned off for the file system.
        ///
        ///
        ///
        ///
        ///                      DISABLING
        ///                    - EFS is turning off automatic backups for the file system.
        ///
        ///
        /// This member is required.
        public let status: EfsClientTypes.Status?

        public init (
            status: EfsClientTypes.Status? = nil
        )
        {
            self.status = status
        }
    }

}

extension BadRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BadRequest(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension BadRequest {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the request is malformed or contains an error such as an invalid
///             parameter value or a missing required parameter.
public struct BadRequest: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct BadRequestBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension BadRequestBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateAccessPointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAccessPointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAccessPointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAccessPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAccessPointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAccessPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAccessPointOutputError>
}

extension CreateAccessPointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAccessPointInput(clientToken: \(Swift.String(describing: clientToken)), fileSystemId: \(Swift.String(describing: fileSystemId)), posixUser: \(Swift.String(describing: posixUser)), rootDirectory: \(Swift.String(describing: rootDirectory)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateAccessPointInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case fileSystemId = "FileSystemId"
        case posixUser = "PosixUser"
        case rootDirectory = "RootDirectory"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let posixUser = posixUser {
            try encodeContainer.encode(posixUser, forKey: .posixUser)
        }
        if let rootDirectory = rootDirectory {
            try encodeContainer.encode(rootDirectory, forKey: .rootDirectory)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateAccessPointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAccessPointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAccessPointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAccessPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAccessPointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAccessPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAccessPointOutputError>
}

public struct CreateAccessPointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAccessPointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAccessPointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAccessPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAccessPointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAccessPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAccessPointOutputError>
}

public struct CreateAccessPointInput: Swift.Equatable {
    /// A string of up to 64 ASCII characters that Amazon EFS uses to ensure idempotent
    ///       creation.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The ID of the EFS file system that the access point provides access to.
    /// This member is required.
    public let fileSystemId: Swift.String?
    /// The operating system user and
    ///       group applied to all file system requests made using the access point.
    public let posixUser: EfsClientTypes.PosixUser?
    /// Specifies the directory on the Amazon EFS file system that the access point exposes as
    ///       the root directory of your file system to NFS clients using the access point.
    ///       The clients using the access point can only access the root directory and below.
    ///       If the RootDirectory > Path specified does not exist,
    ///       EFS creates it and applies the CreationInfo settings when a client connects to an access point.
    ///       When specifying a RootDirectory, you need to provide the Path, and the CreationInfo.
    ///          Amazon EFS creates a root directory only if you have provided the  CreationInfo: OwnUid, OwnGID, and permissions for the directory.
    ///       If  you do not provide this information, Amazon EFS does not create the root directory. If the root directory does not exist, attempts to mount
    ///       using the access point will fail.
    public let rootDirectory: EfsClientTypes.RootDirectory?
    /// Creates tags associated with the access point. Each tag is a key-value pair.
    public let tags: [EfsClientTypes.Tag]?

    public init (
        clientToken: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        posixUser: EfsClientTypes.PosixUser? = nil,
        rootDirectory: EfsClientTypes.RootDirectory? = nil,
        tags: [EfsClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.fileSystemId = fileSystemId
        self.posixUser = posixUser
        self.rootDirectory = rootDirectory
        self.tags = tags
    }
}

struct CreateAccessPointInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let tags: [EfsClientTypes.Tag]?
    public let fileSystemId: Swift.String?
    public let posixUser: EfsClientTypes.PosixUser?
    public let rootDirectory: EfsClientTypes.RootDirectory?
}

extension CreateAccessPointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case fileSystemId = "FileSystemId"
        case posixUser = "PosixUser"
        case rootDirectory = "RootDirectory"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EfsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EfsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EfsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let posixUserDecoded = try containerValues.decodeIfPresent(EfsClientTypes.PosixUser.self, forKey: .posixUser)
        posixUser = posixUserDecoded
        let rootDirectoryDecoded = try containerValues.decodeIfPresent(EfsClientTypes.RootDirectory.self, forKey: .rootDirectory)
        rootDirectory = rootDirectoryDecoded
    }
}

extension CreateAccessPointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccessPointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessPointAlreadyExists" : self = .accessPointAlreadyExists(try AccessPointAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccessPointLimitExceeded" : self = .accessPointLimitExceeded(try AccessPointLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectFileSystemLifeCycleState" : self = .incorrectFileSystemLifeCycleState(try IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAccessPointOutputError: Swift.Error, Swift.Equatable {
    case accessPointAlreadyExists(AccessPointAlreadyExists)
    case accessPointLimitExceeded(AccessPointLimitExceeded)
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case incorrectFileSystemLifeCycleState(IncorrectFileSystemLifeCycleState)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccessPointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAccessPointOutputResponse(accessPointArn: \(Swift.String(describing: accessPointArn)), accessPointId: \(Swift.String(describing: accessPointId)), clientToken: \(Swift.String(describing: clientToken)), fileSystemId: \(Swift.String(describing: fileSystemId)), lifeCycleState: \(Swift.String(describing: lifeCycleState)), name: \(Swift.String(describing: name)), ownerId: \(Swift.String(describing: ownerId)), posixUser: \(Swift.String(describing: posixUser)), rootDirectory: \(Swift.String(describing: rootDirectory)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateAccessPointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAccessPointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPointArn = output.accessPointArn
            self.accessPointId = output.accessPointId
            self.clientToken = output.clientToken
            self.fileSystemId = output.fileSystemId
            self.lifeCycleState = output.lifeCycleState
            self.name = output.name
            self.ownerId = output.ownerId
            self.posixUser = output.posixUser
            self.rootDirectory = output.rootDirectory
            self.tags = output.tags
        } else {
            self.accessPointArn = nil
            self.accessPointId = nil
            self.clientToken = nil
            self.fileSystemId = nil
            self.lifeCycleState = nil
            self.name = nil
            self.ownerId = nil
            self.posixUser = nil
            self.rootDirectory = nil
            self.tags = nil
        }
    }
}

/// Provides a description of an EFS file system access point.
public struct CreateAccessPointOutputResponse: Swift.Equatable {
    /// The  unique Amazon Resource Name (ARN) associated with the access point.
    public let accessPointArn: Swift.String?
    /// The ID of the access point, assigned by Amazon EFS.
    public let accessPointId: Swift.String?
    /// The opaque string specified in the request to ensure idempotent creation.
    public let clientToken: Swift.String?
    /// The ID of the EFS file system that the access point applies to.
    public let fileSystemId: Swift.String?
    /// Identifies the lifecycle phase of the access point.
    public let lifeCycleState: EfsClientTypes.LifeCycleState?
    /// The name of the access point. This is the value of the Name tag.
    public let name: Swift.String?
    /// Identified the AWS account that owns the access point resource.
    public let ownerId: Swift.String?
    /// The full POSIX identity, including the user ID, group ID, and secondary group IDs on the access point that is used for all file operations by
    ///       NFS clients using the access point.
    public let posixUser: EfsClientTypes.PosixUser?
    /// The directory on the Amazon EFS file system that the access point exposes as the root directory to NFS clients using the access point.
    public let rootDirectory: EfsClientTypes.RootDirectory?
    /// The tags associated with the access point, presented as an array of Tag objects.
    public let tags: [EfsClientTypes.Tag]?

    public init (
        accessPointArn: Swift.String? = nil,
        accessPointId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        lifeCycleState: EfsClientTypes.LifeCycleState? = nil,
        name: Swift.String? = nil,
        ownerId: Swift.String? = nil,
        posixUser: EfsClientTypes.PosixUser? = nil,
        rootDirectory: EfsClientTypes.RootDirectory? = nil,
        tags: [EfsClientTypes.Tag]? = nil
    )
    {
        self.accessPointArn = accessPointArn
        self.accessPointId = accessPointId
        self.clientToken = clientToken
        self.fileSystemId = fileSystemId
        self.lifeCycleState = lifeCycleState
        self.name = name
        self.ownerId = ownerId
        self.posixUser = posixUser
        self.rootDirectory = rootDirectory
        self.tags = tags
    }
}

struct CreateAccessPointOutputResponseBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let name: Swift.String?
    public let tags: [EfsClientTypes.Tag]?
    public let accessPointId: Swift.String?
    public let accessPointArn: Swift.String?
    public let fileSystemId: Swift.String?
    public let posixUser: EfsClientTypes.PosixUser?
    public let rootDirectory: EfsClientTypes.RootDirectory?
    public let ownerId: Swift.String?
    public let lifeCycleState: EfsClientTypes.LifeCycleState?
}

extension CreateAccessPointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointArn = "AccessPointArn"
        case accessPointId = "AccessPointId"
        case clientToken = "ClientToken"
        case fileSystemId = "FileSystemId"
        case lifeCycleState = "LifeCycleState"
        case name = "Name"
        case ownerId = "OwnerId"
        case posixUser = "PosixUser"
        case rootDirectory = "RootDirectory"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EfsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EfsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EfsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let accessPointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointId)
        accessPointId = accessPointIdDecoded
        let accessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let posixUserDecoded = try containerValues.decodeIfPresent(EfsClientTypes.PosixUser.self, forKey: .posixUser)
        posixUser = posixUserDecoded
        let rootDirectoryDecoded = try containerValues.decodeIfPresent(EfsClientTypes.RootDirectory.self, forKey: .rootDirectory)
        rootDirectory = rootDirectoryDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(EfsClientTypes.LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
    }
}

public struct CreateFileSystemInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFileSystemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFileSystemOutputError>
}

extension CreateFileSystemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFileSystemInput(availabilityZoneName: \(Swift.String(describing: availabilityZoneName)), backup: \(Swift.String(describing: backup)), creationToken: \(Swift.String(describing: creationToken)), encrypted: \(Swift.String(describing: encrypted)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), performanceMode: \(Swift.String(describing: performanceMode)), provisionedThroughputInMibps: \(Swift.String(describing: provisionedThroughputInMibps)), tags: \(Swift.String(describing: tags)), throughputMode: \(Swift.String(describing: throughputMode)))"}
}

extension CreateFileSystemInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneName = "AvailabilityZoneName"
        case backup = "Backup"
        case creationToken = "CreationToken"
        case encrypted = "Encrypted"
        case kmsKeyId = "KmsKeyId"
        case performanceMode = "PerformanceMode"
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case tags = "Tags"
        case throughputMode = "ThroughputMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZoneName = availabilityZoneName {
            try encodeContainer.encode(availabilityZoneName, forKey: .availabilityZoneName)
        }
        if let backup = backup {
            try encodeContainer.encode(backup, forKey: .backup)
        }
        if let creationToken = creationToken {
            try encodeContainer.encode(creationToken, forKey: .creationToken)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let performanceMode = performanceMode {
            try encodeContainer.encode(performanceMode.rawValue, forKey: .performanceMode)
        }
        if let provisionedThroughputInMibps = provisionedThroughputInMibps {
            try encodeContainer.encode(provisionedThroughputInMibps, forKey: .provisionedThroughputInMibps)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let throughputMode = throughputMode {
            try encodeContainer.encode(throughputMode.rawValue, forKey: .throughputMode)
        }
    }
}

public struct CreateFileSystemInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFileSystemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFileSystemOutputError>
}

public struct CreateFileSystemInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFileSystemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFileSystemOutputError>
}

public struct CreateFileSystemInput: Swift.Equatable {
    /// Used to create a file system that uses One Zone storage classes. It specifies the AWS
    ///       Availability Zone in which to create the file system. Use the format us-east-1a
    ///       to specify the Availability Zone. For
    ///       more information about One Zone storage classes, see <a href="https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html">Using EFS storage classes in the Amazon EFS User Guide.
    ///
    ///             One Zone storage classes are not available in all Availability Zones in AWS Regions where
    ///         Amazon EFS is available.
    ///
    public let availabilityZoneName: Swift.String?
    /// Specifies whether automatic backups are enabled on the file system that you are creating.
    ///       Set the value to true to enable automatic backups. If you are creating a file
    ///       system that uses One Zone storage classes, automatic backups are enabled by default. For more
    ///       information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/awsbackup.html#automatic-backups">Automatic backups in the
    ///         Amazon EFS User Guide.
    ///          Default is false. However, if you specify an AvailabilityZoneName,
    ///       the default is true.
    ///
    ///             AWS Backup is not available in all AWS Regions where Amazon EFS is available.
    ///
    public let backup: Swift.Bool?
    /// A string of up to 64 ASCII characters. Amazon EFS uses this to ensure idempotent
    ///       creation.
    /// This member is required.
    public var creationToken: Swift.String?
    /// A Boolean value that, if true, creates an encrypted file system. When creating an
    ///       encrypted file system, you have the option of specifying CreateFileSystemRequest$KmsKeyId for an existing AWS Key Management Service (AWS
    ///       KMS) customer master key (CMK). If you don't specify a CMK, then the default CMK for
    ///       Amazon EFS, /aws/elasticfilesystem, is used to protect the encrypted file system.
    ///
    public let encrypted: Swift.Bool?
    /// The ID of the AWS KMS CMK that you want to use to protect the encrypted file system. This
    ///       parameter is only required if you want to use a non-default KMS key. If this parameter is not
    ///       specified, the default CMK for Amazon EFS is used. This ID can be in one of the following
    ///       formats:
    ///
    ///
    ///                Key ID - A unique identifier of the key, for example
    ///             1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    ///
    ///                ARN - An Amazon Resource Name (ARN) for the key, for example
    ///             arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    ///
    ///                Key alias - A previously created display name for a key, for example
    ///             alias/projectKey1.
    ///
    ///
    ///                Key alias ARN - An ARN for a key alias, for example
    ///             arn:aws:kms:us-west-2:444455556666:alias/projectKey1.
    ///
    ///
    ///          If KmsKeyId is specified, the CreateFileSystemRequest$Encrypted parameter must be set to true.
    ///
    ///             EFS accepts only symmetric KMS keys. You cannot use asymmetric KMS keys with EFS file systems.
    ///
    public let kmsKeyId: Swift.String?
    /// The performance mode of the file system. We recommend generalPurpose
    ///       performance mode for most file systems. File systems using the maxIO performance
    ///       mode can scale to higher levels of aggregate throughput and operations per second with a
    ///       tradeoff of slightly higher latencies for most file operations. The performance mode
    ///       can't be changed after the file system has been created.
    ///
    ///             The maxIO mode is not supported on file systems using One Zone storage classes.
    ///
    public let performanceMode: EfsClientTypes.PerformanceMode?
    /// The throughput, measured in MiB/s, that you want to provision for a file system that
    ///       you're creating. Valid values are 1-1024. Required if ThroughputMode is set
    ///       to provisioned. The upper limit for throughput is 1024 MiB/s. To increase this
    ///       limit, contact AWS Support. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/limits.html#soft-limits">Amazon EFS quotas that you can increase
    ///       in the Amazon EFS User Guide.
    public let provisionedThroughputInMibps: Swift.Double?
    /// A value that specifies to create one or more tags associated with the file system. Each
    ///         tag is a user-defined key-value pair. Name your file system on creation by including a
    ///           "Key":"Name","Value":"{value}" key-value pair.
    public let tags: [EfsClientTypes.Tag]?
    /// Specifies the throughput mode for the file system, either bursting or
    ///         provisioned. If you set ThroughputMode to
    ///       provisioned, you must also set a value for
    ///         ProvisionedThroughputInMibps. After you create the file system, you can
    ///       decrease your file system's throughput in Provisioned Throughput mode or change between
    ///       the throughput modes, as long as its been more than 24 hours since the last decrease or
    ///       throughput mode change. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/performance.html#provisioned-throughput">Specifying throughput with
    ///         provisioned mode in the Amazon EFS User Guide.
    ///          Default is bursting.
    public let throughputMode: EfsClientTypes.ThroughputMode?

    public init (
        availabilityZoneName: Swift.String? = nil,
        backup: Swift.Bool? = nil,
        creationToken: Swift.String? = nil,
        encrypted: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        performanceMode: EfsClientTypes.PerformanceMode? = nil,
        provisionedThroughputInMibps: Swift.Double? = nil,
        tags: [EfsClientTypes.Tag]? = nil,
        throughputMode: EfsClientTypes.ThroughputMode? = nil
    )
    {
        self.availabilityZoneName = availabilityZoneName
        self.backup = backup
        self.creationToken = creationToken
        self.encrypted = encrypted
        self.kmsKeyId = kmsKeyId
        self.performanceMode = performanceMode
        self.provisionedThroughputInMibps = provisionedThroughputInMibps
        self.tags = tags
        self.throughputMode = throughputMode
    }
}

struct CreateFileSystemInputBody: Swift.Equatable {
    public let creationToken: Swift.String?
    public let performanceMode: EfsClientTypes.PerformanceMode?
    public let encrypted: Swift.Bool?
    public let kmsKeyId: Swift.String?
    public let throughputMode: EfsClientTypes.ThroughputMode?
    public let provisionedThroughputInMibps: Swift.Double?
    public let availabilityZoneName: Swift.String?
    public let backup: Swift.Bool?
    public let tags: [EfsClientTypes.Tag]?
}

extension CreateFileSystemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneName = "AvailabilityZoneName"
        case backup = "Backup"
        case creationToken = "CreationToken"
        case encrypted = "Encrypted"
        case kmsKeyId = "KmsKeyId"
        case performanceMode = "PerformanceMode"
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case tags = "Tags"
        case throughputMode = "ThroughputMode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationToken)
        creationToken = creationTokenDecoded
        let performanceModeDecoded = try containerValues.decodeIfPresent(EfsClientTypes.PerformanceMode.self, forKey: .performanceMode)
        performanceMode = performanceModeDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let throughputModeDecoded = try containerValues.decodeIfPresent(EfsClientTypes.ThroughputMode.self, forKey: .throughputMode)
        throughputMode = throughputModeDecoded
        let provisionedThroughputInMibpsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .provisionedThroughputInMibps)
        provisionedThroughputInMibps = provisionedThroughputInMibpsDecoded
        let availabilityZoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneName)
        availabilityZoneName = availabilityZoneNameDecoded
        let backupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .backup)
        backup = backupDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EfsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EfsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EfsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFileSystemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFileSystemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemAlreadyExists" : self = .fileSystemAlreadyExists(try FileSystemAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemLimitExceeded" : self = .fileSystemLimitExceeded(try FileSystemLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientThroughputCapacity" : self = .insufficientThroughputCapacity(try InsufficientThroughputCapacity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThroughputLimitExceeded" : self = .throughputLimitExceeded(try ThroughputLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedAvailabilityZone" : self = .unsupportedAvailabilityZone(try UnsupportedAvailabilityZone(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFileSystemOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case fileSystemAlreadyExists(FileSystemAlreadyExists)
    case fileSystemLimitExceeded(FileSystemLimitExceeded)
    case insufficientThroughputCapacity(InsufficientThroughputCapacity)
    case internalServerError(InternalServerError)
    case throughputLimitExceeded(ThroughputLimitExceeded)
    case unsupportedAvailabilityZone(UnsupportedAvailabilityZone)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFileSystemOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFileSystemOutputResponse(availabilityZoneId: \(Swift.String(describing: availabilityZoneId)), availabilityZoneName: \(Swift.String(describing: availabilityZoneName)), creationTime: \(Swift.String(describing: creationTime)), creationToken: \(Swift.String(describing: creationToken)), encrypted: \(Swift.String(describing: encrypted)), fileSystemArn: \(Swift.String(describing: fileSystemArn)), fileSystemId: \(Swift.String(describing: fileSystemId)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), lifeCycleState: \(Swift.String(describing: lifeCycleState)), name: \(Swift.String(describing: name)), numberOfMountTargets: \(Swift.String(describing: numberOfMountTargets)), ownerId: \(Swift.String(describing: ownerId)), performanceMode: \(Swift.String(describing: performanceMode)), provisionedThroughputInMibps: \(Swift.String(describing: provisionedThroughputInMibps)), sizeInBytes: \(Swift.String(describing: sizeInBytes)), tags: \(Swift.String(describing: tags)), throughputMode: \(Swift.String(describing: throughputMode)))"}
}

extension CreateFileSystemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFileSystemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.availabilityZoneId = output.availabilityZoneId
            self.availabilityZoneName = output.availabilityZoneName
            self.creationTime = output.creationTime
            self.creationToken = output.creationToken
            self.encrypted = output.encrypted
            self.fileSystemArn = output.fileSystemArn
            self.fileSystemId = output.fileSystemId
            self.kmsKeyId = output.kmsKeyId
            self.lifeCycleState = output.lifeCycleState
            self.name = output.name
            self.numberOfMountTargets = output.numberOfMountTargets
            self.ownerId = output.ownerId
            self.performanceMode = output.performanceMode
            self.provisionedThroughputInMibps = output.provisionedThroughputInMibps
            self.sizeInBytes = output.sizeInBytes
            self.tags = output.tags
            self.throughputMode = output.throughputMode
        } else {
            self.availabilityZoneId = nil
            self.availabilityZoneName = nil
            self.creationTime = nil
            self.creationToken = nil
            self.encrypted = nil
            self.fileSystemArn = nil
            self.fileSystemId = nil
            self.kmsKeyId = nil
            self.lifeCycleState = nil
            self.name = nil
            self.numberOfMountTargets = 0
            self.ownerId = nil
            self.performanceMode = nil
            self.provisionedThroughputInMibps = nil
            self.sizeInBytes = nil
            self.tags = nil
            self.throughputMode = nil
        }
    }
}

/// A description of the file system.
public struct CreateFileSystemOutputResponse: Swift.Equatable {
    /// The unique and consistent identifier of the Availability Zone in which the file system's
    ///       One Zone storage classes exist. For example, use1-az1 is an Availability Zone ID
    ///       for the us-east-1 AWS Region, and it has the same location in every AWS account.
    public let availabilityZoneId: Swift.String?
    /// Describes the AWS Availability Zone in which the file system is located, and is valid only
    ///       for file systems using One Zone storage classes. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html">Using EFS storage classes
    ///       in the Amazon EFS User Guide.
    public let availabilityZoneName: Swift.String?
    /// The time that the file system was created, in seconds (since
    ///       1970-01-01T00:00:00Z).
    /// This member is required.
    public let creationTime: ClientRuntime.Date?
    /// The opaque string specified in the request.
    /// This member is required.
    public let creationToken: Swift.String?
    /// A Boolean value that, if true, indicates that the file system is encrypted.
    public let encrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) for the EFS file system, in the format
    ///       arn:aws:elasticfilesystem:region:account-id:file-system/file-system-id
    ///             .
    ///       Example with sample data: arn:aws:elasticfilesystem:us-west-2:1111333322228888:file-system/fs-01234567
    ///
    public let fileSystemArn: Swift.String?
    /// The ID of the file system, assigned by Amazon EFS.
    /// This member is required.
    public let fileSystemId: Swift.String?
    /// The ID of an AWS Key Management Service (AWS KMS) customer master key (CMK) that was
    ///       used to protect the encrypted file system.
    public let kmsKeyId: Swift.String?
    /// The lifecycle phase of the file system.
    /// This member is required.
    public let lifeCycleState: EfsClientTypes.LifeCycleState?
    /// You can add tags to a file system, including a Name tag. For more
    ///       information, see CreateFileSystem. If the file system has a Name tag, Amazon EFS returns
    ///       the value in this field.
    public let name: Swift.String?
    /// The current number of mount targets that the file system has. For more information, see CreateMountTarget.
    /// This member is required.
    public let numberOfMountTargets: Swift.Int
    /// The AWS account that created the file system. If the file system was created by an IAM
    ///       user, the parent account to which the user belongs is the owner.
    /// This member is required.
    public let ownerId: Swift.String?
    /// The performance mode of the file system.
    /// This member is required.
    public let performanceMode: EfsClientTypes.PerformanceMode?
    /// The amount of provisioned throughput, measured in MiB/s, for the file system. Valid for
    ///       file systems using ThroughputMode set to provisioned.
    public let provisionedThroughputInMibps: Swift.Double?
    /// The latest known metered size (in bytes) of data stored in the file system, in its
    ///         Value field, and the time at which that size was determined in its
    ///         Timestamp field. The Timestamp value is the integer number of
    ///       seconds since 1970-01-01T00:00:00Z. The SizeInBytes value doesn't represent
    ///       the size of a consistent snapshot of the file system, but it is eventually consistent when
    ///       there are no writes to the file system. That is, SizeInBytes represents actual
    ///       size only if the file system is not modified for a period longer than a couple of hours.
    ///       Otherwise, the value is not the exact size that the file system was at any point in time.
    ///
    /// This member is required.
    public let sizeInBytes: EfsClientTypes.FileSystemSize?
    /// The tags associated with the file system, presented as an array of Tag
    ///       objects.
    /// This member is required.
    public let tags: [EfsClientTypes.Tag]?
    /// Displays the file system's throughput mode. For more information, see
    ///       <a href="https://docs.aws.amazon.com/efs/latest/ug/performance.html#throughput-modes">Throughput modes
    ///       in the Amazon EFS User Guide.
    ///
    public let throughputMode: EfsClientTypes.ThroughputMode?

    public init (
        availabilityZoneId: Swift.String? = nil,
        availabilityZoneName: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        creationToken: Swift.String? = nil,
        encrypted: Swift.Bool? = nil,
        fileSystemArn: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        lifeCycleState: EfsClientTypes.LifeCycleState? = nil,
        name: Swift.String? = nil,
        numberOfMountTargets: Swift.Int = 0,
        ownerId: Swift.String? = nil,
        performanceMode: EfsClientTypes.PerformanceMode? = nil,
        provisionedThroughputInMibps: Swift.Double? = nil,
        sizeInBytes: EfsClientTypes.FileSystemSize? = nil,
        tags: [EfsClientTypes.Tag]? = nil,
        throughputMode: EfsClientTypes.ThroughputMode? = nil
    )
    {
        self.availabilityZoneId = availabilityZoneId
        self.availabilityZoneName = availabilityZoneName
        self.creationTime = creationTime
        self.creationToken = creationToken
        self.encrypted = encrypted
        self.fileSystemArn = fileSystemArn
        self.fileSystemId = fileSystemId
        self.kmsKeyId = kmsKeyId
        self.lifeCycleState = lifeCycleState
        self.name = name
        self.numberOfMountTargets = numberOfMountTargets
        self.ownerId = ownerId
        self.performanceMode = performanceMode
        self.provisionedThroughputInMibps = provisionedThroughputInMibps
        self.sizeInBytes = sizeInBytes
        self.tags = tags
        self.throughputMode = throughputMode
    }
}

struct CreateFileSystemOutputResponseBody: Swift.Equatable {
    public let ownerId: Swift.String?
    public let creationToken: Swift.String?
    public let fileSystemId: Swift.String?
    public let fileSystemArn: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let lifeCycleState: EfsClientTypes.LifeCycleState?
    public let name: Swift.String?
    public let numberOfMountTargets: Swift.Int
    public let sizeInBytes: EfsClientTypes.FileSystemSize?
    public let performanceMode: EfsClientTypes.PerformanceMode?
    public let encrypted: Swift.Bool?
    public let kmsKeyId: Swift.String?
    public let throughputMode: EfsClientTypes.ThroughputMode?
    public let provisionedThroughputInMibps: Swift.Double?
    public let availabilityZoneName: Swift.String?
    public let availabilityZoneId: Swift.String?
    public let tags: [EfsClientTypes.Tag]?
}

extension CreateFileSystemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneId = "AvailabilityZoneId"
        case availabilityZoneName = "AvailabilityZoneName"
        case creationTime = "CreationTime"
        case creationToken = "CreationToken"
        case encrypted = "Encrypted"
        case fileSystemArn = "FileSystemArn"
        case fileSystemId = "FileSystemId"
        case kmsKeyId = "KmsKeyId"
        case lifeCycleState = "LifeCycleState"
        case name = "Name"
        case numberOfMountTargets = "NumberOfMountTargets"
        case ownerId = "OwnerId"
        case performanceMode = "PerformanceMode"
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case sizeInBytes = "SizeInBytes"
        case tags = "Tags"
        case throughputMode = "ThroughputMode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let creationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationToken)
        creationToken = creationTokenDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let fileSystemArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemArn)
        fileSystemArn = fileSystemArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(EfsClientTypes.LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let numberOfMountTargetsDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfMountTargets)
        numberOfMountTargets = numberOfMountTargetsDecoded
        let sizeInBytesDecoded = try containerValues.decodeIfPresent(EfsClientTypes.FileSystemSize.self, forKey: .sizeInBytes)
        sizeInBytes = sizeInBytesDecoded
        let performanceModeDecoded = try containerValues.decodeIfPresent(EfsClientTypes.PerformanceMode.self, forKey: .performanceMode)
        performanceMode = performanceModeDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let throughputModeDecoded = try containerValues.decodeIfPresent(EfsClientTypes.ThroughputMode.self, forKey: .throughputMode)
        throughputMode = throughputModeDecoded
        let provisionedThroughputInMibpsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .provisionedThroughputInMibps)
        provisionedThroughputInMibps = provisionedThroughputInMibpsDecoded
        let availabilityZoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneName)
        availabilityZoneName = availabilityZoneNameDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EfsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EfsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EfsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateMountTargetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMountTargetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMountTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMountTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMountTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMountTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMountTargetOutputError>
}

extension CreateMountTargetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMountTargetInput(fileSystemId: \(Swift.String(describing: fileSystemId)), ipAddress: \(Swift.String(describing: ipAddress)), securityGroups: \(Swift.String(describing: securityGroups)), subnetId: \(Swift.String(describing: subnetId)))"}
}

extension CreateMountTargetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemId = "FileSystemId"
        case ipAddress = "IpAddress"
        case securityGroups = "SecurityGroups"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroups0 in securityGroups {
                try securityGroupsContainer.encode(securitygroups0)
            }
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }
}

public struct CreateMountTargetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMountTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMountTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMountTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMountTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMountTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMountTargetOutputError>
}

public struct CreateMountTargetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMountTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMountTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMountTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMountTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMountTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMountTargetOutputError>
}

///
public struct CreateMountTargetInput: Swift.Equatable {
    /// The ID of the file system for which to create the mount target.
    /// This member is required.
    public let fileSystemId: Swift.String?
    /// Valid IPv4 address within the address range of the specified subnet.
    public let ipAddress: Swift.String?
    /// Up to five VPC security group IDs, of the form sg-xxxxxxxx. These must be
    ///       for the same VPC as subnet specified.
    public let securityGroups: [Swift.String]?
    /// The ID of the subnet to add the mount target in. For file systems that use One Zone storage classes, use the subnet
    ///     that is associated with the file system's Availability Zone.
    /// This member is required.
    public let subnetId: Swift.String?

    public init (
        fileSystemId: Swift.String? = nil,
        ipAddress: Swift.String? = nil,
        securityGroups: [Swift.String]? = nil,
        subnetId: Swift.String? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.ipAddress = ipAddress
        self.securityGroups = securityGroups
        self.subnetId = subnetId
    }
}

struct CreateMountTargetInputBody: Swift.Equatable {
    public let fileSystemId: Swift.String?
    public let subnetId: Swift.String?
    public let ipAddress: Swift.String?
    public let securityGroups: [Swift.String]?
}

extension CreateMountTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemId = "FileSystemId"
        case ipAddress = "IpAddress"
        case securityGroups = "SecurityGroups"
        case subnetId = "SubnetId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
    }
}

extension CreateMountTargetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMountTargetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AvailabilityZonesMismatch" : self = .availabilityZonesMismatch(try AvailabilityZonesMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectFileSystemLifeCycleState" : self = .incorrectFileSystemLifeCycleState(try IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IpAddressInUse" : self = .ipAddressInUse(try IpAddressInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MountTargetConflict" : self = .mountTargetConflict(try MountTargetConflict(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NetworkInterfaceLimitExceeded" : self = .networkInterfaceLimitExceeded(try NetworkInterfaceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoFreeAddressesInSubnet" : self = .noFreeAddressesInSubnet(try NoFreeAddressesInSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SecurityGroupLimitExceeded" : self = .securityGroupLimitExceeded(try SecurityGroupLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SecurityGroupNotFound" : self = .securityGroupNotFound(try SecurityGroupNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetNotFound" : self = .subnetNotFound(try SubnetNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedAvailabilityZone" : self = .unsupportedAvailabilityZone(try UnsupportedAvailabilityZone(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMountTargetOutputError: Swift.Error, Swift.Equatable {
    case availabilityZonesMismatch(AvailabilityZonesMismatch)
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case incorrectFileSystemLifeCycleState(IncorrectFileSystemLifeCycleState)
    case internalServerError(InternalServerError)
    case ipAddressInUse(IpAddressInUse)
    case mountTargetConflict(MountTargetConflict)
    case networkInterfaceLimitExceeded(NetworkInterfaceLimitExceeded)
    case noFreeAddressesInSubnet(NoFreeAddressesInSubnet)
    case securityGroupLimitExceeded(SecurityGroupLimitExceeded)
    case securityGroupNotFound(SecurityGroupNotFound)
    case subnetNotFound(SubnetNotFound)
    case unsupportedAvailabilityZone(UnsupportedAvailabilityZone)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMountTargetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMountTargetOutputResponse(availabilityZoneId: \(Swift.String(describing: availabilityZoneId)), availabilityZoneName: \(Swift.String(describing: availabilityZoneName)), fileSystemId: \(Swift.String(describing: fileSystemId)), ipAddress: \(Swift.String(describing: ipAddress)), lifeCycleState: \(Swift.String(describing: lifeCycleState)), mountTargetId: \(Swift.String(describing: mountTargetId)), networkInterfaceId: \(Swift.String(describing: networkInterfaceId)), ownerId: \(Swift.String(describing: ownerId)), subnetId: \(Swift.String(describing: subnetId)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension CreateMountTargetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMountTargetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.availabilityZoneId = output.availabilityZoneId
            self.availabilityZoneName = output.availabilityZoneName
            self.fileSystemId = output.fileSystemId
            self.ipAddress = output.ipAddress
            self.lifeCycleState = output.lifeCycleState
            self.mountTargetId = output.mountTargetId
            self.networkInterfaceId = output.networkInterfaceId
            self.ownerId = output.ownerId
            self.subnetId = output.subnetId
            self.vpcId = output.vpcId
        } else {
            self.availabilityZoneId = nil
            self.availabilityZoneName = nil
            self.fileSystemId = nil
            self.ipAddress = nil
            self.lifeCycleState = nil
            self.mountTargetId = nil
            self.networkInterfaceId = nil
            self.ownerId = nil
            self.subnetId = nil
            self.vpcId = nil
        }
    }
}

/// Provides a description of a mount target.
public struct CreateMountTargetOutputResponse: Swift.Equatable {
    /// The unique and consistent identifier of the Availability Zone that the mount target resides in.
    ///       For example, use1-az1 is an AZ ID for the us-east-1 Region and it has the same location in every AWS account.
    public let availabilityZoneId: Swift.String?
    /// The name of the Availability Zone in which the mount target is located. Availability Zones are
    ///       independently mapped to names for each AWS account. For example, the Availability Zone
    ///       us-east-1a for your AWS account might not be the same location as us-east-1a for another AWS account.
    public let availabilityZoneName: Swift.String?
    /// The ID of the file system for which the mount target is intended.
    /// This member is required.
    public let fileSystemId: Swift.String?
    /// Address at which the file system can be mounted by using the mount target.
    public let ipAddress: Swift.String?
    /// Lifecycle state of the mount target.
    /// This member is required.
    public let lifeCycleState: EfsClientTypes.LifeCycleState?
    /// System-assigned mount target ID.
    /// This member is required.
    public let mountTargetId: Swift.String?
    /// The ID of the network interface that Amazon EFS created when it created the mount
    ///       target.
    public let networkInterfaceId: Swift.String?
    /// AWS account ID that owns the resource.
    public let ownerId: Swift.String?
    /// The ID of the mount target's subnet.
    /// This member is required.
    public let subnetId: Swift.String?
    /// The virtual private cloud (VPC) ID that the mount target is configured in.
    public let vpcId: Swift.String?

    public init (
        availabilityZoneId: Swift.String? = nil,
        availabilityZoneName: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        ipAddress: Swift.String? = nil,
        lifeCycleState: EfsClientTypes.LifeCycleState? = nil,
        mountTargetId: Swift.String? = nil,
        networkInterfaceId: Swift.String? = nil,
        ownerId: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.availabilityZoneId = availabilityZoneId
        self.availabilityZoneName = availabilityZoneName
        self.fileSystemId = fileSystemId
        self.ipAddress = ipAddress
        self.lifeCycleState = lifeCycleState
        self.mountTargetId = mountTargetId
        self.networkInterfaceId = networkInterfaceId
        self.ownerId = ownerId
        self.subnetId = subnetId
        self.vpcId = vpcId
    }
}

struct CreateMountTargetOutputResponseBody: Swift.Equatable {
    public let ownerId: Swift.String?
    public let mountTargetId: Swift.String?
    public let fileSystemId: Swift.String?
    public let subnetId: Swift.String?
    public let lifeCycleState: EfsClientTypes.LifeCycleState?
    public let ipAddress: Swift.String?
    public let networkInterfaceId: Swift.String?
    public let availabilityZoneId: Swift.String?
    public let availabilityZoneName: Swift.String?
    public let vpcId: Swift.String?
}

extension CreateMountTargetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneId = "AvailabilityZoneId"
        case availabilityZoneName = "AvailabilityZoneName"
        case fileSystemId = "FileSystemId"
        case ipAddress = "IpAddress"
        case lifeCycleState = "LifeCycleState"
        case mountTargetId = "MountTargetId"
        case networkInterfaceId = "NetworkInterfaceId"
        case ownerId = "OwnerId"
        case subnetId = "SubnetId"
        case vpcId = "VpcId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let mountTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountTargetId)
        mountTargetId = mountTargetIdDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(EfsClientTypes.LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let availabilityZoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneName)
        availabilityZoneName = availabilityZoneNameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

public struct CreateTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTagsOutputError>
}

extension CreateTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTagsInput(fileSystemId: \(Swift.String(describing: fileSystemId)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateTagsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTagsOutputError>
}

public struct CreateTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTagsOutputError>
}

///
public struct CreateTagsInput: Swift.Equatable {
    /// The ID of the file system whose tags you want to modify (String). This operation modifies
    ///       the tags only, not the file system.
    /// This member is required.
    public let fileSystemId: Swift.String?
    /// An array of Tag objects to add. Each Tag object is a key-value
    ///       pair.
    /// This member is required.
    public let tags: [EfsClientTypes.Tag]?

    public init (
        fileSystemId: Swift.String? = nil,
        tags: [EfsClientTypes.Tag]? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.tags = tags
    }
}

struct CreateTagsInputBody: Swift.Equatable {
    public let tags: [EfsClientTypes.Tag]?
}

extension CreateTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([EfsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EfsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EfsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTagsOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTagsOutputResponse()"}
}

extension CreateTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateTagsOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateTagsOutputResponseBody: Swift.Equatable {
}

extension CreateTagsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension EfsClientTypes.CreationInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ownerGid = "OwnerGid"
        case ownerUid = "OwnerUid"
        case permissions = "Permissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ownerGid = ownerGid {
            try encodeContainer.encode(ownerGid, forKey: .ownerGid)
        }
        if let ownerUid = ownerUid {
            try encodeContainer.encode(ownerUid, forKey: .ownerUid)
        }
        if let permissions = permissions {
            try encodeContainer.encode(permissions, forKey: .permissions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerUidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ownerUid)
        ownerUid = ownerUidDecoded
        let ownerGidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ownerGid)
        ownerGid = ownerGidDecoded
        let permissionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissions)
        permissions = permissionsDecoded
    }
}

extension EfsClientTypes.CreationInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreationInfo(ownerGid: \(Swift.String(describing: ownerGid)), ownerUid: \(Swift.String(describing: ownerUid)), permissions: \(Swift.String(describing: permissions)))"}
}

extension EfsClientTypes {
    /// Required if the RootDirectory > Path specified does not exist.
    ///       Specifies the POSIX IDs and permissions to apply to the access point's RootDirectory > Path.
    ///       If the access point root directory does not exist, EFS creates it with these settings when a client connects to the access point.
    ///       When specifying CreationInfo, you must include values for all properties.
    ///
    ///          Amazon EFS creates a root directory only if you have provided the  CreationInfo: OwnUid, OwnGID, and permissions for the directory.
    ///       If  you do not provide this information, Amazon EFS does not create the root directory. If the root directory does not exist, attempts to mount
    ///       using the access point will fail.
    ///
    ///             If you do not provide CreationInfo and the specified RootDirectory does not exist,
    ///       attempts to mount the file system using the access point will fail.
    ///
    public struct CreationInfo: Swift.Equatable {
        /// Specifies the POSIX group ID to apply to the RootDirectory. Accepts values from 0 to 2^32 (4294967295).
        /// This member is required.
        public let ownerGid: Swift.Int?
        /// Specifies the POSIX user ID to apply to the RootDirectory. Accepts values from 0 to 2^32 (4294967295).
        /// This member is required.
        public let ownerUid: Swift.Int?
        /// Specifies the POSIX permissions to apply to the RootDirectory, in the format of an octal number representing the file's mode bits.
        /// This member is required.
        public let permissions: Swift.String?

        public init (
            ownerGid: Swift.Int? = nil,
            ownerUid: Swift.Int? = nil,
            permissions: Swift.String? = nil
        )
        {
            self.ownerGid = ownerGid
            self.ownerUid = ownerUid
            self.permissions = permissions
        }
    }

}

extension DeleteAccessPointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAccessPointInput(accessPointId: \(Swift.String(describing: accessPointId)))"}
}

extension DeleteAccessPointInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAccessPointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAccessPointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAccessPointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAccessPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAccessPointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAccessPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAccessPointOutputError>
}

public struct DeleteAccessPointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAccessPointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAccessPointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAccessPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAccessPointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAccessPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAccessPointOutputError>
}

public struct DeleteAccessPointInput: Swift.Equatable {
    /// The ID of the access point that you want to delete.
    /// This member is required.
    public let accessPointId: Swift.String?

    public init (
        accessPointId: Swift.String? = nil
    )
    {
        self.accessPointId = accessPointId
    }
}

struct DeleteAccessPointInputBody: Swift.Equatable {
}

extension DeleteAccessPointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccessPointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccessPointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessPointNotFound" : self = .accessPointNotFound(try AccessPointNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccessPointOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFound(AccessPointNotFound)
    case badRequest(BadRequest)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessPointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAccessPointOutputResponse()"}
}

extension DeleteAccessPointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessPointOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAccessPointOutputResponseBody: Swift.Equatable {
}

extension DeleteAccessPointOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFileSystemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFileSystemInput(fileSystemId: \(Swift.String(describing: fileSystemId)))"}
}

extension DeleteFileSystemInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteFileSystemInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFileSystemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFileSystemOutputError>
}

public struct DeleteFileSystemInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFileSystemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFileSystemOutputError>
}

///
public struct DeleteFileSystemInput: Swift.Equatable {
    /// The ID of the file system you want to delete.
    /// This member is required.
    public let fileSystemId: Swift.String?

    public init (
        fileSystemId: Swift.String? = nil
    )
    {
        self.fileSystemId = fileSystemId
    }
}

struct DeleteFileSystemInputBody: Swift.Equatable {
}

extension DeleteFileSystemInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFileSystemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFileSystemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemInUse" : self = .fileSystemInUse(try FileSystemInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFileSystemOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case fileSystemInUse(FileSystemInUse)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFileSystemOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFileSystemOutputResponse()"}
}

extension DeleteFileSystemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFileSystemOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFileSystemOutputResponseBody: Swift.Equatable {
}

extension DeleteFileSystemOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFileSystemPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFileSystemPolicyInput(fileSystemId: \(Swift.String(describing: fileSystemId)))"}
}

extension DeleteFileSystemPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteFileSystemPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFileSystemPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFileSystemPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFileSystemPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFileSystemPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFileSystemPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFileSystemPolicyOutputError>
}

public struct DeleteFileSystemPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFileSystemPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFileSystemPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFileSystemPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFileSystemPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFileSystemPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFileSystemPolicyOutputError>
}

public struct DeleteFileSystemPolicyInput: Swift.Equatable {
    /// Specifies the EFS file system for which to delete the FileSystemPolicy.
    /// This member is required.
    public let fileSystemId: Swift.String?

    public init (
        fileSystemId: Swift.String? = nil
    )
    {
        self.fileSystemId = fileSystemId
    }
}

struct DeleteFileSystemPolicyInputBody: Swift.Equatable {
}

extension DeleteFileSystemPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFileSystemPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFileSystemPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectFileSystemLifeCycleState" : self = .incorrectFileSystemLifeCycleState(try IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFileSystemPolicyOutputError: Swift.Error, Swift.Equatable {
    case fileSystemNotFound(FileSystemNotFound)
    case incorrectFileSystemLifeCycleState(IncorrectFileSystemLifeCycleState)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFileSystemPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFileSystemPolicyOutputResponse()"}
}

extension DeleteFileSystemPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFileSystemPolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFileSystemPolicyOutputResponseBody: Swift.Equatable {
}

extension DeleteFileSystemPolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMountTargetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMountTargetInput(mountTargetId: \(Swift.String(describing: mountTargetId)))"}
}

extension DeleteMountTargetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteMountTargetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMountTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMountTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMountTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMountTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMountTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMountTargetOutputError>
}

public struct DeleteMountTargetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMountTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMountTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMountTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMountTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMountTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMountTargetOutputError>
}

///
public struct DeleteMountTargetInput: Swift.Equatable {
    /// The ID of the mount target to delete (String).
    /// This member is required.
    public let mountTargetId: Swift.String?

    public init (
        mountTargetId: Swift.String? = nil
    )
    {
        self.mountTargetId = mountTargetId
    }
}

struct DeleteMountTargetInputBody: Swift.Equatable {
}

extension DeleteMountTargetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMountTargetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMountTargetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyTimeout" : self = .dependencyTimeout(try DependencyTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MountTargetNotFound" : self = .mountTargetNotFound(try MountTargetNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMountTargetOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case dependencyTimeout(DependencyTimeout)
    case internalServerError(InternalServerError)
    case mountTargetNotFound(MountTargetNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMountTargetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMountTargetOutputResponse()"}
}

extension DeleteMountTargetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMountTargetOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteMountTargetOutputResponseBody: Swift.Equatable {
}

extension DeleteMountTargetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTagsOutputError>
}

extension DeleteTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTagsInput(fileSystemId: \(Swift.String(describing: fileSystemId)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension DeleteTagsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

public struct DeleteTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTagsOutputError>
}

public struct DeleteTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTagsOutputError>
}

///
public struct DeleteTagsInput: Swift.Equatable {
    /// The ID of the file system whose tags you want to delete (String).
    /// This member is required.
    public let fileSystemId: Swift.String?
    /// A list of tag keys to delete.
    /// This member is required.
    public let tagKeys: [Swift.String]?

    public init (
        fileSystemId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.tagKeys = tagKeys
    }
}

struct DeleteTagsInputBody: Swift.Equatable {
    public let tagKeys: [Swift.String]?
}

extension DeleteTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension DeleteTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTagsOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTagsOutputResponse()"}
}

extension DeleteTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTagsOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteTagsOutputResponseBody: Swift.Equatable {
}

extension DeleteTagsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DependencyTimeout: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DependencyTimeout(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension DependencyTimeout {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DependencyTimeoutBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service timed out trying to fulfill the request, and the client should try the
///             call again.
public struct DependencyTimeout: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct DependencyTimeoutBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension DependencyTimeoutBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DescribeAccessPointsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAccessPointsInput(accessPointId: \(Swift.String(describing: accessPointId)), fileSystemId: \(Swift.String(describing: fileSystemId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeAccessPointsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeAccessPointsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccessPointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccessPointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccessPointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccessPointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccessPointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccessPointsOutputError>
}

public struct DescribeAccessPointsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccessPointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccessPointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccessPointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let accessPointId = input.operationInput.accessPointId {
            let accessPointIdQueryItem = ClientRuntime.URLQueryItem(name: "AccessPointId".urlPercentEncoding(), value: Swift.String(accessPointId).urlPercentEncoding())
            input.builder.withQueryItem(accessPointIdQueryItem)
        }
        if let fileSystemId = input.operationInput.fileSystemId {
            let fileSystemIdQueryItem = ClientRuntime.URLQueryItem(name: "FileSystemId".urlPercentEncoding(), value: Swift.String(fileSystemId).urlPercentEncoding())
            input.builder.withQueryItem(fileSystemIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccessPointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccessPointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccessPointsOutputError>
}

public struct DescribeAccessPointsInput: Swift.Equatable {
    /// (Optional) Specifies an EFS access point to describe in the response; mutually exclusive with FileSystemId.
    public let accessPointId: Swift.String?
    /// (Optional) If you provide a FileSystemId, EFS returns all access points for that file system; mutually exclusive with AccessPointId.
    public let fileSystemId: Swift.String?
    /// (Optional) When retrieving all access points for a file system,
    ///       you can optionally specify the MaxItems parameter to limit the number of objects returned in a response.
    ///       The default value is 100.
    public let maxResults: Swift.Int?
    ///
    ///             NextToken is present if the response is paginated. You can use NextMarker in the subsequent request to fetch the next page of access point descriptions.
    public let nextToken: Swift.String?

    public init (
        accessPointId: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPointId = accessPointId
        self.fileSystemId = fileSystemId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAccessPointsInputBody: Swift.Equatable {
}

extension DescribeAccessPointsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccessPointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccessPointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessPointNotFound" : self = .accessPointNotFound(try AccessPointNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccessPointsOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFound(AccessPointNotFound)
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccessPointsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAccessPointsOutputResponse(accessPoints: \(Swift.String(describing: accessPoints)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeAccessPointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAccessPointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPoints = output.accessPoints
            self.nextToken = output.nextToken
        } else {
            self.accessPoints = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAccessPointsOutputResponse: Swift.Equatable {
    /// An array of access point descriptions.
    public let accessPoints: [EfsClientTypes.AccessPointDescription]?
    /// Present if there are more access points than returned in the response.
    ///       You can use the NextMarker in the subsequent request to fetch the additional descriptions.
    public let nextToken: Swift.String?

    public init (
        accessPoints: [EfsClientTypes.AccessPointDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPoints = accessPoints
        self.nextToken = nextToken
    }
}

struct DescribeAccessPointsOutputResponseBody: Swift.Equatable {
    public let accessPoints: [EfsClientTypes.AccessPointDescription]?
    public let nextToken: Swift.String?
}

extension DescribeAccessPointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPoints = "AccessPoints"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPointsContainer = try containerValues.decodeIfPresent([EfsClientTypes.AccessPointDescription?].self, forKey: .accessPoints)
        var accessPointsDecoded0:[EfsClientTypes.AccessPointDescription]? = nil
        if let accessPointsContainer = accessPointsContainer {
            accessPointsDecoded0 = [EfsClientTypes.AccessPointDescription]()
            for structure0 in accessPointsContainer {
                if let structure0 = structure0 {
                    accessPointsDecoded0?.append(structure0)
                }
            }
        }
        accessPoints = accessPointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeAccountPreferencesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccountPreferencesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccountPreferencesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccountPreferencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccountPreferencesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccountPreferencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccountPreferencesOutputError>
}

extension DescribeAccountPreferencesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAccountPreferencesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeAccountPreferencesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeAccountPreferencesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccountPreferencesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccountPreferencesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccountPreferencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccountPreferencesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccountPreferencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccountPreferencesOutputError>
}

public struct DescribeAccountPreferencesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccountPreferencesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccountPreferencesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccountPreferencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccountPreferencesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccountPreferencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccountPreferencesOutputError>
}

public struct DescribeAccountPreferencesInput: Swift.Equatable {
    /// Max results used for pagination.
    public let maxResults: Swift.Int?
    /// Token used for pagination.
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAccountPreferencesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeAccountPreferencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeAccountPreferencesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountPreferencesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountPreferencesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountPreferencesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAccountPreferencesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resourceIdPreference: \(Swift.String(describing: resourceIdPreference)))"}
}

extension DescribeAccountPreferencesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAccountPreferencesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceIdPreference = output.resourceIdPreference
        } else {
            self.nextToken = nil
            self.resourceIdPreference = nil
        }
    }
}

public struct DescribeAccountPreferencesOutputResponse: Swift.Equatable {
    /// Token used for pagination.
    public let nextToken: Swift.String?
    public let resourceIdPreference: EfsClientTypes.ResourceIdPreference?

    public init (
        nextToken: Swift.String? = nil,
        resourceIdPreference: EfsClientTypes.ResourceIdPreference? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceIdPreference = resourceIdPreference
    }
}

struct DescribeAccountPreferencesOutputResponseBody: Swift.Equatable {
    public let resourceIdPreference: EfsClientTypes.ResourceIdPreference?
    public let nextToken: Swift.String?
}

extension DescribeAccountPreferencesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceIdPreference = "ResourceIdPreference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdPreferenceDecoded = try containerValues.decodeIfPresent(EfsClientTypes.ResourceIdPreference.self, forKey: .resourceIdPreference)
        resourceIdPreference = resourceIdPreferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBackupPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBackupPolicyInput(fileSystemId: \(Swift.String(describing: fileSystemId)))"}
}

extension DescribeBackupPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeBackupPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBackupPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBackupPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBackupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBackupPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBackupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBackupPolicyOutputError>
}

public struct DescribeBackupPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBackupPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBackupPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBackupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBackupPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBackupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBackupPolicyOutputError>
}

public struct DescribeBackupPolicyInput: Swift.Equatable {
    /// Specifies which EFS file system to retrieve the BackupPolicy for.
    /// This member is required.
    public let fileSystemId: Swift.String?

    public init (
        fileSystemId: Swift.String? = nil
    )
    {
        self.fileSystemId = fileSystemId
    }
}

struct DescribeBackupPolicyInputBody: Swift.Equatable {
}

extension DescribeBackupPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBackupPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBackupPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFound" : self = .policyNotFound(try PolicyNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBackupPolicyOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case policyNotFound(PolicyNotFound)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBackupPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBackupPolicyOutputResponse(backupPolicy: \(Swift.String(describing: backupPolicy)))"}
}

extension DescribeBackupPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBackupPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupPolicy = output.backupPolicy
        } else {
            self.backupPolicy = nil
        }
    }
}

public struct DescribeBackupPolicyOutputResponse: Swift.Equatable {
    /// Describes the file system's backup policy, indicating whether automatic backups are turned on or off..
    public let backupPolicy: EfsClientTypes.BackupPolicy?

    public init (
        backupPolicy: EfsClientTypes.BackupPolicy? = nil
    )
    {
        self.backupPolicy = backupPolicy
    }
}

struct DescribeBackupPolicyOutputResponseBody: Swift.Equatable {
    public let backupPolicy: EfsClientTypes.BackupPolicy?
}

extension DescribeBackupPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPolicy = "BackupPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPolicyDecoded = try containerValues.decodeIfPresent(EfsClientTypes.BackupPolicy.self, forKey: .backupPolicy)
        backupPolicy = backupPolicyDecoded
    }
}

extension DescribeFileSystemPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFileSystemPolicyInput(fileSystemId: \(Swift.String(describing: fileSystemId)))"}
}

extension DescribeFileSystemPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeFileSystemPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFileSystemPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFileSystemPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFileSystemPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFileSystemPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFileSystemPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFileSystemPolicyOutputError>
}

public struct DescribeFileSystemPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFileSystemPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFileSystemPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFileSystemPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFileSystemPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFileSystemPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFileSystemPolicyOutputError>
}

public struct DescribeFileSystemPolicyInput: Swift.Equatable {
    /// Specifies which EFS file system to retrieve the FileSystemPolicy for.
    /// This member is required.
    public let fileSystemId: Swift.String?

    public init (
        fileSystemId: Swift.String? = nil
    )
    {
        self.fileSystemId = fileSystemId
    }
}

struct DescribeFileSystemPolicyInputBody: Swift.Equatable {
}

extension DescribeFileSystemPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFileSystemPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFileSystemPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFound" : self = .policyNotFound(try PolicyNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFileSystemPolicyOutputError: Swift.Error, Swift.Equatable {
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case policyNotFound(PolicyNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFileSystemPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFileSystemPolicyOutputResponse(fileSystemId: \(Swift.String(describing: fileSystemId)), policy: \(Swift.String(describing: policy)))"}
}

extension DescribeFileSystemPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFileSystemPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileSystemId = output.fileSystemId
            self.policy = output.policy
        } else {
            self.fileSystemId = nil
            self.policy = nil
        }
    }
}

public struct DescribeFileSystemPolicyOutputResponse: Swift.Equatable {
    /// Specifies the EFS file system to which the FileSystemPolicy applies.
    public let fileSystemId: Swift.String?
    /// The JSON formatted FileSystemPolicy for the EFS file system.
    public let policy: Swift.String?

    public init (
        fileSystemId: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.policy = policy
    }
}

struct DescribeFileSystemPolicyOutputResponseBody: Swift.Equatable {
    public let fileSystemId: Swift.String?
    public let policy: Swift.String?
}

extension DescribeFileSystemPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemId = "FileSystemId"
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension DescribeFileSystemsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFileSystemsInput(creationToken: \(Swift.String(describing: creationToken)), fileSystemId: \(Swift.String(describing: fileSystemId)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension DescribeFileSystemsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeFileSystemsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFileSystemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFileSystemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFileSystemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFileSystemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFileSystemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFileSystemsOutputError>
}

public struct DescribeFileSystemsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFileSystemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFileSystemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFileSystemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let creationToken = input.operationInput.creationToken {
            let creationTokenQueryItem = ClientRuntime.URLQueryItem(name: "CreationToken".urlPercentEncoding(), value: Swift.String(creationToken).urlPercentEncoding())
            input.builder.withQueryItem(creationTokenQueryItem)
        }
        if let fileSystemId = input.operationInput.fileSystemId {
            let fileSystemIdQueryItem = ClientRuntime.URLQueryItem(name: "FileSystemId".urlPercentEncoding(), value: Swift.String(fileSystemId).urlPercentEncoding())
            input.builder.withQueryItem(fileSystemIdQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFileSystemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFileSystemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFileSystemsOutputError>
}

///
public struct DescribeFileSystemsInput: Swift.Equatable {
    /// (Optional) Restricts the list to the file system with this creation token (String). You
    ///       specify a creation token when you create an Amazon EFS file system.
    public let creationToken: Swift.String?
    /// (Optional) ID of the file system whose description you want to retrieve
    ///       (String).
    public let fileSystemId: Swift.String?
    /// (Optional) Opaque pagination token returned from a previous
    ///         DescribeFileSystems operation (String). If present, specifies to continue the
    ///       list from where the returning call had left off.
    public let marker: Swift.String?
    /// (Optional) Specifies the maximum number of file systems to return in the response
    ///       (integer). This number is automatically set to 100. The response is paginated at 100 per page if you have more than 100 file systems.
    ///
    public let maxItems: Swift.Int?

    public init (
        creationToken: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.creationToken = creationToken
        self.fileSystemId = fileSystemId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct DescribeFileSystemsInputBody: Swift.Equatable {
}

extension DescribeFileSystemsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFileSystemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFileSystemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFileSystemsOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFileSystemsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFileSystemsOutputResponse(fileSystems: \(Swift.String(describing: fileSystems)), marker: \(Swift.String(describing: marker)), nextMarker: \(Swift.String(describing: nextMarker)))"}
}

extension DescribeFileSystemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFileSystemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileSystems = output.fileSystems
            self.marker = output.marker
            self.nextMarker = output.nextMarker
        } else {
            self.fileSystems = nil
            self.marker = nil
            self.nextMarker = nil
        }
    }
}

public struct DescribeFileSystemsOutputResponse: Swift.Equatable {
    /// An array of file system descriptions.
    public let fileSystems: [EfsClientTypes.FileSystemDescription]?
    /// Present if provided by caller in the request (String).
    public let marker: Swift.String?
    /// Present if there are more file systems than returned in the response (String). You can
    ///       use the NextMarker in the subsequent request to fetch the descriptions.
    public let nextMarker: Swift.String?

    public init (
        fileSystems: [EfsClientTypes.FileSystemDescription]? = nil,
        marker: Swift.String? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.fileSystems = fileSystems
        self.marker = marker
        self.nextMarker = nextMarker
    }
}

struct DescribeFileSystemsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let fileSystems: [EfsClientTypes.FileSystemDescription]?
    public let nextMarker: Swift.String?
}

extension DescribeFileSystemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystems = "FileSystems"
        case marker = "Marker"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let fileSystemsContainer = try containerValues.decodeIfPresent([EfsClientTypes.FileSystemDescription?].self, forKey: .fileSystems)
        var fileSystemsDecoded0:[EfsClientTypes.FileSystemDescription]? = nil
        if let fileSystemsContainer = fileSystemsContainer {
            fileSystemsDecoded0 = [EfsClientTypes.FileSystemDescription]()
            for structure0 in fileSystemsContainer {
                if let structure0 = structure0 {
                    fileSystemsDecoded0?.append(structure0)
                }
            }
        }
        fileSystems = fileSystemsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension DescribeLifecycleConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLifecycleConfigurationInput(fileSystemId: \(Swift.String(describing: fileSystemId)))"}
}

extension DescribeLifecycleConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeLifecycleConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLifecycleConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLifecycleConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLifecycleConfigurationOutputError>
}

public struct DescribeLifecycleConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLifecycleConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLifecycleConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLifecycleConfigurationOutputError>
}

public struct DescribeLifecycleConfigurationInput: Swift.Equatable {
    /// The ID of the file system whose LifecycleConfiguration object you want to
    ///       retrieve (String).
    /// This member is required.
    public let fileSystemId: Swift.String?

    public init (
        fileSystemId: Swift.String? = nil
    )
    {
        self.fileSystemId = fileSystemId
    }
}

struct DescribeLifecycleConfigurationInputBody: Swift.Equatable {
}

extension DescribeLifecycleConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeLifecycleConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLifecycleConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLifecycleConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLifecycleConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLifecycleConfigurationOutputResponse(lifecyclePolicies: \(Swift.String(describing: lifecyclePolicies)))"}
}

extension DescribeLifecycleConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLifecycleConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lifecyclePolicies = output.lifecyclePolicies
        } else {
            self.lifecyclePolicies = nil
        }
    }
}

public struct DescribeLifecycleConfigurationOutputResponse: Swift.Equatable {
    /// An array of lifecycle management policies. Currently, EFS supports a maximum of one
    ///       policy per file system.
    public let lifecyclePolicies: [EfsClientTypes.LifecyclePolicy]?

    public init (
        lifecyclePolicies: [EfsClientTypes.LifecyclePolicy]? = nil
    )
    {
        self.lifecyclePolicies = lifecyclePolicies
    }
}

struct DescribeLifecycleConfigurationOutputResponseBody: Swift.Equatable {
    public let lifecyclePolicies: [EfsClientTypes.LifecyclePolicy]?
}

extension DescribeLifecycleConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicies = "LifecyclePolicies"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecyclePoliciesContainer = try containerValues.decodeIfPresent([EfsClientTypes.LifecyclePolicy?].self, forKey: .lifecyclePolicies)
        var lifecyclePoliciesDecoded0:[EfsClientTypes.LifecyclePolicy]? = nil
        if let lifecyclePoliciesContainer = lifecyclePoliciesContainer {
            lifecyclePoliciesDecoded0 = [EfsClientTypes.LifecyclePolicy]()
            for structure0 in lifecyclePoliciesContainer {
                if let structure0 = structure0 {
                    lifecyclePoliciesDecoded0?.append(structure0)
                }
            }
        }
        lifecyclePolicies = lifecyclePoliciesDecoded0
    }
}

extension DescribeMountTargetSecurityGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMountTargetSecurityGroupsInput(mountTargetId: \(Swift.String(describing: mountTargetId)))"}
}

extension DescribeMountTargetSecurityGroupsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeMountTargetSecurityGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMountTargetSecurityGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMountTargetSecurityGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMountTargetSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMountTargetSecurityGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMountTargetSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMountTargetSecurityGroupsOutputError>
}

public struct DescribeMountTargetSecurityGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMountTargetSecurityGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMountTargetSecurityGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMountTargetSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMountTargetSecurityGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMountTargetSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMountTargetSecurityGroupsOutputError>
}

///
public struct DescribeMountTargetSecurityGroupsInput: Swift.Equatable {
    /// The ID of the mount target whose security groups you want to retrieve.
    /// This member is required.
    public let mountTargetId: Swift.String?

    public init (
        mountTargetId: Swift.String? = nil
    )
    {
        self.mountTargetId = mountTargetId
    }
}

struct DescribeMountTargetSecurityGroupsInputBody: Swift.Equatable {
}

extension DescribeMountTargetSecurityGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeMountTargetSecurityGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMountTargetSecurityGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectMountTargetState" : self = .incorrectMountTargetState(try IncorrectMountTargetState(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MountTargetNotFound" : self = .mountTargetNotFound(try MountTargetNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMountTargetSecurityGroupsOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case incorrectMountTargetState(IncorrectMountTargetState)
    case internalServerError(InternalServerError)
    case mountTargetNotFound(MountTargetNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMountTargetSecurityGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMountTargetSecurityGroupsOutputResponse(securityGroups: \(Swift.String(describing: securityGroups)))"}
}

extension DescribeMountTargetSecurityGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMountTargetSecurityGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.securityGroups = output.securityGroups
        } else {
            self.securityGroups = nil
        }
    }
}

public struct DescribeMountTargetSecurityGroupsOutputResponse: Swift.Equatable {
    /// An array of security groups.
    /// This member is required.
    public let securityGroups: [Swift.String]?

    public init (
        securityGroups: [Swift.String]? = nil
    )
    {
        self.securityGroups = securityGroups
    }
}

struct DescribeMountTargetSecurityGroupsOutputResponseBody: Swift.Equatable {
    public let securityGroups: [Swift.String]?
}

extension DescribeMountTargetSecurityGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroups = "SecurityGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
    }
}

extension DescribeMountTargetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMountTargetsInput(accessPointId: \(Swift.String(describing: accessPointId)), fileSystemId: \(Swift.String(describing: fileSystemId)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), mountTargetId: \(Swift.String(describing: mountTargetId)))"}
}

extension DescribeMountTargetsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeMountTargetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMountTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMountTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMountTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMountTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMountTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMountTargetsOutputError>
}

public struct DescribeMountTargetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMountTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMountTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMountTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accessPointId = input.operationInput.accessPointId {
            let accessPointIdQueryItem = ClientRuntime.URLQueryItem(name: "AccessPointId".urlPercentEncoding(), value: Swift.String(accessPointId).urlPercentEncoding())
            input.builder.withQueryItem(accessPointIdQueryItem)
        }
        if let fileSystemId = input.operationInput.fileSystemId {
            let fileSystemIdQueryItem = ClientRuntime.URLQueryItem(name: "FileSystemId".urlPercentEncoding(), value: Swift.String(fileSystemId).urlPercentEncoding())
            input.builder.withQueryItem(fileSystemIdQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let mountTargetId = input.operationInput.mountTargetId {
            let mountTargetIdQueryItem = ClientRuntime.URLQueryItem(name: "MountTargetId".urlPercentEncoding(), value: Swift.String(mountTargetId).urlPercentEncoding())
            input.builder.withQueryItem(mountTargetIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMountTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMountTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMountTargetsOutputError>
}

///
public struct DescribeMountTargetsInput: Swift.Equatable {
    /// (Optional) The ID of the access point whose mount targets that you want to list. It must be included in your request if a
    ///       FileSystemId or MountTargetId is not included in your request. Accepts either an access point ID or ARN as input.
    public let accessPointId: Swift.String?
    /// (Optional) ID of the file system whose mount targets you want to list (String). It must
    ///       be included in your request if an AccessPointId or MountTargetId is not included. Accepts either a file system ID or ARN as input.
    public let fileSystemId: Swift.String?
    /// (Optional) Opaque pagination token returned from a previous
    ///         DescribeMountTargets operation (String). If present, it specifies to continue
    ///       the list from where the previous returning call left off.
    public let marker: Swift.String?
    /// (Optional) Maximum number of mount targets to return in the response. Currently, this
    ///       number is automatically set to
    ///       10, and other values are ignored. The response is paginated at 100 per page if you have more than 100 mount targets.
    public let maxItems: Swift.Int?
    /// (Optional) ID of the mount target that you want to have described (String). It must be
    ///       included in your request if FileSystemId is not included. Accepts either a mount target ID or ARN as input.
    public let mountTargetId: Swift.String?

    public init (
        accessPointId: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        mountTargetId: Swift.String? = nil
    )
    {
        self.accessPointId = accessPointId
        self.fileSystemId = fileSystemId
        self.marker = marker
        self.maxItems = maxItems
        self.mountTargetId = mountTargetId
    }
}

struct DescribeMountTargetsInputBody: Swift.Equatable {
}

extension DescribeMountTargetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeMountTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMountTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessPointNotFound" : self = .accessPointNotFound(try AccessPointNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MountTargetNotFound" : self = .mountTargetNotFound(try MountTargetNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMountTargetsOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFound(AccessPointNotFound)
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case mountTargetNotFound(MountTargetNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMountTargetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMountTargetsOutputResponse(marker: \(Swift.String(describing: marker)), mountTargets: \(Swift.String(describing: mountTargets)), nextMarker: \(Swift.String(describing: nextMarker)))"}
}

extension DescribeMountTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMountTargetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.mountTargets = output.mountTargets
            self.nextMarker = output.nextMarker
        } else {
            self.marker = nil
            self.mountTargets = nil
            self.nextMarker = nil
        }
    }
}

///
public struct DescribeMountTargetsOutputResponse: Swift.Equatable {
    /// If the request included the Marker, the response returns that value in
    ///       this field.
    public let marker: Swift.String?
    /// Returns the file system's mount targets as an array of
    ///         MountTargetDescription objects.
    public let mountTargets: [EfsClientTypes.MountTargetDescription]?
    /// If a value is present, there are more mount targets to return. In a subsequent request,
    ///       you can provide Marker in your request with this value to retrieve the next set
    ///       of mount targets.
    public let nextMarker: Swift.String?

    public init (
        marker: Swift.String? = nil,
        mountTargets: [EfsClientTypes.MountTargetDescription]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.marker = marker
        self.mountTargets = mountTargets
        self.nextMarker = nextMarker
    }
}

struct DescribeMountTargetsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let mountTargets: [EfsClientTypes.MountTargetDescription]?
    public let nextMarker: Swift.String?
}

extension DescribeMountTargetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case mountTargets = "MountTargets"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let mountTargetsContainer = try containerValues.decodeIfPresent([EfsClientTypes.MountTargetDescription?].self, forKey: .mountTargets)
        var mountTargetsDecoded0:[EfsClientTypes.MountTargetDescription]? = nil
        if let mountTargetsContainer = mountTargetsContainer {
            mountTargetsDecoded0 = [EfsClientTypes.MountTargetDescription]()
            for structure0 in mountTargetsContainer {
                if let structure0 = structure0 {
                    mountTargetsDecoded0?.append(structure0)
                }
            }
        }
        mountTargets = mountTargetsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension DescribeTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTagsInput(fileSystemId: \(Swift.String(describing: fileSystemId)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension DescribeTagsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTagsOutputError>
}

public struct DescribeTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTagsOutputError>
}

///
public struct DescribeTagsInput: Swift.Equatable {
    /// The ID of the file system whose tag set you want to retrieve.
    /// This member is required.
    public let fileSystemId: Swift.String?
    /// (Optional) An opaque pagination token returned from a previous
    ///         DescribeTags operation (String). If present, it specifies to continue the list
    ///       from where the previous call left off.
    public let marker: Swift.String?
    /// (Optional) The maximum number of file system tags to return in the response. Currently,
    ///       this number is automatically set to
    ///       100, and other values are ignored. The response is paginated at 100 per page if you have more than 100 tags.
    public let maxItems: Swift.Int?

    public init (
        fileSystemId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct DescribeTagsInputBody: Swift.Equatable {
}

extension DescribeTagsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTagsOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTagsOutputResponse(marker: \(Swift.String(describing: marker)), nextMarker: \(Swift.String(describing: nextMarker)), tags: \(Swift.String(describing: tags)))"}
}

extension DescribeTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.nextMarker = output.nextMarker
            self.tags = output.tags
        } else {
            self.marker = nil
            self.nextMarker = nil
            self.tags = nil
        }
    }
}

///
public struct DescribeTagsOutputResponse: Swift.Equatable {
    /// If the request included a Marker, the response returns that value in this
    ///       field.
    public let marker: Swift.String?
    /// If a value is present, there are more tags to return. In a subsequent request, you can
    ///       provide the value of NextMarker as the value of the Marker parameter
    ///       in your next request to retrieve the next set of tags.
    public let nextMarker: Swift.String?
    /// Returns tags associated with the file system as an array of Tag objects.
    ///
    /// This member is required.
    public let tags: [EfsClientTypes.Tag]?

    public init (
        marker: Swift.String? = nil,
        nextMarker: Swift.String? = nil,
        tags: [EfsClientTypes.Tag]? = nil
    )
    {
        self.marker = marker
        self.nextMarker = nextMarker
        self.tags = tags
    }
}

struct DescribeTagsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let tags: [EfsClientTypes.Tag]?
    public let nextMarker: Swift.String?
}

extension DescribeTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case nextMarker = "NextMarker"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EfsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EfsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EfsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension FileSystemAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FileSystemAlreadyExists(errorCode: \(Swift.String(describing: errorCode)), fileSystemId: \(Swift.String(describing: fileSystemId)), message: \(Swift.String(describing: message)))"}
}

extension FileSystemAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FileSystemAlreadyExistsBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.fileSystemId = output.fileSystemId
            self.message = output.message
        } else {
            self.errorCode = nil
            self.fileSystemId = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the file system you are trying to create already exists, with the
///             creation token you provided.
public struct FileSystemAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    /// This member is required.
    public var fileSystemId: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.fileSystemId = fileSystemId
        self.message = message
    }
}

struct FileSystemAlreadyExistsBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
    public let fileSystemId: Swift.String?
}

extension FileSystemAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case fileSystemId = "FileSystemId"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
    }
}

extension EfsClientTypes.FileSystemDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneId = "AvailabilityZoneId"
        case availabilityZoneName = "AvailabilityZoneName"
        case creationTime = "CreationTime"
        case creationToken = "CreationToken"
        case encrypted = "Encrypted"
        case fileSystemArn = "FileSystemArn"
        case fileSystemId = "FileSystemId"
        case kmsKeyId = "KmsKeyId"
        case lifeCycleState = "LifeCycleState"
        case name = "Name"
        case numberOfMountTargets = "NumberOfMountTargets"
        case ownerId = "OwnerId"
        case performanceMode = "PerformanceMode"
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case sizeInBytes = "SizeInBytes"
        case tags = "Tags"
        case throughputMode = "ThroughputMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZoneId = availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let availabilityZoneName = availabilityZoneName {
            try encodeContainer.encode(availabilityZoneName, forKey: .availabilityZoneName)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let creationToken = creationToken {
            try encodeContainer.encode(creationToken, forKey: .creationToken)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let fileSystemArn = fileSystemArn {
            try encodeContainer.encode(fileSystemArn, forKey: .fileSystemArn)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lifeCycleState = lifeCycleState {
            try encodeContainer.encode(lifeCycleState.rawValue, forKey: .lifeCycleState)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if numberOfMountTargets != 0 {
            try encodeContainer.encode(numberOfMountTargets, forKey: .numberOfMountTargets)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let performanceMode = performanceMode {
            try encodeContainer.encode(performanceMode.rawValue, forKey: .performanceMode)
        }
        if let provisionedThroughputInMibps = provisionedThroughputInMibps {
            try encodeContainer.encode(provisionedThroughputInMibps, forKey: .provisionedThroughputInMibps)
        }
        if let sizeInBytes = sizeInBytes {
            try encodeContainer.encode(sizeInBytes, forKey: .sizeInBytes)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let throughputMode = throughputMode {
            try encodeContainer.encode(throughputMode.rawValue, forKey: .throughputMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let creationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationToken)
        creationToken = creationTokenDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let fileSystemArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemArn)
        fileSystemArn = fileSystemArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(EfsClientTypes.LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let numberOfMountTargetsDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfMountTargets)
        numberOfMountTargets = numberOfMountTargetsDecoded
        let sizeInBytesDecoded = try containerValues.decodeIfPresent(EfsClientTypes.FileSystemSize.self, forKey: .sizeInBytes)
        sizeInBytes = sizeInBytesDecoded
        let performanceModeDecoded = try containerValues.decodeIfPresent(EfsClientTypes.PerformanceMode.self, forKey: .performanceMode)
        performanceMode = performanceModeDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let throughputModeDecoded = try containerValues.decodeIfPresent(EfsClientTypes.ThroughputMode.self, forKey: .throughputMode)
        throughputMode = throughputModeDecoded
        let provisionedThroughputInMibpsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .provisionedThroughputInMibps)
        provisionedThroughputInMibps = provisionedThroughputInMibpsDecoded
        let availabilityZoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneName)
        availabilityZoneName = availabilityZoneNameDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EfsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EfsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EfsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EfsClientTypes.FileSystemDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FileSystemDescription(availabilityZoneId: \(Swift.String(describing: availabilityZoneId)), availabilityZoneName: \(Swift.String(describing: availabilityZoneName)), creationTime: \(Swift.String(describing: creationTime)), creationToken: \(Swift.String(describing: creationToken)), encrypted: \(Swift.String(describing: encrypted)), fileSystemArn: \(Swift.String(describing: fileSystemArn)), fileSystemId: \(Swift.String(describing: fileSystemId)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), lifeCycleState: \(Swift.String(describing: lifeCycleState)), name: \(Swift.String(describing: name)), numberOfMountTargets: \(Swift.String(describing: numberOfMountTargets)), ownerId: \(Swift.String(describing: ownerId)), performanceMode: \(Swift.String(describing: performanceMode)), provisionedThroughputInMibps: \(Swift.String(describing: provisionedThroughputInMibps)), sizeInBytes: \(Swift.String(describing: sizeInBytes)), tags: \(Swift.String(describing: tags)), throughputMode: \(Swift.String(describing: throughputMode)))"}
}

extension EfsClientTypes {
    /// A description of the file system.
    public struct FileSystemDescription: Swift.Equatable {
        /// The unique and consistent identifier of the Availability Zone in which the file system's
        ///       One Zone storage classes exist. For example, use1-az1 is an Availability Zone ID
        ///       for the us-east-1 AWS Region, and it has the same location in every AWS account.
        public let availabilityZoneId: Swift.String?
        /// Describes the AWS Availability Zone in which the file system is located, and is valid only
        ///       for file systems using One Zone storage classes. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html">Using EFS storage classes
        ///       in the Amazon EFS User Guide.
        public let availabilityZoneName: Swift.String?
        /// The time that the file system was created, in seconds (since
        ///       1970-01-01T00:00:00Z).
        /// This member is required.
        public let creationTime: ClientRuntime.Date?
        /// The opaque string specified in the request.
        /// This member is required.
        public let creationToken: Swift.String?
        /// A Boolean value that, if true, indicates that the file system is encrypted.
        public let encrypted: Swift.Bool?
        /// The Amazon Resource Name (ARN) for the EFS file system, in the format
        ///       arn:aws:elasticfilesystem:region:account-id:file-system/file-system-id
        ///             .
        ///       Example with sample data: arn:aws:elasticfilesystem:us-west-2:1111333322228888:file-system/fs-01234567
        ///
        public let fileSystemArn: Swift.String?
        /// The ID of the file system, assigned by Amazon EFS.
        /// This member is required.
        public let fileSystemId: Swift.String?
        /// The ID of an AWS Key Management Service (AWS KMS) customer master key (CMK) that was
        ///       used to protect the encrypted file system.
        public let kmsKeyId: Swift.String?
        /// The lifecycle phase of the file system.
        /// This member is required.
        public let lifeCycleState: EfsClientTypes.LifeCycleState?
        /// You can add tags to a file system, including a Name tag. For more
        ///       information, see CreateFileSystem. If the file system has a Name tag, Amazon EFS returns
        ///       the value in this field.
        public let name: Swift.String?
        /// The current number of mount targets that the file system has. For more information, see CreateMountTarget.
        /// This member is required.
        public let numberOfMountTargets: Swift.Int
        /// The AWS account that created the file system. If the file system was created by an IAM
        ///       user, the parent account to which the user belongs is the owner.
        /// This member is required.
        public let ownerId: Swift.String?
        /// The performance mode of the file system.
        /// This member is required.
        public let performanceMode: EfsClientTypes.PerformanceMode?
        /// The amount of provisioned throughput, measured in MiB/s, for the file system. Valid for
        ///       file systems using ThroughputMode set to provisioned.
        public let provisionedThroughputInMibps: Swift.Double?
        /// The latest known metered size (in bytes) of data stored in the file system, in its
        ///         Value field, and the time at which that size was determined in its
        ///         Timestamp field. The Timestamp value is the integer number of
        ///       seconds since 1970-01-01T00:00:00Z. The SizeInBytes value doesn't represent
        ///       the size of a consistent snapshot of the file system, but it is eventually consistent when
        ///       there are no writes to the file system. That is, SizeInBytes represents actual
        ///       size only if the file system is not modified for a period longer than a couple of hours.
        ///       Otherwise, the value is not the exact size that the file system was at any point in time.
        ///
        /// This member is required.
        public let sizeInBytes: EfsClientTypes.FileSystemSize?
        /// The tags associated with the file system, presented as an array of Tag
        ///       objects.
        /// This member is required.
        public let tags: [EfsClientTypes.Tag]?
        /// Displays the file system's throughput mode. For more information, see
        ///       <a href="https://docs.aws.amazon.com/efs/latest/ug/performance.html#throughput-modes">Throughput modes
        ///       in the Amazon EFS User Guide.
        ///
        public let throughputMode: EfsClientTypes.ThroughputMode?

        public init (
            availabilityZoneId: Swift.String? = nil,
            availabilityZoneName: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            creationToken: Swift.String? = nil,
            encrypted: Swift.Bool? = nil,
            fileSystemArn: Swift.String? = nil,
            fileSystemId: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            lifeCycleState: EfsClientTypes.LifeCycleState? = nil,
            name: Swift.String? = nil,
            numberOfMountTargets: Swift.Int = 0,
            ownerId: Swift.String? = nil,
            performanceMode: EfsClientTypes.PerformanceMode? = nil,
            provisionedThroughputInMibps: Swift.Double? = nil,
            sizeInBytes: EfsClientTypes.FileSystemSize? = nil,
            tags: [EfsClientTypes.Tag]? = nil,
            throughputMode: EfsClientTypes.ThroughputMode? = nil
        )
        {
            self.availabilityZoneId = availabilityZoneId
            self.availabilityZoneName = availabilityZoneName
            self.creationTime = creationTime
            self.creationToken = creationToken
            self.encrypted = encrypted
            self.fileSystemArn = fileSystemArn
            self.fileSystemId = fileSystemId
            self.kmsKeyId = kmsKeyId
            self.lifeCycleState = lifeCycleState
            self.name = name
            self.numberOfMountTargets = numberOfMountTargets
            self.ownerId = ownerId
            self.performanceMode = performanceMode
            self.provisionedThroughputInMibps = provisionedThroughputInMibps
            self.sizeInBytes = sizeInBytes
            self.tags = tags
            self.throughputMode = throughputMode
        }
    }

}

extension FileSystemInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FileSystemInUse(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension FileSystemInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FileSystemInUseBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if a file system has mount targets.
public struct FileSystemInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct FileSystemInUseBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension FileSystemInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileSystemLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FileSystemLimitExceeded(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension FileSystemLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FileSystemLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the AWS account has already created the maximum number of file systems
///             allowed per account.
public struct FileSystemLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct FileSystemLimitExceededBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension FileSystemLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileSystemNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FileSystemNotFound(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension FileSystemNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FileSystemNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the specified FileSystemId value doesn't exist in the
///             requester's AWS account.
public struct FileSystemNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct FileSystemNotFoundBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension FileSystemNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EfsClientTypes.FileSystemSize: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timestamp = "Timestamp"
        case value = "Value"
        case valueInIA = "ValueInIA"
        case valueInStandard = "ValueInStandard"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if value != 0 {
            try encodeContainer.encode(value, forKey: .value)
        }
        if let valueInIA = valueInIA {
            try encodeContainer.encode(valueInIA, forKey: .valueInIA)
        }
        if let valueInStandard = valueInStandard {
            try encodeContainer.encode(valueInStandard, forKey: .valueInStandard)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decode(Swift.Int.self, forKey: .value)
        value = valueDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let valueInIADecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .valueInIA)
        valueInIA = valueInIADecoded
        let valueInStandardDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .valueInStandard)
        valueInStandard = valueInStandardDecoded
    }
}

extension EfsClientTypes.FileSystemSize: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FileSystemSize(timestamp: \(Swift.String(describing: timestamp)), value: \(Swift.String(describing: value)), valueInIA: \(Swift.String(describing: valueInIA)), valueInStandard: \(Swift.String(describing: valueInStandard)))"}
}

extension EfsClientTypes {
    /// The latest known metered size (in bytes) of data stored in the file system, in its
    ///         Value field, and the time at which that size was determined in its
    ///         Timestamp field. The value doesn't represent the size of a consistent
    ///       snapshot of the file system, but it is eventually consistent when there are no writes to the
    ///       file system. That is, the value represents the actual size only if the file system is not
    ///       modified for a period longer than a couple of hours. Otherwise, the value is not necessarily
    ///       the exact size the file system was at any instant in time.
    public struct FileSystemSize: Swift.Equatable {
        /// The time at which the size of data, returned in the Value field, was
        ///       determined. The value is the integer number of seconds since 1970-01-01T00:00:00Z.
        public let timestamp: ClientRuntime.Date?
        /// The latest known metered size (in bytes) of data stored in the file system.
        /// This member is required.
        public let value: Swift.Int
        /// The latest known metered size (in bytes) of data stored in the Infrequent Access
        ///       storage class.
        public let valueInIA: Swift.Int?
        /// The latest known metered size (in bytes) of data stored in the Standard storage
        ///       class.
        public let valueInStandard: Swift.Int?

        public init (
            timestamp: ClientRuntime.Date? = nil,
            value: Swift.Int = 0,
            valueInIA: Swift.Int? = nil,
            valueInStandard: Swift.Int? = nil
        )
        {
            self.timestamp = timestamp
            self.value = value
            self.valueInIA = valueInIA
            self.valueInStandard = valueInStandard
        }
    }

}

extension IncorrectFileSystemLifeCycleState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IncorrectFileSystemLifeCycleState(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension IncorrectFileSystemLifeCycleState {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IncorrectFileSystemLifeCycleStateBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the file system's lifecycle state is not "available".
public struct IncorrectFileSystemLifeCycleState: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct IncorrectFileSystemLifeCycleStateBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension IncorrectFileSystemLifeCycleStateBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IncorrectMountTargetState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IncorrectMountTargetState(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension IncorrectMountTargetState {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IncorrectMountTargetStateBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the mount target is not in the correct state for the
///             operation.
public struct IncorrectMountTargetState: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct IncorrectMountTargetStateBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension IncorrectMountTargetStateBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientThroughputCapacity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InsufficientThroughputCapacity(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension InsufficientThroughputCapacity {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InsufficientThroughputCapacityBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if there's not enough capacity to provision additional throughput. This value
///             might be returned when you try to create a file system in provisioned throughput mode,
///             when you attempt to increase the provisioned throughput of an existing file system, or
///             when you attempt to change an existing file system from bursting to provisioned
///             throughput mode. Try again later.
public struct InsufficientThroughputCapacity: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct InsufficientThroughputCapacityBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension InsufficientThroughputCapacityBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerError(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension InternalServerError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if an error occurred on the server side.
public struct InternalServerError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct InternalServerErrorBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension InternalServerErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPolicyException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidPolicyException(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension InvalidPolicyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the FileSystemPolicy is is malformed or contains an error such as an invalid
///             parameter value or a missing required parameter. Returned in the case of a policy lockout safety check error.
public struct InvalidPolicyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct InvalidPolicyExceptionBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension InvalidPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IpAddressInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IpAddressInUse(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension IpAddressInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IpAddressInUseBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the request specified an IpAddress that is already in use
///             in the subnet.
public struct IpAddressInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct IpAddressInUseBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension IpAddressInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EfsClientTypes {
    public enum LifeCycleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleted
        case deleting
        case error
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [LifeCycleState] {
            return [
                .available,
                .creating,
                .deleted,
                .deleting,
                .error,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .creating: return "creating"
            case .deleted: return "deleted"
            case .deleting: return "deleting"
            case .error: return "error"
            case .updating: return "updating"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LifeCycleState(rawValue: rawValue) ?? LifeCycleState.sdkUnknown(rawValue)
        }
    }
}

extension EfsClientTypes.LifecyclePolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitionToIA = "TransitionToIA"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transitionToIA = transitionToIA {
            try encodeContainer.encode(transitionToIA.rawValue, forKey: .transitionToIA)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitionToIADecoded = try containerValues.decodeIfPresent(EfsClientTypes.TransitionToIARules.self, forKey: .transitionToIA)
        transitionToIA = transitionToIADecoded
    }
}

extension EfsClientTypes.LifecyclePolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LifecyclePolicy(transitionToIA: \(Swift.String(describing: transitionToIA)))"}
}

extension EfsClientTypes {
    /// Describes a policy used by EFS lifecycle management to transition files to the Infrequent
    ///       Access (IA) storage class.
    public struct LifecyclePolicy: Swift.Equatable {
        ///
        ///       A value that describes the period of time that a file is not accessed, after which it transitions to the IA storage class. Metadata
        ///       operations such as listing the contents of a directory don't count as file access
        ///       events.
        public let transitionToIA: EfsClientTypes.TransitionToIARules?

        public init (
            transitionToIA: EfsClientTypes.TransitionToIARules? = nil
        )
        {
            self.transitionToIA = transitionToIA
        }
    }

}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceId: \(Swift.String(describing: resourceId)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// (Optional) Specifies the maximum number of tag objects to return in the response. The default value is 100.
    public let maxResults: Swift.Int?
    /// (Optional) You can use NextToken in a subsequent request to fetch the next page of access point descriptions if the response payload was paginated.
    public let nextToken: Swift.String?
    /// Specifies the EFS resource you want to retrieve tags for. You can retrieve tags for EFS file systems and access points using this API endpoint.
    /// This member is required.
    public let resourceId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessPointNotFound" : self = .accessPointNotFound(try AccessPointNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFound(AccessPointNotFound)
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(nextToken: \(Swift.String(describing: nextToken)), tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    ///
    ///             NextToken is present if the response payload is paginated. You can use NextToken in a subsequent request to fetch the next page of access point descriptions.
    public let nextToken: Swift.String?
    /// An array of the tags for the specified EFS resource.
    public let tags: [EfsClientTypes.Tag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [EfsClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [EfsClientTypes.Tag]?
    public let nextToken: Swift.String?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([EfsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EfsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EfsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ModifyMountTargetSecurityGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyMountTargetSecurityGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyMountTargetSecurityGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyMountTargetSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyMountTargetSecurityGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyMountTargetSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyMountTargetSecurityGroupsOutputError>
}

extension ModifyMountTargetSecurityGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyMountTargetSecurityGroupsInput(mountTargetId: \(Swift.String(describing: mountTargetId)), securityGroups: \(Swift.String(describing: securityGroups)))"}
}

extension ModifyMountTargetSecurityGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroups = "SecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroups0 in securityGroups {
                try securityGroupsContainer.encode(securitygroups0)
            }
        }
    }
}

public struct ModifyMountTargetSecurityGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyMountTargetSecurityGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyMountTargetSecurityGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyMountTargetSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyMountTargetSecurityGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyMountTargetSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyMountTargetSecurityGroupsOutputError>
}

public struct ModifyMountTargetSecurityGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyMountTargetSecurityGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyMountTargetSecurityGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyMountTargetSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyMountTargetSecurityGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyMountTargetSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyMountTargetSecurityGroupsOutputError>
}

///
public struct ModifyMountTargetSecurityGroupsInput: Swift.Equatable {
    /// The ID of the mount target whose security groups you want to modify.
    /// This member is required.
    public let mountTargetId: Swift.String?
    /// An array of up to five VPC security group IDs.
    public let securityGroups: [Swift.String]?

    public init (
        mountTargetId: Swift.String? = nil,
        securityGroups: [Swift.String]? = nil
    )
    {
        self.mountTargetId = mountTargetId
        self.securityGroups = securityGroups
    }
}

struct ModifyMountTargetSecurityGroupsInputBody: Swift.Equatable {
    public let securityGroups: [Swift.String]?
}

extension ModifyMountTargetSecurityGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroups = "SecurityGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
    }
}

extension ModifyMountTargetSecurityGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyMountTargetSecurityGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectMountTargetState" : self = .incorrectMountTargetState(try IncorrectMountTargetState(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MountTargetNotFound" : self = .mountTargetNotFound(try MountTargetNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SecurityGroupLimitExceeded" : self = .securityGroupLimitExceeded(try SecurityGroupLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SecurityGroupNotFound" : self = .securityGroupNotFound(try SecurityGroupNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyMountTargetSecurityGroupsOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case incorrectMountTargetState(IncorrectMountTargetState)
    case internalServerError(InternalServerError)
    case mountTargetNotFound(MountTargetNotFound)
    case securityGroupLimitExceeded(SecurityGroupLimitExceeded)
    case securityGroupNotFound(SecurityGroupNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyMountTargetSecurityGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyMountTargetSecurityGroupsOutputResponse()"}
}

extension ModifyMountTargetSecurityGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifyMountTargetSecurityGroupsOutputResponse: Swift.Equatable {

    public init() {}
}

struct ModifyMountTargetSecurityGroupsOutputResponseBody: Swift.Equatable {
}

extension ModifyMountTargetSecurityGroupsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension MountTargetConflict: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MountTargetConflict(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension MountTargetConflict {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MountTargetConflictBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the mount target would violate one of the specified restrictions based
///             on the file system's existing mount targets.
public struct MountTargetConflict: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct MountTargetConflictBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension MountTargetConflictBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EfsClientTypes.MountTargetDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneId = "AvailabilityZoneId"
        case availabilityZoneName = "AvailabilityZoneName"
        case fileSystemId = "FileSystemId"
        case ipAddress = "IpAddress"
        case lifeCycleState = "LifeCycleState"
        case mountTargetId = "MountTargetId"
        case networkInterfaceId = "NetworkInterfaceId"
        case ownerId = "OwnerId"
        case subnetId = "SubnetId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZoneId = availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let availabilityZoneName = availabilityZoneName {
            try encodeContainer.encode(availabilityZoneName, forKey: .availabilityZoneName)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let lifeCycleState = lifeCycleState {
            try encodeContainer.encode(lifeCycleState.rawValue, forKey: .lifeCycleState)
        }
        if let mountTargetId = mountTargetId {
            try encodeContainer.encode(mountTargetId, forKey: .mountTargetId)
        }
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let mountTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountTargetId)
        mountTargetId = mountTargetIdDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(EfsClientTypes.LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let availabilityZoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneName)
        availabilityZoneName = availabilityZoneNameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension EfsClientTypes.MountTargetDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MountTargetDescription(availabilityZoneId: \(Swift.String(describing: availabilityZoneId)), availabilityZoneName: \(Swift.String(describing: availabilityZoneName)), fileSystemId: \(Swift.String(describing: fileSystemId)), ipAddress: \(Swift.String(describing: ipAddress)), lifeCycleState: \(Swift.String(describing: lifeCycleState)), mountTargetId: \(Swift.String(describing: mountTargetId)), networkInterfaceId: \(Swift.String(describing: networkInterfaceId)), ownerId: \(Swift.String(describing: ownerId)), subnetId: \(Swift.String(describing: subnetId)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension EfsClientTypes {
    /// Provides a description of a mount target.
    public struct MountTargetDescription: Swift.Equatable {
        /// The unique and consistent identifier of the Availability Zone that the mount target resides in.
        ///       For example, use1-az1 is an AZ ID for the us-east-1 Region and it has the same location in every AWS account.
        public let availabilityZoneId: Swift.String?
        /// The name of the Availability Zone in which the mount target is located. Availability Zones are
        ///       independently mapped to names for each AWS account. For example, the Availability Zone
        ///       us-east-1a for your AWS account might not be the same location as us-east-1a for another AWS account.
        public let availabilityZoneName: Swift.String?
        /// The ID of the file system for which the mount target is intended.
        /// This member is required.
        public let fileSystemId: Swift.String?
        /// Address at which the file system can be mounted by using the mount target.
        public let ipAddress: Swift.String?
        /// Lifecycle state of the mount target.
        /// This member is required.
        public let lifeCycleState: EfsClientTypes.LifeCycleState?
        /// System-assigned mount target ID.
        /// This member is required.
        public let mountTargetId: Swift.String?
        /// The ID of the network interface that Amazon EFS created when it created the mount
        ///       target.
        public let networkInterfaceId: Swift.String?
        /// AWS account ID that owns the resource.
        public let ownerId: Swift.String?
        /// The ID of the mount target's subnet.
        /// This member is required.
        public let subnetId: Swift.String?
        /// The virtual private cloud (VPC) ID that the mount target is configured in.
        public let vpcId: Swift.String?

        public init (
            availabilityZoneId: Swift.String? = nil,
            availabilityZoneName: Swift.String? = nil,
            fileSystemId: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            lifeCycleState: EfsClientTypes.LifeCycleState? = nil,
            mountTargetId: Swift.String? = nil,
            networkInterfaceId: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.availabilityZoneId = availabilityZoneId
            self.availabilityZoneName = availabilityZoneName
            self.fileSystemId = fileSystemId
            self.ipAddress = ipAddress
            self.lifeCycleState = lifeCycleState
            self.mountTargetId = mountTargetId
            self.networkInterfaceId = networkInterfaceId
            self.ownerId = ownerId
            self.subnetId = subnetId
            self.vpcId = vpcId
        }
    }

}

extension MountTargetNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MountTargetNotFound(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension MountTargetNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MountTargetNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if there is no mount target with the specified ID found in the
///             caller's account.
public struct MountTargetNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct MountTargetNotFoundBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension MountTargetNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NetworkInterfaceLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NetworkInterfaceLimitExceeded(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension NetworkInterfaceLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NetworkInterfaceLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The calling account has reached the limit for elastic network interfaces for the
///             specific AWS Region. The client should try to delete some elastic network interfaces or
///             get the account limit raised. For more information, see <a href="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Appendix_Limits.html">Amazon VPC Limits
///             in the Amazon VPC User Guide  (see the Network interfaces per VPC
///             entry in the table).
public struct NetworkInterfaceLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct NetworkInterfaceLimitExceededBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension NetworkInterfaceLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoFreeAddressesInSubnet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoFreeAddressesInSubnet(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension NoFreeAddressesInSubnet {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NoFreeAddressesInSubnetBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if IpAddress was not specified in the request and there are
///             no free IP addresses in the subnet.
public struct NoFreeAddressesInSubnet: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct NoFreeAddressesInSubnetBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension NoFreeAddressesInSubnetBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EfsClientTypes {
    public enum PerformanceMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case generalPurpose
        case maxIo
        case sdkUnknown(Swift.String)

        public static var allCases: [PerformanceMode] {
            return [
                .generalPurpose,
                .maxIo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .generalPurpose: return "generalPurpose"
            case .maxIo: return "maxIO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PerformanceMode(rawValue: rawValue) ?? PerformanceMode.sdkUnknown(rawValue)
        }
    }
}

extension PolicyNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PolicyNotFound(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension PolicyNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PolicyNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the default file system policy is in effect for the EFS file system specified.
public struct PolicyNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct PolicyNotFoundBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension PolicyNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EfsClientTypes.PosixUser: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gid = "Gid"
        case secondaryGids = "SecondaryGids"
        case uid = "Uid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gid = gid {
            try encodeContainer.encode(gid, forKey: .gid)
        }
        if let secondaryGids = secondaryGids {
            var secondaryGidsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryGids)
            for secondarygids0 in secondaryGids {
                try secondaryGidsContainer.encode(secondarygids0)
            }
        }
        if let uid = uid {
            try encodeContainer.encode(uid, forKey: .uid)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uid)
        uid = uidDecoded
        let gidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gid)
        gid = gidDecoded
        let secondaryGidsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .secondaryGids)
        var secondaryGidsDecoded0:[Swift.Int]? = nil
        if let secondaryGidsContainer = secondaryGidsContainer {
            secondaryGidsDecoded0 = [Swift.Int]()
            for long0 in secondaryGidsContainer {
                if let long0 = long0 {
                    secondaryGidsDecoded0?.append(long0)
                }
            }
        }
        secondaryGids = secondaryGidsDecoded0
    }
}

extension EfsClientTypes.PosixUser: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PosixUser(gid: \(Swift.String(describing: gid)), secondaryGids: \(Swift.String(describing: secondaryGids)), uid: \(Swift.String(describing: uid)))"}
}

extension EfsClientTypes {
    /// The full POSIX identity, including the user ID, group ID, and any secondary group IDs, on the access point that is used for all file system operations performed by
    ///       NFS clients using the access point.
    public struct PosixUser: Swift.Equatable {
        /// The POSIX group ID used for all file system operations using this access point.
        /// This member is required.
        public let gid: Swift.Int?
        /// Secondary POSIX group IDs used for all file system operations using this access point.
        public let secondaryGids: [Swift.Int]?
        /// The POSIX user ID used for all file system operations using this access point.
        /// This member is required.
        public let uid: Swift.Int?

        public init (
            gid: Swift.Int? = nil,
            secondaryGids: [Swift.Int]? = nil,
            uid: Swift.Int? = nil
        )
        {
            self.gid = gid
            self.secondaryGids = secondaryGids
            self.uid = uid
        }
    }

}

public struct PutAccountPreferencesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAccountPreferencesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAccountPreferencesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAccountPreferencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAccountPreferencesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAccountPreferencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAccountPreferencesOutputError>
}

extension PutAccountPreferencesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAccountPreferencesInput(resourceIdType: \(Swift.String(describing: resourceIdType)))"}
}

extension PutAccountPreferencesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceIdType = "ResourceIdType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceIdType = resourceIdType {
            try encodeContainer.encode(resourceIdType.rawValue, forKey: .resourceIdType)
        }
    }
}

public struct PutAccountPreferencesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAccountPreferencesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAccountPreferencesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAccountPreferencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAccountPreferencesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAccountPreferencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAccountPreferencesOutputError>
}

public struct PutAccountPreferencesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAccountPreferencesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAccountPreferencesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAccountPreferencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAccountPreferencesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAccountPreferencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAccountPreferencesOutputError>
}

public struct PutAccountPreferencesInput: Swift.Equatable {
    /// A preference indicating a choice to use 63bit/32bit IDs for all applicable resources.
    /// This member is required.
    public let resourceIdType: EfsClientTypes.ResourceIdType?

    public init (
        resourceIdType: EfsClientTypes.ResourceIdType? = nil
    )
    {
        self.resourceIdType = resourceIdType
    }
}

struct PutAccountPreferencesInputBody: Swift.Equatable {
    public let resourceIdType: EfsClientTypes.ResourceIdType?
}

extension PutAccountPreferencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceIdType = "ResourceIdType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdTypeDecoded = try containerValues.decodeIfPresent(EfsClientTypes.ResourceIdType.self, forKey: .resourceIdType)
        resourceIdType = resourceIdTypeDecoded
    }
}

extension PutAccountPreferencesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAccountPreferencesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAccountPreferencesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAccountPreferencesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAccountPreferencesOutputResponse(resourceIdPreference: \(Swift.String(describing: resourceIdPreference)))"}
}

extension PutAccountPreferencesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutAccountPreferencesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceIdPreference = output.resourceIdPreference
        } else {
            self.resourceIdPreference = nil
        }
    }
}

public struct PutAccountPreferencesOutputResponse: Swift.Equatable {
    public let resourceIdPreference: EfsClientTypes.ResourceIdPreference?

    public init (
        resourceIdPreference: EfsClientTypes.ResourceIdPreference? = nil
    )
    {
        self.resourceIdPreference = resourceIdPreference
    }
}

struct PutAccountPreferencesOutputResponseBody: Swift.Equatable {
    public let resourceIdPreference: EfsClientTypes.ResourceIdPreference?
}

extension PutAccountPreferencesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceIdPreference = "ResourceIdPreference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdPreferenceDecoded = try containerValues.decodeIfPresent(EfsClientTypes.ResourceIdPreference.self, forKey: .resourceIdPreference)
        resourceIdPreference = resourceIdPreferenceDecoded
    }
}

public struct PutBackupPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBackupPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBackupPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutBackupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBackupPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBackupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutBackupPolicyOutputError>
}

extension PutBackupPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutBackupPolicyInput(backupPolicy: \(Swift.String(describing: backupPolicy)), fileSystemId: \(Swift.String(describing: fileSystemId)))"}
}

extension PutBackupPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPolicy = "BackupPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPolicy = backupPolicy {
            try encodeContainer.encode(backupPolicy, forKey: .backupPolicy)
        }
    }
}

public struct PutBackupPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBackupPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBackupPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutBackupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBackupPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBackupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutBackupPolicyOutputError>
}

public struct PutBackupPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBackupPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBackupPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutBackupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBackupPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBackupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutBackupPolicyOutputError>
}

public struct PutBackupPolicyInput: Swift.Equatable {
    /// The backup policy included in the PutBackupPolicy request.
    /// This member is required.
    public let backupPolicy: EfsClientTypes.BackupPolicy?
    /// Specifies which EFS file system to update the backup policy for.
    /// This member is required.
    public let fileSystemId: Swift.String?

    public init (
        backupPolicy: EfsClientTypes.BackupPolicy? = nil,
        fileSystemId: Swift.String? = nil
    )
    {
        self.backupPolicy = backupPolicy
        self.fileSystemId = fileSystemId
    }
}

struct PutBackupPolicyInputBody: Swift.Equatable {
    public let backupPolicy: EfsClientTypes.BackupPolicy?
}

extension PutBackupPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPolicy = "BackupPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPolicyDecoded = try containerValues.decodeIfPresent(EfsClientTypes.BackupPolicy.self, forKey: .backupPolicy)
        backupPolicy = backupPolicyDecoded
    }
}

extension PutBackupPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutBackupPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectFileSystemLifeCycleState" : self = .incorrectFileSystemLifeCycleState(try IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBackupPolicyOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case incorrectFileSystemLifeCycleState(IncorrectFileSystemLifeCycleState)
    case internalServerError(InternalServerError)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBackupPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutBackupPolicyOutputResponse(backupPolicy: \(Swift.String(describing: backupPolicy)))"}
}

extension PutBackupPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutBackupPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupPolicy = output.backupPolicy
        } else {
            self.backupPolicy = nil
        }
    }
}

public struct PutBackupPolicyOutputResponse: Swift.Equatable {
    /// Describes the file system's backup policy, indicating whether automatic backups are turned on or off..
    public let backupPolicy: EfsClientTypes.BackupPolicy?

    public init (
        backupPolicy: EfsClientTypes.BackupPolicy? = nil
    )
    {
        self.backupPolicy = backupPolicy
    }
}

struct PutBackupPolicyOutputResponseBody: Swift.Equatable {
    public let backupPolicy: EfsClientTypes.BackupPolicy?
}

extension PutBackupPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPolicy = "BackupPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPolicyDecoded = try containerValues.decodeIfPresent(EfsClientTypes.BackupPolicy.self, forKey: .backupPolicy)
        backupPolicy = backupPolicyDecoded
    }
}

public struct PutFileSystemPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutFileSystemPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutFileSystemPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutFileSystemPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutFileSystemPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutFileSystemPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutFileSystemPolicyOutputError>
}

extension PutFileSystemPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutFileSystemPolicyInput(bypassPolicyLockoutSafetyCheck: \(Swift.String(describing: bypassPolicyLockoutSafetyCheck)), fileSystemId: \(Swift.String(describing: fileSystemId)), policy: \(Swift.String(describing: policy)))"}
}

extension PutFileSystemPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bypassPolicyLockoutSafetyCheck = "BypassPolicyLockoutSafetyCheck"
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bypassPolicyLockoutSafetyCheck != false {
            try encodeContainer.encode(bypassPolicyLockoutSafetyCheck, forKey: .bypassPolicyLockoutSafetyCheck)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct PutFileSystemPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutFileSystemPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutFileSystemPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutFileSystemPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutFileSystemPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutFileSystemPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutFileSystemPolicyOutputError>
}

public struct PutFileSystemPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutFileSystemPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutFileSystemPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutFileSystemPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutFileSystemPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutFileSystemPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutFileSystemPolicyOutputError>
}

public struct PutFileSystemPolicyInput: Swift.Equatable {
    /// (Optional) A flag to indicate whether to bypass the FileSystemPolicy lockout safety check. The policy lockout safety check
    ///       determines whether the policy in the request will prevent the principal making the request will be locked out from making future PutFileSystemPolicy requests on the file system.
    ///       Set BypassPolicyLockoutSafetyCheck to True only when you intend to prevent
    ///       the principal that is making the request from making a subsequent PutFileSystemPolicy request on the file system.
    ///       The default value is False.
    ///
    public let bypassPolicyLockoutSafetyCheck: Swift.Bool
    /// The ID of the EFS file system that you want to create or update the FileSystemPolicy for.
    /// This member is required.
    public let fileSystemId: Swift.String?
    /// The FileSystemPolicy that you're creating. Accepts a JSON formatted policy definition.
    ///      EFS file system policies have a 20,000 character limit.
    ///       To find out more about the elements that make up a file system policy, see
    ///       <a href="https://docs.aws.amazon.com/efs/latest/ug/access-control-overview.html#access-control-manage-access-intro-resource-policies">EFS Resource-based Policies.
    ///
    /// This member is required.
    public let policy: Swift.String?

    public init (
        bypassPolicyLockoutSafetyCheck: Swift.Bool = false,
        fileSystemId: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.bypassPolicyLockoutSafetyCheck = bypassPolicyLockoutSafetyCheck
        self.fileSystemId = fileSystemId
        self.policy = policy
    }
}

struct PutFileSystemPolicyInputBody: Swift.Equatable {
    public let policy: Swift.String?
    public let bypassPolicyLockoutSafetyCheck: Swift.Bool
}

extension PutFileSystemPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bypassPolicyLockoutSafetyCheck = "BypassPolicyLockoutSafetyCheck"
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let bypassPolicyLockoutSafetyCheckDecoded = try containerValues.decode(Swift.Bool.self, forKey: .bypassPolicyLockoutSafetyCheck)
        bypassPolicyLockoutSafetyCheck = bypassPolicyLockoutSafetyCheckDecoded
    }
}

extension PutFileSystemPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFileSystemPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectFileSystemLifeCycleState" : self = .incorrectFileSystemLifeCycleState(try IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPolicyException" : self = .invalidPolicyException(try InvalidPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutFileSystemPolicyOutputError: Swift.Error, Swift.Equatable {
    case fileSystemNotFound(FileSystemNotFound)
    case incorrectFileSystemLifeCycleState(IncorrectFileSystemLifeCycleState)
    case internalServerError(InternalServerError)
    case invalidPolicyException(InvalidPolicyException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFileSystemPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutFileSystemPolicyOutputResponse(fileSystemId: \(Swift.String(describing: fileSystemId)), policy: \(Swift.String(describing: policy)))"}
}

extension PutFileSystemPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutFileSystemPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileSystemId = output.fileSystemId
            self.policy = output.policy
        } else {
            self.fileSystemId = nil
            self.policy = nil
        }
    }
}

public struct PutFileSystemPolicyOutputResponse: Swift.Equatable {
    /// Specifies the EFS file system to which the FileSystemPolicy applies.
    public let fileSystemId: Swift.String?
    /// The JSON formatted FileSystemPolicy for the EFS file system.
    public let policy: Swift.String?

    public init (
        fileSystemId: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.policy = policy
    }
}

struct PutFileSystemPolicyOutputResponseBody: Swift.Equatable {
    public let fileSystemId: Swift.String?
    public let policy: Swift.String?
}

extension PutFileSystemPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemId = "FileSystemId"
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

public struct PutLifecycleConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLifecycleConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLifecycleConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLifecycleConfigurationOutputError>
}

extension PutLifecycleConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutLifecycleConfigurationInput(fileSystemId: \(Swift.String(describing: fileSystemId)), lifecyclePolicies: \(Swift.String(describing: lifecyclePolicies)))"}
}

extension PutLifecycleConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicies = "LifecyclePolicies"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecyclePolicies = lifecyclePolicies {
            var lifecyclePoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lifecyclePolicies)
            for lifecyclepolicies0 in lifecyclePolicies {
                try lifecyclePoliciesContainer.encode(lifecyclepolicies0)
            }
        }
    }
}

public struct PutLifecycleConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLifecycleConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLifecycleConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLifecycleConfigurationOutputError>
}

public struct PutLifecycleConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLifecycleConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLifecycleConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLifecycleConfigurationOutputError>
}

public struct PutLifecycleConfigurationInput: Swift.Equatable {
    /// The ID of the file system for which you are creating the
    ///         LifecycleConfiguration object (String).
    /// This member is required.
    public let fileSystemId: Swift.String?
    /// An array of LifecyclePolicy objects that define the file system's
    ///         LifecycleConfiguration object. A LifecycleConfiguration object
    ///       tells lifecycle management when to transition files from the Standard storage class to the
    ///       Infrequent Access storage class.
    /// This member is required.
    public let lifecyclePolicies: [EfsClientTypes.LifecyclePolicy]?

    public init (
        fileSystemId: Swift.String? = nil,
        lifecyclePolicies: [EfsClientTypes.LifecyclePolicy]? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.lifecyclePolicies = lifecyclePolicies
    }
}

struct PutLifecycleConfigurationInputBody: Swift.Equatable {
    public let lifecyclePolicies: [EfsClientTypes.LifecyclePolicy]?
}

extension PutLifecycleConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicies = "LifecyclePolicies"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecyclePoliciesContainer = try containerValues.decodeIfPresent([EfsClientTypes.LifecyclePolicy?].self, forKey: .lifecyclePolicies)
        var lifecyclePoliciesDecoded0:[EfsClientTypes.LifecyclePolicy]? = nil
        if let lifecyclePoliciesContainer = lifecyclePoliciesContainer {
            lifecyclePoliciesDecoded0 = [EfsClientTypes.LifecyclePolicy]()
            for structure0 in lifecyclePoliciesContainer {
                if let structure0 = structure0 {
                    lifecyclePoliciesDecoded0?.append(structure0)
                }
            }
        }
        lifecyclePolicies = lifecyclePoliciesDecoded0
    }
}

extension PutLifecycleConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLifecycleConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectFileSystemLifeCycleState" : self = .incorrectFileSystemLifeCycleState(try IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutLifecycleConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case incorrectFileSystemLifeCycleState(IncorrectFileSystemLifeCycleState)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLifecycleConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutLifecycleConfigurationOutputResponse(lifecyclePolicies: \(Swift.String(describing: lifecyclePolicies)))"}
}

extension PutLifecycleConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutLifecycleConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lifecyclePolicies = output.lifecyclePolicies
        } else {
            self.lifecyclePolicies = nil
        }
    }
}

public struct PutLifecycleConfigurationOutputResponse: Swift.Equatable {
    /// An array of lifecycle management policies. Currently, EFS supports a maximum of one
    ///       policy per file system.
    public let lifecyclePolicies: [EfsClientTypes.LifecyclePolicy]?

    public init (
        lifecyclePolicies: [EfsClientTypes.LifecyclePolicy]? = nil
    )
    {
        self.lifecyclePolicies = lifecyclePolicies
    }
}

struct PutLifecycleConfigurationOutputResponseBody: Swift.Equatable {
    public let lifecyclePolicies: [EfsClientTypes.LifecyclePolicy]?
}

extension PutLifecycleConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicies = "LifecyclePolicies"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecyclePoliciesContainer = try containerValues.decodeIfPresent([EfsClientTypes.LifecyclePolicy?].self, forKey: .lifecyclePolicies)
        var lifecyclePoliciesDecoded0:[EfsClientTypes.LifecyclePolicy]? = nil
        if let lifecyclePoliciesContainer = lifecyclePoliciesContainer {
            lifecyclePoliciesDecoded0 = [EfsClientTypes.LifecyclePolicy]()
            for structure0 in lifecyclePoliciesContainer {
                if let structure0 = structure0 {
                    lifecyclePoliciesDecoded0?.append(structure0)
                }
            }
        }
        lifecyclePolicies = lifecyclePoliciesDecoded0
    }
}

extension EfsClientTypes {
    /// An EFS resource, for example a file system or a mount target.
    public enum Resource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case filesystem
        case mounttarget
        case sdkUnknown(Swift.String)

        public static var allCases: [Resource] {
            return [
                .filesystem,
                .mounttarget,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .filesystem: return "FILE_SYSTEM"
            case .mounttarget: return "MOUNT_TARGET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Resource(rawValue: rawValue) ?? Resource.sdkUnknown(rawValue)
        }
    }
}

extension EfsClientTypes.ResourceIdPreference: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceIdType = "ResourceIdType"
        case resources = "Resources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceIdType = resourceIdType {
            try encodeContainer.encode(resourceIdType.rawValue, forKey: .resourceIdType)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resources0 in resources {
                try resourcesContainer.encode(resources0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdTypeDecoded = try containerValues.decodeIfPresent(EfsClientTypes.ResourceIdType.self, forKey: .resourceIdType)
        resourceIdType = resourceIdTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([EfsClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[EfsClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [EfsClientTypes.Resource]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension EfsClientTypes.ResourceIdPreference: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceIdPreference(resourceIdType: \(Swift.String(describing: resourceIdType)), resources: \(Swift.String(describing: resources)))"}
}

extension EfsClientTypes {
    public struct ResourceIdPreference: Swift.Equatable {
        /// A preference indicating a choice to use 63bit/32bit IDs for all applicable resources.
        public let resourceIdType: EfsClientTypes.ResourceIdType?
        /// EFS resources to which a preference applies to.
        public let resources: [EfsClientTypes.Resource]?

        public init (
            resourceIdType: EfsClientTypes.ResourceIdType? = nil,
            resources: [EfsClientTypes.Resource]? = nil
        )
        {
            self.resourceIdType = resourceIdType
            self.resources = resources
        }
    }

}

extension EfsClientTypes {
    /// A preference indicating a choice to use 63bit/32bit IDs for all applicable resources.
    public enum ResourceIdType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case longid
        case shortid
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceIdType] {
            return [
                .longid,
                .shortid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .longid: return "LONG_ID"
            case .shortid: return "SHORT_ID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceIdType(rawValue: rawValue) ?? ResourceIdType.sdkUnknown(rawValue)
        }
    }
}

extension EfsClientTypes.RootDirectory: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationInfo = "CreationInfo"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationInfo = creationInfo {
            try encodeContainer.encode(creationInfo, forKey: .creationInfo)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let creationInfoDecoded = try containerValues.decodeIfPresent(EfsClientTypes.CreationInfo.self, forKey: .creationInfo)
        creationInfo = creationInfoDecoded
    }
}

extension EfsClientTypes.RootDirectory: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RootDirectory(creationInfo: \(Swift.String(describing: creationInfo)), path: \(Swift.String(describing: path)))"}
}

extension EfsClientTypes {
    /// Specifies the directory on the Amazon EFS file system that the access point provides access to.
    ///       The access point exposes the specified file system path as
    ///       the root directory of your file system to applications using the access point.
    ///       NFS clients using the access point can only access data in the access point's RootDirectory and it's subdirectories.
    public struct RootDirectory: Swift.Equatable {
        /// (Optional) Specifies the POSIX IDs and permissions to apply to the access point's RootDirectory.
        ///       If the RootDirectory > Path specified does not exist,
        ///       EFS creates the root directory using the CreationInfo settings when a client connects to an access point.
        ///       When specifying the CreationInfo, you must provide values for all properties.
        ///
        ///
        ///             If you do not provide CreationInfo and the specified RootDirectory > Path does not exist,
        ///       attempts to mount the file system using the access point will fail.
        ///
        public let creationInfo: EfsClientTypes.CreationInfo?
        /// Specifies the path on the EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system.
        ///        A path can have up to four subdirectories.
        ///     If the specified path does not exist, you are required to provide the CreationInfo.
        public let path: Swift.String?

        public init (
            creationInfo: EfsClientTypes.CreationInfo? = nil,
            path: Swift.String? = nil
        )
        {
            self.creationInfo = creationInfo
            self.path = path
        }
    }

}

extension SecurityGroupLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SecurityGroupLimitExceeded(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension SecurityGroupLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SecurityGroupLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the size of SecurityGroups specified in the request is
///             greater than five.
public struct SecurityGroupLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct SecurityGroupLimitExceededBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension SecurityGroupLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SecurityGroupNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SecurityGroupNotFound(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension SecurityGroupNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SecurityGroupNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if one of the specified security groups doesn't exist in the subnet's
///             VPC.
public struct SecurityGroupNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct SecurityGroupNotFoundBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension SecurityGroupNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EfsClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabling
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabling: return "DISABLING"
            case .enabled: return "ENABLED"
            case .enabling: return "ENABLING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension SubnetNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetNotFound(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension SubnetNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubnetNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if there is no subnet with ID SubnetId provided in the
///             request.
public struct SubnetNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct SubnetNotFoundBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension SubnetNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EfsClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension EfsClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension EfsClientTypes {
    /// A tag is a key-value pair. Allowed characters are letters, white space, and numbers that
    ///       can be represented in UTF-8, and the following characters: + - = . _ : /.
    public struct Tag: Swift.Equatable {
        /// The tag key (String). The key can't start with aws:.
        /// This member is required.
        public let key: Swift.String?
        /// The value of the tag key.
        /// This member is required.
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceId: \(Swift.String(describing: resourceId)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The ID specifying the EFS resource that you want to create a tag for.
    /// This member is required.
    public let resourceId: Swift.String?
    /// An array of Tag objects to add. Each Tag object is a key-value
    ///       pair.
    /// This member is required.
    public let tags: [EfsClientTypes.Tag]?

    public init (
        resourceId: Swift.String? = nil,
        tags: [EfsClientTypes.Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [EfsClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([EfsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EfsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EfsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessPointNotFound" : self = .accessPointNotFound(try AccessPointNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFound(AccessPointNotFound)
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThroughputLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThroughputLimitExceeded(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension ThroughputLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThroughputLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the throughput mode or amount of provisioned throughput can't be changed
///             because the throughput limit of 1024 MiB/s has been reached.
public struct ThroughputLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct ThroughputLimitExceededBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension ThroughputLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EfsClientTypes {
    public enum ThroughputMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bursting
        case provisioned
        case sdkUnknown(Swift.String)

        public static var allCases: [ThroughputMode] {
            return [
                .bursting,
                .provisioned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bursting: return "bursting"
            case .provisioned: return "provisioned"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThroughputMode(rawValue: rawValue) ?? ThroughputMode.sdkUnknown(rawValue)
        }
    }
}

extension TooManyRequests: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyRequests(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension TooManyRequests {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if you dont wait at least 24 hours before changing the throughput mode, or
///             decreasing the Provisioned Throughput value.
public struct TooManyRequests: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct TooManyRequestsBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension TooManyRequestsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EfsClientTypes {
    public enum TransitionToIARules: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case after14Days
        case after30Days
        case after60Days
        case after7Days
        case after90Days
        case sdkUnknown(Swift.String)

        public static var allCases: [TransitionToIARules] {
            return [
                .after14Days,
                .after30Days,
                .after60Days,
                .after7Days,
                .after90Days,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .after14Days: return "AFTER_14_DAYS"
            case .after30Days: return "AFTER_30_DAYS"
            case .after60Days: return "AFTER_60_DAYS"
            case .after7Days: return "AFTER_7_DAYS"
            case .after90Days: return "AFTER_90_DAYS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransitionToIARules(rawValue: rawValue) ?? TransitionToIARules.sdkUnknown(rawValue)
        }
    }
}

extension UnsupportedAvailabilityZone: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedAvailabilityZone(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension UnsupportedAvailabilityZone {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedAvailabilityZoneBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the requested Amazon EFS functionality is not available in the specified Availability Zone.
public struct UnsupportedAvailabilityZone: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct UnsupportedAvailabilityZoneBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension UnsupportedAvailabilityZoneBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceId: \(Swift.String(describing: resourceId)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// Specifies the EFS resource that you want to remove tags from.
    /// This member is required.
    public let resourceId: Swift.String?
    /// The keys of the key-value tag pairs that you want to remove from the specified EFS
    ///       resource.
    /// This member is required.
    public let tagKeys: [Swift.String]?

    public init (
        resourceId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessPointNotFound" : self = .accessPointNotFound(try AccessPointNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFound(AccessPointNotFound)
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateFileSystemInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFileSystemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFileSystemOutputError>
}

extension UpdateFileSystemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFileSystemInput(fileSystemId: \(Swift.String(describing: fileSystemId)), provisionedThroughputInMibps: \(Swift.String(describing: provisionedThroughputInMibps)), throughputMode: \(Swift.String(describing: throughputMode)))"}
}

extension UpdateFileSystemInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case throughputMode = "ThroughputMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let provisionedThroughputInMibps = provisionedThroughputInMibps {
            try encodeContainer.encode(provisionedThroughputInMibps, forKey: .provisionedThroughputInMibps)
        }
        if let throughputMode = throughputMode {
            try encodeContainer.encode(throughputMode.rawValue, forKey: .throughputMode)
        }
    }
}

public struct UpdateFileSystemInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFileSystemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFileSystemOutputError>
}

public struct UpdateFileSystemInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFileSystemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFileSystemOutputError>
}

public struct UpdateFileSystemInput: Swift.Equatable {
    /// The ID of the file system that you want to update.
    /// This member is required.
    public let fileSystemId: Swift.String?
    /// (Optional) Sets the amount of provisioned throughput, in MiB/s, for the file
    ///       system. Valid values are 1-1024. If you are changing the throughput mode to provisioned, you must also
    ///       provide the amount of provisioned throughput. Required if ThroughputMode is changed
    ///       to provisioned on update.
    public let provisionedThroughputInMibps: Swift.Double?
    /// (Optional) Updates the file system's throughput mode. If you're not
    ///       updating your throughput mode, you don't need to provide this value in your
    ///       request. If you are changing the ThroughputMode to provisioned,
    ///       you must also set a value for ProvisionedThroughputInMibps.
    public let throughputMode: EfsClientTypes.ThroughputMode?

    public init (
        fileSystemId: Swift.String? = nil,
        provisionedThroughputInMibps: Swift.Double? = nil,
        throughputMode: EfsClientTypes.ThroughputMode? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.provisionedThroughputInMibps = provisionedThroughputInMibps
        self.throughputMode = throughputMode
    }
}

struct UpdateFileSystemInputBody: Swift.Equatable {
    public let throughputMode: EfsClientTypes.ThroughputMode?
    public let provisionedThroughputInMibps: Swift.Double?
}

extension UpdateFileSystemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case throughputMode = "ThroughputMode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let throughputModeDecoded = try containerValues.decodeIfPresent(EfsClientTypes.ThroughputMode.self, forKey: .throughputMode)
        throughputMode = throughputModeDecoded
        let provisionedThroughputInMibpsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .provisionedThroughputInMibps)
        provisionedThroughputInMibps = provisionedThroughputInMibpsDecoded
    }
}

extension UpdateFileSystemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFileSystemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectFileSystemLifeCycleState" : self = .incorrectFileSystemLifeCycleState(try IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientThroughputCapacity" : self = .insufficientThroughputCapacity(try InsufficientThroughputCapacity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThroughputLimitExceeded" : self = .throughputLimitExceeded(try ThroughputLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequests" : self = .tooManyRequests(try TooManyRequests(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFileSystemOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case incorrectFileSystemLifeCycleState(IncorrectFileSystemLifeCycleState)
    case insufficientThroughputCapacity(InsufficientThroughputCapacity)
    case internalServerError(InternalServerError)
    case throughputLimitExceeded(ThroughputLimitExceeded)
    case tooManyRequests(TooManyRequests)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFileSystemOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFileSystemOutputResponse(availabilityZoneId: \(Swift.String(describing: availabilityZoneId)), availabilityZoneName: \(Swift.String(describing: availabilityZoneName)), creationTime: \(Swift.String(describing: creationTime)), creationToken: \(Swift.String(describing: creationToken)), encrypted: \(Swift.String(describing: encrypted)), fileSystemArn: \(Swift.String(describing: fileSystemArn)), fileSystemId: \(Swift.String(describing: fileSystemId)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), lifeCycleState: \(Swift.String(describing: lifeCycleState)), name: \(Swift.String(describing: name)), numberOfMountTargets: \(Swift.String(describing: numberOfMountTargets)), ownerId: \(Swift.String(describing: ownerId)), performanceMode: \(Swift.String(describing: performanceMode)), provisionedThroughputInMibps: \(Swift.String(describing: provisionedThroughputInMibps)), sizeInBytes: \(Swift.String(describing: sizeInBytes)), tags: \(Swift.String(describing: tags)), throughputMode: \(Swift.String(describing: throughputMode)))"}
}

extension UpdateFileSystemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFileSystemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.availabilityZoneId = output.availabilityZoneId
            self.availabilityZoneName = output.availabilityZoneName
            self.creationTime = output.creationTime
            self.creationToken = output.creationToken
            self.encrypted = output.encrypted
            self.fileSystemArn = output.fileSystemArn
            self.fileSystemId = output.fileSystemId
            self.kmsKeyId = output.kmsKeyId
            self.lifeCycleState = output.lifeCycleState
            self.name = output.name
            self.numberOfMountTargets = output.numberOfMountTargets
            self.ownerId = output.ownerId
            self.performanceMode = output.performanceMode
            self.provisionedThroughputInMibps = output.provisionedThroughputInMibps
            self.sizeInBytes = output.sizeInBytes
            self.tags = output.tags
            self.throughputMode = output.throughputMode
        } else {
            self.availabilityZoneId = nil
            self.availabilityZoneName = nil
            self.creationTime = nil
            self.creationToken = nil
            self.encrypted = nil
            self.fileSystemArn = nil
            self.fileSystemId = nil
            self.kmsKeyId = nil
            self.lifeCycleState = nil
            self.name = nil
            self.numberOfMountTargets = 0
            self.ownerId = nil
            self.performanceMode = nil
            self.provisionedThroughputInMibps = nil
            self.sizeInBytes = nil
            self.tags = nil
            self.throughputMode = nil
        }
    }
}

/// A description of the file system.
public struct UpdateFileSystemOutputResponse: Swift.Equatable {
    /// The unique and consistent identifier of the Availability Zone in which the file system's
    ///       One Zone storage classes exist. For example, use1-az1 is an Availability Zone ID
    ///       for the us-east-1 AWS Region, and it has the same location in every AWS account.
    public let availabilityZoneId: Swift.String?
    /// Describes the AWS Availability Zone in which the file system is located, and is valid only
    ///       for file systems using One Zone storage classes. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html">Using EFS storage classes
    ///       in the Amazon EFS User Guide.
    public let availabilityZoneName: Swift.String?
    /// The time that the file system was created, in seconds (since
    ///       1970-01-01T00:00:00Z).
    /// This member is required.
    public let creationTime: ClientRuntime.Date?
    /// The opaque string specified in the request.
    /// This member is required.
    public let creationToken: Swift.String?
    /// A Boolean value that, if true, indicates that the file system is encrypted.
    public let encrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) for the EFS file system, in the format
    ///       arn:aws:elasticfilesystem:region:account-id:file-system/file-system-id
    ///             .
    ///       Example with sample data: arn:aws:elasticfilesystem:us-west-2:1111333322228888:file-system/fs-01234567
    ///
    public let fileSystemArn: Swift.String?
    /// The ID of the file system, assigned by Amazon EFS.
    /// This member is required.
    public let fileSystemId: Swift.String?
    /// The ID of an AWS Key Management Service (AWS KMS) customer master key (CMK) that was
    ///       used to protect the encrypted file system.
    public let kmsKeyId: Swift.String?
    /// The lifecycle phase of the file system.
    /// This member is required.
    public let lifeCycleState: EfsClientTypes.LifeCycleState?
    /// You can add tags to a file system, including a Name tag. For more
    ///       information, see CreateFileSystem. If the file system has a Name tag, Amazon EFS returns
    ///       the value in this field.
    public let name: Swift.String?
    /// The current number of mount targets that the file system has. For more information, see CreateMountTarget.
    /// This member is required.
    public let numberOfMountTargets: Swift.Int
    /// The AWS account that created the file system. If the file system was created by an IAM
    ///       user, the parent account to which the user belongs is the owner.
    /// This member is required.
    public let ownerId: Swift.String?
    /// The performance mode of the file system.
    /// This member is required.
    public let performanceMode: EfsClientTypes.PerformanceMode?
    /// The amount of provisioned throughput, measured in MiB/s, for the file system. Valid for
    ///       file systems using ThroughputMode set to provisioned.
    public let provisionedThroughputInMibps: Swift.Double?
    /// The latest known metered size (in bytes) of data stored in the file system, in its
    ///         Value field, and the time at which that size was determined in its
    ///         Timestamp field. The Timestamp value is the integer number of
    ///       seconds since 1970-01-01T00:00:00Z. The SizeInBytes value doesn't represent
    ///       the size of a consistent snapshot of the file system, but it is eventually consistent when
    ///       there are no writes to the file system. That is, SizeInBytes represents actual
    ///       size only if the file system is not modified for a period longer than a couple of hours.
    ///       Otherwise, the value is not the exact size that the file system was at any point in time.
    ///
    /// This member is required.
    public let sizeInBytes: EfsClientTypes.FileSystemSize?
    /// The tags associated with the file system, presented as an array of Tag
    ///       objects.
    /// This member is required.
    public let tags: [EfsClientTypes.Tag]?
    /// Displays the file system's throughput mode. For more information, see
    ///       <a href="https://docs.aws.amazon.com/efs/latest/ug/performance.html#throughput-modes">Throughput modes
    ///       in the Amazon EFS User Guide.
    ///
    public let throughputMode: EfsClientTypes.ThroughputMode?

    public init (
        availabilityZoneId: Swift.String? = nil,
        availabilityZoneName: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        creationToken: Swift.String? = nil,
        encrypted: Swift.Bool? = nil,
        fileSystemArn: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        lifeCycleState: EfsClientTypes.LifeCycleState? = nil,
        name: Swift.String? = nil,
        numberOfMountTargets: Swift.Int = 0,
        ownerId: Swift.String? = nil,
        performanceMode: EfsClientTypes.PerformanceMode? = nil,
        provisionedThroughputInMibps: Swift.Double? = nil,
        sizeInBytes: EfsClientTypes.FileSystemSize? = nil,
        tags: [EfsClientTypes.Tag]? = nil,
        throughputMode: EfsClientTypes.ThroughputMode? = nil
    )
    {
        self.availabilityZoneId = availabilityZoneId
        self.availabilityZoneName = availabilityZoneName
        self.creationTime = creationTime
        self.creationToken = creationToken
        self.encrypted = encrypted
        self.fileSystemArn = fileSystemArn
        self.fileSystemId = fileSystemId
        self.kmsKeyId = kmsKeyId
        self.lifeCycleState = lifeCycleState
        self.name = name
        self.numberOfMountTargets = numberOfMountTargets
        self.ownerId = ownerId
        self.performanceMode = performanceMode
        self.provisionedThroughputInMibps = provisionedThroughputInMibps
        self.sizeInBytes = sizeInBytes
        self.tags = tags
        self.throughputMode = throughputMode
    }
}

struct UpdateFileSystemOutputResponseBody: Swift.Equatable {
    public let ownerId: Swift.String?
    public let creationToken: Swift.String?
    public let fileSystemId: Swift.String?
    public let fileSystemArn: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let lifeCycleState: EfsClientTypes.LifeCycleState?
    public let name: Swift.String?
    public let numberOfMountTargets: Swift.Int
    public let sizeInBytes: EfsClientTypes.FileSystemSize?
    public let performanceMode: EfsClientTypes.PerformanceMode?
    public let encrypted: Swift.Bool?
    public let kmsKeyId: Swift.String?
    public let throughputMode: EfsClientTypes.ThroughputMode?
    public let provisionedThroughputInMibps: Swift.Double?
    public let availabilityZoneName: Swift.String?
    public let availabilityZoneId: Swift.String?
    public let tags: [EfsClientTypes.Tag]?
}

extension UpdateFileSystemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneId = "AvailabilityZoneId"
        case availabilityZoneName = "AvailabilityZoneName"
        case creationTime = "CreationTime"
        case creationToken = "CreationToken"
        case encrypted = "Encrypted"
        case fileSystemArn = "FileSystemArn"
        case fileSystemId = "FileSystemId"
        case kmsKeyId = "KmsKeyId"
        case lifeCycleState = "LifeCycleState"
        case name = "Name"
        case numberOfMountTargets = "NumberOfMountTargets"
        case ownerId = "OwnerId"
        case performanceMode = "PerformanceMode"
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case sizeInBytes = "SizeInBytes"
        case tags = "Tags"
        case throughputMode = "ThroughputMode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let creationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationToken)
        creationToken = creationTokenDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let fileSystemArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemArn)
        fileSystemArn = fileSystemArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(EfsClientTypes.LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let numberOfMountTargetsDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfMountTargets)
        numberOfMountTargets = numberOfMountTargetsDecoded
        let sizeInBytesDecoded = try containerValues.decodeIfPresent(EfsClientTypes.FileSystemSize.self, forKey: .sizeInBytes)
        sizeInBytes = sizeInBytesDecoded
        let performanceModeDecoded = try containerValues.decodeIfPresent(EfsClientTypes.PerformanceMode.self, forKey: .performanceMode)
        performanceMode = performanceModeDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let throughputModeDecoded = try containerValues.decodeIfPresent(EfsClientTypes.ThroughputMode.self, forKey: .throughputMode)
        throughputMode = throughputModeDecoded
        let provisionedThroughputInMibpsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .provisionedThroughputInMibps)
        provisionedThroughputInMibps = provisionedThroughputInMibpsDecoded
        let availabilityZoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneName)
        availabilityZoneName = availabilityZoneNameDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EfsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EfsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EfsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the AWS Backup service is not available in the Region in which the request was made.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
