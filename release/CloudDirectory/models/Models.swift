// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Access denied. Check your permissions.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AddFacetToObjectInputBodyMiddleware: Middleware {
    public let id: String = "AddFacetToObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddFacetToObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<AddFacetToObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddFacetToObjectInput>
    public typealias MOutput = OperationOutput<AddFacetToObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddFacetToObjectOutputError>
}

extension AddFacetToObjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddFacetToObjectInput(directoryArn: \(String(describing: directoryArn)), objectAttributeList: \(String(describing: objectAttributeList)), objectReference: \(String(describing: objectReference)), schemaFacet: \(String(describing: schemaFacet)))"}
}

extension AddFacetToObjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectAttributeList = "ObjectAttributeList"
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectAttributeList = objectAttributeList {
            var objectAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectAttributeList)
            for attributekeyandvaluelist0 in objectAttributeList {
                try objectAttributeListContainer.encode(attributekeyandvaluelist0)
            }
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let schemaFacet = schemaFacet {
            try encodeContainer.encode(schemaFacet, forKey: .schemaFacet)
        }
    }
}

public struct AddFacetToObjectInputHeadersMiddleware: Middleware {
    public let id: String = "AddFacetToObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddFacetToObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<AddFacetToObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddFacetToObjectInput>
    public typealias MOutput = OperationOutput<AddFacetToObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddFacetToObjectOutputError>
}

public struct AddFacetToObjectInputQueryItemMiddleware: Middleware {
    public let id: String = "AddFacetToObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddFacetToObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<AddFacetToObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddFacetToObjectInput>
    public typealias MOutput = OperationOutput<AddFacetToObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddFacetToObjectOutputError>
}

public struct AddFacetToObjectInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that is associated with the <a>Directory</a>
    ///       where the object resides. For more information, see <a>arns</a>.</p>
    public let directoryArn: String?
    /// <p>Attributes on the facet that you are adding to the object.</p>
    public let objectAttributeList: [AttributeKeyAndValue]?
    /// <p>A reference to the object you are adding the specified facet to.</p>
    public let objectReference: ObjectReference?
    /// <p>Identifiers for the facet that you are adding to the object. See <a>SchemaFacet</a> for details.</p>
    public let schemaFacet: SchemaFacet?

    public init (
        directoryArn: String? = nil,
        objectAttributeList: [AttributeKeyAndValue]? = nil,
        objectReference: ObjectReference? = nil,
        schemaFacet: SchemaFacet? = nil
    )
    {
        self.directoryArn = directoryArn
        self.objectAttributeList = objectAttributeList
        self.objectReference = objectReference
        self.schemaFacet = schemaFacet
    }
}

struct AddFacetToObjectInputBody: Equatable {
    public let schemaFacet: SchemaFacet?
    public let objectAttributeList: [AttributeKeyAndValue]?
    public let objectReference: ObjectReference?
}

extension AddFacetToObjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case objectAttributeList = "ObjectAttributeList"
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetDecoded = try containerValues.decodeIfPresent(SchemaFacet.self, forKey: .schemaFacet)
        schemaFacet = schemaFacetDecoded
        let objectAttributeListContainer = try containerValues.decodeIfPresent([AttributeKeyAndValue?].self, forKey: .objectAttributeList)
        var objectAttributeListDecoded0:[AttributeKeyAndValue]? = nil
        if let objectAttributeListContainer = objectAttributeListContainer {
            objectAttributeListDecoded0 = [AttributeKeyAndValue]()
            for structure0 in objectAttributeListContainer {
                if let structure0 = structure0 {
                    objectAttributeListDecoded0?.append(structure0)
                }
            }
        }
        objectAttributeList = objectAttributeListDecoded0
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension AddFacetToObjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddFacetToObjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddFacetToObjectOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddFacetToObjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddFacetToObjectOutputResponse()"}
}

extension AddFacetToObjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddFacetToObjectOutputResponse: Equatable {

    public init() {}
}

struct AddFacetToObjectOutputResponseBody: Equatable {
}

extension AddFacetToObjectOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ApplySchemaInputBodyMiddleware: Middleware {
    public let id: String = "ApplySchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplySchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplySchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplySchemaInput>
    public typealias MOutput = OperationOutput<ApplySchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplySchemaOutputError>
}

extension ApplySchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplySchemaInput(directoryArn: \(String(describing: directoryArn)), publishedSchemaArn: \(String(describing: publishedSchemaArn)))"}
}

extension ApplySchemaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let publishedSchemaArn = publishedSchemaArn {
            try encodeContainer.encode(publishedSchemaArn, forKey: .publishedSchemaArn)
        }
    }
}

public struct ApplySchemaInputHeadersMiddleware: Middleware {
    public let id: String = "ApplySchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplySchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplySchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplySchemaInput>
    public typealias MOutput = OperationOutput<ApplySchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplySchemaOutputError>
}

public struct ApplySchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "ApplySchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplySchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplySchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplySchemaInput>
    public typealias MOutput = OperationOutput<ApplySchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplySchemaOutputError>
}

public struct ApplySchemaInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that is associated with the <a>Directory</a>
    ///       into which the schema is copied. For more information, see <a>arns</a>.</p>
    public let directoryArn: String?
    /// <p>Published schema Amazon Resource Name (ARN) that needs to be copied. For more
    ///       information, see <a>arns</a>.</p>
    public let publishedSchemaArn: String?

    public init (
        directoryArn: String? = nil,
        publishedSchemaArn: String? = nil
    )
    {
        self.directoryArn = directoryArn
        self.publishedSchemaArn = publishedSchemaArn
    }
}

struct ApplySchemaInputBody: Equatable {
    public let publishedSchemaArn: String?
}

extension ApplySchemaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publishedSchemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publishedSchemaArn)
        publishedSchemaArn = publishedSchemaArnDecoded
    }
}

extension ApplySchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ApplySchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAttachmentException" : self = .invalidAttachmentException(try InvalidAttachmentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SchemaAlreadyExistsException" : self = .schemaAlreadyExistsException(try SchemaAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ApplySchemaOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidAttachmentException(InvalidAttachmentException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case schemaAlreadyExistsException(SchemaAlreadyExistsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ApplySchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplySchemaOutputResponse(appliedSchemaArn: \(String(describing: appliedSchemaArn)), directoryArn: \(String(describing: directoryArn)))"}
}

extension ApplySchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ApplySchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appliedSchemaArn = output.appliedSchemaArn
            self.directoryArn = output.directoryArn
        } else {
            self.appliedSchemaArn = nil
            self.directoryArn = nil
        }
    }
}

public struct ApplySchemaOutputResponse: Equatable {
    /// <p>The applied schema ARN that is associated with the copied schema in the <a>Directory</a>. You can use this ARN to describe the schema information applied on
    ///       this directory. For more information, see <a>arns</a>.</p>
    public let appliedSchemaArn: String?
    /// <p>The ARN that is associated with the <a>Directory</a>. For more information,
    ///       see <a>arns</a>.</p>
    public let directoryArn: String?

    public init (
        appliedSchemaArn: String? = nil,
        directoryArn: String? = nil
    )
    {
        self.appliedSchemaArn = appliedSchemaArn
        self.directoryArn = directoryArn
    }
}

struct ApplySchemaOutputResponseBody: Equatable {
    public let appliedSchemaArn: String?
    public let directoryArn: String?
}

extension ApplySchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appliedSchemaArn = "AppliedSchemaArn"
        case directoryArn = "DirectoryArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appliedSchemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appliedSchemaArn)
        appliedSchemaArn = appliedSchemaArnDecoded
        let directoryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
    }
}

public struct AttachObjectInputBodyMiddleware: Middleware {
    public let id: String = "AttachObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachObjectInput>
    public typealias MOutput = OperationOutput<AttachObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachObjectOutputError>
}

extension AttachObjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachObjectInput(childReference: \(String(describing: childReference)), directoryArn: \(String(describing: directoryArn)), linkName: \(String(describing: linkName)), parentReference: \(String(describing: parentReference)))"}
}

extension AttachObjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case childReference = "ChildReference"
        case linkName = "LinkName"
        case parentReference = "ParentReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childReference = childReference {
            try encodeContainer.encode(childReference, forKey: .childReference)
        }
        if let linkName = linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let parentReference = parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
    }
}

public struct AttachObjectInputHeadersMiddleware: Middleware {
    public let id: String = "AttachObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachObjectInput>
    public typealias MOutput = OperationOutput<AttachObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachObjectOutputError>
}

public struct AttachObjectInputQueryItemMiddleware: Middleware {
    public let id: String = "AttachObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachObjectInput>
    public typealias MOutput = OperationOutput<AttachObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachObjectOutputError>
}

public struct AttachObjectInput: Equatable {
    /// <p>The child object reference to be attached to the object.</p>
    public let childReference: ObjectReference?
    /// <p>Amazon Resource Name (ARN) that is associated with the <a>Directory</a>
    ///       where both objects reside. For more information, see <a>arns</a>.</p>
    public let directoryArn: String?
    /// <p>The link name with which the child object is attached to the parent.</p>
    public let linkName: String?
    /// <p>The parent object reference.</p>
    public let parentReference: ObjectReference?

    public init (
        childReference: ObjectReference? = nil,
        directoryArn: String? = nil,
        linkName: String? = nil,
        parentReference: ObjectReference? = nil
    )
    {
        self.childReference = childReference
        self.directoryArn = directoryArn
        self.linkName = linkName
        self.parentReference = parentReference
    }
}

struct AttachObjectInputBody: Equatable {
    public let parentReference: ObjectReference?
    public let childReference: ObjectReference?
    public let linkName: String?
}

extension AttachObjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case childReference = "ChildReference"
        case linkName = "LinkName"
        case parentReference = "ParentReference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let childReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .childReference)
        childReference = childReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkName)
        linkName = linkNameDecoded
    }
}

extension AttachObjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AttachObjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAttachmentException" : self = .invalidAttachmentException(try InvalidAttachmentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LinkNameAlreadyInUseException" : self = .linkNameAlreadyInUseException(try LinkNameAlreadyInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachObjectOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidAttachmentException(InvalidAttachmentException)
    case limitExceededException(LimitExceededException)
    case linkNameAlreadyInUseException(LinkNameAlreadyInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachObjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachObjectOutputResponse(attachedObjectIdentifier: \(String(describing: attachedObjectIdentifier)))"}
}

extension AttachObjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AttachObjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attachedObjectIdentifier = output.attachedObjectIdentifier
        } else {
            self.attachedObjectIdentifier = nil
        }
    }
}

public struct AttachObjectOutputResponse: Equatable {
    /// <p>The attached <code>ObjectIdentifier</code>, which is the child
    ///         <code>ObjectIdentifier</code>.</p>
    public let attachedObjectIdentifier: String?

    public init (
        attachedObjectIdentifier: String? = nil
    )
    {
        self.attachedObjectIdentifier = attachedObjectIdentifier
    }
}

struct AttachObjectOutputResponseBody: Equatable {
    public let attachedObjectIdentifier: String?
}

extension AttachObjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attachedObjectIdentifier = "AttachedObjectIdentifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachedObjectIdentifier)
        attachedObjectIdentifier = attachedObjectIdentifierDecoded
    }
}

public struct AttachPolicyInputBodyMiddleware: Middleware {
    public let id: String = "AttachPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachPolicyInput>
    public typealias MOutput = OperationOutput<AttachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachPolicyOutputError>
}

extension AttachPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachPolicyInput(directoryArn: \(String(describing: directoryArn)), objectReference: \(String(describing: objectReference)), policyReference: \(String(describing: policyReference)))"}
}

extension AttachPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectReference = "ObjectReference"
        case policyReference = "PolicyReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let policyReference = policyReference {
            try encodeContainer.encode(policyReference, forKey: .policyReference)
        }
    }
}

public struct AttachPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "AttachPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachPolicyInput>
    public typealias MOutput = OperationOutput<AttachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachPolicyOutputError>
}

public struct AttachPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "AttachPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachPolicyInput>
    public typealias MOutput = OperationOutput<AttachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachPolicyOutputError>
}

public struct AttachPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that is associated with the <a>Directory</a>
    ///       where both objects reside. For more information, see <a>arns</a>.</p>
    public let directoryArn: String?
    /// <p>The reference that identifies the object to which the policy will be
    ///       attached.</p>
    public let objectReference: ObjectReference?
    /// <p>The reference that is associated with the policy object.</p>
    public let policyReference: ObjectReference?

    public init (
        directoryArn: String? = nil,
        objectReference: ObjectReference? = nil,
        policyReference: ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.objectReference = objectReference
        self.policyReference = policyReference
    }
}

struct AttachPolicyInputBody: Equatable {
    public let policyReference: ObjectReference?
    public let objectReference: ObjectReference?
}

extension AttachPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case objectReference = "ObjectReference"
        case policyReference = "PolicyReference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .policyReference)
        policyReference = policyReferenceDecoded
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension AttachPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AttachPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotPolicyException" : self = .notPolicyException(try NotPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachPolicyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case notPolicyException(NotPolicyException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachPolicyOutputResponse()"}
}

extension AttachPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AttachPolicyOutputResponse: Equatable {

    public init() {}
}

struct AttachPolicyOutputResponseBody: Equatable {
}

extension AttachPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AttachToIndexInputBodyMiddleware: Middleware {
    public let id: String = "AttachToIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachToIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachToIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachToIndexInput>
    public typealias MOutput = OperationOutput<AttachToIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachToIndexOutputError>
}

extension AttachToIndexInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachToIndexInput(directoryArn: \(String(describing: directoryArn)), indexReference: \(String(describing: indexReference)), targetReference: \(String(describing: targetReference)))"}
}

extension AttachToIndexInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexReference = "IndexReference"
        case targetReference = "TargetReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexReference = indexReference {
            try encodeContainer.encode(indexReference, forKey: .indexReference)
        }
        if let targetReference = targetReference {
            try encodeContainer.encode(targetReference, forKey: .targetReference)
        }
    }
}

public struct AttachToIndexInputHeadersMiddleware: Middleware {
    public let id: String = "AttachToIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachToIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachToIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachToIndexInput>
    public typealias MOutput = OperationOutput<AttachToIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachToIndexOutputError>
}

public struct AttachToIndexInputQueryItemMiddleware: Middleware {
    public let id: String = "AttachToIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachToIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachToIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachToIndexInput>
    public typealias MOutput = OperationOutput<AttachToIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachToIndexOutputError>
}

public struct AttachToIndexInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the directory where the object and index
    ///       exist.</p>
    public let directoryArn: String?
    /// <p>A reference to the index that you are attaching the object to.</p>
    public let indexReference: ObjectReference?
    /// <p>A reference to the object that you are attaching to the index.</p>
    public let targetReference: ObjectReference?

    public init (
        directoryArn: String? = nil,
        indexReference: ObjectReference? = nil,
        targetReference: ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.indexReference = indexReference
        self.targetReference = targetReference
    }
}

struct AttachToIndexInputBody: Equatable {
    public let indexReference: ObjectReference?
    public let targetReference: ObjectReference?
}

extension AttachToIndexInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexReference = "IndexReference"
        case targetReference = "TargetReference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .indexReference)
        indexReference = indexReferenceDecoded
        let targetReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .targetReference)
        targetReference = targetReferenceDecoded
    }
}

extension AttachToIndexOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AttachToIndexOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IndexedAttributeMissingException" : self = .indexedAttributeMissingException(try IndexedAttributeMissingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAttachmentException" : self = .invalidAttachmentException(try InvalidAttachmentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LinkNameAlreadyInUseException" : self = .linkNameAlreadyInUseException(try LinkNameAlreadyInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotIndexException" : self = .notIndexException(try NotIndexException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachToIndexOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case indexedAttributeMissingException(IndexedAttributeMissingException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidAttachmentException(InvalidAttachmentException)
    case limitExceededException(LimitExceededException)
    case linkNameAlreadyInUseException(LinkNameAlreadyInUseException)
    case notIndexException(NotIndexException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachToIndexOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachToIndexOutputResponse(attachedObjectIdentifier: \(String(describing: attachedObjectIdentifier)))"}
}

extension AttachToIndexOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AttachToIndexOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attachedObjectIdentifier = output.attachedObjectIdentifier
        } else {
            self.attachedObjectIdentifier = nil
        }
    }
}

public struct AttachToIndexOutputResponse: Equatable {
    /// <p>The <code>ObjectIdentifier</code> of the object that was attached to the index.</p>
    public let attachedObjectIdentifier: String?

    public init (
        attachedObjectIdentifier: String? = nil
    )
    {
        self.attachedObjectIdentifier = attachedObjectIdentifier
    }
}

struct AttachToIndexOutputResponseBody: Equatable {
    public let attachedObjectIdentifier: String?
}

extension AttachToIndexOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attachedObjectIdentifier = "AttachedObjectIdentifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachedObjectIdentifier)
        attachedObjectIdentifier = attachedObjectIdentifierDecoded
    }
}

public struct AttachTypedLinkInputBodyMiddleware: Middleware {
    public let id: String = "AttachTypedLinkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachTypedLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachTypedLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachTypedLinkInput>
    public typealias MOutput = OperationOutput<AttachTypedLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachTypedLinkOutputError>
}

extension AttachTypedLinkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachTypedLinkInput(attributes: \(String(describing: attributes)), directoryArn: \(String(describing: directoryArn)), sourceObjectReference: \(String(describing: sourceObjectReference)), targetObjectReference: \(String(describing: targetObjectReference)), typedLinkFacet: \(String(describing: typedLinkFacet)))"}
}

extension AttachTypedLinkInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case sourceObjectReference = "SourceObjectReference"
        case targetObjectReference = "TargetObjectReference"
        case typedLinkFacet = "TypedLinkFacet"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributenameandvaluelist0 in attributes {
                try attributesContainer.encode(attributenameandvaluelist0)
            }
        }
        if let sourceObjectReference = sourceObjectReference {
            try encodeContainer.encode(sourceObjectReference, forKey: .sourceObjectReference)
        }
        if let targetObjectReference = targetObjectReference {
            try encodeContainer.encode(targetObjectReference, forKey: .targetObjectReference)
        }
        if let typedLinkFacet = typedLinkFacet {
            try encodeContainer.encode(typedLinkFacet, forKey: .typedLinkFacet)
        }
    }
}

public struct AttachTypedLinkInputHeadersMiddleware: Middleware {
    public let id: String = "AttachTypedLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachTypedLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachTypedLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachTypedLinkInput>
    public typealias MOutput = OperationOutput<AttachTypedLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachTypedLinkOutputError>
}

public struct AttachTypedLinkInputQueryItemMiddleware: Middleware {
    public let id: String = "AttachTypedLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachTypedLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachTypedLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachTypedLinkInput>
    public typealias MOutput = OperationOutput<AttachTypedLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachTypedLinkOutputError>
}

public struct AttachTypedLinkInput: Equatable {
    /// <p>A set of attributes that are associated with the typed link.</p>
    public let attributes: [AttributeNameAndValue]?
    /// <p>The Amazon Resource Name (ARN) of the directory where you want to attach the typed
    ///       link.</p>
    public let directoryArn: String?
    /// <p>Identifies the source object that the typed link will attach to.</p>
    public let sourceObjectReference: ObjectReference?
    /// <p>Identifies the target object that the typed link will attach to.</p>
    public let targetObjectReference: ObjectReference?
    /// <p>Identifies the typed link facet that is associated with the typed link.</p>
    public let typedLinkFacet: TypedLinkSchemaAndFacetName?

    public init (
        attributes: [AttributeNameAndValue]? = nil,
        directoryArn: String? = nil,
        sourceObjectReference: ObjectReference? = nil,
        targetObjectReference: ObjectReference? = nil,
        typedLinkFacet: TypedLinkSchemaAndFacetName? = nil
    )
    {
        self.attributes = attributes
        self.directoryArn = directoryArn
        self.sourceObjectReference = sourceObjectReference
        self.targetObjectReference = targetObjectReference
        self.typedLinkFacet = typedLinkFacet
    }
}

struct AttachTypedLinkInputBody: Equatable {
    public let sourceObjectReference: ObjectReference?
    public let targetObjectReference: ObjectReference?
    public let typedLinkFacet: TypedLinkSchemaAndFacetName?
    public let attributes: [AttributeNameAndValue]?
}

extension AttachTypedLinkInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case sourceObjectReference = "SourceObjectReference"
        case targetObjectReference = "TargetObjectReference"
        case typedLinkFacet = "TypedLinkFacet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceObjectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .sourceObjectReference)
        sourceObjectReference = sourceObjectReferenceDecoded
        let targetObjectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .targetObjectReference)
        targetObjectReference = targetObjectReferenceDecoded
        let typedLinkFacetDecoded = try containerValues.decodeIfPresent(TypedLinkSchemaAndFacetName.self, forKey: .typedLinkFacet)
        typedLinkFacet = typedLinkFacetDecoded
        let attributesContainer = try containerValues.decodeIfPresent([AttributeNameAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[AttributeNameAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [AttributeNameAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension AttachTypedLinkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AttachTypedLinkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAttachmentException" : self = .invalidAttachmentException(try InvalidAttachmentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachTypedLinkOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidAttachmentException(InvalidAttachmentException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachTypedLinkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachTypedLinkOutputResponse(typedLinkSpecifier: \(String(describing: typedLinkSpecifier)))"}
}

extension AttachTypedLinkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AttachTypedLinkOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.typedLinkSpecifier = output.typedLinkSpecifier
        } else {
            self.typedLinkSpecifier = nil
        }
    }
}

public struct AttachTypedLinkOutputResponse: Equatable {
    /// <p>Returns a typed link specifier as output.</p>
    public let typedLinkSpecifier: TypedLinkSpecifier?

    public init (
        typedLinkSpecifier: TypedLinkSpecifier? = nil
    )
    {
        self.typedLinkSpecifier = typedLinkSpecifier
    }
}

struct AttachTypedLinkOutputResponseBody: Equatable {
    public let typedLinkSpecifier: TypedLinkSpecifier?
}

extension AttachTypedLinkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
    }
}

extension AttributeKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case facetName = "FacetName"
        case name = "Name"
        case schemaArn = "SchemaArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facetName = facetName {
            try encodeContainer.encode(facetName, forKey: .facetName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let facetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .facetName)
        facetName = facetNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AttributeKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttributeKey(facetName: \(String(describing: facetName)), name: \(String(describing: name)), schemaArn: \(String(describing: schemaArn)))"}
}

/// <p>A unique identifier for an attribute.</p>
public struct AttributeKey: Equatable {
    /// <p>The name of the facet that the attribute exists within.</p>
    public let facetName: String?
    /// <p>The name of the attribute.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the schema that contains the facet and
    ///       attribute.</p>
    public let schemaArn: String?

    public init (
        facetName: String? = nil,
        name: String? = nil,
        schemaArn: String? = nil
    )
    {
        self.facetName = facetName
        self.name = name
        self.schemaArn = schemaArn
    }
}

extension AttributeKeyAndValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(AttributeKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(TypedAttributeValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension AttributeKeyAndValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttributeKeyAndValue(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>The combination of an attribute key and an attribute value.</p>
public struct AttributeKeyAndValue: Equatable {
    /// <p>The key of the attribute.</p>
    public let key: AttributeKey?
    /// <p>The value of the attribute.</p>
    public let value: TypedAttributeValue?

    public init (
        key: AttributeKey? = nil,
        value: TypedAttributeValue? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension AttributeNameAndValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "AttributeName"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(TypedAttributeValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension AttributeNameAndValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttributeNameAndValue(attributeName: \(String(describing: attributeName)), value: \(String(describing: value)))"}
}

/// <p>Identifies the attribute name and value for a typed link.</p>
public struct AttributeNameAndValue: Equatable {
    /// <p>The attribute name of the typed link.</p>
    public let attributeName: String?
    /// <p>The value for the typed link.</p>
    public let value: TypedAttributeValue?

    public init (
        attributeName: String? = nil,
        value: TypedAttributeValue? = nil
    )
    {
        self.attributeName = attributeName
        self.value = value
    }
}

extension BatchAddFacetToObject: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectAttributeList = "ObjectAttributeList"
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectAttributeList = objectAttributeList {
            var objectAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectAttributeList)
            for attributekeyandvaluelist0 in objectAttributeList {
                try objectAttributeListContainer.encode(attributekeyandvaluelist0)
            }
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let schemaFacet = schemaFacet {
            try encodeContainer.encode(schemaFacet, forKey: .schemaFacet)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetDecoded = try containerValues.decodeIfPresent(SchemaFacet.self, forKey: .schemaFacet)
        schemaFacet = schemaFacetDecoded
        let objectAttributeListContainer = try containerValues.decodeIfPresent([AttributeKeyAndValue?].self, forKey: .objectAttributeList)
        var objectAttributeListDecoded0:[AttributeKeyAndValue]? = nil
        if let objectAttributeListContainer = objectAttributeListContainer {
            objectAttributeListDecoded0 = [AttributeKeyAndValue]()
            for structure0 in objectAttributeListContainer {
                if let structure0 = structure0 {
                    objectAttributeListDecoded0?.append(structure0)
                }
            }
        }
        objectAttributeList = objectAttributeListDecoded0
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension BatchAddFacetToObject: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAddFacetToObject(objectAttributeList: \(String(describing: objectAttributeList)), objectReference: \(String(describing: objectReference)), schemaFacet: \(String(describing: schemaFacet)))"}
}

/// <p>Represents the output of a batch add facet to object operation.</p>
public struct BatchAddFacetToObject: Equatable {
    /// <p>The attributes to set on the object.</p>
    public let objectAttributeList: [AttributeKeyAndValue]?
    /// <p>A reference to the object being mutated.</p>
    public let objectReference: ObjectReference?
    /// <p>Represents the facet being added to the object.</p>
    public let schemaFacet: SchemaFacet?

    public init (
        objectAttributeList: [AttributeKeyAndValue]? = nil,
        objectReference: ObjectReference? = nil,
        schemaFacet: SchemaFacet? = nil
    )
    {
        self.objectAttributeList = objectAttributeList
        self.objectReference = objectReference
        self.schemaFacet = schemaFacet
    }
}

extension BatchAddFacetToObjectResponse: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension BatchAddFacetToObjectResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAddFacetToObjectResponse()"}
}

/// <p>The result of a batch add facet to object operation.</p>
public struct BatchAddFacetToObjectResponse: Equatable {

    public init() {}
}

extension BatchAttachObject: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case childReference = "ChildReference"
        case linkName = "LinkName"
        case parentReference = "ParentReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childReference = childReference {
            try encodeContainer.encode(childReference, forKey: .childReference)
        }
        if let linkName = linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let parentReference = parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let childReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .childReference)
        childReference = childReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkName)
        linkName = linkNameDecoded
    }
}

extension BatchAttachObject: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAttachObject(childReference: \(String(describing: childReference)), linkName: \(String(describing: linkName)), parentReference: \(String(describing: parentReference)))"}
}

/// <p>Represents the output of an <a>AttachObject</a> operation.</p>
public struct BatchAttachObject: Equatable {
    /// <p>The child object reference that is to be attached to the object.</p>
    public let childReference: ObjectReference?
    /// <p>The name of the link.</p>
    public let linkName: String?
    /// <p>The parent object reference.</p>
    public let parentReference: ObjectReference?

    public init (
        childReference: ObjectReference? = nil,
        linkName: String? = nil,
        parentReference: ObjectReference? = nil
    )
    {
        self.childReference = childReference
        self.linkName = linkName
        self.parentReference = parentReference
    }
}

extension BatchAttachObjectResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachedObjectIdentifier
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachedObjectIdentifier = attachedObjectIdentifier {
            try encodeContainer.encode(attachedObjectIdentifier, forKey: .attachedObjectIdentifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachedObjectIdentifier)
        attachedObjectIdentifier = attachedObjectIdentifierDecoded
    }
}

extension BatchAttachObjectResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAttachObjectResponse(attachedObjectIdentifier: \(String(describing: attachedObjectIdentifier)))"}
}

/// <p>Represents the output batch <a>AttachObject</a> response operation.</p>
public struct BatchAttachObjectResponse: Equatable {
    /// <p>The <code>ObjectIdentifier</code> of the object that has been attached.</p>
    public let attachedObjectIdentifier: String?

    public init (
        attachedObjectIdentifier: String? = nil
    )
    {
        self.attachedObjectIdentifier = attachedObjectIdentifier
    }
}

extension BatchAttachPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectReference = "ObjectReference"
        case policyReference = "PolicyReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let policyReference = policyReference {
            try encodeContainer.encode(policyReference, forKey: .policyReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .policyReference)
        policyReference = policyReferenceDecoded
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension BatchAttachPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAttachPolicy(objectReference: \(String(describing: objectReference)), policyReference: \(String(describing: policyReference)))"}
}

/// <p>Attaches a policy object to a regular object inside a <a>BatchRead</a> operation. For more information, see <a>AttachPolicy</a> and <a>BatchReadRequest$Operations</a>.</p>
public struct BatchAttachPolicy: Equatable {
    /// <p>The reference that identifies the object to which the policy will be
    ///        attached.</p>
    public let objectReference: ObjectReference?
    /// <p>The reference that is associated with the policy object.</p>
    public let policyReference: ObjectReference?

    public init (
        objectReference: ObjectReference? = nil,
        policyReference: ObjectReference? = nil
    )
    {
        self.objectReference = objectReference
        self.policyReference = policyReference
    }
}

extension BatchAttachPolicyResponse: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension BatchAttachPolicyResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAttachPolicyResponse()"}
}

/// <p>Represents the output of an <a>AttachPolicy</a> response
///       operation.</p>
public struct BatchAttachPolicyResponse: Equatable {

    public init() {}
}

extension BatchAttachToIndex: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexReference = "IndexReference"
        case targetReference = "TargetReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexReference = indexReference {
            try encodeContainer.encode(indexReference, forKey: .indexReference)
        }
        if let targetReference = targetReference {
            try encodeContainer.encode(targetReference, forKey: .targetReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .indexReference)
        indexReference = indexReferenceDecoded
        let targetReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .targetReference)
        targetReference = targetReferenceDecoded
    }
}

extension BatchAttachToIndex: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAttachToIndex(indexReference: \(String(describing: indexReference)), targetReference: \(String(describing: targetReference)))"}
}

/// <p>Attaches the specified object to the specified index inside a <a>BatchRead</a> operation. For more information, see <a>AttachToIndex</a> and <a>BatchReadRequest$Operations</a>.</p>
public struct BatchAttachToIndex: Equatable {
    /// <p>A reference to the index that you are attaching the object to.</p>
    public let indexReference: ObjectReference?
    /// <p>A reference to the object that you are attaching to the index.</p>
    public let targetReference: ObjectReference?

    public init (
        indexReference: ObjectReference? = nil,
        targetReference: ObjectReference? = nil
    )
    {
        self.indexReference = indexReference
        self.targetReference = targetReference
    }
}

extension BatchAttachToIndexResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachedObjectIdentifier = "AttachedObjectIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachedObjectIdentifier = attachedObjectIdentifier {
            try encodeContainer.encode(attachedObjectIdentifier, forKey: .attachedObjectIdentifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachedObjectIdentifier)
        attachedObjectIdentifier = attachedObjectIdentifierDecoded
    }
}

extension BatchAttachToIndexResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAttachToIndexResponse(attachedObjectIdentifier: \(String(describing: attachedObjectIdentifier)))"}
}

/// <p>Represents the output of a <a>AttachToIndex</a> response operation.</p>
public struct BatchAttachToIndexResponse: Equatable {
    /// <p>The <code>ObjectIdentifier</code> of the object that was attached to the index.</p>
    public let attachedObjectIdentifier: String?

    public init (
        attachedObjectIdentifier: String? = nil
    )
    {
        self.attachedObjectIdentifier = attachedObjectIdentifier
    }
}

extension BatchAttachTypedLink: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case sourceObjectReference = "SourceObjectReference"
        case targetObjectReference = "TargetObjectReference"
        case typedLinkFacet = "TypedLinkFacet"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributenameandvaluelist0 in attributes {
                try attributesContainer.encode(attributenameandvaluelist0)
            }
        }
        if let sourceObjectReference = sourceObjectReference {
            try encodeContainer.encode(sourceObjectReference, forKey: .sourceObjectReference)
        }
        if let targetObjectReference = targetObjectReference {
            try encodeContainer.encode(targetObjectReference, forKey: .targetObjectReference)
        }
        if let typedLinkFacet = typedLinkFacet {
            try encodeContainer.encode(typedLinkFacet, forKey: .typedLinkFacet)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceObjectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .sourceObjectReference)
        sourceObjectReference = sourceObjectReferenceDecoded
        let targetObjectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .targetObjectReference)
        targetObjectReference = targetObjectReferenceDecoded
        let typedLinkFacetDecoded = try containerValues.decodeIfPresent(TypedLinkSchemaAndFacetName.self, forKey: .typedLinkFacet)
        typedLinkFacet = typedLinkFacetDecoded
        let attributesContainer = try containerValues.decodeIfPresent([AttributeNameAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[AttributeNameAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [AttributeNameAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension BatchAttachTypedLink: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAttachTypedLink(attributes: \(String(describing: attributes)), sourceObjectReference: \(String(describing: sourceObjectReference)), targetObjectReference: \(String(describing: targetObjectReference)), typedLinkFacet: \(String(describing: typedLinkFacet)))"}
}

/// <p>Attaches a typed link to a specified source and target object inside a <a>BatchRead</a> operation. For more information, see <a>AttachTypedLink</a> and <a>BatchReadRequest$Operations</a>.</p>
public struct BatchAttachTypedLink: Equatable {
    /// <p>A set of attributes that are associated with the typed link.</p>
    public let attributes: [AttributeNameAndValue]?
    /// <p>Identifies the source object that the typed link will attach to.</p>
    public let sourceObjectReference: ObjectReference?
    /// <p>Identifies the target object that the typed link will attach to.</p>
    public let targetObjectReference: ObjectReference?
    /// <p>Identifies the typed link facet that is associated with the typed link.</p>
    public let typedLinkFacet: TypedLinkSchemaAndFacetName?

    public init (
        attributes: [AttributeNameAndValue]? = nil,
        sourceObjectReference: ObjectReference? = nil,
        targetObjectReference: ObjectReference? = nil,
        typedLinkFacet: TypedLinkSchemaAndFacetName? = nil
    )
    {
        self.attributes = attributes
        self.sourceObjectReference = sourceObjectReference
        self.targetObjectReference = targetObjectReference
        self.typedLinkFacet = typedLinkFacet
    }
}

extension BatchAttachTypedLinkResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let typedLinkSpecifier = typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
    }
}

extension BatchAttachTypedLinkResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAttachTypedLinkResponse(typedLinkSpecifier: \(String(describing: typedLinkSpecifier)))"}
}

/// <p>Represents the output of a <a>AttachTypedLink</a> response operation.</p>
public struct BatchAttachTypedLinkResponse: Equatable {
    /// <p>Returns a typed link specifier as output.</p>
    public let typedLinkSpecifier: TypedLinkSpecifier?

    public init (
        typedLinkSpecifier: TypedLinkSpecifier? = nil
    )
    {
        self.typedLinkSpecifier = typedLinkSpecifier
    }
}

extension BatchCreateIndex: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batchReferenceName = "BatchReferenceName"
        case isUnique = "IsUnique"
        case linkName = "LinkName"
        case orderedIndexedAttributeList = "OrderedIndexedAttributeList"
        case parentReference = "ParentReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchReferenceName = batchReferenceName {
            try encodeContainer.encode(batchReferenceName, forKey: .batchReferenceName)
        }
        if isUnique != false {
            try encodeContainer.encode(isUnique, forKey: .isUnique)
        }
        if let linkName = linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let orderedIndexedAttributeList = orderedIndexedAttributeList {
            var orderedIndexedAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orderedIndexedAttributeList)
            for attributekeylist0 in orderedIndexedAttributeList {
                try orderedIndexedAttributeListContainer.encode(attributekeylist0)
            }
        }
        if let parentReference = parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderedIndexedAttributeListContainer = try containerValues.decodeIfPresent([AttributeKey?].self, forKey: .orderedIndexedAttributeList)
        var orderedIndexedAttributeListDecoded0:[AttributeKey]? = nil
        if let orderedIndexedAttributeListContainer = orderedIndexedAttributeListContainer {
            orderedIndexedAttributeListDecoded0 = [AttributeKey]()
            for structure0 in orderedIndexedAttributeListContainer {
                if let structure0 = structure0 {
                    orderedIndexedAttributeListDecoded0?.append(structure0)
                }
            }
        }
        orderedIndexedAttributeList = orderedIndexedAttributeListDecoded0
        let isUniqueDecoded = try containerValues.decode(Bool.self, forKey: .isUnique)
        isUnique = isUniqueDecoded
        let parentReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkName)
        linkName = linkNameDecoded
        let batchReferenceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .batchReferenceName)
        batchReferenceName = batchReferenceNameDecoded
    }
}

extension BatchCreateIndex: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchCreateIndex(batchReferenceName: \(String(describing: batchReferenceName)), isUnique: \(String(describing: isUnique)), linkName: \(String(describing: linkName)), orderedIndexedAttributeList: \(String(describing: orderedIndexedAttributeList)), parentReference: \(String(describing: parentReference)))"}
}

/// <p>Creates an index object inside of a <a>BatchRead</a> operation. For more information, see <a>CreateIndex</a> and <a>BatchReadRequest$Operations</a>.</p>
public struct BatchCreateIndex: Equatable {
    /// <p>The batch reference name. See <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/transaction_support.html">Transaction Support</a> for more information.</p>
    public let batchReferenceName: String?
    /// <p>Indicates whether the attribute that is being indexed has unique values or
    ///        not.</p>
    public let isUnique: Bool
    /// <p>The name of the link between the parent object and the index object.</p>
    public let linkName: String?
    /// <p>Specifies the attributes that should be indexed on. Currently only a single attribute
    ///        is supported.</p>
    public let orderedIndexedAttributeList: [AttributeKey]?
    /// <p>A reference to the parent object that contains the index object.</p>
    public let parentReference: ObjectReference?

    public init (
        batchReferenceName: String? = nil,
        isUnique: Bool = false,
        linkName: String? = nil,
        orderedIndexedAttributeList: [AttributeKey]? = nil,
        parentReference: ObjectReference? = nil
    )
    {
        self.batchReferenceName = batchReferenceName
        self.isUnique = isUnique
        self.linkName = linkName
        self.orderedIndexedAttributeList = orderedIndexedAttributeList
        self.parentReference = parentReference
    }
}

extension BatchCreateIndexResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectIdentifier = "ObjectIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectIdentifier = objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

extension BatchCreateIndexResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchCreateIndexResponse(objectIdentifier: \(String(describing: objectIdentifier)))"}
}

/// <p>Represents the output of a <a>CreateIndex</a> response operation.</p>
public struct BatchCreateIndexResponse: Equatable {
    /// <p>The <code>ObjectIdentifier</code> of the index created by this operation.</p>
    public let objectIdentifier: String?

    public init (
        objectIdentifier: String? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
    }
}

extension BatchCreateObject: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batchReferenceName = "BatchReferenceName"
        case linkName = "LinkName"
        case objectAttributeList = "ObjectAttributeList"
        case parentReference = "ParentReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchReferenceName = batchReferenceName {
            try encodeContainer.encode(batchReferenceName, forKey: .batchReferenceName)
        }
        if let linkName = linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let objectAttributeList = objectAttributeList {
            var objectAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectAttributeList)
            for attributekeyandvaluelist0 in objectAttributeList {
                try objectAttributeListContainer.encode(attributekeyandvaluelist0)
            }
        }
        if let parentReference = parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
        if let schemaFacet = schemaFacet {
            var schemaFacetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schemaFacet)
            for schemafacetlist0 in schemaFacet {
                try schemaFacetContainer.encode(schemafacetlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetContainer = try containerValues.decodeIfPresent([SchemaFacet?].self, forKey: .schemaFacet)
        var schemaFacetDecoded0:[SchemaFacet]? = nil
        if let schemaFacetContainer = schemaFacetContainer {
            schemaFacetDecoded0 = [SchemaFacet]()
            for structure0 in schemaFacetContainer {
                if let structure0 = structure0 {
                    schemaFacetDecoded0?.append(structure0)
                }
            }
        }
        schemaFacet = schemaFacetDecoded0
        let objectAttributeListContainer = try containerValues.decodeIfPresent([AttributeKeyAndValue?].self, forKey: .objectAttributeList)
        var objectAttributeListDecoded0:[AttributeKeyAndValue]? = nil
        if let objectAttributeListContainer = objectAttributeListContainer {
            objectAttributeListDecoded0 = [AttributeKeyAndValue]()
            for structure0 in objectAttributeListContainer {
                if let structure0 = structure0 {
                    objectAttributeListDecoded0?.append(structure0)
                }
            }
        }
        objectAttributeList = objectAttributeListDecoded0
        let parentReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkName)
        linkName = linkNameDecoded
        let batchReferenceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .batchReferenceName)
        batchReferenceName = batchReferenceNameDecoded
    }
}

extension BatchCreateObject: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchCreateObject(batchReferenceName: \(String(describing: batchReferenceName)), linkName: \(String(describing: linkName)), objectAttributeList: \(String(describing: objectAttributeList)), parentReference: \(String(describing: parentReference)), schemaFacet: \(String(describing: schemaFacet)))"}
}

/// <p>Represents the output of a <a>CreateObject</a> operation.</p>
public struct BatchCreateObject: Equatable {
    /// <p>The batch reference name. See <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/transaction_support.html">Transaction Support</a> for more information.</p>
    public let batchReferenceName: String?
    /// <p>The name of the link.</p>
    public let linkName: String?
    /// <p>An attribute map, which contains an attribute ARN as the key and attribute value as
    ///       the map value.</p>
    public let objectAttributeList: [AttributeKeyAndValue]?
    /// <p>If specified, the parent reference to which this object will be attached.</p>
    public let parentReference: ObjectReference?
    /// <p>A list of <code>FacetArns</code> that will be associated with the object. For more
    ///       information, see <a>arns</a>.</p>
    public let schemaFacet: [SchemaFacet]?

    public init (
        batchReferenceName: String? = nil,
        linkName: String? = nil,
        objectAttributeList: [AttributeKeyAndValue]? = nil,
        parentReference: ObjectReference? = nil,
        schemaFacet: [SchemaFacet]? = nil
    )
    {
        self.batchReferenceName = batchReferenceName
        self.linkName = linkName
        self.objectAttributeList = objectAttributeList
        self.parentReference = parentReference
        self.schemaFacet = schemaFacet
    }
}

extension BatchCreateObjectResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectIdentifier = "ObjectIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectIdentifier = objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

extension BatchCreateObjectResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchCreateObjectResponse(objectIdentifier: \(String(describing: objectIdentifier)))"}
}

/// <p>Represents the output of a <a>CreateObject</a> response operation.</p>
public struct BatchCreateObjectResponse: Equatable {
    /// <p>The ID that is associated with the object.</p>
    public let objectIdentifier: String?

    public init (
        objectIdentifier: String? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
    }
}

extension BatchDeleteObject: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension BatchDeleteObject: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteObject(objectReference: \(String(describing: objectReference)))"}
}

/// <p>Represents the output of a <a>DeleteObject</a> operation.</p>
public struct BatchDeleteObject: Equatable {
    /// <p>The reference that identifies the object.</p>
    public let objectReference: ObjectReference?

    public init (
        objectReference: ObjectReference? = nil
    )
    {
        self.objectReference = objectReference
    }
}

extension BatchDeleteObjectResponse: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension BatchDeleteObjectResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteObjectResponse()"}
}

/// <p>Represents the output of a <a>DeleteObject</a> response operation.</p>
public struct BatchDeleteObjectResponse: Equatable {

    public init() {}
}

extension BatchDetachFromIndex: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexReference = "IndexReference"
        case targetReference = "TargetReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexReference = indexReference {
            try encodeContainer.encode(indexReference, forKey: .indexReference)
        }
        if let targetReference = targetReference {
            try encodeContainer.encode(targetReference, forKey: .targetReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .indexReference)
        indexReference = indexReferenceDecoded
        let targetReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .targetReference)
        targetReference = targetReferenceDecoded
    }
}

extension BatchDetachFromIndex: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDetachFromIndex(indexReference: \(String(describing: indexReference)), targetReference: \(String(describing: targetReference)))"}
}

/// <p>Detaches the specified object from the specified index inside a <a>BatchRead</a> operation. For more information, see <a>DetachFromIndex</a> and <a>BatchReadRequest$Operations</a>.</p>
public struct BatchDetachFromIndex: Equatable {
    /// <p>A reference to the index object.</p>
    public let indexReference: ObjectReference?
    /// <p>A reference to the object being detached from the index.</p>
    public let targetReference: ObjectReference?

    public init (
        indexReference: ObjectReference? = nil,
        targetReference: ObjectReference? = nil
    )
    {
        self.indexReference = indexReference
        self.targetReference = targetReference
    }
}

extension BatchDetachFromIndexResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detachedObjectIdentifier = "DetachedObjectIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detachedObjectIdentifier = detachedObjectIdentifier {
            try encodeContainer.encode(detachedObjectIdentifier, forKey: .detachedObjectIdentifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detachedObjectIdentifier)
        detachedObjectIdentifier = detachedObjectIdentifierDecoded
    }
}

extension BatchDetachFromIndexResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDetachFromIndexResponse(detachedObjectIdentifier: \(String(describing: detachedObjectIdentifier)))"}
}

/// <p>Represents the output of a <a>DetachFromIndex</a> response operation.</p>
public struct BatchDetachFromIndexResponse: Equatable {
    /// <p>The <code>ObjectIdentifier</code> of the object that was detached from the index.</p>
    public let detachedObjectIdentifier: String?

    public init (
        detachedObjectIdentifier: String? = nil
    )
    {
        self.detachedObjectIdentifier = detachedObjectIdentifier
    }
}

extension BatchDetachObject: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batchReferenceName = "BatchReferenceName"
        case linkName = "LinkName"
        case parentReference = "ParentReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchReferenceName = batchReferenceName {
            try encodeContainer.encode(batchReferenceName, forKey: .batchReferenceName)
        }
        if let linkName = linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let parentReference = parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkName)
        linkName = linkNameDecoded
        let batchReferenceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .batchReferenceName)
        batchReferenceName = batchReferenceNameDecoded
    }
}

extension BatchDetachObject: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDetachObject(batchReferenceName: \(String(describing: batchReferenceName)), linkName: \(String(describing: linkName)), parentReference: \(String(describing: parentReference)))"}
}

/// <p>Represents the output of a <a>DetachObject</a> operation.</p>
public struct BatchDetachObject: Equatable {
    /// <p>The batch reference name. See <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/transaction_support.html">Transaction Support</a> for more information.</p>
    public let batchReferenceName: String?
    /// <p>The name of the link.</p>
    public let linkName: String?
    /// <p>Parent reference from which the object with the specified link name is
    ///       detached.</p>
    public let parentReference: ObjectReference?

    public init (
        batchReferenceName: String? = nil,
        linkName: String? = nil,
        parentReference: ObjectReference? = nil
    )
    {
        self.batchReferenceName = batchReferenceName
        self.linkName = linkName
        self.parentReference = parentReference
    }
}

extension BatchDetachObjectResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detachedObjectIdentifier
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detachedObjectIdentifier = detachedObjectIdentifier {
            try encodeContainer.encode(detachedObjectIdentifier, forKey: .detachedObjectIdentifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detachedObjectIdentifier)
        detachedObjectIdentifier = detachedObjectIdentifierDecoded
    }
}

extension BatchDetachObjectResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDetachObjectResponse(detachedObjectIdentifier: \(String(describing: detachedObjectIdentifier)))"}
}

/// <p>Represents the output of a <a>DetachObject</a> response operation.</p>
public struct BatchDetachObjectResponse: Equatable {
    /// <p>The <code>ObjectIdentifier</code> of the detached object.</p>
    public let detachedObjectIdentifier: String?

    public init (
        detachedObjectIdentifier: String? = nil
    )
    {
        self.detachedObjectIdentifier = detachedObjectIdentifier
    }
}

extension BatchDetachPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectReference = "ObjectReference"
        case policyReference = "PolicyReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let policyReference = policyReference {
            try encodeContainer.encode(policyReference, forKey: .policyReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .policyReference)
        policyReference = policyReferenceDecoded
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension BatchDetachPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDetachPolicy(objectReference: \(String(describing: objectReference)), policyReference: \(String(describing: policyReference)))"}
}

/// <p>Detaches the specified policy from the specified directory inside a <a>BatchWrite</a> operation. For more information, see <a>DetachPolicy</a> and <a>BatchWriteRequest$Operations</a>.</p>
public struct BatchDetachPolicy: Equatable {
    /// <p>Reference that identifies the object whose policy object will be detached.</p>
    public let objectReference: ObjectReference?
    /// <p>Reference that identifies the policy object.</p>
    public let policyReference: ObjectReference?

    public init (
        objectReference: ObjectReference? = nil,
        policyReference: ObjectReference? = nil
    )
    {
        self.objectReference = objectReference
        self.policyReference = policyReference
    }
}

extension BatchDetachPolicyResponse: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension BatchDetachPolicyResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDetachPolicyResponse()"}
}

/// <p>Represents the output of a <a>DetachPolicy</a> response operation.</p>
public struct BatchDetachPolicyResponse: Equatable {

    public init() {}
}

extension BatchDetachTypedLink: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let typedLinkSpecifier = typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
    }
}

extension BatchDetachTypedLink: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDetachTypedLink(typedLinkSpecifier: \(String(describing: typedLinkSpecifier)))"}
}

/// <p>Detaches a typed link from a specified source and target object inside a <a>BatchRead</a> operation. For more information, see <a>DetachTypedLink</a> and <a>BatchReadRequest$Operations</a>.</p>
public struct BatchDetachTypedLink: Equatable {
    /// <p>Used to accept a typed link specifier as input.</p>
    public let typedLinkSpecifier: TypedLinkSpecifier?

    public init (
        typedLinkSpecifier: TypedLinkSpecifier? = nil
    )
    {
        self.typedLinkSpecifier = typedLinkSpecifier
    }
}

extension BatchDetachTypedLinkResponse: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension BatchDetachTypedLinkResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDetachTypedLinkResponse()"}
}

/// <p>Represents the output of a <a>DetachTypedLink</a> response operation.</p>
public struct BatchDetachTypedLinkResponse: Equatable {

    public init() {}
}

extension BatchGetLinkAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeNames = "AttributeNames"
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeNames = attributeNames {
            var attributeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeNames)
            for attributenamelist0 in attributeNames {
                try attributeNamesContainer.encode(attributenamelist0)
            }
        }
        if let typedLinkSpecifier = typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
        let attributeNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .attributeNames)
        var attributeNamesDecoded0:[String]? = nil
        if let attributeNamesContainer = attributeNamesContainer {
            attributeNamesDecoded0 = [String]()
            for string0 in attributeNamesContainer {
                if let string0 = string0 {
                    attributeNamesDecoded0?.append(string0)
                }
            }
        }
        attributeNames = attributeNamesDecoded0
    }
}

extension BatchGetLinkAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetLinkAttributes(attributeNames: \(String(describing: attributeNames)), typedLinkSpecifier: \(String(describing: typedLinkSpecifier)))"}
}

/// <p>Retrieves attributes that are associated with a typed link inside a <a>BatchRead</a> operation. For more information, see <a>GetLinkAttributes</a> and <a>BatchReadRequest$Operations</a>.</p>
public struct BatchGetLinkAttributes: Equatable {
    /// <p>A list of attribute names whose values will be retrieved.</p>
    public let attributeNames: [String]?
    /// <p>Allows a typed link specifier to be accepted as input.</p>
    public let typedLinkSpecifier: TypedLinkSpecifier?

    public init (
        attributeNames: [String]? = nil,
        typedLinkSpecifier: TypedLinkSpecifier? = nil
    )
    {
        self.attributeNames = attributeNames
        self.typedLinkSpecifier = typedLinkSpecifier
    }
}

extension BatchGetLinkAttributesResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributekeyandvaluelist0 in attributes {
                try attributesContainer.encode(attributekeyandvaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([AttributeKeyAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[AttributeKeyAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [AttributeKeyAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension BatchGetLinkAttributesResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetLinkAttributesResponse(attributes: \(String(describing: attributes)))"}
}

/// <p>Represents the output of a <a>GetLinkAttributes</a> response operation.</p>
public struct BatchGetLinkAttributesResponse: Equatable {
    /// <p>The attributes that are associated with the typed link.</p>
    public let attributes: [AttributeKeyAndValue]?

    public init (
        attributes: [AttributeKeyAndValue]? = nil
    )
    {
        self.attributes = attributes
    }
}

extension BatchGetObjectAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeNames = "AttributeNames"
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeNames = attributeNames {
            var attributeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeNames)
            for attributenamelist0 in attributeNames {
                try attributeNamesContainer.encode(attributenamelist0)
            }
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let schemaFacet = schemaFacet {
            try encodeContainer.encode(schemaFacet, forKey: .schemaFacet)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let schemaFacetDecoded = try containerValues.decodeIfPresent(SchemaFacet.self, forKey: .schemaFacet)
        schemaFacet = schemaFacetDecoded
        let attributeNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .attributeNames)
        var attributeNamesDecoded0:[String]? = nil
        if let attributeNamesContainer = attributeNamesContainer {
            attributeNamesDecoded0 = [String]()
            for string0 in attributeNamesContainer {
                if let string0 = string0 {
                    attributeNamesDecoded0?.append(string0)
                }
            }
        }
        attributeNames = attributeNamesDecoded0
    }
}

extension BatchGetObjectAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetObjectAttributes(attributeNames: \(String(describing: attributeNames)), objectReference: \(String(describing: objectReference)), schemaFacet: \(String(describing: schemaFacet)))"}
}

/// <p>Retrieves attributes within a facet that are associated with an object inside an <a>BatchRead</a> operation. For more information, see <a>GetObjectAttributes</a> and <a>BatchReadRequest$Operations</a>.</p>
public struct BatchGetObjectAttributes: Equatable {
    /// <p>List of attribute names whose values will be retrieved.</p>
    public let attributeNames: [String]?
    /// <p>Reference that identifies the object whose attributes will be retrieved.</p>
    public let objectReference: ObjectReference?
    /// <p>Identifier for the facet whose attributes will be retrieved. See <a>SchemaFacet</a> for details.</p>
    public let schemaFacet: SchemaFacet?

    public init (
        attributeNames: [String]? = nil,
        objectReference: ObjectReference? = nil,
        schemaFacet: SchemaFacet? = nil
    )
    {
        self.attributeNames = attributeNames
        self.objectReference = objectReference
        self.schemaFacet = schemaFacet
    }
}

extension BatchGetObjectAttributesResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributekeyandvaluelist0 in attributes {
                try attributesContainer.encode(attributekeyandvaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([AttributeKeyAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[AttributeKeyAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [AttributeKeyAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension BatchGetObjectAttributesResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetObjectAttributesResponse(attributes: \(String(describing: attributes)))"}
}

/// <p>Represents the output of a <a>GetObjectAttributes</a> response operation.</p>
public struct BatchGetObjectAttributesResponse: Equatable {
    /// <p>The attribute values that are associated with an object.</p>
    public let attributes: [AttributeKeyAndValue]?

    public init (
        attributes: [AttributeKeyAndValue]? = nil
    )
    {
        self.attributes = attributes
    }
}

extension BatchGetObjectInformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension BatchGetObjectInformation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetObjectInformation(objectReference: \(String(describing: objectReference)))"}
}

/// <p>Retrieves metadata about an object inside a <a>BatchRead</a> operation. For more information, see <a>GetObjectInformation</a> and <a>BatchReadRequest$Operations</a>.</p>
public struct BatchGetObjectInformation: Equatable {
    /// <p>A reference to the object.</p>
    public let objectReference: ObjectReference?

    public init (
        objectReference: ObjectReference? = nil
    )
    {
        self.objectReference = objectReference
    }
}

extension BatchGetObjectInformationResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectIdentifier = "ObjectIdentifier"
        case schemaFacets = "SchemaFacets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectIdentifier = objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
        if let schemaFacets = schemaFacets {
            var schemaFacetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schemaFacets)
            for schemafacetlist0 in schemaFacets {
                try schemaFacetsContainer.encode(schemafacetlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetsContainer = try containerValues.decodeIfPresent([SchemaFacet?].self, forKey: .schemaFacets)
        var schemaFacetsDecoded0:[SchemaFacet]? = nil
        if let schemaFacetsContainer = schemaFacetsContainer {
            schemaFacetsDecoded0 = [SchemaFacet]()
            for structure0 in schemaFacetsContainer {
                if let structure0 = structure0 {
                    schemaFacetsDecoded0?.append(structure0)
                }
            }
        }
        schemaFacets = schemaFacetsDecoded0
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

extension BatchGetObjectInformationResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetObjectInformationResponse(objectIdentifier: \(String(describing: objectIdentifier)), schemaFacets: \(String(describing: schemaFacets)))"}
}

/// <p>Represents the output of a <a>GetObjectInformation</a> response operation.</p>
public struct BatchGetObjectInformationResponse: Equatable {
    /// <p>The <code>ObjectIdentifier</code> of the specified object.</p>
    public let objectIdentifier: String?
    /// <p>The facets attached to the specified object.</p>
    public let schemaFacets: [SchemaFacet]?

    public init (
        objectIdentifier: String? = nil,
        schemaFacets: [SchemaFacet]? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
        self.schemaFacets = schemaFacets
    }
}

extension BatchListAttachedIndices: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case targetReference = "TargetReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let targetReference = targetReference {
            try encodeContainer.encode(targetReference, forKey: .targetReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .targetReference)
        targetReference = targetReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension BatchListAttachedIndices: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchListAttachedIndices(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), targetReference: \(String(describing: targetReference)))"}
}

/// <p>Lists indices attached to an object inside a <a>BatchRead</a> operation. For more information, see <a>ListAttachedIndices</a> and <a>BatchReadRequest$Operations</a>.</p>
public struct BatchListAttachedIndices: Equatable {
    /// <p>The maximum number of results to retrieve.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>A reference to the object that has indices attached.</p>
    public let targetReference: ObjectReference?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        targetReference: ObjectReference? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetReference = targetReference
    }
}

extension BatchListAttachedIndicesResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexAttachments = "IndexAttachments"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexAttachments = indexAttachments {
            var indexAttachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .indexAttachments)
            for indexattachmentlist0 in indexAttachments {
                try indexAttachmentsContainer.encode(indexattachmentlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexAttachmentsContainer = try containerValues.decodeIfPresent([IndexAttachment?].self, forKey: .indexAttachments)
        var indexAttachmentsDecoded0:[IndexAttachment]? = nil
        if let indexAttachmentsContainer = indexAttachmentsContainer {
            indexAttachmentsDecoded0 = [IndexAttachment]()
            for structure0 in indexAttachmentsContainer {
                if let structure0 = structure0 {
                    indexAttachmentsDecoded0?.append(structure0)
                }
            }
        }
        indexAttachments = indexAttachmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BatchListAttachedIndicesResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchListAttachedIndicesResponse(indexAttachments: \(String(describing: indexAttachments)), nextToken: \(String(describing: nextToken)))"}
}

/// <p>Represents the output of a <a>ListAttachedIndices</a> response operation.</p>
public struct BatchListAttachedIndicesResponse: Equatable {
    /// <p>The indices attached to the specified object.</p>
    public let indexAttachments: [IndexAttachment]?
    /// <p>The pagination token.</p>
    public let nextToken: String?

    public init (
        indexAttachments: [IndexAttachment]? = nil,
        nextToken: String? = nil
    )
    {
        self.indexAttachments = indexAttachments
        self.nextToken = nextToken
    }
}

extension BatchListIncomingTypedLinks: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filterAttributeRanges = "FilterAttributeRanges"
        case filterTypedLink = "FilterTypedLink"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterAttributeRanges = filterAttributeRanges {
            var filterAttributeRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterAttributeRanges)
            for typedlinkattributerangelist0 in filterAttributeRanges {
                try filterAttributeRangesContainer.encode(typedlinkattributerangelist0)
            }
        }
        if let filterTypedLink = filterTypedLink {
            try encodeContainer.encode(filterTypedLink, forKey: .filterTypedLink)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let filterAttributeRangesContainer = try containerValues.decodeIfPresent([TypedLinkAttributeRange?].self, forKey: .filterAttributeRanges)
        var filterAttributeRangesDecoded0:[TypedLinkAttributeRange]? = nil
        if let filterAttributeRangesContainer = filterAttributeRangesContainer {
            filterAttributeRangesDecoded0 = [TypedLinkAttributeRange]()
            for structure0 in filterAttributeRangesContainer {
                if let structure0 = structure0 {
                    filterAttributeRangesDecoded0?.append(structure0)
                }
            }
        }
        filterAttributeRanges = filterAttributeRangesDecoded0
        let filterTypedLinkDecoded = try containerValues.decodeIfPresent(TypedLinkSchemaAndFacetName.self, forKey: .filterTypedLink)
        filterTypedLink = filterTypedLinkDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension BatchListIncomingTypedLinks: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchListIncomingTypedLinks(filterAttributeRanges: \(String(describing: filterAttributeRanges)), filterTypedLink: \(String(describing: filterTypedLink)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), objectReference: \(String(describing: objectReference)))"}
}

/// <p>Returns a paginated list of all the incoming <a>TypedLinkSpecifier</a> information for an object inside a <a>BatchRead</a> operation. For more information, see <a>ListIncomingTypedLinks</a> and <a>BatchReadRequest$Operations</a>.</p>
public struct BatchListIncomingTypedLinks: Equatable {
    /// <p>Provides range filters for multiple attributes. When providing ranges to typed link
    ///        selection, any inexact ranges must be specified at the end. Any attributes that do not have a
    ///        range specified are presumed to match the entire range.</p>
    public let filterAttributeRanges: [TypedLinkAttributeRange]?
    /// <p>Filters are interpreted in the order of the attributes on the typed link facet, not the
    ///        order in which they are supplied to any API calls.</p>
    public let filterTypedLink: TypedLinkSchemaAndFacetName?
    /// <p>The maximum number of results to retrieve.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The reference that identifies the object whose attributes will be listed.</p>
    public let objectReference: ObjectReference?

    public init (
        filterAttributeRanges: [TypedLinkAttributeRange]? = nil,
        filterTypedLink: TypedLinkSchemaAndFacetName? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        objectReference: ObjectReference? = nil
    )
    {
        self.filterAttributeRanges = filterAttributeRanges
        self.filterTypedLink = filterTypedLink
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

extension BatchListIncomingTypedLinksResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case linkSpecifiers = "LinkSpecifiers"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linkSpecifiers = linkSpecifiers {
            var linkSpecifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .linkSpecifiers)
            for typedlinkspecifierlist0 in linkSpecifiers {
                try linkSpecifiersContainer.encode(typedlinkspecifierlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkSpecifiersContainer = try containerValues.decodeIfPresent([TypedLinkSpecifier?].self, forKey: .linkSpecifiers)
        var linkSpecifiersDecoded0:[TypedLinkSpecifier]? = nil
        if let linkSpecifiersContainer = linkSpecifiersContainer {
            linkSpecifiersDecoded0 = [TypedLinkSpecifier]()
            for structure0 in linkSpecifiersContainer {
                if let structure0 = structure0 {
                    linkSpecifiersDecoded0?.append(structure0)
                }
            }
        }
        linkSpecifiers = linkSpecifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BatchListIncomingTypedLinksResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchListIncomingTypedLinksResponse(linkSpecifiers: \(String(describing: linkSpecifiers)), nextToken: \(String(describing: nextToken)))"}
}

/// <p>Represents the output of a <a>ListIncomingTypedLinks</a> response operation.</p>
public struct BatchListIncomingTypedLinksResponse: Equatable {
    /// <p>Returns one or more typed link specifiers as output.</p>
    public let linkSpecifiers: [TypedLinkSpecifier]?
    /// <p>The pagination token.</p>
    public let nextToken: String?

    public init (
        linkSpecifiers: [TypedLinkSpecifier]? = nil,
        nextToken: String? = nil
    )
    {
        self.linkSpecifiers = linkSpecifiers
        self.nextToken = nextToken
    }
}

extension BatchListIndex: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexReference = "IndexReference"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case rangesOnIndexedValues = "RangesOnIndexedValues"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexReference = indexReference {
            try encodeContainer.encode(indexReference, forKey: .indexReference)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let rangesOnIndexedValues = rangesOnIndexedValues {
            var rangesOnIndexedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rangesOnIndexedValues)
            for objectattributerangelist0 in rangesOnIndexedValues {
                try rangesOnIndexedValuesContainer.encode(objectattributerangelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rangesOnIndexedValuesContainer = try containerValues.decodeIfPresent([ObjectAttributeRange?].self, forKey: .rangesOnIndexedValues)
        var rangesOnIndexedValuesDecoded0:[ObjectAttributeRange]? = nil
        if let rangesOnIndexedValuesContainer = rangesOnIndexedValuesContainer {
            rangesOnIndexedValuesDecoded0 = [ObjectAttributeRange]()
            for structure0 in rangesOnIndexedValuesContainer {
                if let structure0 = structure0 {
                    rangesOnIndexedValuesDecoded0?.append(structure0)
                }
            }
        }
        rangesOnIndexedValues = rangesOnIndexedValuesDecoded0
        let indexReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .indexReference)
        indexReference = indexReferenceDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BatchListIndex: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchListIndex(indexReference: \(String(describing: indexReference)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), rangesOnIndexedValues: \(String(describing: rangesOnIndexedValues)))"}
}

/// <p>Lists objects attached to the specified index inside a <a>BatchRead</a> operation. For more information, see <a>ListIndex</a> and <a>BatchReadRequest$Operations</a>.</p>
public struct BatchListIndex: Equatable {
    /// <p>The reference to the index to list.</p>
    public let indexReference: ObjectReference?
    /// <p>The maximum number of results to retrieve.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>Specifies the ranges of indexed values that you want to query.</p>
    public let rangesOnIndexedValues: [ObjectAttributeRange]?

    public init (
        indexReference: ObjectReference? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        rangesOnIndexedValues: [ObjectAttributeRange]? = nil
    )
    {
        self.indexReference = indexReference
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.rangesOnIndexedValues = rangesOnIndexedValues
    }
}

extension BatchListIndexResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexAttachments = "IndexAttachments"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexAttachments = indexAttachments {
            var indexAttachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .indexAttachments)
            for indexattachmentlist0 in indexAttachments {
                try indexAttachmentsContainer.encode(indexattachmentlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexAttachmentsContainer = try containerValues.decodeIfPresent([IndexAttachment?].self, forKey: .indexAttachments)
        var indexAttachmentsDecoded0:[IndexAttachment]? = nil
        if let indexAttachmentsContainer = indexAttachmentsContainer {
            indexAttachmentsDecoded0 = [IndexAttachment]()
            for structure0 in indexAttachmentsContainer {
                if let structure0 = structure0 {
                    indexAttachmentsDecoded0?.append(structure0)
                }
            }
        }
        indexAttachments = indexAttachmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BatchListIndexResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchListIndexResponse(indexAttachments: \(String(describing: indexAttachments)), nextToken: \(String(describing: nextToken)))"}
}

/// <p>Represents the output of a <a>ListIndex</a> response operation.</p>
public struct BatchListIndexResponse: Equatable {
    /// <p>The objects and indexed values attached to the index.</p>
    public let indexAttachments: [IndexAttachment]?
    /// <p>The pagination token.</p>
    public let nextToken: String?

    public init (
        indexAttachments: [IndexAttachment]? = nil,
        nextToken: String? = nil
    )
    {
        self.indexAttachments = indexAttachments
        self.nextToken = nextToken
    }
}

extension BatchListObjectAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case facetFilter = "FacetFilter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facetFilter = facetFilter {
            try encodeContainer.encode(facetFilter, forKey: .facetFilter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let facetFilterDecoded = try containerValues.decodeIfPresent(SchemaFacet.self, forKey: .facetFilter)
        facetFilter = facetFilterDecoded
    }
}

extension BatchListObjectAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchListObjectAttributes(facetFilter: \(String(describing: facetFilter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), objectReference: \(String(describing: objectReference)))"}
}

/// <p>Represents the output of a <a>ListObjectAttributes</a> operation.</p>
public struct BatchListObjectAttributes: Equatable {
    /// <p>Used to filter the list of object attributes that are associated with a certain
    ///       facet.</p>
    public let facetFilter: SchemaFacet?
    /// <p>The maximum number of items to be retrieved in a single call. This is an approximate
    ///       number.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>Reference of the object whose attributes need to be listed.</p>
    public let objectReference: ObjectReference?

    public init (
        facetFilter: SchemaFacet? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        objectReference: ObjectReference? = nil
    )
    {
        self.facetFilter = facetFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

extension BatchListObjectAttributesResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributekeyandvaluelist0 in attributes {
                try attributesContainer.encode(attributekeyandvaluelist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([AttributeKeyAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[AttributeKeyAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [AttributeKeyAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BatchListObjectAttributesResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchListObjectAttributesResponse(attributes: \(String(describing: attributes)), nextToken: \(String(describing: nextToken)))"}
}

/// <p>Represents the output of a <a>ListObjectAttributes</a> response operation.</p>
public struct BatchListObjectAttributesResponse: Equatable {
    /// <p>The attributes map that is associated with the object. <code>AttributeArn</code> is the
    ///       key; attribute value is the value.</p>
    public let attributes: [AttributeKeyAndValue]?
    /// <p>The pagination token.</p>
    public let nextToken: String?

    public init (
        attributes: [AttributeKeyAndValue]? = nil,
        nextToken: String? = nil
    )
    {
        self.attributes = attributes
        self.nextToken = nextToken
    }
}

extension BatchListObjectChildren: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension BatchListObjectChildren: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchListObjectChildren(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), objectReference: \(String(describing: objectReference)))"}
}

/// <p>Represents the output of a <a>ListObjectChildren</a> operation.</p>
public struct BatchListObjectChildren: Equatable {
    /// <p>Maximum number of items to be retrieved in a single call. This is an approximate
    ///        number.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>Reference of the object for which child objects are being listed.</p>
    public let objectReference: ObjectReference?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        objectReference: ObjectReference? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

extension BatchListObjectChildrenResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case children = "Children"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let children = children {
            var childrenContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .children)
            for (dictKey0, linknametoobjectidentifiermap0) in children {
                try childrenContainer.encode(linknametoobjectidentifiermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let childrenContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .children)
        var childrenDecoded0: [String:String]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [String:String]()
            for (key0, objectidentifier0) in childrenContainer {
                if let objectidentifier0 = objectidentifier0 {
                    childrenDecoded0?[key0] = objectidentifier0
                }
            }
        }
        children = childrenDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BatchListObjectChildrenResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchListObjectChildrenResponse(children: \(String(describing: children)), nextToken: \(String(describing: nextToken)))"}
}

/// <p>Represents the output of a <a>ListObjectChildren</a> response operation.</p>
public struct BatchListObjectChildrenResponse: Equatable {
    /// <p>The children structure, which is a map with the key as the <code>LinkName</code> and
    ///         <code>ObjectIdentifier</code> as the value.</p>
    public let children: [String:String]?
    /// <p>The pagination token.</p>
    public let nextToken: String?

    public init (
        children: [String:String]? = nil,
        nextToken: String? = nil
    )
    {
        self.children = children
        self.nextToken = nextToken
    }
}

extension BatchListObjectParentPaths: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension BatchListObjectParentPaths: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchListObjectParentPaths(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), objectReference: \(String(describing: objectReference)))"}
}

/// <p>Retrieves all available parent paths for any object type such as node, leaf node, policy node, and index node objects inside a <a>BatchRead</a> operation. For more information, see <a>ListObjectParentPaths</a> and <a>BatchReadRequest$Operations</a>.</p>
public struct BatchListObjectParentPaths: Equatable {
    /// <p>The maximum number of results to retrieve.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The reference that identifies the object whose attributes will be listed.</p>
    public let objectReference: ObjectReference?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        objectReference: ObjectReference? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

extension BatchListObjectParentPathsResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case pathToObjectIdentifiersList = "PathToObjectIdentifiersList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pathToObjectIdentifiersList = pathToObjectIdentifiersList {
            var pathToObjectIdentifiersListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pathToObjectIdentifiersList)
            for pathtoobjectidentifierslist0 in pathToObjectIdentifiersList {
                try pathToObjectIdentifiersListContainer.encode(pathtoobjectidentifierslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathToObjectIdentifiersListContainer = try containerValues.decodeIfPresent([PathToObjectIdentifiers?].self, forKey: .pathToObjectIdentifiersList)
        var pathToObjectIdentifiersListDecoded0:[PathToObjectIdentifiers]? = nil
        if let pathToObjectIdentifiersListContainer = pathToObjectIdentifiersListContainer {
            pathToObjectIdentifiersListDecoded0 = [PathToObjectIdentifiers]()
            for structure0 in pathToObjectIdentifiersListContainer {
                if let structure0 = structure0 {
                    pathToObjectIdentifiersListDecoded0?.append(structure0)
                }
            }
        }
        pathToObjectIdentifiersList = pathToObjectIdentifiersListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BatchListObjectParentPathsResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchListObjectParentPathsResponse(nextToken: \(String(describing: nextToken)), pathToObjectIdentifiersList: \(String(describing: pathToObjectIdentifiersList)))"}
}

/// <p>Represents the output of a <a>ListObjectParentPaths</a> response operation.</p>
public struct BatchListObjectParentPathsResponse: Equatable {
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>Returns the path to the <code>ObjectIdentifiers</code> that are associated with the
    ///        directory.</p>
    public let pathToObjectIdentifiersList: [PathToObjectIdentifiers]?

    public init (
        nextToken: String? = nil,
        pathToObjectIdentifiersList: [PathToObjectIdentifiers]? = nil
    )
    {
        self.nextToken = nextToken
        self.pathToObjectIdentifiersList = pathToObjectIdentifiersList
    }
}

extension BatchListObjectParents: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension BatchListObjectParents: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchListObjectParents(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), objectReference: \(String(describing: objectReference)))"}
}

public struct BatchListObjectParents: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
    /// <p>The reference that identifies an object.</p>
    public let objectReference: ObjectReference?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        objectReference: ObjectReference? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

extension BatchListObjectParentsResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case parentLinks = "ParentLinks"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parentLinks = parentLinks {
            var parentLinksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parentLinks)
            for objectidentifierandlinknamelist0 in parentLinks {
                try parentLinksContainer.encode(objectidentifierandlinknamelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentLinksContainer = try containerValues.decodeIfPresent([ObjectIdentifierAndLinkNameTuple?].self, forKey: .parentLinks)
        var parentLinksDecoded0:[ObjectIdentifierAndLinkNameTuple]? = nil
        if let parentLinksContainer = parentLinksContainer {
            parentLinksDecoded0 = [ObjectIdentifierAndLinkNameTuple]()
            for structure0 in parentLinksContainer {
                if let structure0 = structure0 {
                    parentLinksDecoded0?.append(structure0)
                }
            }
        }
        parentLinks = parentLinksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BatchListObjectParentsResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchListObjectParentsResponse(nextToken: \(String(describing: nextToken)), parentLinks: \(String(describing: parentLinks)))"}
}

public struct BatchListObjectParentsResponse: Equatable {
    public let nextToken: String?
    public let parentLinks: [ObjectIdentifierAndLinkNameTuple]?

    public init (
        nextToken: String? = nil,
        parentLinks: [ObjectIdentifierAndLinkNameTuple]? = nil
    )
    {
        self.nextToken = nextToken
        self.parentLinks = parentLinks
    }
}

extension BatchListObjectPolicies: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension BatchListObjectPolicies: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchListObjectPolicies(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), objectReference: \(String(describing: objectReference)))"}
}

/// <p>Returns policies attached to an object in pagination fashion inside a <a>BatchRead</a> operation. For more information, see <a>ListObjectPolicies</a> and <a>BatchReadRequest$Operations</a>.</p>
public struct BatchListObjectPolicies: Equatable {
    /// <p>The maximum number of results to retrieve.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The reference that identifies the object whose attributes will be listed.</p>
    public let objectReference: ObjectReference?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        objectReference: ObjectReference? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

extension BatchListObjectPoliciesResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachedPolicyIds = "AttachedPolicyIds"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachedPolicyIds = attachedPolicyIds {
            var attachedPolicyIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachedPolicyIds)
            for objectidentifierlist0 in attachedPolicyIds {
                try attachedPolicyIdsContainer.encode(objectidentifierlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedPolicyIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .attachedPolicyIds)
        var attachedPolicyIdsDecoded0:[String]? = nil
        if let attachedPolicyIdsContainer = attachedPolicyIdsContainer {
            attachedPolicyIdsDecoded0 = [String]()
            for string0 in attachedPolicyIdsContainer {
                if let string0 = string0 {
                    attachedPolicyIdsDecoded0?.append(string0)
                }
            }
        }
        attachedPolicyIds = attachedPolicyIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BatchListObjectPoliciesResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchListObjectPoliciesResponse(attachedPolicyIds: \(String(describing: attachedPolicyIds)), nextToken: \(String(describing: nextToken)))"}
}

/// <p>Represents the output of a <a>ListObjectPolicies</a> response operation.</p>
public struct BatchListObjectPoliciesResponse: Equatable {
    /// <p>A list of policy <code>ObjectIdentifiers</code>, that are attached to the
    ///        object.</p>
    public let attachedPolicyIds: [String]?
    /// <p>The pagination token.</p>
    public let nextToken: String?

    public init (
        attachedPolicyIds: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.attachedPolicyIds = attachedPolicyIds
        self.nextToken = nextToken
    }
}

extension BatchListOutgoingTypedLinks: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filterAttributeRanges = "FilterAttributeRanges"
        case filterTypedLink = "FilterTypedLink"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterAttributeRanges = filterAttributeRanges {
            var filterAttributeRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterAttributeRanges)
            for typedlinkattributerangelist0 in filterAttributeRanges {
                try filterAttributeRangesContainer.encode(typedlinkattributerangelist0)
            }
        }
        if let filterTypedLink = filterTypedLink {
            try encodeContainer.encode(filterTypedLink, forKey: .filterTypedLink)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let filterAttributeRangesContainer = try containerValues.decodeIfPresent([TypedLinkAttributeRange?].self, forKey: .filterAttributeRanges)
        var filterAttributeRangesDecoded0:[TypedLinkAttributeRange]? = nil
        if let filterAttributeRangesContainer = filterAttributeRangesContainer {
            filterAttributeRangesDecoded0 = [TypedLinkAttributeRange]()
            for structure0 in filterAttributeRangesContainer {
                if let structure0 = structure0 {
                    filterAttributeRangesDecoded0?.append(structure0)
                }
            }
        }
        filterAttributeRanges = filterAttributeRangesDecoded0
        let filterTypedLinkDecoded = try containerValues.decodeIfPresent(TypedLinkSchemaAndFacetName.self, forKey: .filterTypedLink)
        filterTypedLink = filterTypedLinkDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension BatchListOutgoingTypedLinks: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchListOutgoingTypedLinks(filterAttributeRanges: \(String(describing: filterAttributeRanges)), filterTypedLink: \(String(describing: filterTypedLink)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), objectReference: \(String(describing: objectReference)))"}
}

/// <p>Returns a paginated list of all the outgoing <a>TypedLinkSpecifier</a> information for an object inside a <a>BatchRead</a> operation. For more information, see <a>ListOutgoingTypedLinks</a> and <a>BatchReadRequest$Operations</a>.</p>
public struct BatchListOutgoingTypedLinks: Equatable {
    /// <p>Provides range filters for multiple attributes. When providing ranges to typed link
    ///        selection, any inexact ranges must be specified at the end. Any attributes that do not have a
    ///        range specified are presumed to match the entire range.</p>
    public let filterAttributeRanges: [TypedLinkAttributeRange]?
    /// <p>Filters are interpreted in the order of the attributes defined on the typed link facet,
    ///        not the order they are supplied to any API calls.</p>
    public let filterTypedLink: TypedLinkSchemaAndFacetName?
    /// <p>The maximum number of results to retrieve.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The reference that identifies the object whose attributes will be listed.</p>
    public let objectReference: ObjectReference?

    public init (
        filterAttributeRanges: [TypedLinkAttributeRange]? = nil,
        filterTypedLink: TypedLinkSchemaAndFacetName? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        objectReference: ObjectReference? = nil
    )
    {
        self.filterAttributeRanges = filterAttributeRanges
        self.filterTypedLink = filterTypedLink
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

extension BatchListOutgoingTypedLinksResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case typedLinkSpecifiers = "TypedLinkSpecifiers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let typedLinkSpecifiers = typedLinkSpecifiers {
            var typedLinkSpecifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .typedLinkSpecifiers)
            for typedlinkspecifierlist0 in typedLinkSpecifiers {
                try typedLinkSpecifiersContainer.encode(typedlinkspecifierlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifiersContainer = try containerValues.decodeIfPresent([TypedLinkSpecifier?].self, forKey: .typedLinkSpecifiers)
        var typedLinkSpecifiersDecoded0:[TypedLinkSpecifier]? = nil
        if let typedLinkSpecifiersContainer = typedLinkSpecifiersContainer {
            typedLinkSpecifiersDecoded0 = [TypedLinkSpecifier]()
            for structure0 in typedLinkSpecifiersContainer {
                if let structure0 = structure0 {
                    typedLinkSpecifiersDecoded0?.append(structure0)
                }
            }
        }
        typedLinkSpecifiers = typedLinkSpecifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BatchListOutgoingTypedLinksResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchListOutgoingTypedLinksResponse(nextToken: \(String(describing: nextToken)), typedLinkSpecifiers: \(String(describing: typedLinkSpecifiers)))"}
}

/// <p>Represents the output of a <a>ListOutgoingTypedLinks</a> response operation.</p>
public struct BatchListOutgoingTypedLinksResponse: Equatable {
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>Returns a typed link specifier as output.</p>
    public let typedLinkSpecifiers: [TypedLinkSpecifier]?

    public init (
        nextToken: String? = nil,
        typedLinkSpecifiers: [TypedLinkSpecifier]? = nil
    )
    {
        self.nextToken = nextToken
        self.typedLinkSpecifiers = typedLinkSpecifiers
    }
}

extension BatchListPolicyAttachments: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case policyReference = "PolicyReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let policyReference = policyReference {
            try encodeContainer.encode(policyReference, forKey: .policyReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .policyReference)
        policyReference = policyReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension BatchListPolicyAttachments: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchListPolicyAttachments(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), policyReference: \(String(describing: policyReference)))"}
}

/// <p>Returns all of the <code>ObjectIdentifiers</code> to which a given policy is attached inside a <a>BatchRead</a> operation. For more information, see <a>ListPolicyAttachments</a> and <a>BatchReadRequest$Operations</a>.</p>
public struct BatchListPolicyAttachments: Equatable {
    /// <p>The maximum number of results to retrieve.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The reference that identifies the policy object.</p>
    public let policyReference: ObjectReference?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        policyReference: ObjectReference? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyReference = policyReference
    }
}

extension BatchListPolicyAttachmentsResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case objectIdentifiers = "ObjectIdentifiers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectIdentifiers = objectIdentifiers {
            var objectIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectIdentifiers)
            for objectidentifierlist0 in objectIdentifiers {
                try objectIdentifiersContainer.encode(objectidentifierlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifiersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .objectIdentifiers)
        var objectIdentifiersDecoded0:[String]? = nil
        if let objectIdentifiersContainer = objectIdentifiersContainer {
            objectIdentifiersDecoded0 = [String]()
            for string0 in objectIdentifiersContainer {
                if let string0 = string0 {
                    objectIdentifiersDecoded0?.append(string0)
                }
            }
        }
        objectIdentifiers = objectIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BatchListPolicyAttachmentsResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchListPolicyAttachmentsResponse(nextToken: \(String(describing: nextToken)), objectIdentifiers: \(String(describing: objectIdentifiers)))"}
}

/// <p>Represents the output of a <a>ListPolicyAttachments</a> response operation.</p>
public struct BatchListPolicyAttachmentsResponse: Equatable {
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>A list of <code>ObjectIdentifiers</code> to which the policy is attached.</p>
    public let objectIdentifiers: [String]?

    public init (
        nextToken: String? = nil,
        objectIdentifiers: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.objectIdentifiers = objectIdentifiers
    }
}

extension BatchLookupPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension BatchLookupPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchLookupPolicy(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), objectReference: \(String(describing: objectReference)))"}
}

/// <p>Lists all policies from the root of the Directory to the object specified inside a <a>BatchRead</a> operation. For more information, see <a>LookupPolicy</a> and <a>BatchReadRequest$Operations</a>.</p>
public struct BatchLookupPolicy: Equatable {
    /// <p>The maximum number of results to retrieve.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>Reference that identifies the object whose policies will be looked up.</p>
    public let objectReference: ObjectReference?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        objectReference: ObjectReference? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

extension BatchLookupPolicyResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case policyToPathList = "PolicyToPathList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let policyToPathList = policyToPathList {
            var policyToPathListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyToPathList)
            for policytopathlist0 in policyToPathList {
                try policyToPathListContainer.encode(policytopathlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyToPathListContainer = try containerValues.decodeIfPresent([PolicyToPath?].self, forKey: .policyToPathList)
        var policyToPathListDecoded0:[PolicyToPath]? = nil
        if let policyToPathListContainer = policyToPathListContainer {
            policyToPathListDecoded0 = [PolicyToPath]()
            for structure0 in policyToPathListContainer {
                if let structure0 = structure0 {
                    policyToPathListDecoded0?.append(structure0)
                }
            }
        }
        policyToPathList = policyToPathListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BatchLookupPolicyResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchLookupPolicyResponse(nextToken: \(String(describing: nextToken)), policyToPathList: \(String(describing: policyToPathList)))"}
}

/// <p>Represents the output of a <a>LookupPolicy</a> response operation.</p>
public struct BatchLookupPolicyResponse: Equatable {
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>Provides list of path to policies. Policies contain <code>PolicyId</code>, <code>ObjectIdentifier</code>, and
    ///        <code>PolicyType</code>. For more
    ///        information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies">Policies</a>.</p>
    public let policyToPathList: [PolicyToPath]?

    public init (
        nextToken: String? = nil,
        policyToPathList: [PolicyToPath]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyToPathList = policyToPathList
    }
}

extension BatchReadException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(BatchReadExceptionType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchReadException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchReadException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

/// <p>The batch read exception structure, which contains the exception type and
///       message.</p>
public struct BatchReadException: Equatable {
    /// <p>An exception message that is associated with the failure.</p>
    public let message: String?
    /// <p>A type of exception, such as <code>InvalidArnException</code>.</p>
    public let type: BatchReadExceptionType?

    public init (
        message: String? = nil,
        type: BatchReadExceptionType? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

public enum BatchReadExceptionType {
    case accessdeniedexception
    case cannotlistparentofrootexception
    case directorynotenabledexception
    case facetvalidationexception
    case internalserviceexception
    case invalidarnexception
    case invalidnexttokenexception
    case limitexceededexception
    case notindexexception
    case notnodeexception
    case notpolicyexception
    case resourcenotfoundexception
    case validationexception
    case sdkUnknown(String)
}

extension BatchReadExceptionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BatchReadExceptionType] {
        return [
            .accessdeniedexception,
            .cannotlistparentofrootexception,
            .directorynotenabledexception,
            .facetvalidationexception,
            .internalserviceexception,
            .invalidarnexception,
            .invalidnexttokenexception,
            .limitexceededexception,
            .notindexexception,
            .notnodeexception,
            .notpolicyexception,
            .resourcenotfoundexception,
            .validationexception,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessdeniedexception: return "AccessDeniedException"
        case .cannotlistparentofrootexception: return "CannotListParentOfRootException"
        case .directorynotenabledexception: return "DirectoryNotEnabledException"
        case .facetvalidationexception: return "FacetValidationException"
        case .internalserviceexception: return "InternalServiceException"
        case .invalidarnexception: return "InvalidArnException"
        case .invalidnexttokenexception: return "InvalidNextTokenException"
        case .limitexceededexception: return "LimitExceededException"
        case .notindexexception: return "NotIndexException"
        case .notnodeexception: return "NotNodeException"
        case .notpolicyexception: return "NotPolicyException"
        case .resourcenotfoundexception: return "ResourceNotFoundException"
        case .validationexception: return "ValidationException"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BatchReadExceptionType(rawValue: rawValue) ?? BatchReadExceptionType.sdkUnknown(rawValue)
    }
}

public struct BatchReadInputBodyMiddleware: Middleware {
    public let id: String = "BatchReadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchReadInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchReadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchReadInput>
    public typealias MOutput = OperationOutput<BatchReadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchReadOutputError>
}

extension BatchReadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchReadInput(consistencyLevel: \(String(describing: consistencyLevel)), directoryArn: \(String(describing: directoryArn)), operations: \(String(describing: operations)))"}
}

extension BatchReadInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case operations = "Operations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for batchreadoperationlist0 in operations {
                try operationsContainer.encode(batchreadoperationlist0)
            }
        }
    }
}

public struct BatchReadInputHeadersMiddleware: Middleware {
    public let id: String = "BatchReadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchReadInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchReadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let consistencyLevel = input.operationInput.consistencyLevel {
            input.builder.withHeader(name: "x-amz-consistency-level", value: String(consistencyLevel.rawValue))
        }
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchReadInput>
    public typealias MOutput = OperationOutput<BatchReadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchReadOutputError>
}

public struct BatchReadInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchReadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchReadInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchReadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchReadInput>
    public typealias MOutput = OperationOutput<BatchReadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchReadOutputError>
}

public struct BatchReadInput: Equatable {
    /// <p>Represents the manner and timing in which the successful write or update of an object
    ///       is reflected in a subsequent read operation of that same object.</p>
    public let consistencyLevel: ConsistencyLevel?
    /// <p>The Amazon Resource Name (ARN) that is associated with the <a>Directory</a>.
    ///       For more information, see <a>arns</a>.</p>
    public let directoryArn: String?
    /// <p>A list of operations that are part of the batch.</p>
    public let operations: [BatchReadOperation]?

    public init (
        consistencyLevel: ConsistencyLevel? = nil,
        directoryArn: String? = nil,
        operations: [BatchReadOperation]? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.operations = operations
    }
}

struct BatchReadInputBody: Equatable {
    public let operations: [BatchReadOperation]?
}

extension BatchReadInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operations = "Operations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationsContainer = try containerValues.decodeIfPresent([BatchReadOperation?].self, forKey: .operations)
        var operationsDecoded0:[BatchReadOperation]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [BatchReadOperation]()
            for structure0 in operationsContainer {
                if let structure0 = structure0 {
                    operationsDecoded0?.append(structure0)
                }
            }
        }
        operations = operationsDecoded0
    }
}

extension BatchReadOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case getLinkAttributes = "GetLinkAttributes"
        case getObjectAttributes = "GetObjectAttributes"
        case getObjectInformation = "GetObjectInformation"
        case listAttachedIndices = "ListAttachedIndices"
        case listIncomingTypedLinks = "ListIncomingTypedLinks"
        case listIndex = "ListIndex"
        case listObjectAttributes = "ListObjectAttributes"
        case listObjectChildren = "ListObjectChildren"
        case listObjectParentPaths = "ListObjectParentPaths"
        case listObjectParents = "ListObjectParents"
        case listObjectPolicies = "ListObjectPolicies"
        case listOutgoingTypedLinks = "ListOutgoingTypedLinks"
        case listPolicyAttachments = "ListPolicyAttachments"
        case lookupPolicy = "LookupPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let getLinkAttributes = getLinkAttributes {
            try encodeContainer.encode(getLinkAttributes, forKey: .getLinkAttributes)
        }
        if let getObjectAttributes = getObjectAttributes {
            try encodeContainer.encode(getObjectAttributes, forKey: .getObjectAttributes)
        }
        if let getObjectInformation = getObjectInformation {
            try encodeContainer.encode(getObjectInformation, forKey: .getObjectInformation)
        }
        if let listAttachedIndices = listAttachedIndices {
            try encodeContainer.encode(listAttachedIndices, forKey: .listAttachedIndices)
        }
        if let listIncomingTypedLinks = listIncomingTypedLinks {
            try encodeContainer.encode(listIncomingTypedLinks, forKey: .listIncomingTypedLinks)
        }
        if let listIndex = listIndex {
            try encodeContainer.encode(listIndex, forKey: .listIndex)
        }
        if let listObjectAttributes = listObjectAttributes {
            try encodeContainer.encode(listObjectAttributes, forKey: .listObjectAttributes)
        }
        if let listObjectChildren = listObjectChildren {
            try encodeContainer.encode(listObjectChildren, forKey: .listObjectChildren)
        }
        if let listObjectParentPaths = listObjectParentPaths {
            try encodeContainer.encode(listObjectParentPaths, forKey: .listObjectParentPaths)
        }
        if let listObjectParents = listObjectParents {
            try encodeContainer.encode(listObjectParents, forKey: .listObjectParents)
        }
        if let listObjectPolicies = listObjectPolicies {
            try encodeContainer.encode(listObjectPolicies, forKey: .listObjectPolicies)
        }
        if let listOutgoingTypedLinks = listOutgoingTypedLinks {
            try encodeContainer.encode(listOutgoingTypedLinks, forKey: .listOutgoingTypedLinks)
        }
        if let listPolicyAttachments = listPolicyAttachments {
            try encodeContainer.encode(listPolicyAttachments, forKey: .listPolicyAttachments)
        }
        if let lookupPolicy = lookupPolicy {
            try encodeContainer.encode(lookupPolicy, forKey: .lookupPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listObjectAttributesDecoded = try containerValues.decodeIfPresent(BatchListObjectAttributes.self, forKey: .listObjectAttributes)
        listObjectAttributes = listObjectAttributesDecoded
        let listObjectChildrenDecoded = try containerValues.decodeIfPresent(BatchListObjectChildren.self, forKey: .listObjectChildren)
        listObjectChildren = listObjectChildrenDecoded
        let listAttachedIndicesDecoded = try containerValues.decodeIfPresent(BatchListAttachedIndices.self, forKey: .listAttachedIndices)
        listAttachedIndices = listAttachedIndicesDecoded
        let listObjectParentPathsDecoded = try containerValues.decodeIfPresent(BatchListObjectParentPaths.self, forKey: .listObjectParentPaths)
        listObjectParentPaths = listObjectParentPathsDecoded
        let getObjectInformationDecoded = try containerValues.decodeIfPresent(BatchGetObjectInformation.self, forKey: .getObjectInformation)
        getObjectInformation = getObjectInformationDecoded
        let getObjectAttributesDecoded = try containerValues.decodeIfPresent(BatchGetObjectAttributes.self, forKey: .getObjectAttributes)
        getObjectAttributes = getObjectAttributesDecoded
        let listObjectParentsDecoded = try containerValues.decodeIfPresent(BatchListObjectParents.self, forKey: .listObjectParents)
        listObjectParents = listObjectParentsDecoded
        let listObjectPoliciesDecoded = try containerValues.decodeIfPresent(BatchListObjectPolicies.self, forKey: .listObjectPolicies)
        listObjectPolicies = listObjectPoliciesDecoded
        let listPolicyAttachmentsDecoded = try containerValues.decodeIfPresent(BatchListPolicyAttachments.self, forKey: .listPolicyAttachments)
        listPolicyAttachments = listPolicyAttachmentsDecoded
        let lookupPolicyDecoded = try containerValues.decodeIfPresent(BatchLookupPolicy.self, forKey: .lookupPolicy)
        lookupPolicy = lookupPolicyDecoded
        let listIndexDecoded = try containerValues.decodeIfPresent(BatchListIndex.self, forKey: .listIndex)
        listIndex = listIndexDecoded
        let listOutgoingTypedLinksDecoded = try containerValues.decodeIfPresent(BatchListOutgoingTypedLinks.self, forKey: .listOutgoingTypedLinks)
        listOutgoingTypedLinks = listOutgoingTypedLinksDecoded
        let listIncomingTypedLinksDecoded = try containerValues.decodeIfPresent(BatchListIncomingTypedLinks.self, forKey: .listIncomingTypedLinks)
        listIncomingTypedLinks = listIncomingTypedLinksDecoded
        let getLinkAttributesDecoded = try containerValues.decodeIfPresent(BatchGetLinkAttributes.self, forKey: .getLinkAttributes)
        getLinkAttributes = getLinkAttributesDecoded
    }
}

extension BatchReadOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchReadOperation(getLinkAttributes: \(String(describing: getLinkAttributes)), getObjectAttributes: \(String(describing: getObjectAttributes)), getObjectInformation: \(String(describing: getObjectInformation)), listAttachedIndices: \(String(describing: listAttachedIndices)), listIncomingTypedLinks: \(String(describing: listIncomingTypedLinks)), listIndex: \(String(describing: listIndex)), listObjectAttributes: \(String(describing: listObjectAttributes)), listObjectChildren: \(String(describing: listObjectChildren)), listObjectParentPaths: \(String(describing: listObjectParentPaths)), listObjectParents: \(String(describing: listObjectParents)), listObjectPolicies: \(String(describing: listObjectPolicies)), listOutgoingTypedLinks: \(String(describing: listOutgoingTypedLinks)), listPolicyAttachments: \(String(describing: listPolicyAttachments)), lookupPolicy: \(String(describing: lookupPolicy)))"}
}

/// <p>Represents the output of a <code>BatchRead</code> operation.</p>
public struct BatchReadOperation: Equatable {
    /// <p>Retrieves attributes that are associated with a typed link.</p>
    public let getLinkAttributes: BatchGetLinkAttributes?
    /// <p>Retrieves attributes within a facet that are associated with an object.</p>
    public let getObjectAttributes: BatchGetObjectAttributes?
    /// <p>Retrieves metadata about an object.</p>
    public let getObjectInformation: BatchGetObjectInformation?
    /// <p>Lists indices attached to an object.</p>
    public let listAttachedIndices: BatchListAttachedIndices?
    /// <p>Returns a paginated list of all the incoming <a>TypedLinkSpecifier</a>
    ///        information for an object. It also supports filtering by typed link facet and identity
    ///        attributes. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
    public let listIncomingTypedLinks: BatchListIncomingTypedLinks?
    /// <p>Lists objects attached to the specified index.</p>
    public let listIndex: BatchListIndex?
    /// <p>Lists all attributes that are associated with an object.</p>
    public let listObjectAttributes: BatchListObjectAttributes?
    /// <p>Returns a paginated list of child objects that are associated with a given
    ///       object.</p>
    public let listObjectChildren: BatchListObjectChildren?
    /// <p>Retrieves all available parent paths for any object type such as node, leaf node,
    ///        policy node, and index node objects. For more information about objects, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directorystructure.html">Directory Structure</a>.</p>
    public let listObjectParentPaths: BatchListObjectParentPaths?
    public let listObjectParents: BatchListObjectParents?
    /// <p>Returns policies attached to an object in pagination fashion.</p>
    public let listObjectPolicies: BatchListObjectPolicies?
    /// <p>Returns a paginated list of all the outgoing <a>TypedLinkSpecifier</a>
    ///        information for an object. It also supports filtering by typed link facet and identity
    ///        attributes. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
    public let listOutgoingTypedLinks: BatchListOutgoingTypedLinks?
    /// <p>Returns all of the <code>ObjectIdentifiers</code> to which a given policy is attached.</p>
    public let listPolicyAttachments: BatchListPolicyAttachments?
    /// <p>Lists all policies from the root of the <a>Directory</a> to the object
    ///        specified. If there are no policies present, an empty list is returned. If policies are
    ///        present, and if some objects don't have the policies attached, it returns the <code>ObjectIdentifier</code>
    ///        for such objects. If policies are present, it returns <code>ObjectIdentifier</code>, <code>policyId</code>, and
    ///        <code>policyType</code>. Paths that don't lead to the root from the target object are ignored. For more
    ///        information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies">Policies</a>.</p>
    public let lookupPolicy: BatchLookupPolicy?

    public init (
        getLinkAttributes: BatchGetLinkAttributes? = nil,
        getObjectAttributes: BatchGetObjectAttributes? = nil,
        getObjectInformation: BatchGetObjectInformation? = nil,
        listAttachedIndices: BatchListAttachedIndices? = nil,
        listIncomingTypedLinks: BatchListIncomingTypedLinks? = nil,
        listIndex: BatchListIndex? = nil,
        listObjectAttributes: BatchListObjectAttributes? = nil,
        listObjectChildren: BatchListObjectChildren? = nil,
        listObjectParentPaths: BatchListObjectParentPaths? = nil,
        listObjectParents: BatchListObjectParents? = nil,
        listObjectPolicies: BatchListObjectPolicies? = nil,
        listOutgoingTypedLinks: BatchListOutgoingTypedLinks? = nil,
        listPolicyAttachments: BatchListPolicyAttachments? = nil,
        lookupPolicy: BatchLookupPolicy? = nil
    )
    {
        self.getLinkAttributes = getLinkAttributes
        self.getObjectAttributes = getObjectAttributes
        self.getObjectInformation = getObjectInformation
        self.listAttachedIndices = listAttachedIndices
        self.listIncomingTypedLinks = listIncomingTypedLinks
        self.listIndex = listIndex
        self.listObjectAttributes = listObjectAttributes
        self.listObjectChildren = listObjectChildren
        self.listObjectParentPaths = listObjectParentPaths
        self.listObjectParents = listObjectParents
        self.listObjectPolicies = listObjectPolicies
        self.listOutgoingTypedLinks = listOutgoingTypedLinks
        self.listPolicyAttachments = listPolicyAttachments
        self.lookupPolicy = lookupPolicy
    }
}

extension BatchReadOperationResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exceptionResponse = "ExceptionResponse"
        case successfulResponse = "SuccessfulResponse"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exceptionResponse = exceptionResponse {
            try encodeContainer.encode(exceptionResponse, forKey: .exceptionResponse)
        }
        if let successfulResponse = successfulResponse {
            try encodeContainer.encode(successfulResponse, forKey: .successfulResponse)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulResponseDecoded = try containerValues.decodeIfPresent(BatchReadSuccessfulResponse.self, forKey: .successfulResponse)
        successfulResponse = successfulResponseDecoded
        let exceptionResponseDecoded = try containerValues.decodeIfPresent(BatchReadException.self, forKey: .exceptionResponse)
        exceptionResponse = exceptionResponseDecoded
    }
}

extension BatchReadOperationResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchReadOperationResponse(exceptionResponse: \(String(describing: exceptionResponse)), successfulResponse: \(String(describing: successfulResponse)))"}
}

/// <p>Represents the output of a <code>BatchRead</code> response operation.</p>
public struct BatchReadOperationResponse: Equatable {
    /// <p>Identifies which operation in a batch has failed.</p>
    public let exceptionResponse: BatchReadException?
    /// <p>Identifies which operation in a batch has succeeded.</p>
    public let successfulResponse: BatchReadSuccessfulResponse?

    public init (
        exceptionResponse: BatchReadException? = nil,
        successfulResponse: BatchReadSuccessfulResponse? = nil
    )
    {
        self.exceptionResponse = exceptionResponse
        self.successfulResponse = successfulResponse
    }
}

extension BatchReadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchReadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchReadOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchReadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchReadOutputResponse(responses: \(String(describing: responses)))"}
}

extension BatchReadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchReadOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.responses = output.responses
        } else {
            self.responses = nil
        }
    }
}

public struct BatchReadOutputResponse: Equatable {
    /// <p>A list of all the responses for each batch read.</p>
    public let responses: [BatchReadOperationResponse]?

    public init (
        responses: [BatchReadOperationResponse]? = nil
    )
    {
        self.responses = responses
    }
}

struct BatchReadOutputResponseBody: Equatable {
    public let responses: [BatchReadOperationResponse]?
}

extension BatchReadOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case responses = "Responses"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responsesContainer = try containerValues.decodeIfPresent([BatchReadOperationResponse?].self, forKey: .responses)
        var responsesDecoded0:[BatchReadOperationResponse]? = nil
        if let responsesContainer = responsesContainer {
            responsesDecoded0 = [BatchReadOperationResponse]()
            for structure0 in responsesContainer {
                if let structure0 = structure0 {
                    responsesDecoded0?.append(structure0)
                }
            }
        }
        responses = responsesDecoded0
    }
}

extension BatchReadSuccessfulResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case getLinkAttributes = "GetLinkAttributes"
        case getObjectAttributes = "GetObjectAttributes"
        case getObjectInformation = "GetObjectInformation"
        case listAttachedIndices = "ListAttachedIndices"
        case listIncomingTypedLinks = "ListIncomingTypedLinks"
        case listIndex = "ListIndex"
        case listObjectAttributes = "ListObjectAttributes"
        case listObjectChildren = "ListObjectChildren"
        case listObjectParentPaths = "ListObjectParentPaths"
        case listObjectParents = "ListObjectParents"
        case listObjectPolicies = "ListObjectPolicies"
        case listOutgoingTypedLinks = "ListOutgoingTypedLinks"
        case listPolicyAttachments = "ListPolicyAttachments"
        case lookupPolicy = "LookupPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let getLinkAttributes = getLinkAttributes {
            try encodeContainer.encode(getLinkAttributes, forKey: .getLinkAttributes)
        }
        if let getObjectAttributes = getObjectAttributes {
            try encodeContainer.encode(getObjectAttributes, forKey: .getObjectAttributes)
        }
        if let getObjectInformation = getObjectInformation {
            try encodeContainer.encode(getObjectInformation, forKey: .getObjectInformation)
        }
        if let listAttachedIndices = listAttachedIndices {
            try encodeContainer.encode(listAttachedIndices, forKey: .listAttachedIndices)
        }
        if let listIncomingTypedLinks = listIncomingTypedLinks {
            try encodeContainer.encode(listIncomingTypedLinks, forKey: .listIncomingTypedLinks)
        }
        if let listIndex = listIndex {
            try encodeContainer.encode(listIndex, forKey: .listIndex)
        }
        if let listObjectAttributes = listObjectAttributes {
            try encodeContainer.encode(listObjectAttributes, forKey: .listObjectAttributes)
        }
        if let listObjectChildren = listObjectChildren {
            try encodeContainer.encode(listObjectChildren, forKey: .listObjectChildren)
        }
        if let listObjectParentPaths = listObjectParentPaths {
            try encodeContainer.encode(listObjectParentPaths, forKey: .listObjectParentPaths)
        }
        if let listObjectParents = listObjectParents {
            try encodeContainer.encode(listObjectParents, forKey: .listObjectParents)
        }
        if let listObjectPolicies = listObjectPolicies {
            try encodeContainer.encode(listObjectPolicies, forKey: .listObjectPolicies)
        }
        if let listOutgoingTypedLinks = listOutgoingTypedLinks {
            try encodeContainer.encode(listOutgoingTypedLinks, forKey: .listOutgoingTypedLinks)
        }
        if let listPolicyAttachments = listPolicyAttachments {
            try encodeContainer.encode(listPolicyAttachments, forKey: .listPolicyAttachments)
        }
        if let lookupPolicy = lookupPolicy {
            try encodeContainer.encode(lookupPolicy, forKey: .lookupPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listObjectAttributesDecoded = try containerValues.decodeIfPresent(BatchListObjectAttributesResponse.self, forKey: .listObjectAttributes)
        listObjectAttributes = listObjectAttributesDecoded
        let listObjectChildrenDecoded = try containerValues.decodeIfPresent(BatchListObjectChildrenResponse.self, forKey: .listObjectChildren)
        listObjectChildren = listObjectChildrenDecoded
        let getObjectInformationDecoded = try containerValues.decodeIfPresent(BatchGetObjectInformationResponse.self, forKey: .getObjectInformation)
        getObjectInformation = getObjectInformationDecoded
        let getObjectAttributesDecoded = try containerValues.decodeIfPresent(BatchGetObjectAttributesResponse.self, forKey: .getObjectAttributes)
        getObjectAttributes = getObjectAttributesDecoded
        let listAttachedIndicesDecoded = try containerValues.decodeIfPresent(BatchListAttachedIndicesResponse.self, forKey: .listAttachedIndices)
        listAttachedIndices = listAttachedIndicesDecoded
        let listObjectParentPathsDecoded = try containerValues.decodeIfPresent(BatchListObjectParentPathsResponse.self, forKey: .listObjectParentPaths)
        listObjectParentPaths = listObjectParentPathsDecoded
        let listObjectPoliciesDecoded = try containerValues.decodeIfPresent(BatchListObjectPoliciesResponse.self, forKey: .listObjectPolicies)
        listObjectPolicies = listObjectPoliciesDecoded
        let listPolicyAttachmentsDecoded = try containerValues.decodeIfPresent(BatchListPolicyAttachmentsResponse.self, forKey: .listPolicyAttachments)
        listPolicyAttachments = listPolicyAttachmentsDecoded
        let lookupPolicyDecoded = try containerValues.decodeIfPresent(BatchLookupPolicyResponse.self, forKey: .lookupPolicy)
        lookupPolicy = lookupPolicyDecoded
        let listIndexDecoded = try containerValues.decodeIfPresent(BatchListIndexResponse.self, forKey: .listIndex)
        listIndex = listIndexDecoded
        let listOutgoingTypedLinksDecoded = try containerValues.decodeIfPresent(BatchListOutgoingTypedLinksResponse.self, forKey: .listOutgoingTypedLinks)
        listOutgoingTypedLinks = listOutgoingTypedLinksDecoded
        let listIncomingTypedLinksDecoded = try containerValues.decodeIfPresent(BatchListIncomingTypedLinksResponse.self, forKey: .listIncomingTypedLinks)
        listIncomingTypedLinks = listIncomingTypedLinksDecoded
        let getLinkAttributesDecoded = try containerValues.decodeIfPresent(BatchGetLinkAttributesResponse.self, forKey: .getLinkAttributes)
        getLinkAttributes = getLinkAttributesDecoded
        let listObjectParentsDecoded = try containerValues.decodeIfPresent(BatchListObjectParentsResponse.self, forKey: .listObjectParents)
        listObjectParents = listObjectParentsDecoded
    }
}

extension BatchReadSuccessfulResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchReadSuccessfulResponse(getLinkAttributes: \(String(describing: getLinkAttributes)), getObjectAttributes: \(String(describing: getObjectAttributes)), getObjectInformation: \(String(describing: getObjectInformation)), listAttachedIndices: \(String(describing: listAttachedIndices)), listIncomingTypedLinks: \(String(describing: listIncomingTypedLinks)), listIndex: \(String(describing: listIndex)), listObjectAttributes: \(String(describing: listObjectAttributes)), listObjectChildren: \(String(describing: listObjectChildren)), listObjectParentPaths: \(String(describing: listObjectParentPaths)), listObjectParents: \(String(describing: listObjectParents)), listObjectPolicies: \(String(describing: listObjectPolicies)), listOutgoingTypedLinks: \(String(describing: listOutgoingTypedLinks)), listPolicyAttachments: \(String(describing: listPolicyAttachments)), lookupPolicy: \(String(describing: lookupPolicy)))"}
}

/// <p>Represents the output of a <code>BatchRead</code> success response operation.</p>
public struct BatchReadSuccessfulResponse: Equatable {
    /// <p>The list of attributes to retrieve from the typed link.</p>
    public let getLinkAttributes: BatchGetLinkAttributesResponse?
    /// <p>Retrieves attributes within a facet that are associated with an object.</p>
    public let getObjectAttributes: BatchGetObjectAttributesResponse?
    /// <p>Retrieves metadata about an object.</p>
    public let getObjectInformation: BatchGetObjectInformationResponse?
    /// <p>Lists indices attached to an object.</p>
    public let listAttachedIndices: BatchListAttachedIndicesResponse?
    /// <p>Returns a paginated list of all the incoming <a>TypedLinkSpecifier</a>
    ///        information for an object. It also supports filtering by typed link facet and identity
    ///        attributes. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
    public let listIncomingTypedLinks: BatchListIncomingTypedLinksResponse?
    /// <p>Lists objects attached to the specified index.</p>
    public let listIndex: BatchListIndexResponse?
    /// <p>Lists all attributes that are associated with an object.</p>
    public let listObjectAttributes: BatchListObjectAttributesResponse?
    /// <p>Returns a paginated list of child objects that are associated with a given
    ///       object.</p>
    public let listObjectChildren: BatchListObjectChildrenResponse?
    /// <p>Retrieves all available parent paths for any object type such as node, leaf node,
    ///        policy node, and index node objects. For more information about objects, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directorystructure.html">Directory Structure</a>.</p>
    public let listObjectParentPaths: BatchListObjectParentPathsResponse?
    public let listObjectParents: BatchListObjectParentsResponse?
    /// <p>Returns policies attached to an object in pagination fashion.</p>
    public let listObjectPolicies: BatchListObjectPoliciesResponse?
    /// <p>Returns a paginated list of all the outgoing <a>TypedLinkSpecifier</a>
    ///        information for an object. It also supports filtering by typed link facet and identity
    ///        attributes. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
    public let listOutgoingTypedLinks: BatchListOutgoingTypedLinksResponse?
    /// <p>Returns all of the <code>ObjectIdentifiers</code> to which a given policy is attached.</p>
    public let listPolicyAttachments: BatchListPolicyAttachmentsResponse?
    /// <p>Lists all policies from the root of the <a>Directory</a> to the object
    ///        specified. If there are no policies present, an empty list is returned. If policies are
    ///        present, and if some objects don't have the policies attached, it returns the <code>ObjectIdentifier</code>
    ///        for such objects. If policies are present, it returns <code>ObjectIdentifier</code>, <code>policyId</code>, and
    ///        <code>policyType</code>. Paths that don't lead to the root from the target object are ignored. For more
    ///        information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies">Policies</a>.</p>
    public let lookupPolicy: BatchLookupPolicyResponse?

    public init (
        getLinkAttributes: BatchGetLinkAttributesResponse? = nil,
        getObjectAttributes: BatchGetObjectAttributesResponse? = nil,
        getObjectInformation: BatchGetObjectInformationResponse? = nil,
        listAttachedIndices: BatchListAttachedIndicesResponse? = nil,
        listIncomingTypedLinks: BatchListIncomingTypedLinksResponse? = nil,
        listIndex: BatchListIndexResponse? = nil,
        listObjectAttributes: BatchListObjectAttributesResponse? = nil,
        listObjectChildren: BatchListObjectChildrenResponse? = nil,
        listObjectParentPaths: BatchListObjectParentPathsResponse? = nil,
        listObjectParents: BatchListObjectParentsResponse? = nil,
        listObjectPolicies: BatchListObjectPoliciesResponse? = nil,
        listOutgoingTypedLinks: BatchListOutgoingTypedLinksResponse? = nil,
        listPolicyAttachments: BatchListPolicyAttachmentsResponse? = nil,
        lookupPolicy: BatchLookupPolicyResponse? = nil
    )
    {
        self.getLinkAttributes = getLinkAttributes
        self.getObjectAttributes = getObjectAttributes
        self.getObjectInformation = getObjectInformation
        self.listAttachedIndices = listAttachedIndices
        self.listIncomingTypedLinks = listIncomingTypedLinks
        self.listIndex = listIndex
        self.listObjectAttributes = listObjectAttributes
        self.listObjectChildren = listObjectChildren
        self.listObjectParentPaths = listObjectParentPaths
        self.listObjectParents = listObjectParents
        self.listObjectPolicies = listObjectPolicies
        self.listOutgoingTypedLinks = listOutgoingTypedLinks
        self.listPolicyAttachments = listPolicyAttachments
        self.lookupPolicy = lookupPolicy
    }
}

extension BatchRemoveFacetFromObject: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let schemaFacet = schemaFacet {
            try encodeContainer.encode(schemaFacet, forKey: .schemaFacet)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetDecoded = try containerValues.decodeIfPresent(SchemaFacet.self, forKey: .schemaFacet)
        schemaFacet = schemaFacetDecoded
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension BatchRemoveFacetFromObject: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchRemoveFacetFromObject(objectReference: \(String(describing: objectReference)), schemaFacet: \(String(describing: schemaFacet)))"}
}

/// <p>A batch operation to remove a facet from an object.</p>
public struct BatchRemoveFacetFromObject: Equatable {
    /// <p>A reference to the object whose facet will be removed.</p>
    public let objectReference: ObjectReference?
    /// <p>The facet to remove from the object.</p>
    public let schemaFacet: SchemaFacet?

    public init (
        objectReference: ObjectReference? = nil,
        schemaFacet: SchemaFacet? = nil
    )
    {
        self.objectReference = objectReference
        self.schemaFacet = schemaFacet
    }
}

extension BatchRemoveFacetFromObjectResponse: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension BatchRemoveFacetFromObjectResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchRemoveFacetFromObjectResponse()"}
}

/// <p>An empty result that represents success.</p>
public struct BatchRemoveFacetFromObjectResponse: Equatable {

    public init() {}
}

extension BatchUpdateLinkAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdates = attributeUpdates {
            var attributeUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeUpdates)
            for linkattributeupdatelist0 in attributeUpdates {
                try attributeUpdatesContainer.encode(linkattributeupdatelist0)
            }
        }
        if let typedLinkSpecifier = typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
        let attributeUpdatesContainer = try containerValues.decodeIfPresent([LinkAttributeUpdate?].self, forKey: .attributeUpdates)
        var attributeUpdatesDecoded0:[LinkAttributeUpdate]? = nil
        if let attributeUpdatesContainer = attributeUpdatesContainer {
            attributeUpdatesDecoded0 = [LinkAttributeUpdate]()
            for structure0 in attributeUpdatesContainer {
                if let structure0 = structure0 {
                    attributeUpdatesDecoded0?.append(structure0)
                }
            }
        }
        attributeUpdates = attributeUpdatesDecoded0
    }
}

extension BatchUpdateLinkAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchUpdateLinkAttributes(attributeUpdates: \(String(describing: attributeUpdates)), typedLinkSpecifier: \(String(describing: typedLinkSpecifier)))"}
}

/// <p>Updates a given typed link’s attributes inside a <a>BatchRead</a> operation. Attributes to be updated must not contribute to the typed link’s identity, as defined by its <code>IdentityAttributeOrder</code>. For more information, see <a>UpdateLinkAttributes</a> and <a>BatchReadRequest$Operations</a>.</p>
public struct BatchUpdateLinkAttributes: Equatable {
    /// <p>The attributes update structure.</p>
    public let attributeUpdates: [LinkAttributeUpdate]?
    /// <p>Allows a typed link specifier to be accepted as input.</p>
    public let typedLinkSpecifier: TypedLinkSpecifier?

    public init (
        attributeUpdates: [LinkAttributeUpdate]? = nil,
        typedLinkSpecifier: TypedLinkSpecifier? = nil
    )
    {
        self.attributeUpdates = attributeUpdates
        self.typedLinkSpecifier = typedLinkSpecifier
    }
}

extension BatchUpdateLinkAttributesResponse: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension BatchUpdateLinkAttributesResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchUpdateLinkAttributesResponse()"}
}

/// <p>Represents the output of a <a>UpdateLinkAttributes</a> response operation.</p>
public struct BatchUpdateLinkAttributesResponse: Equatable {

    public init() {}
}

extension BatchUpdateObjectAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdates = attributeUpdates {
            var attributeUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeUpdates)
            for objectattributeupdatelist0 in attributeUpdates {
                try attributeUpdatesContainer.encode(objectattributeupdatelist0)
            }
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let attributeUpdatesContainer = try containerValues.decodeIfPresent([ObjectAttributeUpdate?].self, forKey: .attributeUpdates)
        var attributeUpdatesDecoded0:[ObjectAttributeUpdate]? = nil
        if let attributeUpdatesContainer = attributeUpdatesContainer {
            attributeUpdatesDecoded0 = [ObjectAttributeUpdate]()
            for structure0 in attributeUpdatesContainer {
                if let structure0 = structure0 {
                    attributeUpdatesDecoded0?.append(structure0)
                }
            }
        }
        attributeUpdates = attributeUpdatesDecoded0
    }
}

extension BatchUpdateObjectAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchUpdateObjectAttributes(attributeUpdates: \(String(describing: attributeUpdates)), objectReference: \(String(describing: objectReference)))"}
}

/// <p>Represents the output of a <code>BatchUpdate</code> operation. </p>
public struct BatchUpdateObjectAttributes: Equatable {
    /// <p>Attributes update structure.</p>
    public let attributeUpdates: [ObjectAttributeUpdate]?
    /// <p>Reference that identifies the object.</p>
    public let objectReference: ObjectReference?

    public init (
        attributeUpdates: [ObjectAttributeUpdate]? = nil,
        objectReference: ObjectReference? = nil
    )
    {
        self.attributeUpdates = attributeUpdates
        self.objectReference = objectReference
    }
}

extension BatchUpdateObjectAttributesResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectIdentifier = "ObjectIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectIdentifier = objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

extension BatchUpdateObjectAttributesResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchUpdateObjectAttributesResponse(objectIdentifier: \(String(describing: objectIdentifier)))"}
}

/// <p>Represents the output of a <code>BatchUpdate</code> response operation.</p>
public struct BatchUpdateObjectAttributesResponse: Equatable {
    /// <p>ID that is associated with the object.</p>
    public let objectIdentifier: String?

    public init (
        objectIdentifier: String? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
    }
}

extension BatchWriteException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchWriteException(index: \(String(describing: index)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension BatchWriteException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchWriteExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.index = output.index
            self.message = output.message
            self.type = output.type
        } else {
            self.index = 0
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A <code>BatchWrite</code> exception has occurred.</p>
public struct BatchWriteException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var index: Int
    public var message: String?
    public var type: BatchWriteExceptionType?

    public init (
        index: Int = 0,
        message: String? = nil,
        type: BatchWriteExceptionType? = nil
    )
    {
        self.index = index
        self.message = message
        self.type = type
    }
}

struct BatchWriteExceptionBody: Equatable {
    public let index: Int
    public let type: BatchWriteExceptionType?
    public let message: String?
}

extension BatchWriteExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case index = "Index"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexDecoded = try containerValues.decode(Int.self, forKey: .index)
        index = indexDecoded
        let typeDecoded = try containerValues.decodeIfPresent(BatchWriteExceptionType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum BatchWriteExceptionType {
    case accessdeniedexception
    case directorynotenabledexception
    case facetvalidationexception
    case indexedattributemissingexception
    case internalserviceexception
    case invalidarnexception
    case invalidattachmentexception
    case limitexceededexception
    case linknamealreadyinuseexception
    case notindexexception
    case notnodeexception
    case notpolicyexception
    case objectalreadydetachedexception
    case objectnotdetachedexception
    case resourcenotfoundexception
    case stillcontainslinksexception
    case unsupportedindextypeexception
    case validationexception
    case sdkUnknown(String)
}

extension BatchWriteExceptionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BatchWriteExceptionType] {
        return [
            .accessdeniedexception,
            .directorynotenabledexception,
            .facetvalidationexception,
            .indexedattributemissingexception,
            .internalserviceexception,
            .invalidarnexception,
            .invalidattachmentexception,
            .limitexceededexception,
            .linknamealreadyinuseexception,
            .notindexexception,
            .notnodeexception,
            .notpolicyexception,
            .objectalreadydetachedexception,
            .objectnotdetachedexception,
            .resourcenotfoundexception,
            .stillcontainslinksexception,
            .unsupportedindextypeexception,
            .validationexception,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessdeniedexception: return "AccessDeniedException"
        case .directorynotenabledexception: return "DirectoryNotEnabledException"
        case .facetvalidationexception: return "FacetValidationException"
        case .indexedattributemissingexception: return "IndexedAttributeMissingException"
        case .internalserviceexception: return "InternalServiceException"
        case .invalidarnexception: return "InvalidArnException"
        case .invalidattachmentexception: return "InvalidAttachmentException"
        case .limitexceededexception: return "LimitExceededException"
        case .linknamealreadyinuseexception: return "LinkNameAlreadyInUseException"
        case .notindexexception: return "NotIndexException"
        case .notnodeexception: return "NotNodeException"
        case .notpolicyexception: return "NotPolicyException"
        case .objectalreadydetachedexception: return "ObjectAlreadyDetachedException"
        case .objectnotdetachedexception: return "ObjectNotDetachedException"
        case .resourcenotfoundexception: return "ResourceNotFoundException"
        case .stillcontainslinksexception: return "StillContainsLinksException"
        case .unsupportedindextypeexception: return "UnsupportedIndexTypeException"
        case .validationexception: return "ValidationException"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BatchWriteExceptionType(rawValue: rawValue) ?? BatchWriteExceptionType.sdkUnknown(rawValue)
    }
}

public struct BatchWriteInputBodyMiddleware: Middleware {
    public let id: String = "BatchWriteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchWriteInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchWriteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchWriteInput>
    public typealias MOutput = OperationOutput<BatchWriteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchWriteOutputError>
}

extension BatchWriteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchWriteInput(directoryArn: \(String(describing: directoryArn)), operations: \(String(describing: operations)))"}
}

extension BatchWriteInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case operations = "Operations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for batchwriteoperationlist0 in operations {
                try operationsContainer.encode(batchwriteoperationlist0)
            }
        }
    }
}

public struct BatchWriteInputHeadersMiddleware: Middleware {
    public let id: String = "BatchWriteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchWriteInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchWriteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchWriteInput>
    public typealias MOutput = OperationOutput<BatchWriteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchWriteOutputError>
}

public struct BatchWriteInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchWriteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchWriteInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchWriteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchWriteInput>
    public typealias MOutput = OperationOutput<BatchWriteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchWriteOutputError>
}

public struct BatchWriteInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that is associated with the <a>Directory</a>.
    ///       For more information, see <a>arns</a>.</p>
    public let directoryArn: String?
    /// <p>A list of operations that are part of the batch.</p>
    public let operations: [BatchWriteOperation]?

    public init (
        directoryArn: String? = nil,
        operations: [BatchWriteOperation]? = nil
    )
    {
        self.directoryArn = directoryArn
        self.operations = operations
    }
}

struct BatchWriteInputBody: Equatable {
    public let operations: [BatchWriteOperation]?
}

extension BatchWriteInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operations = "Operations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationsContainer = try containerValues.decodeIfPresent([BatchWriteOperation?].self, forKey: .operations)
        var operationsDecoded0:[BatchWriteOperation]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [BatchWriteOperation]()
            for structure0 in operationsContainer {
                if let structure0 = structure0 {
                    operationsDecoded0?.append(structure0)
                }
            }
        }
        operations = operationsDecoded0
    }
}

extension BatchWriteOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addFacetToObject = "AddFacetToObject"
        case attachObject = "AttachObject"
        case attachPolicy = "AttachPolicy"
        case attachToIndex = "AttachToIndex"
        case attachTypedLink = "AttachTypedLink"
        case createIndex = "CreateIndex"
        case createObject = "CreateObject"
        case deleteObject = "DeleteObject"
        case detachFromIndex = "DetachFromIndex"
        case detachObject = "DetachObject"
        case detachPolicy = "DetachPolicy"
        case detachTypedLink = "DetachTypedLink"
        case removeFacetFromObject = "RemoveFacetFromObject"
        case updateLinkAttributes = "UpdateLinkAttributes"
        case updateObjectAttributes = "UpdateObjectAttributes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addFacetToObject = addFacetToObject {
            try encodeContainer.encode(addFacetToObject, forKey: .addFacetToObject)
        }
        if let attachObject = attachObject {
            try encodeContainer.encode(attachObject, forKey: .attachObject)
        }
        if let attachPolicy = attachPolicy {
            try encodeContainer.encode(attachPolicy, forKey: .attachPolicy)
        }
        if let attachToIndex = attachToIndex {
            try encodeContainer.encode(attachToIndex, forKey: .attachToIndex)
        }
        if let attachTypedLink = attachTypedLink {
            try encodeContainer.encode(attachTypedLink, forKey: .attachTypedLink)
        }
        if let createIndex = createIndex {
            try encodeContainer.encode(createIndex, forKey: .createIndex)
        }
        if let createObject = createObject {
            try encodeContainer.encode(createObject, forKey: .createObject)
        }
        if let deleteObject = deleteObject {
            try encodeContainer.encode(deleteObject, forKey: .deleteObject)
        }
        if let detachFromIndex = detachFromIndex {
            try encodeContainer.encode(detachFromIndex, forKey: .detachFromIndex)
        }
        if let detachObject = detachObject {
            try encodeContainer.encode(detachObject, forKey: .detachObject)
        }
        if let detachPolicy = detachPolicy {
            try encodeContainer.encode(detachPolicy, forKey: .detachPolicy)
        }
        if let detachTypedLink = detachTypedLink {
            try encodeContainer.encode(detachTypedLink, forKey: .detachTypedLink)
        }
        if let removeFacetFromObject = removeFacetFromObject {
            try encodeContainer.encode(removeFacetFromObject, forKey: .removeFacetFromObject)
        }
        if let updateLinkAttributes = updateLinkAttributes {
            try encodeContainer.encode(updateLinkAttributes, forKey: .updateLinkAttributes)
        }
        if let updateObjectAttributes = updateObjectAttributes {
            try encodeContainer.encode(updateObjectAttributes, forKey: .updateObjectAttributes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createObjectDecoded = try containerValues.decodeIfPresent(BatchCreateObject.self, forKey: .createObject)
        createObject = createObjectDecoded
        let attachObjectDecoded = try containerValues.decodeIfPresent(BatchAttachObject.self, forKey: .attachObject)
        attachObject = attachObjectDecoded
        let detachObjectDecoded = try containerValues.decodeIfPresent(BatchDetachObject.self, forKey: .detachObject)
        detachObject = detachObjectDecoded
        let updateObjectAttributesDecoded = try containerValues.decodeIfPresent(BatchUpdateObjectAttributes.self, forKey: .updateObjectAttributes)
        updateObjectAttributes = updateObjectAttributesDecoded
        let deleteObjectDecoded = try containerValues.decodeIfPresent(BatchDeleteObject.self, forKey: .deleteObject)
        deleteObject = deleteObjectDecoded
        let addFacetToObjectDecoded = try containerValues.decodeIfPresent(BatchAddFacetToObject.self, forKey: .addFacetToObject)
        addFacetToObject = addFacetToObjectDecoded
        let removeFacetFromObjectDecoded = try containerValues.decodeIfPresent(BatchRemoveFacetFromObject.self, forKey: .removeFacetFromObject)
        removeFacetFromObject = removeFacetFromObjectDecoded
        let attachPolicyDecoded = try containerValues.decodeIfPresent(BatchAttachPolicy.self, forKey: .attachPolicy)
        attachPolicy = attachPolicyDecoded
        let detachPolicyDecoded = try containerValues.decodeIfPresent(BatchDetachPolicy.self, forKey: .detachPolicy)
        detachPolicy = detachPolicyDecoded
        let createIndexDecoded = try containerValues.decodeIfPresent(BatchCreateIndex.self, forKey: .createIndex)
        createIndex = createIndexDecoded
        let attachToIndexDecoded = try containerValues.decodeIfPresent(BatchAttachToIndex.self, forKey: .attachToIndex)
        attachToIndex = attachToIndexDecoded
        let detachFromIndexDecoded = try containerValues.decodeIfPresent(BatchDetachFromIndex.self, forKey: .detachFromIndex)
        detachFromIndex = detachFromIndexDecoded
        let attachTypedLinkDecoded = try containerValues.decodeIfPresent(BatchAttachTypedLink.self, forKey: .attachTypedLink)
        attachTypedLink = attachTypedLinkDecoded
        let detachTypedLinkDecoded = try containerValues.decodeIfPresent(BatchDetachTypedLink.self, forKey: .detachTypedLink)
        detachTypedLink = detachTypedLinkDecoded
        let updateLinkAttributesDecoded = try containerValues.decodeIfPresent(BatchUpdateLinkAttributes.self, forKey: .updateLinkAttributes)
        updateLinkAttributes = updateLinkAttributesDecoded
    }
}

extension BatchWriteOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchWriteOperation(addFacetToObject: \(String(describing: addFacetToObject)), attachObject: \(String(describing: attachObject)), attachPolicy: \(String(describing: attachPolicy)), attachToIndex: \(String(describing: attachToIndex)), attachTypedLink: \(String(describing: attachTypedLink)), createIndex: \(String(describing: createIndex)), createObject: \(String(describing: createObject)), deleteObject: \(String(describing: deleteObject)), detachFromIndex: \(String(describing: detachFromIndex)), detachObject: \(String(describing: detachObject)), detachPolicy: \(String(describing: detachPolicy)), detachTypedLink: \(String(describing: detachTypedLink)), removeFacetFromObject: \(String(describing: removeFacetFromObject)), updateLinkAttributes: \(String(describing: updateLinkAttributes)), updateObjectAttributes: \(String(describing: updateObjectAttributes)))"}
}

/// <p>Represents the output of a <code>BatchWrite</code> operation. </p>
public struct BatchWriteOperation: Equatable {
    /// <p>A batch operation that adds a facet to an object.</p>
    public let addFacetToObject: BatchAddFacetToObject?
    /// <p>Attaches an object to a <a>Directory</a>.</p>
    public let attachObject: BatchAttachObject?
    /// <p>Attaches a policy object to a regular object. An object can have a limited number of attached
    ///        policies.</p>
    public let attachPolicy: BatchAttachPolicy?
    /// <p>Attaches the specified object to the specified index.</p>
    public let attachToIndex: BatchAttachToIndex?
    /// <p>Attaches a typed link to a specified source and target object. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
    public let attachTypedLink: BatchAttachTypedLink?
    /// <p>Creates an index object. See <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/indexing_search.htm">Indexing and search</a> for more information.</p>
    public let createIndex: BatchCreateIndex?
    /// <p>Creates an object.</p>
    public let createObject: BatchCreateObject?
    /// <p>Deletes an object in a <a>Directory</a>.</p>
    public let deleteObject: BatchDeleteObject?
    /// <p>Detaches the specified object from the specified index.</p>
    public let detachFromIndex: BatchDetachFromIndex?
    /// <p>Detaches an object from a <a>Directory</a>.</p>
    public let detachObject: BatchDetachObject?
    /// <p>Detaches a policy from a <a>Directory</a>.</p>
    public let detachPolicy: BatchDetachPolicy?
    /// <p>Detaches a typed link from a specified source and target object. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
    public let detachTypedLink: BatchDetachTypedLink?
    /// <p>A batch operation that removes a facet from an object.</p>
    public let removeFacetFromObject: BatchRemoveFacetFromObject?
    /// <p>Updates a given object's attributes.</p>
    public let updateLinkAttributes: BatchUpdateLinkAttributes?
    /// <p>Updates a given object's attributes.</p>
    public let updateObjectAttributes: BatchUpdateObjectAttributes?

    public init (
        addFacetToObject: BatchAddFacetToObject? = nil,
        attachObject: BatchAttachObject? = nil,
        attachPolicy: BatchAttachPolicy? = nil,
        attachToIndex: BatchAttachToIndex? = nil,
        attachTypedLink: BatchAttachTypedLink? = nil,
        createIndex: BatchCreateIndex? = nil,
        createObject: BatchCreateObject? = nil,
        deleteObject: BatchDeleteObject? = nil,
        detachFromIndex: BatchDetachFromIndex? = nil,
        detachObject: BatchDetachObject? = nil,
        detachPolicy: BatchDetachPolicy? = nil,
        detachTypedLink: BatchDetachTypedLink? = nil,
        removeFacetFromObject: BatchRemoveFacetFromObject? = nil,
        updateLinkAttributes: BatchUpdateLinkAttributes? = nil,
        updateObjectAttributes: BatchUpdateObjectAttributes? = nil
    )
    {
        self.addFacetToObject = addFacetToObject
        self.attachObject = attachObject
        self.attachPolicy = attachPolicy
        self.attachToIndex = attachToIndex
        self.attachTypedLink = attachTypedLink
        self.createIndex = createIndex
        self.createObject = createObject
        self.deleteObject = deleteObject
        self.detachFromIndex = detachFromIndex
        self.detachObject = detachObject
        self.detachPolicy = detachPolicy
        self.detachTypedLink = detachTypedLink
        self.removeFacetFromObject = removeFacetFromObject
        self.updateLinkAttributes = updateLinkAttributes
        self.updateObjectAttributes = updateObjectAttributes
    }
}

extension BatchWriteOperationResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addFacetToObject = "AddFacetToObject"
        case attachObject = "AttachObject"
        case attachPolicy = "AttachPolicy"
        case attachToIndex = "AttachToIndex"
        case attachTypedLink = "AttachTypedLink"
        case createIndex = "CreateIndex"
        case createObject = "CreateObject"
        case deleteObject = "DeleteObject"
        case detachFromIndex = "DetachFromIndex"
        case detachObject = "DetachObject"
        case detachPolicy = "DetachPolicy"
        case detachTypedLink = "DetachTypedLink"
        case removeFacetFromObject = "RemoveFacetFromObject"
        case updateLinkAttributes = "UpdateLinkAttributes"
        case updateObjectAttributes = "UpdateObjectAttributes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addFacetToObject = addFacetToObject {
            try encodeContainer.encode(addFacetToObject, forKey: .addFacetToObject)
        }
        if let attachObject = attachObject {
            try encodeContainer.encode(attachObject, forKey: .attachObject)
        }
        if let attachPolicy = attachPolicy {
            try encodeContainer.encode(attachPolicy, forKey: .attachPolicy)
        }
        if let attachToIndex = attachToIndex {
            try encodeContainer.encode(attachToIndex, forKey: .attachToIndex)
        }
        if let attachTypedLink = attachTypedLink {
            try encodeContainer.encode(attachTypedLink, forKey: .attachTypedLink)
        }
        if let createIndex = createIndex {
            try encodeContainer.encode(createIndex, forKey: .createIndex)
        }
        if let createObject = createObject {
            try encodeContainer.encode(createObject, forKey: .createObject)
        }
        if let deleteObject = deleteObject {
            try encodeContainer.encode(deleteObject, forKey: .deleteObject)
        }
        if let detachFromIndex = detachFromIndex {
            try encodeContainer.encode(detachFromIndex, forKey: .detachFromIndex)
        }
        if let detachObject = detachObject {
            try encodeContainer.encode(detachObject, forKey: .detachObject)
        }
        if let detachPolicy = detachPolicy {
            try encodeContainer.encode(detachPolicy, forKey: .detachPolicy)
        }
        if let detachTypedLink = detachTypedLink {
            try encodeContainer.encode(detachTypedLink, forKey: .detachTypedLink)
        }
        if let removeFacetFromObject = removeFacetFromObject {
            try encodeContainer.encode(removeFacetFromObject, forKey: .removeFacetFromObject)
        }
        if let updateLinkAttributes = updateLinkAttributes {
            try encodeContainer.encode(updateLinkAttributes, forKey: .updateLinkAttributes)
        }
        if let updateObjectAttributes = updateObjectAttributes {
            try encodeContainer.encode(updateObjectAttributes, forKey: .updateObjectAttributes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createObjectDecoded = try containerValues.decodeIfPresent(BatchCreateObjectResponse.self, forKey: .createObject)
        createObject = createObjectDecoded
        let attachObjectDecoded = try containerValues.decodeIfPresent(BatchAttachObjectResponse.self, forKey: .attachObject)
        attachObject = attachObjectDecoded
        let detachObjectDecoded = try containerValues.decodeIfPresent(BatchDetachObjectResponse.self, forKey: .detachObject)
        detachObject = detachObjectDecoded
        let updateObjectAttributesDecoded = try containerValues.decodeIfPresent(BatchUpdateObjectAttributesResponse.self, forKey: .updateObjectAttributes)
        updateObjectAttributes = updateObjectAttributesDecoded
        let deleteObjectDecoded = try containerValues.decodeIfPresent(BatchDeleteObjectResponse.self, forKey: .deleteObject)
        deleteObject = deleteObjectDecoded
        let addFacetToObjectDecoded = try containerValues.decodeIfPresent(BatchAddFacetToObjectResponse.self, forKey: .addFacetToObject)
        addFacetToObject = addFacetToObjectDecoded
        let removeFacetFromObjectDecoded = try containerValues.decodeIfPresent(BatchRemoveFacetFromObjectResponse.self, forKey: .removeFacetFromObject)
        removeFacetFromObject = removeFacetFromObjectDecoded
        let attachPolicyDecoded = try containerValues.decodeIfPresent(BatchAttachPolicyResponse.self, forKey: .attachPolicy)
        attachPolicy = attachPolicyDecoded
        let detachPolicyDecoded = try containerValues.decodeIfPresent(BatchDetachPolicyResponse.self, forKey: .detachPolicy)
        detachPolicy = detachPolicyDecoded
        let createIndexDecoded = try containerValues.decodeIfPresent(BatchCreateIndexResponse.self, forKey: .createIndex)
        createIndex = createIndexDecoded
        let attachToIndexDecoded = try containerValues.decodeIfPresent(BatchAttachToIndexResponse.self, forKey: .attachToIndex)
        attachToIndex = attachToIndexDecoded
        let detachFromIndexDecoded = try containerValues.decodeIfPresent(BatchDetachFromIndexResponse.self, forKey: .detachFromIndex)
        detachFromIndex = detachFromIndexDecoded
        let attachTypedLinkDecoded = try containerValues.decodeIfPresent(BatchAttachTypedLinkResponse.self, forKey: .attachTypedLink)
        attachTypedLink = attachTypedLinkDecoded
        let detachTypedLinkDecoded = try containerValues.decodeIfPresent(BatchDetachTypedLinkResponse.self, forKey: .detachTypedLink)
        detachTypedLink = detachTypedLinkDecoded
        let updateLinkAttributesDecoded = try containerValues.decodeIfPresent(BatchUpdateLinkAttributesResponse.self, forKey: .updateLinkAttributes)
        updateLinkAttributes = updateLinkAttributesDecoded
    }
}

extension BatchWriteOperationResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchWriteOperationResponse(addFacetToObject: \(String(describing: addFacetToObject)), attachObject: \(String(describing: attachObject)), attachPolicy: \(String(describing: attachPolicy)), attachToIndex: \(String(describing: attachToIndex)), attachTypedLink: \(String(describing: attachTypedLink)), createIndex: \(String(describing: createIndex)), createObject: \(String(describing: createObject)), deleteObject: \(String(describing: deleteObject)), detachFromIndex: \(String(describing: detachFromIndex)), detachObject: \(String(describing: detachObject)), detachPolicy: \(String(describing: detachPolicy)), detachTypedLink: \(String(describing: detachTypedLink)), removeFacetFromObject: \(String(describing: removeFacetFromObject)), updateLinkAttributes: \(String(describing: updateLinkAttributes)), updateObjectAttributes: \(String(describing: updateObjectAttributes)))"}
}

/// <p>Represents the output of a <code>BatchWrite</code> response operation.</p>
public struct BatchWriteOperationResponse: Equatable {
    /// <p>The result of an add facet to object batch operation.</p>
    public let addFacetToObject: BatchAddFacetToObjectResponse?
    /// <p>Attaches an object to a <a>Directory</a>.</p>
    public let attachObject: BatchAttachObjectResponse?
    /// <p>Attaches a policy object to a regular object. An object can have a limited number of attached
    ///        policies.</p>
    public let attachPolicy: BatchAttachPolicyResponse?
    /// <p>Attaches the specified object to the specified index.</p>
    public let attachToIndex: BatchAttachToIndexResponse?
    /// <p>Attaches a typed link to a specified source and target object. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
    public let attachTypedLink: BatchAttachTypedLinkResponse?
    /// <p>Creates an index object. See <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/indexing_search.htm">Indexing and search</a> for more information.</p>
    public let createIndex: BatchCreateIndexResponse?
    /// <p>Creates an object in a <a>Directory</a>.</p>
    public let createObject: BatchCreateObjectResponse?
    /// <p>Deletes an object in a <a>Directory</a>.</p>
    public let deleteObject: BatchDeleteObjectResponse?
    /// <p>Detaches the specified object from the specified index.</p>
    public let detachFromIndex: BatchDetachFromIndexResponse?
    /// <p>Detaches an object from a <a>Directory</a>.</p>
    public let detachObject: BatchDetachObjectResponse?
    /// <p>Detaches a policy from a <a>Directory</a>.</p>
    public let detachPolicy: BatchDetachPolicyResponse?
    /// <p>Detaches a typed link from a specified source and target object. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
    public let detachTypedLink: BatchDetachTypedLinkResponse?
    /// <p>The result of a batch remove facet from object operation.</p>
    public let removeFacetFromObject: BatchRemoveFacetFromObjectResponse?
    /// <p>Represents the output of a <code>BatchWrite</code> response operation.</p>
    public let updateLinkAttributes: BatchUpdateLinkAttributesResponse?
    /// <p>Updates a given object’s attributes.</p>
    public let updateObjectAttributes: BatchUpdateObjectAttributesResponse?

    public init (
        addFacetToObject: BatchAddFacetToObjectResponse? = nil,
        attachObject: BatchAttachObjectResponse? = nil,
        attachPolicy: BatchAttachPolicyResponse? = nil,
        attachToIndex: BatchAttachToIndexResponse? = nil,
        attachTypedLink: BatchAttachTypedLinkResponse? = nil,
        createIndex: BatchCreateIndexResponse? = nil,
        createObject: BatchCreateObjectResponse? = nil,
        deleteObject: BatchDeleteObjectResponse? = nil,
        detachFromIndex: BatchDetachFromIndexResponse? = nil,
        detachObject: BatchDetachObjectResponse? = nil,
        detachPolicy: BatchDetachPolicyResponse? = nil,
        detachTypedLink: BatchDetachTypedLinkResponse? = nil,
        removeFacetFromObject: BatchRemoveFacetFromObjectResponse? = nil,
        updateLinkAttributes: BatchUpdateLinkAttributesResponse? = nil,
        updateObjectAttributes: BatchUpdateObjectAttributesResponse? = nil
    )
    {
        self.addFacetToObject = addFacetToObject
        self.attachObject = attachObject
        self.attachPolicy = attachPolicy
        self.attachToIndex = attachToIndex
        self.attachTypedLink = attachTypedLink
        self.createIndex = createIndex
        self.createObject = createObject
        self.deleteObject = deleteObject
        self.detachFromIndex = detachFromIndex
        self.detachObject = detachObject
        self.detachPolicy = detachPolicy
        self.detachTypedLink = detachTypedLink
        self.removeFacetFromObject = removeFacetFromObject
        self.updateLinkAttributes = updateLinkAttributes
        self.updateObjectAttributes = updateObjectAttributes
    }
}

extension BatchWriteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchWriteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BatchWriteException" : self = .batchWriteException(try BatchWriteException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchWriteOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case batchWriteException(BatchWriteException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchWriteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchWriteOutputResponse(responses: \(String(describing: responses)))"}
}

extension BatchWriteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchWriteOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.responses = output.responses
        } else {
            self.responses = nil
        }
    }
}

public struct BatchWriteOutputResponse: Equatable {
    /// <p>A list of all the responses for each batch write.</p>
    public let responses: [BatchWriteOperationResponse]?

    public init (
        responses: [BatchWriteOperationResponse]? = nil
    )
    {
        self.responses = responses
    }
}

struct BatchWriteOutputResponseBody: Equatable {
    public let responses: [BatchWriteOperationResponse]?
}

extension BatchWriteOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case responses = "Responses"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responsesContainer = try containerValues.decodeIfPresent([BatchWriteOperationResponse?].self, forKey: .responses)
        var responsesDecoded0:[BatchWriteOperationResponse]? = nil
        if let responsesContainer = responsesContainer {
            responsesDecoded0 = [BatchWriteOperationResponse]()
            for structure0 in responsesContainer {
                if let structure0 = structure0 {
                    responsesDecoded0?.append(structure0)
                }
            }
        }
        responses = responsesDecoded0
    }
}

extension CannotListParentOfRootException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CannotListParentOfRootException(message: \(String(describing: message)))"}
}

extension CannotListParentOfRootException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CannotListParentOfRootExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cannot list the parents of a <a>Directory</a> root.</p>
public struct CannotListParentOfRootException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CannotListParentOfRootExceptionBody: Equatable {
    public let message: String?
}

extension CannotListParentOfRootExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ConsistencyLevel {
    case eventual
    case serializable
    case sdkUnknown(String)
}

extension ConsistencyLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConsistencyLevel] {
        return [
            .eventual,
            .serializable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .eventual: return "EVENTUAL"
        case .serializable: return "SERIALIZABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConsistencyLevel(rawValue: rawValue) ?? ConsistencyLevel.sdkUnknown(rawValue)
    }
}

public struct CreateDirectoryInputBodyMiddleware: Middleware {
    public let id: String = "CreateDirectoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDirectoryInput>
    public typealias MOutput = OperationOutput<CreateDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDirectoryOutputError>
}

extension CreateDirectoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDirectoryInput(name: \(String(describing: name)), schemaArn: \(String(describing: schemaArn)))"}
}

extension CreateDirectoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateDirectoryInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDirectoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDirectoryInput>
    public typealias MOutput = OperationOutput<CreateDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDirectoryOutputError>
}

public struct CreateDirectoryInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDirectoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDirectoryInput>
    public typealias MOutput = OperationOutput<CreateDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDirectoryOutputError>
}

public struct CreateDirectoryInput: Equatable {
    /// <p>The name of the <a>Directory</a>. Should be unique per account, per
    ///       region.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the published schema that will be copied into the
    ///       data <a>Directory</a>. For more information, see <a>arns</a>.</p>
    public let schemaArn: String?

    public init (
        name: String? = nil,
        schemaArn: String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct CreateDirectoryInputBody: Equatable {
    public let name: String?
}

extension CreateDirectoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateDirectoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDirectoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryAlreadyExistsException" : self = .directoryAlreadyExistsException(try DirectoryAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDirectoryOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryAlreadyExistsException(DirectoryAlreadyExistsException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDirectoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDirectoryOutputResponse(appliedSchemaArn: \(String(describing: appliedSchemaArn)), directoryArn: \(String(describing: directoryArn)), name: \(String(describing: name)), objectIdentifier: \(String(describing: objectIdentifier)))"}
}

extension CreateDirectoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDirectoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appliedSchemaArn = output.appliedSchemaArn
            self.directoryArn = output.directoryArn
            self.name = output.name
            self.objectIdentifier = output.objectIdentifier
        } else {
            self.appliedSchemaArn = nil
            self.directoryArn = nil
            self.name = nil
            self.objectIdentifier = nil
        }
    }
}

public struct CreateDirectoryOutputResponse: Equatable {
    /// <p>The ARN of the published schema in the <a>Directory</a>. Once a published
    ///       schema is copied into the directory, it has its own ARN, which is referred to applied schema
    ///       ARN. For more information, see <a>arns</a>.</p>
    public let appliedSchemaArn: String?
    /// <p>The ARN that is associated with the <a>Directory</a>. For more information,
    ///       see <a>arns</a>.</p>
    public let directoryArn: String?
    /// <p>The name of the <a>Directory</a>.</p>
    public let name: String?
    /// <p>The root object node of the created directory.</p>
    public let objectIdentifier: String?

    public init (
        appliedSchemaArn: String? = nil,
        directoryArn: String? = nil,
        name: String? = nil,
        objectIdentifier: String? = nil
    )
    {
        self.appliedSchemaArn = appliedSchemaArn
        self.directoryArn = directoryArn
        self.name = name
        self.objectIdentifier = objectIdentifier
    }
}

struct CreateDirectoryOutputResponseBody: Equatable {
    public let directoryArn: String?
    public let name: String?
    public let objectIdentifier: String?
    public let appliedSchemaArn: String?
}

extension CreateDirectoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appliedSchemaArn = "AppliedSchemaArn"
        case directoryArn = "DirectoryArn"
        case name = "Name"
        case objectIdentifier = "ObjectIdentifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
        let appliedSchemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appliedSchemaArn)
        appliedSchemaArn = appliedSchemaArnDecoded
    }
}

public struct CreateFacetInputBodyMiddleware: Middleware {
    public let id: String = "CreateFacetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFacetInput>
    public typealias MOutput = OperationOutput<CreateFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFacetOutputError>
}

extension CreateFacetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFacetInput(attributes: \(String(describing: attributes)), facetStyle: \(String(describing: facetStyle)), name: \(String(describing: name)), objectType: \(String(describing: objectType)), schemaArn: \(String(describing: schemaArn)))"}
}

extension CreateFacetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case facetStyle = "FacetStyle"
        case name = "Name"
        case objectType = "ObjectType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for facetattributelist0 in attributes {
                try attributesContainer.encode(facetattributelist0)
            }
        }
        if let facetStyle = facetStyle {
            try encodeContainer.encode(facetStyle.rawValue, forKey: .facetStyle)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let objectType = objectType {
            try encodeContainer.encode(objectType.rawValue, forKey: .objectType)
        }
    }
}

public struct CreateFacetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFacetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFacetInput>
    public typealias MOutput = OperationOutput<CreateFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFacetOutputError>
}

public struct CreateFacetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFacetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFacetInput>
    public typealias MOutput = OperationOutput<CreateFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFacetOutputError>
}

public struct CreateFacetInput: Equatable {
    /// <p>The attributes that are associated with the <a>Facet</a>.</p>
    public let attributes: [FacetAttribute]?
    /// <p>There are two different styles that you can define on any given facet, <code>Static</code> and <code>Dynamic</code>. For static facets, all attributes must be defined in the schema. For dynamic facets, attributes can be defined during data plane operations.</p>
    public let facetStyle: FacetStyle?
    /// <p>The name of the <a>Facet</a>, which is unique for a given schema.</p>
    public let name: String?
    /// <p>Specifies whether a given object created from this facet is of type node, leaf node,
    ///       policy or index.</p>
    ///          <ul>
    ///             <li>
    ///                <p>Node: Can have multiple children but one parent.</p>
    ///             </li>
    ///          </ul>
    ///          <ul>
    ///             <li>
    ///                <p>Leaf node: Cannot have children but can have multiple parents.</p>
    ///             </li>
    ///          </ul>
    ///          <ul>
    ///             <li>
    ///                <p>Policy: Allows you to store a policy document and policy type. For more
    ///         information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies">Policies</a>.</p>
    ///             </li>
    ///          </ul>
    ///          <ul>
    ///             <li>
    ///                <p>Index: Can be created with the Index API.</p>
    ///             </li>
    ///          </ul>
    public let objectType: ObjectType?
    /// <p>The schema ARN in which the new <a>Facet</a> will be created. For more
    ///       information, see <a>arns</a>.</p>
    public let schemaArn: String?

    public init (
        attributes: [FacetAttribute]? = nil,
        facetStyle: FacetStyle? = nil,
        name: String? = nil,
        objectType: ObjectType? = nil,
        schemaArn: String? = nil
    )
    {
        self.attributes = attributes
        self.facetStyle = facetStyle
        self.name = name
        self.objectType = objectType
        self.schemaArn = schemaArn
    }
}

struct CreateFacetInputBody: Equatable {
    public let name: String?
    public let attributes: [FacetAttribute]?
    public let objectType: ObjectType?
    public let facetStyle: FacetStyle?
}

extension CreateFacetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case facetStyle = "FacetStyle"
        case name = "Name"
        case objectType = "ObjectType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([FacetAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[FacetAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [FacetAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let objectTypeDecoded = try containerValues.decodeIfPresent(ObjectType.self, forKey: .objectType)
        objectType = objectTypeDecoded
        let facetStyleDecoded = try containerValues.decodeIfPresent(FacetStyle.self, forKey: .facetStyle)
        facetStyle = facetStyleDecoded
    }
}

extension CreateFacetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFacetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetAlreadyExistsException" : self = .facetAlreadyExistsException(try FacetAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRuleException" : self = .invalidRuleException(try InvalidRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFacetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case facetAlreadyExistsException(FacetAlreadyExistsException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidRuleException(InvalidRuleException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFacetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFacetOutputResponse()"}
}

extension CreateFacetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateFacetOutputResponse: Equatable {

    public init() {}
}

struct CreateFacetOutputResponseBody: Equatable {
}

extension CreateFacetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateIndexInputBodyMiddleware: Middleware {
    public let id: String = "CreateIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIndexInput>
    public typealias MOutput = OperationOutput<CreateIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIndexOutputError>
}

extension CreateIndexInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIndexInput(directoryArn: \(String(describing: directoryArn)), isUnique: \(String(describing: isUnique)), linkName: \(String(describing: linkName)), orderedIndexedAttributeList: \(String(describing: orderedIndexedAttributeList)), parentReference: \(String(describing: parentReference)))"}
}

extension CreateIndexInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isUnique = "IsUnique"
        case linkName = "LinkName"
        case orderedIndexedAttributeList = "OrderedIndexedAttributeList"
        case parentReference = "ParentReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isUnique != false {
            try encodeContainer.encode(isUnique, forKey: .isUnique)
        }
        if let linkName = linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let orderedIndexedAttributeList = orderedIndexedAttributeList {
            var orderedIndexedAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orderedIndexedAttributeList)
            for attributekeylist0 in orderedIndexedAttributeList {
                try orderedIndexedAttributeListContainer.encode(attributekeylist0)
            }
        }
        if let parentReference = parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
    }
}

public struct CreateIndexInputHeadersMiddleware: Middleware {
    public let id: String = "CreateIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIndexInput>
    public typealias MOutput = OperationOutput<CreateIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIndexOutputError>
}

public struct CreateIndexInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIndexInput>
    public typealias MOutput = OperationOutput<CreateIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIndexOutputError>
}

public struct CreateIndexInput: Equatable {
    /// <p>The ARN of the directory where the index should be created.</p>
    public let directoryArn: String?
    /// <p>Indicates whether the attribute that is being indexed has unique values or
    ///       not.</p>
    public let isUnique: Bool
    /// <p>The name of the link between the parent object and the index object.</p>
    public let linkName: String?
    /// <p>Specifies the attributes that should be indexed on. Currently only a single attribute
    ///       is supported.</p>
    public let orderedIndexedAttributeList: [AttributeKey]?
    /// <p>A reference to the parent object that contains the index object.</p>
    public let parentReference: ObjectReference?

    public init (
        directoryArn: String? = nil,
        isUnique: Bool = false,
        linkName: String? = nil,
        orderedIndexedAttributeList: [AttributeKey]? = nil,
        parentReference: ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.isUnique = isUnique
        self.linkName = linkName
        self.orderedIndexedAttributeList = orderedIndexedAttributeList
        self.parentReference = parentReference
    }
}

struct CreateIndexInputBody: Equatable {
    public let orderedIndexedAttributeList: [AttributeKey]?
    public let isUnique: Bool
    public let parentReference: ObjectReference?
    public let linkName: String?
}

extension CreateIndexInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isUnique = "IsUnique"
        case linkName = "LinkName"
        case orderedIndexedAttributeList = "OrderedIndexedAttributeList"
        case parentReference = "ParentReference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderedIndexedAttributeListContainer = try containerValues.decodeIfPresent([AttributeKey?].self, forKey: .orderedIndexedAttributeList)
        var orderedIndexedAttributeListDecoded0:[AttributeKey]? = nil
        if let orderedIndexedAttributeListContainer = orderedIndexedAttributeListContainer {
            orderedIndexedAttributeListDecoded0 = [AttributeKey]()
            for structure0 in orderedIndexedAttributeListContainer {
                if let structure0 = structure0 {
                    orderedIndexedAttributeListDecoded0?.append(structure0)
                }
            }
        }
        orderedIndexedAttributeList = orderedIndexedAttributeListDecoded0
        let isUniqueDecoded = try containerValues.decode(Bool.self, forKey: .isUnique)
        isUnique = isUniqueDecoded
        let parentReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkName)
        linkName = linkNameDecoded
    }
}

extension CreateIndexOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIndexOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LinkNameAlreadyInUseException" : self = .linkNameAlreadyInUseException(try LinkNameAlreadyInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedIndexTypeException" : self = .unsupportedIndexTypeException(try UnsupportedIndexTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIndexOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case linkNameAlreadyInUseException(LinkNameAlreadyInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case unsupportedIndexTypeException(UnsupportedIndexTypeException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIndexOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIndexOutputResponse(objectIdentifier: \(String(describing: objectIdentifier)))"}
}

extension CreateIndexOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateIndexOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.objectIdentifier = output.objectIdentifier
        } else {
            self.objectIdentifier = nil
        }
    }
}

public struct CreateIndexOutputResponse: Equatable {
    /// <p>The <code>ObjectIdentifier</code> of the index created by this operation.</p>
    public let objectIdentifier: String?

    public init (
        objectIdentifier: String? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
    }
}

struct CreateIndexOutputResponseBody: Equatable {
    public let objectIdentifier: String?
}

extension CreateIndexOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case objectIdentifier = "ObjectIdentifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

public struct CreateObjectInputBodyMiddleware: Middleware {
    public let id: String = "CreateObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateObjectInput>
    public typealias MOutput = OperationOutput<CreateObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateObjectOutputError>
}

extension CreateObjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateObjectInput(directoryArn: \(String(describing: directoryArn)), linkName: \(String(describing: linkName)), objectAttributeList: \(String(describing: objectAttributeList)), parentReference: \(String(describing: parentReference)), schemaFacets: \(String(describing: schemaFacets)))"}
}

extension CreateObjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case linkName = "LinkName"
        case objectAttributeList = "ObjectAttributeList"
        case parentReference = "ParentReference"
        case schemaFacets = "SchemaFacets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linkName = linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let objectAttributeList = objectAttributeList {
            var objectAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectAttributeList)
            for attributekeyandvaluelist0 in objectAttributeList {
                try objectAttributeListContainer.encode(attributekeyandvaluelist0)
            }
        }
        if let parentReference = parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
        if let schemaFacets = schemaFacets {
            var schemaFacetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schemaFacets)
            for schemafacetlist0 in schemaFacets {
                try schemaFacetsContainer.encode(schemafacetlist0)
            }
        }
    }
}

public struct CreateObjectInputHeadersMiddleware: Middleware {
    public let id: String = "CreateObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateObjectInput>
    public typealias MOutput = OperationOutput<CreateObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateObjectOutputError>
}

public struct CreateObjectInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateObjectInput>
    public typealias MOutput = OperationOutput<CreateObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateObjectOutputError>
}

public struct CreateObjectInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that is associated with the <a>Directory</a>
    ///       in which the object will be created. For more information, see <a>arns</a>.</p>
    public let directoryArn: String?
    /// <p>The name of link that is used to attach this object to a parent.</p>
    public let linkName: String?
    /// <p>The attribute map whose attribute ARN contains the key and attribute value as the map
    ///       value.</p>
    public let objectAttributeList: [AttributeKeyAndValue]?
    /// <p>If specified, the parent reference to which this object will be attached.</p>
    public let parentReference: ObjectReference?
    /// <p>A list of schema facets to be associated with the object. Do not provide minor version components. See <a>SchemaFacet</a> for details.</p>
    public let schemaFacets: [SchemaFacet]?

    public init (
        directoryArn: String? = nil,
        linkName: String? = nil,
        objectAttributeList: [AttributeKeyAndValue]? = nil,
        parentReference: ObjectReference? = nil,
        schemaFacets: [SchemaFacet]? = nil
    )
    {
        self.directoryArn = directoryArn
        self.linkName = linkName
        self.objectAttributeList = objectAttributeList
        self.parentReference = parentReference
        self.schemaFacets = schemaFacets
    }
}

struct CreateObjectInputBody: Equatable {
    public let schemaFacets: [SchemaFacet]?
    public let objectAttributeList: [AttributeKeyAndValue]?
    public let parentReference: ObjectReference?
    public let linkName: String?
}

extension CreateObjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case linkName = "LinkName"
        case objectAttributeList = "ObjectAttributeList"
        case parentReference = "ParentReference"
        case schemaFacets = "SchemaFacets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetsContainer = try containerValues.decodeIfPresent([SchemaFacet?].self, forKey: .schemaFacets)
        var schemaFacetsDecoded0:[SchemaFacet]? = nil
        if let schemaFacetsContainer = schemaFacetsContainer {
            schemaFacetsDecoded0 = [SchemaFacet]()
            for structure0 in schemaFacetsContainer {
                if let structure0 = structure0 {
                    schemaFacetsDecoded0?.append(structure0)
                }
            }
        }
        schemaFacets = schemaFacetsDecoded0
        let objectAttributeListContainer = try containerValues.decodeIfPresent([AttributeKeyAndValue?].self, forKey: .objectAttributeList)
        var objectAttributeListDecoded0:[AttributeKeyAndValue]? = nil
        if let objectAttributeListContainer = objectAttributeListContainer {
            objectAttributeListDecoded0 = [AttributeKeyAndValue]()
            for structure0 in objectAttributeListContainer {
                if let structure0 = structure0 {
                    objectAttributeListDecoded0?.append(structure0)
                }
            }
        }
        objectAttributeList = objectAttributeListDecoded0
        let parentReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkName)
        linkName = linkNameDecoded
    }
}

extension CreateObjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateObjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LinkNameAlreadyInUseException" : self = .linkNameAlreadyInUseException(try LinkNameAlreadyInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedIndexTypeException" : self = .unsupportedIndexTypeException(try UnsupportedIndexTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateObjectOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case linkNameAlreadyInUseException(LinkNameAlreadyInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case unsupportedIndexTypeException(UnsupportedIndexTypeException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateObjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateObjectOutputResponse(objectIdentifier: \(String(describing: objectIdentifier)))"}
}

extension CreateObjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateObjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.objectIdentifier = output.objectIdentifier
        } else {
            self.objectIdentifier = nil
        }
    }
}

public struct CreateObjectOutputResponse: Equatable {
    /// <p>The identifier that is associated with the object.</p>
    public let objectIdentifier: String?

    public init (
        objectIdentifier: String? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
    }
}

struct CreateObjectOutputResponseBody: Equatable {
    public let objectIdentifier: String?
}

extension CreateObjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case objectIdentifier = "ObjectIdentifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

public struct CreateSchemaInputBodyMiddleware: Middleware {
    public let id: String = "CreateSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSchemaInput>
    public typealias MOutput = OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSchemaOutputError>
}

extension CreateSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSchemaInput(name: \(String(describing: name)))"}
}

extension CreateSchemaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSchemaInput>
    public typealias MOutput = OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSchemaOutputError>
}

public struct CreateSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSchemaInput>
    public typealias MOutput = OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSchemaOutputError>
}

public struct CreateSchemaInput: Equatable {
    /// <p>The name that is associated with the schema. This is unique to each account and in each
    ///       region.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct CreateSchemaInputBody: Equatable {
    public let name: String?
}

extension CreateSchemaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SchemaAlreadyExistsException" : self = .schemaAlreadyExistsException(try SchemaAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSchemaOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case retryableConflictException(RetryableConflictException)
    case schemaAlreadyExistsException(SchemaAlreadyExistsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSchemaOutputResponse(schemaArn: \(String(describing: schemaArn)))"}
}

extension CreateSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.schemaArn = output.schemaArn
        } else {
            self.schemaArn = nil
        }
    }
}

public struct CreateSchemaOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) that is associated with the schema. For more
    ///       information, see <a>arns</a>.</p>
    public let schemaArn: String?

    public init (
        schemaArn: String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct CreateSchemaOutputResponseBody: Equatable {
    public let schemaArn: String?
}

extension CreateSchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case schemaArn = "SchemaArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

public struct CreateTypedLinkFacetInputBodyMiddleware: Middleware {
    public let id: String = "CreateTypedLinkFacetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTypedLinkFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTypedLinkFacetInput>
    public typealias MOutput = OperationOutput<CreateTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTypedLinkFacetOutputError>
}

extension CreateTypedLinkFacetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTypedLinkFacetInput(facet: \(String(describing: facet)), schemaArn: \(String(describing: schemaArn)))"}
}

extension CreateTypedLinkFacetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case facet = "Facet"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facet = facet {
            try encodeContainer.encode(facet, forKey: .facet)
        }
    }
}

public struct CreateTypedLinkFacetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTypedLinkFacetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTypedLinkFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTypedLinkFacetInput>
    public typealias MOutput = OperationOutput<CreateTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTypedLinkFacetOutputError>
}

public struct CreateTypedLinkFacetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTypedLinkFacetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTypedLinkFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTypedLinkFacetInput>
    public typealias MOutput = OperationOutput<CreateTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTypedLinkFacetOutputError>
}

public struct CreateTypedLinkFacetInput: Equatable {
    /// <p>
    ///             <a>Facet</a> structure that is associated with the typed link
    ///       facet.</p>
    public let facet: TypedLinkFacet?
    /// <p>The Amazon Resource Name (ARN) that is associated with the schema. For more
    ///       information, see <a>arns</a>.</p>
    public let schemaArn: String?

    public init (
        facet: TypedLinkFacet? = nil,
        schemaArn: String? = nil
    )
    {
        self.facet = facet
        self.schemaArn = schemaArn
    }
}

struct CreateTypedLinkFacetInputBody: Equatable {
    public let facet: TypedLinkFacet?
}

extension CreateTypedLinkFacetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case facet = "Facet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let facetDecoded = try containerValues.decodeIfPresent(TypedLinkFacet.self, forKey: .facet)
        facet = facetDecoded
    }
}

extension CreateTypedLinkFacetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTypedLinkFacetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetAlreadyExistsException" : self = .facetAlreadyExistsException(try FacetAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRuleException" : self = .invalidRuleException(try InvalidRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTypedLinkFacetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case facetAlreadyExistsException(FacetAlreadyExistsException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidRuleException(InvalidRuleException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTypedLinkFacetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTypedLinkFacetOutputResponse()"}
}

extension CreateTypedLinkFacetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateTypedLinkFacetOutputResponse: Equatable {

    public init() {}
}

struct CreateTypedLinkFacetOutputResponseBody: Equatable {
}

extension CreateTypedLinkFacetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDirectoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDirectoryInput(directoryArn: \(String(describing: directoryArn)))"}
}

extension DeleteDirectoryInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDirectoryInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDirectoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDirectoryInput>
    public typealias MOutput = OperationOutput<DeleteDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDirectoryOutputError>
}

public struct DeleteDirectoryInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDirectoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDirectoryInput>
    public typealias MOutput = OperationOutput<DeleteDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDirectoryOutputError>
}

public struct DeleteDirectoryInput: Equatable {
    /// <p>The ARN of the directory to delete.</p>
    public let directoryArn: String?

    public init (
        directoryArn: String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct DeleteDirectoryInputBody: Equatable {
}

extension DeleteDirectoryInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDirectoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDirectoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryDeletedException" : self = .directoryDeletedException(try DirectoryDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotDisabledException" : self = .directoryNotDisabledException(try DirectoryNotDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDirectoryOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryDeletedException(DirectoryDeletedException)
    case directoryNotDisabledException(DirectoryNotDisabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDirectoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDirectoryOutputResponse(directoryArn: \(String(describing: directoryArn)))"}
}

extension DeleteDirectoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDirectoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.directoryArn = output.directoryArn
        } else {
            self.directoryArn = nil
        }
    }
}

public struct DeleteDirectoryOutputResponse: Equatable {
    /// <p>The ARN of the deleted directory.</p>
    public let directoryArn: String?

    public init (
        directoryArn: String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct DeleteDirectoryOutputResponseBody: Equatable {
    public let directoryArn: String?
}

extension DeleteDirectoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryArn = "DirectoryArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
    }
}

public struct DeleteFacetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteFacetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFacetInput>
    public typealias MOutput = OperationOutput<DeleteFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFacetOutputError>
}

extension DeleteFacetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFacetInput(name: \(String(describing: name)), schemaArn: \(String(describing: schemaArn)))"}
}

extension DeleteFacetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteFacetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFacetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFacetInput>
    public typealias MOutput = OperationOutput<DeleteFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFacetOutputError>
}

public struct DeleteFacetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFacetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFacetInput>
    public typealias MOutput = OperationOutput<DeleteFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFacetOutputError>
}

public struct DeleteFacetInput: Equatable {
    /// <p>The name of the facet to delete.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) that is associated with the <a>Facet</a>.
    ///       For more information, see <a>arns</a>.</p>
    public let schemaArn: String?

    public init (
        name: String? = nil,
        schemaArn: String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct DeleteFacetInputBody: Equatable {
    public let name: String?
}

extension DeleteFacetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteFacetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFacetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetInUseException" : self = .facetInUseException(try FacetInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetNotFoundException" : self = .facetNotFoundException(try FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFacetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case facetInUseException(FacetInUseException)
    case facetNotFoundException(FacetNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFacetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFacetOutputResponse()"}
}

extension DeleteFacetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFacetOutputResponse: Equatable {

    public init() {}
}

struct DeleteFacetOutputResponseBody: Equatable {
}

extension DeleteFacetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteObjectInputBodyMiddleware: Middleware {
    public let id: String = "DeleteObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteObjectInput>
    public typealias MOutput = OperationOutput<DeleteObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteObjectOutputError>
}

extension DeleteObjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteObjectInput(directoryArn: \(String(describing: directoryArn)), objectReference: \(String(describing: objectReference)))"}
}

extension DeleteObjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct DeleteObjectInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteObjectInput>
    public typealias MOutput = OperationOutput<DeleteObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteObjectOutputError>
}

public struct DeleteObjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteObjectInput>
    public typealias MOutput = OperationOutput<DeleteObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteObjectOutputError>
}

public struct DeleteObjectInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that is associated with the <a>Directory</a>
    ///       where the object resides. For more information, see <a>arns</a>.</p>
    public let directoryArn: String?
    /// <p>A reference that identifies the object.</p>
    public let objectReference: ObjectReference?

    public init (
        directoryArn: String? = nil,
        objectReference: ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.objectReference = objectReference
    }
}

struct DeleteObjectInputBody: Equatable {
    public let objectReference: ObjectReference?
}

extension DeleteObjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension DeleteObjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteObjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ObjectNotDetachedException" : self = .objectNotDetachedException(try ObjectNotDetachedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteObjectOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case objectNotDetachedException(ObjectNotDetachedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteObjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteObjectOutputResponse()"}
}

extension DeleteObjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteObjectOutputResponse: Equatable {

    public init() {}
}

struct DeleteObjectOutputResponseBody: Equatable {
}

extension DeleteObjectOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSchemaInput(schemaArn: \(String(describing: schemaArn)))"}
}

extension DeleteSchemaInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSchemaInput>
    public typealias MOutput = OperationOutput<DeleteSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSchemaOutputError>
}

public struct DeleteSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSchemaInput>
    public typealias MOutput = OperationOutput<DeleteSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSchemaOutputError>
}

public struct DeleteSchemaInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the development schema. For more information, see
    ///         <a>arns</a>.</p>
    public let schemaArn: String?

    public init (
        schemaArn: String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct DeleteSchemaInputBody: Equatable {
}

extension DeleteSchemaInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StillContainsLinksException" : self = .stillContainsLinksException(try StillContainsLinksException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSchemaOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case stillContainsLinksException(StillContainsLinksException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSchemaOutputResponse(schemaArn: \(String(describing: schemaArn)))"}
}

extension DeleteSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteSchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.schemaArn = output.schemaArn
        } else {
            self.schemaArn = nil
        }
    }
}

public struct DeleteSchemaOutputResponse: Equatable {
    /// <p>The input ARN that is returned as part of the response. For more information, see
    ///         <a>arns</a>.</p>
    public let schemaArn: String?

    public init (
        schemaArn: String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct DeleteSchemaOutputResponseBody: Equatable {
    public let schemaArn: String?
}

extension DeleteSchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case schemaArn = "SchemaArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

public struct DeleteTypedLinkFacetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTypedLinkFacetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTypedLinkFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTypedLinkFacetInput>
    public typealias MOutput = OperationOutput<DeleteTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTypedLinkFacetOutputError>
}

extension DeleteTypedLinkFacetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTypedLinkFacetInput(name: \(String(describing: name)), schemaArn: \(String(describing: schemaArn)))"}
}

extension DeleteTypedLinkFacetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteTypedLinkFacetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTypedLinkFacetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTypedLinkFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTypedLinkFacetInput>
    public typealias MOutput = OperationOutput<DeleteTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTypedLinkFacetOutputError>
}

public struct DeleteTypedLinkFacetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTypedLinkFacetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTypedLinkFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTypedLinkFacetInput>
    public typealias MOutput = OperationOutput<DeleteTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTypedLinkFacetOutputError>
}

public struct DeleteTypedLinkFacetInput: Equatable {
    /// <p>The unique name of the typed link facet.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) that is associated with the schema. For more
    ///       information, see <a>arns</a>.</p>
    public let schemaArn: String?

    public init (
        name: String? = nil,
        schemaArn: String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct DeleteTypedLinkFacetInputBody: Equatable {
    public let name: String?
}

extension DeleteTypedLinkFacetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteTypedLinkFacetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTypedLinkFacetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetNotFoundException" : self = .facetNotFoundException(try FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTypedLinkFacetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case facetNotFoundException(FacetNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTypedLinkFacetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTypedLinkFacetOutputResponse()"}
}

extension DeleteTypedLinkFacetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTypedLinkFacetOutputResponse: Equatable {

    public init() {}
}

struct DeleteTypedLinkFacetOutputResponseBody: Equatable {
}

extension DeleteTypedLinkFacetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DetachFromIndexInputBodyMiddleware: Middleware {
    public let id: String = "DetachFromIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachFromIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachFromIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachFromIndexInput>
    public typealias MOutput = OperationOutput<DetachFromIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachFromIndexOutputError>
}

extension DetachFromIndexInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachFromIndexInput(directoryArn: \(String(describing: directoryArn)), indexReference: \(String(describing: indexReference)), targetReference: \(String(describing: targetReference)))"}
}

extension DetachFromIndexInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexReference = "IndexReference"
        case targetReference = "TargetReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexReference = indexReference {
            try encodeContainer.encode(indexReference, forKey: .indexReference)
        }
        if let targetReference = targetReference {
            try encodeContainer.encode(targetReference, forKey: .targetReference)
        }
    }
}

public struct DetachFromIndexInputHeadersMiddleware: Middleware {
    public let id: String = "DetachFromIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachFromIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachFromIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachFromIndexInput>
    public typealias MOutput = OperationOutput<DetachFromIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachFromIndexOutputError>
}

public struct DetachFromIndexInputQueryItemMiddleware: Middleware {
    public let id: String = "DetachFromIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachFromIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachFromIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachFromIndexInput>
    public typealias MOutput = OperationOutput<DetachFromIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachFromIndexOutputError>
}

public struct DetachFromIndexInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the directory the index and object exist
    ///       in.</p>
    public let directoryArn: String?
    /// <p>A reference to the index object.</p>
    public let indexReference: ObjectReference?
    /// <p>A reference to the object being detached from the index.</p>
    public let targetReference: ObjectReference?

    public init (
        directoryArn: String? = nil,
        indexReference: ObjectReference? = nil,
        targetReference: ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.indexReference = indexReference
        self.targetReference = targetReference
    }
}

struct DetachFromIndexInputBody: Equatable {
    public let indexReference: ObjectReference?
    public let targetReference: ObjectReference?
}

extension DetachFromIndexInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexReference = "IndexReference"
        case targetReference = "TargetReference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .indexReference)
        indexReference = indexReferenceDecoded
        let targetReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .targetReference)
        targetReference = targetReferenceDecoded
    }
}

extension DetachFromIndexOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetachFromIndexOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotIndexException" : self = .notIndexException(try NotIndexException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ObjectAlreadyDetachedException" : self = .objectAlreadyDetachedException(try ObjectAlreadyDetachedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachFromIndexOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case notIndexException(NotIndexException)
    case objectAlreadyDetachedException(ObjectAlreadyDetachedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachFromIndexOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachFromIndexOutputResponse(detachedObjectIdentifier: \(String(describing: detachedObjectIdentifier)))"}
}

extension DetachFromIndexOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DetachFromIndexOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.detachedObjectIdentifier = output.detachedObjectIdentifier
        } else {
            self.detachedObjectIdentifier = nil
        }
    }
}

public struct DetachFromIndexOutputResponse: Equatable {
    /// <p>The <code>ObjectIdentifier</code> of the object that was detached from the index.</p>
    public let detachedObjectIdentifier: String?

    public init (
        detachedObjectIdentifier: String? = nil
    )
    {
        self.detachedObjectIdentifier = detachedObjectIdentifier
    }
}

struct DetachFromIndexOutputResponseBody: Equatable {
    public let detachedObjectIdentifier: String?
}

extension DetachFromIndexOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detachedObjectIdentifier = "DetachedObjectIdentifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detachedObjectIdentifier)
        detachedObjectIdentifier = detachedObjectIdentifierDecoded
    }
}

public struct DetachObjectInputBodyMiddleware: Middleware {
    public let id: String = "DetachObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachObjectInput>
    public typealias MOutput = OperationOutput<DetachObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachObjectOutputError>
}

extension DetachObjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachObjectInput(directoryArn: \(String(describing: directoryArn)), linkName: \(String(describing: linkName)), parentReference: \(String(describing: parentReference)))"}
}

extension DetachObjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case linkName = "LinkName"
        case parentReference = "ParentReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linkName = linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let parentReference = parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
    }
}

public struct DetachObjectInputHeadersMiddleware: Middleware {
    public let id: String = "DetachObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachObjectInput>
    public typealias MOutput = OperationOutput<DetachObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachObjectOutputError>
}

public struct DetachObjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DetachObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachObjectInput>
    public typealias MOutput = OperationOutput<DetachObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachObjectOutputError>
}

public struct DetachObjectInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that is associated with the <a>Directory</a>
    ///       where objects reside. For more information, see <a>arns</a>.</p>
    public let directoryArn: String?
    /// <p>The link name associated with the object that needs to be detached.</p>
    public let linkName: String?
    /// <p>The parent reference from which the object with the specified link name is
    ///       detached.</p>
    public let parentReference: ObjectReference?

    public init (
        directoryArn: String? = nil,
        linkName: String? = nil,
        parentReference: ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.linkName = linkName
        self.parentReference = parentReference
    }
}

struct DetachObjectInputBody: Equatable {
    public let parentReference: ObjectReference?
    public let linkName: String?
}

extension DetachObjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case linkName = "LinkName"
        case parentReference = "ParentReference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkName)
        linkName = linkNameDecoded
    }
}

extension DetachObjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetachObjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotNodeException" : self = .notNodeException(try NotNodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachObjectOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case notNodeException(NotNodeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachObjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachObjectOutputResponse(detachedObjectIdentifier: \(String(describing: detachedObjectIdentifier)))"}
}

extension DetachObjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DetachObjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.detachedObjectIdentifier = output.detachedObjectIdentifier
        } else {
            self.detachedObjectIdentifier = nil
        }
    }
}

public struct DetachObjectOutputResponse: Equatable {
    /// <p>The <code>ObjectIdentifier</code> that was detached from the object.</p>
    public let detachedObjectIdentifier: String?

    public init (
        detachedObjectIdentifier: String? = nil
    )
    {
        self.detachedObjectIdentifier = detachedObjectIdentifier
    }
}

struct DetachObjectOutputResponseBody: Equatable {
    public let detachedObjectIdentifier: String?
}

extension DetachObjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detachedObjectIdentifier = "DetachedObjectIdentifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detachedObjectIdentifier)
        detachedObjectIdentifier = detachedObjectIdentifierDecoded
    }
}

public struct DetachPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DetachPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachPolicyInput>
    public typealias MOutput = OperationOutput<DetachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachPolicyOutputError>
}

extension DetachPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachPolicyInput(directoryArn: \(String(describing: directoryArn)), objectReference: \(String(describing: objectReference)), policyReference: \(String(describing: policyReference)))"}
}

extension DetachPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectReference = "ObjectReference"
        case policyReference = "PolicyReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let policyReference = policyReference {
            try encodeContainer.encode(policyReference, forKey: .policyReference)
        }
    }
}

public struct DetachPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DetachPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachPolicyInput>
    public typealias MOutput = OperationOutput<DetachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachPolicyOutputError>
}

public struct DetachPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DetachPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachPolicyInput>
    public typealias MOutput = OperationOutput<DetachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachPolicyOutputError>
}

public struct DetachPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that is associated with the <a>Directory</a>
    ///       where both objects reside. For more information, see <a>arns</a>.</p>
    public let directoryArn: String?
    /// <p>Reference that identifies the object whose policy object will be detached.</p>
    public let objectReference: ObjectReference?
    /// <p>Reference that identifies the policy object.</p>
    public let policyReference: ObjectReference?

    public init (
        directoryArn: String? = nil,
        objectReference: ObjectReference? = nil,
        policyReference: ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.objectReference = objectReference
        self.policyReference = policyReference
    }
}

struct DetachPolicyInputBody: Equatable {
    public let policyReference: ObjectReference?
    public let objectReference: ObjectReference?
}

extension DetachPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case objectReference = "ObjectReference"
        case policyReference = "PolicyReference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .policyReference)
        policyReference = policyReferenceDecoded
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension DetachPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetachPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotPolicyException" : self = .notPolicyException(try NotPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachPolicyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case notPolicyException(NotPolicyException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachPolicyOutputResponse()"}
}

extension DetachPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DetachPolicyOutputResponse: Equatable {

    public init() {}
}

struct DetachPolicyOutputResponseBody: Equatable {
}

extension DetachPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DetachTypedLinkInputBodyMiddleware: Middleware {
    public let id: String = "DetachTypedLinkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachTypedLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachTypedLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachTypedLinkInput>
    public typealias MOutput = OperationOutput<DetachTypedLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachTypedLinkOutputError>
}

extension DetachTypedLinkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachTypedLinkInput(directoryArn: \(String(describing: directoryArn)), typedLinkSpecifier: \(String(describing: typedLinkSpecifier)))"}
}

extension DetachTypedLinkInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let typedLinkSpecifier = typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }
}

public struct DetachTypedLinkInputHeadersMiddleware: Middleware {
    public let id: String = "DetachTypedLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachTypedLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachTypedLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachTypedLinkInput>
    public typealias MOutput = OperationOutput<DetachTypedLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachTypedLinkOutputError>
}

public struct DetachTypedLinkInputQueryItemMiddleware: Middleware {
    public let id: String = "DetachTypedLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachTypedLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachTypedLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachTypedLinkInput>
    public typealias MOutput = OperationOutput<DetachTypedLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachTypedLinkOutputError>
}

public struct DetachTypedLinkInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the directory where you want to detach the typed
    ///       link.</p>
    public let directoryArn: String?
    /// <p>Used to accept a typed link specifier as input.</p>
    public let typedLinkSpecifier: TypedLinkSpecifier?

    public init (
        directoryArn: String? = nil,
        typedLinkSpecifier: TypedLinkSpecifier? = nil
    )
    {
        self.directoryArn = directoryArn
        self.typedLinkSpecifier = typedLinkSpecifier
    }
}

struct DetachTypedLinkInputBody: Equatable {
    public let typedLinkSpecifier: TypedLinkSpecifier?
}

extension DetachTypedLinkInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
    }
}

extension DetachTypedLinkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetachTypedLinkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachTypedLinkOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachTypedLinkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachTypedLinkOutputResponse()"}
}

extension DetachTypedLinkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DetachTypedLinkOutputResponse: Equatable {

    public init() {}
}

struct DetachTypedLinkOutputResponseBody: Equatable {
}

extension DetachTypedLinkOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Directory: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime = "CreationDateTime"
        case directoryArn = "DirectoryArn"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let directoryArn = directoryArn {
            try encodeContainer.encode(directoryArn, forKey: .directoryArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let directoryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DirectoryState.self, forKey: .state)
        state = stateDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

extension Directory: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Directory(creationDateTime: \(String(describing: creationDateTime)), directoryArn: \(String(describing: directoryArn)), name: \(String(describing: name)), state: \(String(describing: state)))"}
}

/// <p>Directory structure that includes the directory name and directory ARN.</p>
public struct Directory: Equatable {
    /// <p>The date and time when the directory was created.</p>
    public let creationDateTime: Date?
    /// <p>The Amazon Resource Name (ARN) that is associated with the directory. For more
    ///       information, see <a>arns</a>.</p>
    public let directoryArn: String?
    /// <p>The name of the directory.</p>
    public let name: String?
    /// <p>The state of the directory. Can be either <code>Enabled</code>, <code>Disabled</code>, or <code>Deleted</code>.</p>
    public let state: DirectoryState?

    public init (
        creationDateTime: Date? = nil,
        directoryArn: String? = nil,
        name: String? = nil,
        state: DirectoryState? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.directoryArn = directoryArn
        self.name = name
        self.state = state
    }
}

extension DirectoryAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryAlreadyExistsException(message: \(String(describing: message)))"}
}

extension DirectoryAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DirectoryAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a <a>Directory</a> could not be created due to a naming
///       conflict. Choose a different name and try again.</p>
public struct DirectoryAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DirectoryAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension DirectoryAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DirectoryDeletedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryDeletedException(message: \(String(describing: message)))"}
}

extension DirectoryDeletedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DirectoryDeletedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A directory that has been deleted and to which access has been attempted. Note: The
///       requested resource will eventually cease to exist.</p>
public struct DirectoryDeletedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DirectoryDeletedExceptionBody: Equatable {
    public let message: String?
}

extension DirectoryDeletedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DirectoryNotDisabledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryNotDisabledException(message: \(String(describing: message)))"}
}

extension DirectoryNotDisabledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DirectoryNotDisabledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An operation can only operate on a disabled directory.</p>
public struct DirectoryNotDisabledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DirectoryNotDisabledExceptionBody: Equatable {
    public let message: String?
}

extension DirectoryNotDisabledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DirectoryNotEnabledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryNotEnabledException(message: \(String(describing: message)))"}
}

extension DirectoryNotEnabledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DirectoryNotEnabledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Operations are only permitted on enabled directories.</p>
public struct DirectoryNotEnabledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DirectoryNotEnabledExceptionBody: Equatable {
    public let message: String?
}

extension DirectoryNotEnabledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum DirectoryState {
    case deleted
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension DirectoryState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DirectoryState] {
        return [
            .deleted,
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleted: return "DELETED"
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DirectoryState(rawValue: rawValue) ?? DirectoryState.sdkUnknown(rawValue)
    }
}

extension DisableDirectoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableDirectoryInput(directoryArn: \(String(describing: directoryArn)))"}
}

extension DisableDirectoryInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisableDirectoryInputHeadersMiddleware: Middleware {
    public let id: String = "DisableDirectoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableDirectoryInput>
    public typealias MOutput = OperationOutput<DisableDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableDirectoryOutputError>
}

public struct DisableDirectoryInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableDirectoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableDirectoryInput>
    public typealias MOutput = OperationOutput<DisableDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableDirectoryOutputError>
}

public struct DisableDirectoryInput: Equatable {
    /// <p>The ARN of the directory to disable.</p>
    public let directoryArn: String?

    public init (
        directoryArn: String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct DisableDirectoryInputBody: Equatable {
}

extension DisableDirectoryInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisableDirectoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableDirectoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryDeletedException" : self = .directoryDeletedException(try DirectoryDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableDirectoryOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryDeletedException(DirectoryDeletedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableDirectoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableDirectoryOutputResponse(directoryArn: \(String(describing: directoryArn)))"}
}

extension DisableDirectoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisableDirectoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.directoryArn = output.directoryArn
        } else {
            self.directoryArn = nil
        }
    }
}

public struct DisableDirectoryOutputResponse: Equatable {
    /// <p>The ARN of the directory that has been disabled.</p>
    public let directoryArn: String?

    public init (
        directoryArn: String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct DisableDirectoryOutputResponseBody: Equatable {
    public let directoryArn: String?
}

extension DisableDirectoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryArn = "DirectoryArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
    }
}

extension EnableDirectoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableDirectoryInput(directoryArn: \(String(describing: directoryArn)))"}
}

extension EnableDirectoryInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct EnableDirectoryInputHeadersMiddleware: Middleware {
    public let id: String = "EnableDirectoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableDirectoryInput>
    public typealias MOutput = OperationOutput<EnableDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableDirectoryOutputError>
}

public struct EnableDirectoryInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableDirectoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableDirectoryInput>
    public typealias MOutput = OperationOutput<EnableDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableDirectoryOutputError>
}

public struct EnableDirectoryInput: Equatable {
    /// <p>The ARN of the directory to enable.</p>
    public let directoryArn: String?

    public init (
        directoryArn: String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct EnableDirectoryInputBody: Equatable {
}

extension EnableDirectoryInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension EnableDirectoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableDirectoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryDeletedException" : self = .directoryDeletedException(try DirectoryDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableDirectoryOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryDeletedException(DirectoryDeletedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableDirectoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableDirectoryOutputResponse(directoryArn: \(String(describing: directoryArn)))"}
}

extension EnableDirectoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EnableDirectoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.directoryArn = output.directoryArn
        } else {
            self.directoryArn = nil
        }
    }
}

public struct EnableDirectoryOutputResponse: Equatable {
    /// <p>The ARN of the enabled directory.</p>
    public let directoryArn: String?

    public init (
        directoryArn: String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct EnableDirectoryOutputResponseBody: Equatable {
    public let directoryArn: String?
}

extension EnableDirectoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryArn = "DirectoryArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
    }
}

extension Facet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case facetStyle = "FacetStyle"
        case name = "Name"
        case objectType = "ObjectType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facetStyle = facetStyle {
            try encodeContainer.encode(facetStyle.rawValue, forKey: .facetStyle)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let objectType = objectType {
            try encodeContainer.encode(objectType.rawValue, forKey: .objectType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let objectTypeDecoded = try containerValues.decodeIfPresent(ObjectType.self, forKey: .objectType)
        objectType = objectTypeDecoded
        let facetStyleDecoded = try containerValues.decodeIfPresent(FacetStyle.self, forKey: .facetStyle)
        facetStyle = facetStyleDecoded
    }
}

extension Facet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Facet(facetStyle: \(String(describing: facetStyle)), name: \(String(describing: name)), objectType: \(String(describing: objectType)))"}
}

/// <p>A structure that contains <code>Name</code>, <code>ARN</code>, <code>Attributes</code>, <code>
///                <a>Rule</a>s</code>, and
///       <code>ObjectTypes</code>. See <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_whatarefacets.html">Facets</a> for more information.</p>
public struct Facet: Equatable {
    /// <p>There are two different styles that you can define on any given facet, <code>Static</code> and <code>Dynamic</code>. For static facets, all attributes must be defined in the schema. For dynamic facets, attributes can be defined during data plane operations.</p>
    public let facetStyle: FacetStyle?
    /// <p>The name of the <a>Facet</a>.</p>
    public let name: String?
    /// <p>The object type that is associated with the facet. See <a>CreateFacetRequest$ObjectType</a> for more details.</p>
    public let objectType: ObjectType?

    public init (
        facetStyle: FacetStyle? = nil,
        name: String? = nil,
        objectType: ObjectType? = nil
    )
    {
        self.facetStyle = facetStyle
        self.name = name
        self.objectType = objectType
    }
}

extension FacetAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FacetAlreadyExistsException(message: \(String(describing: message)))"}
}

extension FacetAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FacetAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A facet with the same name already exists.</p>
public struct FacetAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FacetAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension FacetAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FacetAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeDefinition = "AttributeDefinition"
        case attributeReference = "AttributeReference"
        case name = "Name"
        case requiredBehavior = "RequiredBehavior"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeDefinition = attributeDefinition {
            try encodeContainer.encode(attributeDefinition, forKey: .attributeDefinition)
        }
        if let attributeReference = attributeReference {
            try encodeContainer.encode(attributeReference, forKey: .attributeReference)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requiredBehavior = requiredBehavior {
            try encodeContainer.encode(requiredBehavior.rawValue, forKey: .requiredBehavior)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let attributeDefinitionDecoded = try containerValues.decodeIfPresent(FacetAttributeDefinition.self, forKey: .attributeDefinition)
        attributeDefinition = attributeDefinitionDecoded
        let attributeReferenceDecoded = try containerValues.decodeIfPresent(FacetAttributeReference.self, forKey: .attributeReference)
        attributeReference = attributeReferenceDecoded
        let requiredBehaviorDecoded = try containerValues.decodeIfPresent(RequiredAttributeBehavior.self, forKey: .requiredBehavior)
        requiredBehavior = requiredBehaviorDecoded
    }
}

extension FacetAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FacetAttribute(attributeDefinition: \(String(describing: attributeDefinition)), attributeReference: \(String(describing: attributeReference)), name: \(String(describing: name)), requiredBehavior: \(String(describing: requiredBehavior)))"}
}

/// <p>An attribute that is associated with the <a>Facet</a>.</p>
public struct FacetAttribute: Equatable {
    /// <p>A facet attribute consists of either a definition or a reference. This structure
    ///       contains the attribute definition. See <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_attributereferences.html">Attribute References</a> for more information.</p>
    public let attributeDefinition: FacetAttributeDefinition?
    /// <p>An attribute reference that is associated with the attribute. See <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_attributereferences.html">Attribute References</a> for more information.</p>
    public let attributeReference: FacetAttributeReference?
    /// <p>The name of the facet attribute.</p>
    public let name: String?
    /// <p>The required behavior of the <code>FacetAttribute</code>.</p>
    public let requiredBehavior: RequiredAttributeBehavior?

    public init (
        attributeDefinition: FacetAttributeDefinition? = nil,
        attributeReference: FacetAttributeReference? = nil,
        name: String? = nil,
        requiredBehavior: RequiredAttributeBehavior? = nil
    )
    {
        self.attributeDefinition = attributeDefinition
        self.attributeReference = attributeReference
        self.name = name
        self.requiredBehavior = requiredBehavior
    }
}

extension FacetAttributeDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValue = "DefaultValue"
        case isImmutable = "IsImmutable"
        case rules = "Rules"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if isImmutable != false {
            try encodeContainer.encode(isImmutable, forKey: .isImmutable)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .rules)
            for (dictKey0, rulemap0) in rules {
                try rulesContainer.encode(rulemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(FacetAttributeType.self, forKey: .type)
        type = typeDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(TypedAttributeValue.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let isImmutableDecoded = try containerValues.decode(Bool.self, forKey: .isImmutable)
        isImmutable = isImmutableDecoded
        let rulesContainer = try containerValues.decodeIfPresent([String: Rule?].self, forKey: .rules)
        var rulesDecoded0: [String:Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [String:Rule]()
            for (key0, rule0) in rulesContainer {
                if let rule0 = rule0 {
                    rulesDecoded0?[key0] = rule0
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension FacetAttributeDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FacetAttributeDefinition(defaultValue: \(String(describing: defaultValue)), isImmutable: \(String(describing: isImmutable)), rules: \(String(describing: rules)), type: \(String(describing: type)))"}
}

/// <p>A facet attribute definition. See <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_attributereferences.html">Attribute References</a> for more information.</p>
public struct FacetAttributeDefinition: Equatable {
    /// <p>The default value of the attribute (if configured).</p>
    public let defaultValue: TypedAttributeValue?
    /// <p>Whether the attribute is mutable or not.</p>
    public let isImmutable: Bool
    /// <p>Validation rules attached to the attribute definition.</p>
    public let rules: [String:Rule]?
    /// <p>The type of the attribute.</p>
    public let type: FacetAttributeType?

    public init (
        defaultValue: TypedAttributeValue? = nil,
        isImmutable: Bool = false,
        rules: [String:Rule]? = nil,
        type: FacetAttributeType? = nil
    )
    {
        self.defaultValue = defaultValue
        self.isImmutable = isImmutable
        self.rules = rules
        self.type = type
    }
}

extension FacetAttributeReference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case targetAttributeName = "TargetAttributeName"
        case targetFacetName = "TargetFacetName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetAttributeName = targetAttributeName {
            try encodeContainer.encode(targetAttributeName, forKey: .targetAttributeName)
        }
        if let targetFacetName = targetFacetName {
            try encodeContainer.encode(targetFacetName, forKey: .targetFacetName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetFacetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetFacetName)
        targetFacetName = targetFacetNameDecoded
        let targetAttributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetAttributeName)
        targetAttributeName = targetAttributeNameDecoded
    }
}

extension FacetAttributeReference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FacetAttributeReference(targetAttributeName: \(String(describing: targetAttributeName)), targetFacetName: \(String(describing: targetFacetName)))"}
}

/// <p>The facet attribute reference that specifies the attribute definition that contains the
///       attribute facet name and attribute name.</p>
public struct FacetAttributeReference: Equatable {
    /// <p>The target attribute name that is associated with the facet reference. See <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_attributereferences.html">Attribute References</a> for more information.</p>
    public let targetAttributeName: String?
    /// <p>The target facet name that is associated with the facet reference. See <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_attributereferences.html">Attribute References</a> for more information.</p>
    public let targetFacetName: String?

    public init (
        targetAttributeName: String? = nil,
        targetFacetName: String? = nil
    )
    {
        self.targetAttributeName = targetAttributeName
        self.targetFacetName = targetFacetName
    }
}

public enum FacetAttributeType {
    case binary
    case boolean
    case datetime
    case number
    case string
    case variant
    case sdkUnknown(String)
}

extension FacetAttributeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FacetAttributeType] {
        return [
            .binary,
            .boolean,
            .datetime,
            .number,
            .string,
            .variant,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .binary: return "BINARY"
        case .boolean: return "BOOLEAN"
        case .datetime: return "DATETIME"
        case .number: return "NUMBER"
        case .string: return "STRING"
        case .variant: return "VARIANT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FacetAttributeType(rawValue: rawValue) ?? FacetAttributeType.sdkUnknown(rawValue)
    }
}

extension FacetAttributeUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case attribute = "Attribute"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let attribute = attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(FacetAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let actionDecoded = try containerValues.decodeIfPresent(UpdateActionType.self, forKey: .action)
        action = actionDecoded
    }
}

extension FacetAttributeUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FacetAttributeUpdate(action: \(String(describing: action)), attribute: \(String(describing: attribute)))"}
}

/// <p>A structure that contains information used to update an attribute.</p>
public struct FacetAttributeUpdate: Equatable {
    /// <p>The action to perform when updating the attribute.</p>
    public let action: UpdateActionType?
    /// <p>The attribute to update.</p>
    public let attribute: FacetAttribute?

    public init (
        action: UpdateActionType? = nil,
        attribute: FacetAttribute? = nil
    )
    {
        self.action = action
        self.attribute = attribute
    }
}

extension FacetInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FacetInUseException(message: \(String(describing: message)))"}
}

extension FacetInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FacetInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Occurs when deleting a facet that contains an attribute that is a target to an
///       attribute reference in a different facet.</p>
public struct FacetInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FacetInUseExceptionBody: Equatable {
    public let message: String?
}

extension FacetInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FacetNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FacetNotFoundException(message: \(String(describing: message)))"}
}

extension FacetNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FacetNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified <a>Facet</a> could not be found.</p>
public struct FacetNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FacetNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension FacetNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum FacetStyle {
    case `dynamic`
    case `static`
    case sdkUnknown(String)
}

extension FacetStyle : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FacetStyle] {
        return [
            .dynamic,
            .static,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dynamic: return "DYNAMIC"
        case .static: return "STATIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FacetStyle(rawValue: rawValue) ?? FacetStyle.sdkUnknown(rawValue)
    }
}

extension FacetValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FacetValidationException(message: \(String(describing: message)))"}
}

extension FacetValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FacetValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The <a>Facet</a> that you provided was not well formed or could not be
///       validated with the schema.</p>
public struct FacetValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FacetValidationExceptionBody: Equatable {
    public let message: String?
}

extension FacetValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetAppliedSchemaVersionInputBodyMiddleware: Middleware {
    public let id: String = "GetAppliedSchemaVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppliedSchemaVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppliedSchemaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppliedSchemaVersionInput>
    public typealias MOutput = OperationOutput<GetAppliedSchemaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppliedSchemaVersionOutputError>
}

extension GetAppliedSchemaVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAppliedSchemaVersionInput(schemaArn: \(String(describing: schemaArn)))"}
}

extension GetAppliedSchemaVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case schemaArn = "SchemaArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

public struct GetAppliedSchemaVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetAppliedSchemaVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppliedSchemaVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppliedSchemaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppliedSchemaVersionInput>
    public typealias MOutput = OperationOutput<GetAppliedSchemaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppliedSchemaVersionOutputError>
}

public struct GetAppliedSchemaVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAppliedSchemaVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppliedSchemaVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppliedSchemaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppliedSchemaVersionInput>
    public typealias MOutput = OperationOutput<GetAppliedSchemaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppliedSchemaVersionOutputError>
}

public struct GetAppliedSchemaVersionInput: Equatable {
    /// <p>The ARN of the applied schema.</p>
    public let schemaArn: String?

    public init (
        schemaArn: String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct GetAppliedSchemaVersionInputBody: Equatable {
    public let schemaArn: String?
}

extension GetAppliedSchemaVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case schemaArn = "SchemaArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

extension GetAppliedSchemaVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAppliedSchemaVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAppliedSchemaVersionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAppliedSchemaVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAppliedSchemaVersionOutputResponse(appliedSchemaArn: \(String(describing: appliedSchemaArn)))"}
}

extension GetAppliedSchemaVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAppliedSchemaVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appliedSchemaArn = output.appliedSchemaArn
        } else {
            self.appliedSchemaArn = nil
        }
    }
}

public struct GetAppliedSchemaVersionOutputResponse: Equatable {
    /// <p>Current applied schema ARN, including the minor version in use if one was provided.</p>
    public let appliedSchemaArn: String?

    public init (
        appliedSchemaArn: String? = nil
    )
    {
        self.appliedSchemaArn = appliedSchemaArn
    }
}

struct GetAppliedSchemaVersionOutputResponseBody: Equatable {
    public let appliedSchemaArn: String?
}

extension GetAppliedSchemaVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appliedSchemaArn = "AppliedSchemaArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appliedSchemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appliedSchemaArn)
        appliedSchemaArn = appliedSchemaArnDecoded
    }
}

extension GetDirectoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDirectoryInput(directoryArn: \(String(describing: directoryArn)))"}
}

extension GetDirectoryInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDirectoryInputHeadersMiddleware: Middleware {
    public let id: String = "GetDirectoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDirectoryInput>
    public typealias MOutput = OperationOutput<GetDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDirectoryOutputError>
}

public struct GetDirectoryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDirectoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDirectoryInput>
    public typealias MOutput = OperationOutput<GetDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDirectoryOutputError>
}

public struct GetDirectoryInput: Equatable {
    /// <p>The ARN of the directory.</p>
    public let directoryArn: String?

    public init (
        directoryArn: String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct GetDirectoryInputBody: Equatable {
}

extension GetDirectoryInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDirectoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDirectoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDirectoryOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDirectoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDirectoryOutputResponse(directory: \(String(describing: directory)))"}
}

extension GetDirectoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDirectoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.directory = output.directory
        } else {
            self.directory = nil
        }
    }
}

public struct GetDirectoryOutputResponse: Equatable {
    /// <p>Metadata about the directory.</p>
    public let directory: Directory?

    public init (
        directory: Directory? = nil
    )
    {
        self.directory = directory
    }
}

struct GetDirectoryOutputResponseBody: Equatable {
    public let directory: Directory?
}

extension GetDirectoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directory = "Directory"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryDecoded = try containerValues.decodeIfPresent(Directory.self, forKey: .directory)
        directory = directoryDecoded
    }
}

public struct GetFacetInputBodyMiddleware: Middleware {
    public let id: String = "GetFacetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFacetInput>
    public typealias MOutput = OperationOutput<GetFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFacetOutputError>
}

extension GetFacetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFacetInput(name: \(String(describing: name)), schemaArn: \(String(describing: schemaArn)))"}
}

extension GetFacetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetFacetInputHeadersMiddleware: Middleware {
    public let id: String = "GetFacetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFacetInput>
    public typealias MOutput = OperationOutput<GetFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFacetOutputError>
}

public struct GetFacetInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFacetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFacetInput>
    public typealias MOutput = OperationOutput<GetFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFacetOutputError>
}

public struct GetFacetInput: Equatable {
    /// <p>The name of the facet to retrieve.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) that is associated with the <a>Facet</a>.
    ///       For more information, see <a>arns</a>.</p>
    public let schemaArn: String?

    public init (
        name: String? = nil,
        schemaArn: String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct GetFacetInputBody: Equatable {
    public let name: String?
}

extension GetFacetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetFacetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFacetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetNotFoundException" : self = .facetNotFoundException(try FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFacetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case facetNotFoundException(FacetNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFacetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFacetOutputResponse(facet: \(String(describing: facet)))"}
}

extension GetFacetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFacetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.facet = output.facet
        } else {
            self.facet = nil
        }
    }
}

public struct GetFacetOutputResponse: Equatable {
    /// <p>The <a>Facet</a> structure that is associated with the facet.</p>
    public let facet: Facet?

    public init (
        facet: Facet? = nil
    )
    {
        self.facet = facet
    }
}

struct GetFacetOutputResponseBody: Equatable {
    public let facet: Facet?
}

extension GetFacetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case facet = "Facet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let facetDecoded = try containerValues.decodeIfPresent(Facet.self, forKey: .facet)
        facet = facetDecoded
    }
}

public struct GetLinkAttributesInputBodyMiddleware: Middleware {
    public let id: String = "GetLinkAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLinkAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLinkAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLinkAttributesInput>
    public typealias MOutput = OperationOutput<GetLinkAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLinkAttributesOutputError>
}

extension GetLinkAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLinkAttributesInput(attributeNames: \(String(describing: attributeNames)), consistencyLevel: \(String(describing: consistencyLevel)), directoryArn: \(String(describing: directoryArn)), typedLinkSpecifier: \(String(describing: typedLinkSpecifier)))"}
}

extension GetLinkAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeNames = "AttributeNames"
        case consistencyLevel = "ConsistencyLevel"
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeNames = attributeNames {
            var attributeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeNames)
            for attributenamelist0 in attributeNames {
                try attributeNamesContainer.encode(attributenamelist0)
            }
        }
        if let consistencyLevel = consistencyLevel {
            try encodeContainer.encode(consistencyLevel.rawValue, forKey: .consistencyLevel)
        }
        if let typedLinkSpecifier = typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }
}

public struct GetLinkAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "GetLinkAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLinkAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLinkAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLinkAttributesInput>
    public typealias MOutput = OperationOutput<GetLinkAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLinkAttributesOutputError>
}

public struct GetLinkAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLinkAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLinkAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLinkAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLinkAttributesInput>
    public typealias MOutput = OperationOutput<GetLinkAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLinkAttributesOutputError>
}

public struct GetLinkAttributesInput: Equatable {
    /// <p>A list of attribute names whose values will be retrieved.</p>
    public let attributeNames: [String]?
    /// <p>The consistency level at which to retrieve the attributes on a typed link.</p>
    public let consistencyLevel: ConsistencyLevel?
    /// <p>The Amazon Resource Name (ARN) that is associated with the Directory where the typed link resides. For more information, see <a>arns</a> or <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
    public let directoryArn: String?
    /// <p>Allows a typed link specifier to be accepted as input.</p>
    public let typedLinkSpecifier: TypedLinkSpecifier?

    public init (
        attributeNames: [String]? = nil,
        consistencyLevel: ConsistencyLevel? = nil,
        directoryArn: String? = nil,
        typedLinkSpecifier: TypedLinkSpecifier? = nil
    )
    {
        self.attributeNames = attributeNames
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.typedLinkSpecifier = typedLinkSpecifier
    }
}

struct GetLinkAttributesInputBody: Equatable {
    public let typedLinkSpecifier: TypedLinkSpecifier?
    public let attributeNames: [String]?
    public let consistencyLevel: ConsistencyLevel?
}

extension GetLinkAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributeNames = "AttributeNames"
        case consistencyLevel = "ConsistencyLevel"
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
        let attributeNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .attributeNames)
        var attributeNamesDecoded0:[String]? = nil
        if let attributeNamesContainer = attributeNamesContainer {
            attributeNamesDecoded0 = [String]()
            for string0 in attributeNamesContainer {
                if let string0 = string0 {
                    attributeNamesDecoded0?.append(string0)
                }
            }
        }
        attributeNames = attributeNamesDecoded0
        let consistencyLevelDecoded = try containerValues.decodeIfPresent(ConsistencyLevel.self, forKey: .consistencyLevel)
        consistencyLevel = consistencyLevelDecoded
    }
}

extension GetLinkAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLinkAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLinkAttributesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLinkAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLinkAttributesOutputResponse(attributes: \(String(describing: attributes)))"}
}

extension GetLinkAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLinkAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

public struct GetLinkAttributesOutputResponse: Equatable {
    /// <p>The attributes that are associated with the typed link.</p>
    public let attributes: [AttributeKeyAndValue]?

    public init (
        attributes: [AttributeKeyAndValue]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetLinkAttributesOutputResponseBody: Equatable {
    public let attributes: [AttributeKeyAndValue]?
}

extension GetLinkAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([AttributeKeyAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[AttributeKeyAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [AttributeKeyAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

public struct GetObjectAttributesInputBodyMiddleware: Middleware {
    public let id: String = "GetObjectAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectAttributesInput>
    public typealias MOutput = OperationOutput<GetObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectAttributesOutputError>
}

extension GetObjectAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetObjectAttributesInput(attributeNames: \(String(describing: attributeNames)), consistencyLevel: \(String(describing: consistencyLevel)), directoryArn: \(String(describing: directoryArn)), objectReference: \(String(describing: objectReference)), schemaFacet: \(String(describing: schemaFacet)))"}
}

extension GetObjectAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeNames = "AttributeNames"
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeNames = attributeNames {
            var attributeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeNames)
            for attributenamelist0 in attributeNames {
                try attributeNamesContainer.encode(attributenamelist0)
            }
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let schemaFacet = schemaFacet {
            try encodeContainer.encode(schemaFacet, forKey: .schemaFacet)
        }
    }
}

public struct GetObjectAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "GetObjectAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let consistencyLevel = input.operationInput.consistencyLevel {
            input.builder.withHeader(name: "x-amz-consistency-level", value: String(consistencyLevel.rawValue))
        }
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectAttributesInput>
    public typealias MOutput = OperationOutput<GetObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectAttributesOutputError>
}

public struct GetObjectAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetObjectAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectAttributesInput>
    public typealias MOutput = OperationOutput<GetObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectAttributesOutputError>
}

public struct GetObjectAttributesInput: Equatable {
    /// <p>List of attribute names whose values will be retrieved.</p>
    public let attributeNames: [String]?
    /// <p>The consistency level at which to retrieve the attributes on an object.</p>
    public let consistencyLevel: ConsistencyLevel?
    /// <p>The Amazon Resource Name (ARN) that is associated with the <a>Directory</a> where the object resides.</p>
    public let directoryArn: String?
    /// <p>Reference that identifies the object whose attributes will be retrieved.</p>
    public let objectReference: ObjectReference?
    /// <p>Identifier for the facet whose attributes will be retrieved. See <a>SchemaFacet</a> for details.</p>
    public let schemaFacet: SchemaFacet?

    public init (
        attributeNames: [String]? = nil,
        consistencyLevel: ConsistencyLevel? = nil,
        directoryArn: String? = nil,
        objectReference: ObjectReference? = nil,
        schemaFacet: SchemaFacet? = nil
    )
    {
        self.attributeNames = attributeNames
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.objectReference = objectReference
        self.schemaFacet = schemaFacet
    }
}

struct GetObjectAttributesInputBody: Equatable {
    public let objectReference: ObjectReference?
    public let schemaFacet: SchemaFacet?
    public let attributeNames: [String]?
}

extension GetObjectAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributeNames = "AttributeNames"
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let schemaFacetDecoded = try containerValues.decodeIfPresent(SchemaFacet.self, forKey: .schemaFacet)
        schemaFacet = schemaFacetDecoded
        let attributeNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .attributeNames)
        var attributeNamesDecoded0:[String]? = nil
        if let attributeNamesContainer = attributeNamesContainer {
            attributeNamesDecoded0 = [String]()
            for string0 in attributeNamesContainer {
                if let string0 = string0 {
                    attributeNamesDecoded0?.append(string0)
                }
            }
        }
        attributeNames = attributeNamesDecoded0
    }
}

extension GetObjectAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetObjectAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetObjectAttributesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetObjectAttributesOutputResponse(attributes: \(String(describing: attributes)))"}
}

extension GetObjectAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetObjectAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

public struct GetObjectAttributesOutputResponse: Equatable {
    /// <p>The attributes that are associated with the object.</p>
    public let attributes: [AttributeKeyAndValue]?

    public init (
        attributes: [AttributeKeyAndValue]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetObjectAttributesOutputResponseBody: Equatable {
    public let attributes: [AttributeKeyAndValue]?
}

extension GetObjectAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([AttributeKeyAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[AttributeKeyAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [AttributeKeyAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

public struct GetObjectInformationInputBodyMiddleware: Middleware {
    public let id: String = "GetObjectInformationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectInformationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectInformationInput>
    public typealias MOutput = OperationOutput<GetObjectInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectInformationOutputError>
}

extension GetObjectInformationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetObjectInformationInput(consistencyLevel: \(String(describing: consistencyLevel)), directoryArn: \(String(describing: directoryArn)), objectReference: \(String(describing: objectReference)))"}
}

extension GetObjectInformationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct GetObjectInformationInputHeadersMiddleware: Middleware {
    public let id: String = "GetObjectInformationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectInformationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let consistencyLevel = input.operationInput.consistencyLevel {
            input.builder.withHeader(name: "x-amz-consistency-level", value: String(consistencyLevel.rawValue))
        }
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectInformationInput>
    public typealias MOutput = OperationOutput<GetObjectInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectInformationOutputError>
}

public struct GetObjectInformationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetObjectInformationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectInformationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectInformationInput>
    public typealias MOutput = OperationOutput<GetObjectInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectInformationOutputError>
}

public struct GetObjectInformationInput: Equatable {
    /// <p>The consistency level at which to retrieve the object information.</p>
    public let consistencyLevel: ConsistencyLevel?
    /// <p>The ARN of the directory being retrieved.</p>
    public let directoryArn: String?
    /// <p>A reference to the object.</p>
    public let objectReference: ObjectReference?

    public init (
        consistencyLevel: ConsistencyLevel? = nil,
        directoryArn: String? = nil,
        objectReference: ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.objectReference = objectReference
    }
}

struct GetObjectInformationInputBody: Equatable {
    public let objectReference: ObjectReference?
}

extension GetObjectInformationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension GetObjectInformationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetObjectInformationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetObjectInformationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectInformationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetObjectInformationOutputResponse(objectIdentifier: \(String(describing: objectIdentifier)), schemaFacets: \(String(describing: schemaFacets)))"}
}

extension GetObjectInformationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetObjectInformationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.objectIdentifier = output.objectIdentifier
            self.schemaFacets = output.schemaFacets
        } else {
            self.objectIdentifier = nil
            self.schemaFacets = nil
        }
    }
}

public struct GetObjectInformationOutputResponse: Equatable {
    /// <p>The <code>ObjectIdentifier</code> of the specified object.</p>
    public let objectIdentifier: String?
    /// <p>The facets attached to the specified object. Although the response does not include minor version information, the most recently applied minor version of each Facet is in effect. See <a>GetAppliedSchemaVersion</a> for details.</p>
    public let schemaFacets: [SchemaFacet]?

    public init (
        objectIdentifier: String? = nil,
        schemaFacets: [SchemaFacet]? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
        self.schemaFacets = schemaFacets
    }
}

struct GetObjectInformationOutputResponseBody: Equatable {
    public let schemaFacets: [SchemaFacet]?
    public let objectIdentifier: String?
}

extension GetObjectInformationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case objectIdentifier = "ObjectIdentifier"
        case schemaFacets = "SchemaFacets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetsContainer = try containerValues.decodeIfPresent([SchemaFacet?].self, forKey: .schemaFacets)
        var schemaFacetsDecoded0:[SchemaFacet]? = nil
        if let schemaFacetsContainer = schemaFacetsContainer {
            schemaFacetsDecoded0 = [SchemaFacet]()
            for structure0 in schemaFacetsContainer {
                if let structure0 = structure0 {
                    schemaFacetsDecoded0?.append(structure0)
                }
            }
        }
        schemaFacets = schemaFacetsDecoded0
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

extension GetSchemaAsJsonInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSchemaAsJsonInput(schemaArn: \(String(describing: schemaArn)))"}
}

extension GetSchemaAsJsonInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSchemaAsJsonInputHeadersMiddleware: Middleware {
    public let id: String = "GetSchemaAsJsonInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSchemaAsJsonInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSchemaAsJsonOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSchemaAsJsonInput>
    public typealias MOutput = OperationOutput<GetSchemaAsJsonOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSchemaAsJsonOutputError>
}

public struct GetSchemaAsJsonInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSchemaAsJsonInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSchemaAsJsonInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSchemaAsJsonOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSchemaAsJsonInput>
    public typealias MOutput = OperationOutput<GetSchemaAsJsonOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSchemaAsJsonOutputError>
}

public struct GetSchemaAsJsonInput: Equatable {
    /// <p>The ARN of the schema to retrieve.</p>
    public let schemaArn: String?

    public init (
        schemaArn: String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct GetSchemaAsJsonInputBody: Equatable {
}

extension GetSchemaAsJsonInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSchemaAsJsonOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSchemaAsJsonOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSchemaAsJsonOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSchemaAsJsonOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSchemaAsJsonOutputResponse(document: \(String(describing: document)), name: \(String(describing: name)))"}
}

extension GetSchemaAsJsonOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSchemaAsJsonOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.document = output.document
            self.name = output.name
        } else {
            self.document = nil
            self.name = nil
        }
    }
}

public struct GetSchemaAsJsonOutputResponse: Equatable {
    /// <p>The JSON representation of the schema document.</p>
    public let document: String?
    /// <p>The name of the retrieved schema.</p>
    public let name: String?

    public init (
        document: String? = nil,
        name: String? = nil
    )
    {
        self.document = document
        self.name = name
    }
}

struct GetSchemaAsJsonOutputResponseBody: Equatable {
    public let name: String?
    public let document: String?
}

extension GetSchemaAsJsonOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case document = "Document"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let documentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .document)
        document = documentDecoded
    }
}

public struct GetTypedLinkFacetInformationInputBodyMiddleware: Middleware {
    public let id: String = "GetTypedLinkFacetInformationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTypedLinkFacetInformationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTypedLinkFacetInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTypedLinkFacetInformationInput>
    public typealias MOutput = OperationOutput<GetTypedLinkFacetInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTypedLinkFacetInformationOutputError>
}

extension GetTypedLinkFacetInformationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTypedLinkFacetInformationInput(name: \(String(describing: name)), schemaArn: \(String(describing: schemaArn)))"}
}

extension GetTypedLinkFacetInformationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetTypedLinkFacetInformationInputHeadersMiddleware: Middleware {
    public let id: String = "GetTypedLinkFacetInformationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTypedLinkFacetInformationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTypedLinkFacetInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTypedLinkFacetInformationInput>
    public typealias MOutput = OperationOutput<GetTypedLinkFacetInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTypedLinkFacetInformationOutputError>
}

public struct GetTypedLinkFacetInformationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTypedLinkFacetInformationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTypedLinkFacetInformationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTypedLinkFacetInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTypedLinkFacetInformationInput>
    public typealias MOutput = OperationOutput<GetTypedLinkFacetInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTypedLinkFacetInformationOutputError>
}

public struct GetTypedLinkFacetInformationInput: Equatable {
    /// <p>The unique name of the typed link facet.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) that is associated with the schema. For more
    ///       information, see <a>arns</a>.</p>
    public let schemaArn: String?

    public init (
        name: String? = nil,
        schemaArn: String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct GetTypedLinkFacetInformationInputBody: Equatable {
    public let name: String?
}

extension GetTypedLinkFacetInformationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetTypedLinkFacetInformationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTypedLinkFacetInformationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetNotFoundException" : self = .facetNotFoundException(try FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTypedLinkFacetInformationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case facetNotFoundException(FacetNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTypedLinkFacetInformationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTypedLinkFacetInformationOutputResponse(identityAttributeOrder: \(String(describing: identityAttributeOrder)))"}
}

extension GetTypedLinkFacetInformationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTypedLinkFacetInformationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.identityAttributeOrder = output.identityAttributeOrder
        } else {
            self.identityAttributeOrder = nil
        }
    }
}

public struct GetTypedLinkFacetInformationOutputResponse: Equatable {
    /// <p>The order of identity attributes for the facet, from most significant to least significant. The ability to filter typed
    ///       links considers the order that the attributes are defined on the typed link facet. When
    ///       providing ranges to typed link selection, any inexact ranges must be specified at the end. Any
    ///       attributes that do not have a range specified are presumed to match the entire range. Filters
    ///       are interpreted in the order of the attributes on the typed link facet, not the order in which
    ///       they are supplied to any API calls. For more information about identity attributes, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
    public let identityAttributeOrder: [String]?

    public init (
        identityAttributeOrder: [String]? = nil
    )
    {
        self.identityAttributeOrder = identityAttributeOrder
    }
}

struct GetTypedLinkFacetInformationOutputResponseBody: Equatable {
    public let identityAttributeOrder: [String]?
}

extension GetTypedLinkFacetInformationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityAttributeOrder = "IdentityAttributeOrder"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityAttributeOrderContainer = try containerValues.decodeIfPresent([String?].self, forKey: .identityAttributeOrder)
        var identityAttributeOrderDecoded0:[String]? = nil
        if let identityAttributeOrderContainer = identityAttributeOrderContainer {
            identityAttributeOrderDecoded0 = [String]()
            for string0 in identityAttributeOrderContainer {
                if let string0 = string0 {
                    identityAttributeOrderDecoded0?.append(string0)
                }
            }
        }
        identityAttributeOrder = identityAttributeOrderDecoded0
    }
}

extension IncompatibleSchemaException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncompatibleSchemaException(message: \(String(describing: message)))"}
}

extension IncompatibleSchemaException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IncompatibleSchemaExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates a failure occurred while performing a check for backward compatibility between the specified schema and the schema that is currently applied to the directory.</p>
public struct IncompatibleSchemaException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IncompatibleSchemaExceptionBody: Equatable {
    public let message: String?
}

extension IncompatibleSchemaExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IndexAttachment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexedAttributes = "IndexedAttributes"
        case objectIdentifier = "ObjectIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexedAttributes = indexedAttributes {
            var indexedAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .indexedAttributes)
            for attributekeyandvaluelist0 in indexedAttributes {
                try indexedAttributesContainer.encode(attributekeyandvaluelist0)
            }
        }
        if let objectIdentifier = objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexedAttributesContainer = try containerValues.decodeIfPresent([AttributeKeyAndValue?].self, forKey: .indexedAttributes)
        var indexedAttributesDecoded0:[AttributeKeyAndValue]? = nil
        if let indexedAttributesContainer = indexedAttributesContainer {
            indexedAttributesDecoded0 = [AttributeKeyAndValue]()
            for structure0 in indexedAttributesContainer {
                if let structure0 = structure0 {
                    indexedAttributesDecoded0?.append(structure0)
                }
            }
        }
        indexedAttributes = indexedAttributesDecoded0
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

extension IndexAttachment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IndexAttachment(indexedAttributes: \(String(describing: indexedAttributes)), objectIdentifier: \(String(describing: objectIdentifier)))"}
}

/// <p>Represents an index and an attached object.</p>
public struct IndexAttachment: Equatable {
    /// <p>The indexed attribute values.</p>
    public let indexedAttributes: [AttributeKeyAndValue]?
    /// <p>In response to <a>ListIndex</a>, the <code>ObjectIdentifier</code> of the object attached to the index. In response to <a>ListAttachedIndices</a>, the <code>ObjectIdentifier</code> of the index attached to the object. This field will always contain the <code>ObjectIdentifier</code> of the object on the opposite side of the attachment specified in the query.</p>
    public let objectIdentifier: String?

    public init (
        indexedAttributes: [AttributeKeyAndValue]? = nil,
        objectIdentifier: String? = nil
    )
    {
        self.indexedAttributes = indexedAttributes
        self.objectIdentifier = objectIdentifier
    }
}

extension IndexedAttributeMissingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IndexedAttributeMissingException(message: \(String(describing: message)))"}
}

extension IndexedAttributeMissingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IndexedAttributeMissingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An object has been attempted to be attached to an object that does not have the appropriate attribute value.</p>
public struct IndexedAttributeMissingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IndexedAttributeMissingExceptionBody: Equatable {
    public let message: String?
}

extension IndexedAttributeMissingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceException(message: \(String(describing: message)))"}
}

extension InternalServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates a problem that must be resolved by Amazon Web Services. This might be a transient error in which case you can retry your request until it succeeds. Otherwise, go to the <a href="http://status.aws.amazon.com/">AWS Service Health Dashboard</a> site to see if there are any operational issues with the service.</p>
public struct InternalServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceExceptionBody: Equatable {
    public let message: String?
}

extension InternalServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArnException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidArnException(message: \(String(describing: message)))"}
}

extension InvalidArnException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidArnExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the provided ARN value is not valid.</p>
public struct InvalidArnException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArnExceptionBody: Equatable {
    public let message: String?
}

extension InvalidArnExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAttachmentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidAttachmentException(message: \(String(describing: message)))"}
}

extension InvalidAttachmentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidAttachmentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that an attempt to make an attachment was invalid. For example, attaching two nodes
///       with a link type that is not applicable to the nodes or attempting to apply a schema to a directory a second time.</p>
public struct InvalidAttachmentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAttachmentExceptionBody: Equatable {
    public let message: String?
}

extension InvalidAttachmentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFacetUpdateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidFacetUpdateException(message: \(String(describing: message)))"}
}

extension InvalidFacetUpdateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidFacetUpdateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An attempt to modify a <a>Facet</a> resulted in an invalid schema
///       exception.</p>
public struct InvalidFacetUpdateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFacetUpdateExceptionBody: Equatable {
    public let message: String?
}

extension InvalidFacetUpdateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the <code>NextToken</code> value is not valid.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRuleException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRuleException(message: \(String(describing: message)))"}
}

extension InvalidRuleException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRuleExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Occurs when any of the rule parameter keys or values are invalid.</p>
public struct InvalidRuleException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRuleExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRuleExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSchemaDocException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSchemaDocException(message: \(String(describing: message)))"}
}

extension InvalidSchemaDocException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidSchemaDocExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the provided <code>SchemaDoc</code> value is not valid.</p>
public struct InvalidSchemaDocException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSchemaDocExceptionBody: Equatable {
    public let message: String?
}

extension InvalidSchemaDocExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTaggingRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTaggingRequestException(message: \(String(describing: message)))"}
}

extension InvalidTaggingRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTaggingRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Can occur for multiple reasons such as when you tag a resource that doesn’t exist or if you specify a higher number of tags for a resource than the allowed limit. Allowed limit is 50 tags per resource.</p>
public struct InvalidTaggingRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTaggingRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTaggingRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that limits are exceeded. See <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/limits.html">Limits</a> for more information.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LinkAttributeAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeActionType = "AttributeActionType"
        case attributeUpdateValue = "AttributeUpdateValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeActionType = attributeActionType {
            try encodeContainer.encode(attributeActionType.rawValue, forKey: .attributeActionType)
        }
        if let attributeUpdateValue = attributeUpdateValue {
            try encodeContainer.encode(attributeUpdateValue, forKey: .attributeUpdateValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeActionTypeDecoded = try containerValues.decodeIfPresent(UpdateActionType.self, forKey: .attributeActionType)
        attributeActionType = attributeActionTypeDecoded
        let attributeUpdateValueDecoded = try containerValues.decodeIfPresent(TypedAttributeValue.self, forKey: .attributeUpdateValue)
        attributeUpdateValue = attributeUpdateValueDecoded
    }
}

extension LinkAttributeAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LinkAttributeAction(attributeActionType: \(String(describing: attributeActionType)), attributeUpdateValue: \(String(describing: attributeUpdateValue)))"}
}

/// <p>The action to take on a typed link attribute value. Updates are only supported for attributes which don’t contribute to link identity.</p>
public struct LinkAttributeAction: Equatable {
    /// <p>A type that can be either <code>UPDATE_OR_CREATE</code> or <code>DELETE</code>.</p>
    public let attributeActionType: UpdateActionType?
    /// <p>The value that you want to update to.</p>
    public let attributeUpdateValue: TypedAttributeValue?

    public init (
        attributeActionType: UpdateActionType? = nil,
        attributeUpdateValue: TypedAttributeValue? = nil
    )
    {
        self.attributeActionType = attributeActionType
        self.attributeUpdateValue = attributeUpdateValue
    }
}

extension LinkAttributeUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeAction = "AttributeAction"
        case attributeKey = "AttributeKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeAction = attributeAction {
            try encodeContainer.encode(attributeAction, forKey: .attributeAction)
        }
        if let attributeKey = attributeKey {
            try encodeContainer.encode(attributeKey, forKey: .attributeKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeKeyDecoded = try containerValues.decodeIfPresent(AttributeKey.self, forKey: .attributeKey)
        attributeKey = attributeKeyDecoded
        let attributeActionDecoded = try containerValues.decodeIfPresent(LinkAttributeAction.self, forKey: .attributeAction)
        attributeAction = attributeActionDecoded
    }
}

extension LinkAttributeUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LinkAttributeUpdate(attributeAction: \(String(describing: attributeAction)), attributeKey: \(String(describing: attributeKey)))"}
}

/// <p>Structure that contains attribute update information.</p>
public struct LinkAttributeUpdate: Equatable {
    /// <p>The action to perform as part of the attribute update.</p>
    public let attributeAction: LinkAttributeAction?
    /// <p>The key of the attribute being updated.</p>
    public let attributeKey: AttributeKey?

    public init (
        attributeAction: LinkAttributeAction? = nil,
        attributeKey: AttributeKey? = nil
    )
    {
        self.attributeAction = attributeAction
        self.attributeKey = attributeKey
    }
}

extension LinkNameAlreadyInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LinkNameAlreadyInUseException(message: \(String(describing: message)))"}
}

extension LinkNameAlreadyInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LinkNameAlreadyInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a link could not be created due to a naming conflict. Choose a different
///       name and then try again.</p>
public struct LinkNameAlreadyInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LinkNameAlreadyInUseExceptionBody: Equatable {
    public let message: String?
}

extension LinkNameAlreadyInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAppliedSchemaArnsInputBodyMiddleware: Middleware {
    public let id: String = "ListAppliedSchemaArnsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAppliedSchemaArnsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAppliedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAppliedSchemaArnsInput>
    public typealias MOutput = OperationOutput<ListAppliedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAppliedSchemaArnsOutputError>
}

extension ListAppliedSchemaArnsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAppliedSchemaArnsInput(directoryArn: \(String(describing: directoryArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), schemaArn: \(String(describing: schemaArn)))"}
}

extension ListAppliedSchemaArnsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryArn = "DirectoryArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaArn = "SchemaArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryArn = directoryArn {
            try encodeContainer.encode(directoryArn, forKey: .directoryArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

public struct ListAppliedSchemaArnsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAppliedSchemaArnsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAppliedSchemaArnsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAppliedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAppliedSchemaArnsInput>
    public typealias MOutput = OperationOutput<ListAppliedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAppliedSchemaArnsOutputError>
}

public struct ListAppliedSchemaArnsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAppliedSchemaArnsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAppliedSchemaArnsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAppliedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAppliedSchemaArnsInput>
    public typealias MOutput = OperationOutput<ListAppliedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAppliedSchemaArnsOutputError>
}

public struct ListAppliedSchemaArnsInput: Equatable {
    /// <p>The ARN of the directory you are listing.</p>
    public let directoryArn: String?
    /// <p>The maximum number of results to retrieve.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The response for <code>ListAppliedSchemaArns</code> when this parameter is used will list all minor version ARNs for a major version.</p>
    public let schemaArn: String?

    public init (
        directoryArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        schemaArn: String? = nil
    )
    {
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListAppliedSchemaArnsInputBody: Equatable {
    public let directoryArn: String?
    public let schemaArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListAppliedSchemaArnsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryArn = "DirectoryArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaArn = "SchemaArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppliedSchemaArnsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppliedSchemaArnsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppliedSchemaArnsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppliedSchemaArnsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAppliedSchemaArnsOutputResponse(nextToken: \(String(describing: nextToken)), schemaArns: \(String(describing: schemaArns)))"}
}

extension ListAppliedSchemaArnsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAppliedSchemaArnsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.schemaArns = output.schemaArns
        } else {
            self.nextToken = nil
            self.schemaArns = nil
        }
    }
}

public struct ListAppliedSchemaArnsOutputResponse: Equatable {
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The ARNs of schemas that are applied to the directory.</p>
    public let schemaArns: [String]?

    public init (
        nextToken: String? = nil,
        schemaArns: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaArns = schemaArns
    }
}

struct ListAppliedSchemaArnsOutputResponseBody: Equatable {
    public let schemaArns: [String]?
    public let nextToken: String?
}

extension ListAppliedSchemaArnsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case schemaArns = "SchemaArns"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .schemaArns)
        var schemaArnsDecoded0:[String]? = nil
        if let schemaArnsContainer = schemaArnsContainer {
            schemaArnsDecoded0 = [String]()
            for string0 in schemaArnsContainer {
                if let string0 = string0 {
                    schemaArnsDecoded0?.append(string0)
                }
            }
        }
        schemaArns = schemaArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAttachedIndicesInputBodyMiddleware: Middleware {
    public let id: String = "ListAttachedIndicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAttachedIndicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAttachedIndicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAttachedIndicesInput>
    public typealias MOutput = OperationOutput<ListAttachedIndicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAttachedIndicesOutputError>
}

extension ListAttachedIndicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAttachedIndicesInput(consistencyLevel: \(String(describing: consistencyLevel)), directoryArn: \(String(describing: directoryArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), targetReference: \(String(describing: targetReference)))"}
}

extension ListAttachedIndicesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case targetReference = "TargetReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let targetReference = targetReference {
            try encodeContainer.encode(targetReference, forKey: .targetReference)
        }
    }
}

public struct ListAttachedIndicesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAttachedIndicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAttachedIndicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAttachedIndicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let consistencyLevel = input.operationInput.consistencyLevel {
            input.builder.withHeader(name: "x-amz-consistency-level", value: String(consistencyLevel.rawValue))
        }
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAttachedIndicesInput>
    public typealias MOutput = OperationOutput<ListAttachedIndicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAttachedIndicesOutputError>
}

public struct ListAttachedIndicesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAttachedIndicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAttachedIndicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAttachedIndicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAttachedIndicesInput>
    public typealias MOutput = OperationOutput<ListAttachedIndicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAttachedIndicesOutputError>
}

public struct ListAttachedIndicesInput: Equatable {
    /// <p>The consistency level to use for this operation.</p>
    public let consistencyLevel: ConsistencyLevel?
    /// <p>The ARN of the directory.</p>
    public let directoryArn: String?
    /// <p>The maximum number of results to retrieve.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>A reference to the object that has indices attached.</p>
    public let targetReference: ObjectReference?

    public init (
        consistencyLevel: ConsistencyLevel? = nil,
        directoryArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        targetReference: ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetReference = targetReference
    }
}

struct ListAttachedIndicesInputBody: Equatable {
    public let targetReference: ObjectReference?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListAttachedIndicesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case targetReference = "TargetReference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .targetReference)
        targetReference = targetReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAttachedIndicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAttachedIndicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAttachedIndicesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAttachedIndicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAttachedIndicesOutputResponse(indexAttachments: \(String(describing: indexAttachments)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAttachedIndicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAttachedIndicesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.indexAttachments = output.indexAttachments
            self.nextToken = output.nextToken
        } else {
            self.indexAttachments = nil
            self.nextToken = nil
        }
    }
}

public struct ListAttachedIndicesOutputResponse: Equatable {
    /// <p>The indices attached to the specified object.</p>
    public let indexAttachments: [IndexAttachment]?
    /// <p>The pagination token.</p>
    public let nextToken: String?

    public init (
        indexAttachments: [IndexAttachment]? = nil,
        nextToken: String? = nil
    )
    {
        self.indexAttachments = indexAttachments
        self.nextToken = nextToken
    }
}

struct ListAttachedIndicesOutputResponseBody: Equatable {
    public let indexAttachments: [IndexAttachment]?
    public let nextToken: String?
}

extension ListAttachedIndicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexAttachments = "IndexAttachments"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexAttachmentsContainer = try containerValues.decodeIfPresent([IndexAttachment?].self, forKey: .indexAttachments)
        var indexAttachmentsDecoded0:[IndexAttachment]? = nil
        if let indexAttachmentsContainer = indexAttachmentsContainer {
            indexAttachmentsDecoded0 = [IndexAttachment]()
            for structure0 in indexAttachmentsContainer {
                if let structure0 = structure0 {
                    indexAttachmentsDecoded0?.append(structure0)
                }
            }
        }
        indexAttachments = indexAttachmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDevelopmentSchemaArnsInputBodyMiddleware: Middleware {
    public let id: String = "ListDevelopmentSchemaArnsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDevelopmentSchemaArnsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDevelopmentSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDevelopmentSchemaArnsInput>
    public typealias MOutput = OperationOutput<ListDevelopmentSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDevelopmentSchemaArnsOutputError>
}

extension ListDevelopmentSchemaArnsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDevelopmentSchemaArnsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDevelopmentSchemaArnsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDevelopmentSchemaArnsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDevelopmentSchemaArnsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDevelopmentSchemaArnsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDevelopmentSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDevelopmentSchemaArnsInput>
    public typealias MOutput = OperationOutput<ListDevelopmentSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDevelopmentSchemaArnsOutputError>
}

public struct ListDevelopmentSchemaArnsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDevelopmentSchemaArnsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDevelopmentSchemaArnsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDevelopmentSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDevelopmentSchemaArnsInput>
    public typealias MOutput = OperationOutput<ListDevelopmentSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDevelopmentSchemaArnsOutputError>
}

public struct ListDevelopmentSchemaArnsInput: Equatable {
    /// <p>The maximum number of results to retrieve.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDevelopmentSchemaArnsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListDevelopmentSchemaArnsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDevelopmentSchemaArnsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDevelopmentSchemaArnsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDevelopmentSchemaArnsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDevelopmentSchemaArnsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDevelopmentSchemaArnsOutputResponse(nextToken: \(String(describing: nextToken)), schemaArns: \(String(describing: schemaArns)))"}
}

extension ListDevelopmentSchemaArnsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDevelopmentSchemaArnsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.schemaArns = output.schemaArns
        } else {
            self.nextToken = nil
            self.schemaArns = nil
        }
    }
}

public struct ListDevelopmentSchemaArnsOutputResponse: Equatable {
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The ARNs of retrieved development schemas.</p>
    public let schemaArns: [String]?

    public init (
        nextToken: String? = nil,
        schemaArns: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaArns = schemaArns
    }
}

struct ListDevelopmentSchemaArnsOutputResponseBody: Equatable {
    public let schemaArns: [String]?
    public let nextToken: String?
}

extension ListDevelopmentSchemaArnsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case schemaArns = "SchemaArns"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .schemaArns)
        var schemaArnsDecoded0:[String]? = nil
        if let schemaArnsContainer = schemaArnsContainer {
            schemaArnsDecoded0 = [String]()
            for string0 in schemaArnsContainer {
                if let string0 = string0 {
                    schemaArnsDecoded0?.append(string0)
                }
            }
        }
        schemaArns = schemaArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDirectoriesInputBodyMiddleware: Middleware {
    public let id: String = "ListDirectoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDirectoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDirectoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDirectoriesInput>
    public typealias MOutput = OperationOutput<ListDirectoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDirectoriesOutputError>
}

extension ListDirectoriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDirectoriesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), state: \(String(describing: state)))"}
}

extension ListDirectoriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case state
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

public struct ListDirectoriesInputHeadersMiddleware: Middleware {
    public let id: String = "ListDirectoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDirectoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDirectoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDirectoriesInput>
    public typealias MOutput = OperationOutput<ListDirectoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDirectoriesOutputError>
}

public struct ListDirectoriesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDirectoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDirectoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDirectoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDirectoriesInput>
    public typealias MOutput = OperationOutput<ListDirectoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDirectoriesOutputError>
}

public struct ListDirectoriesInput: Equatable {
    /// <p>The maximum number of results to retrieve.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The state of the directories in the list. Can be either Enabled, Disabled, or
    ///       Deleted.</p>
    public let state: DirectoryState?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        state: DirectoryState? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.state = state
    }
}

struct ListDirectoriesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let state: DirectoryState?
}

extension ListDirectoriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case state
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DirectoryState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ListDirectoriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDirectoriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDirectoriesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDirectoriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDirectoriesOutputResponse(directories: \(String(describing: directories)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDirectoriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDirectoriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.directories = output.directories
            self.nextToken = output.nextToken
        } else {
            self.directories = nil
            self.nextToken = nil
        }
    }
}

public struct ListDirectoriesOutputResponse: Equatable {
    /// <p>Lists all directories that are associated with your account in pagination
    ///       fashion.</p>
    public let directories: [Directory]?
    /// <p>The pagination token.</p>
    public let nextToken: String?

    public init (
        directories: [Directory]? = nil,
        nextToken: String? = nil
    )
    {
        self.directories = directories
        self.nextToken = nextToken
    }
}

struct ListDirectoriesOutputResponseBody: Equatable {
    public let directories: [Directory]?
    public let nextToken: String?
}

extension ListDirectoriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directories = "Directories"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoriesContainer = try containerValues.decodeIfPresent([Directory?].self, forKey: .directories)
        var directoriesDecoded0:[Directory]? = nil
        if let directoriesContainer = directoriesContainer {
            directoriesDecoded0 = [Directory]()
            for structure0 in directoriesContainer {
                if let structure0 = structure0 {
                    directoriesDecoded0?.append(structure0)
                }
            }
        }
        directories = directoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFacetAttributesInputBodyMiddleware: Middleware {
    public let id: String = "ListFacetAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFacetAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFacetAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFacetAttributesInput>
    public typealias MOutput = OperationOutput<ListFacetAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFacetAttributesOutputError>
}

extension ListFacetAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFacetAttributesInput(maxResults: \(String(describing: maxResults)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)), schemaArn: \(String(describing: schemaArn)))"}
}

extension ListFacetAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFacetAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "ListFacetAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFacetAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFacetAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFacetAttributesInput>
    public typealias MOutput = OperationOutput<ListFacetAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFacetAttributesOutputError>
}

public struct ListFacetAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFacetAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFacetAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFacetAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFacetAttributesInput>
    public typealias MOutput = OperationOutput<ListFacetAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFacetAttributesOutputError>
}

public struct ListFacetAttributesInput: Equatable {
    /// <p>The maximum number of results to retrieve.</p>
    public let maxResults: Int?
    /// <p>The name of the facet whose attributes will be retrieved.</p>
    public let name: String?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The ARN of the schema where the facet resides.</p>
    public let schemaArn: String?

    public init (
        maxResults: Int? = nil,
        name: String? = nil,
        nextToken: String? = nil,
        schemaArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListFacetAttributesInputBody: Equatable {
    public let name: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListFacetAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFacetAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFacetAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetNotFoundException" : self = .facetNotFoundException(try FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFacetAttributesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case facetNotFoundException(FacetNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFacetAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFacetAttributesOutputResponse(attributes: \(String(describing: attributes)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFacetAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFacetAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributes = output.attributes
            self.nextToken = output.nextToken
        } else {
            self.attributes = nil
            self.nextToken = nil
        }
    }
}

public struct ListFacetAttributesOutputResponse: Equatable {
    /// <p>The attributes attached to the facet.</p>
    public let attributes: [FacetAttribute]?
    /// <p>The pagination token.</p>
    public let nextToken: String?

    public init (
        attributes: [FacetAttribute]? = nil,
        nextToken: String? = nil
    )
    {
        self.attributes = attributes
        self.nextToken = nextToken
    }
}

struct ListFacetAttributesOutputResponseBody: Equatable {
    public let attributes: [FacetAttribute]?
    public let nextToken: String?
}

extension ListFacetAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([FacetAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[FacetAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [FacetAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFacetNamesInputBodyMiddleware: Middleware {
    public let id: String = "ListFacetNamesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFacetNamesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFacetNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFacetNamesInput>
    public typealias MOutput = OperationOutput<ListFacetNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFacetNamesOutputError>
}

extension ListFacetNamesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFacetNamesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), schemaArn: \(String(describing: schemaArn)))"}
}

extension ListFacetNamesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFacetNamesInputHeadersMiddleware: Middleware {
    public let id: String = "ListFacetNamesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFacetNamesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFacetNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFacetNamesInput>
    public typealias MOutput = OperationOutput<ListFacetNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFacetNamesOutputError>
}

public struct ListFacetNamesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFacetNamesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFacetNamesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFacetNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFacetNamesInput>
    public typealias MOutput = OperationOutput<ListFacetNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFacetNamesOutputError>
}

public struct ListFacetNamesInput: Equatable {
    /// <p>The maximum number of results to retrieve.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) to retrieve facet names from.</p>
    public let schemaArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        schemaArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListFacetNamesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListFacetNamesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFacetNamesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFacetNamesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFacetNamesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFacetNamesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFacetNamesOutputResponse(facetNames: \(String(describing: facetNames)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFacetNamesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFacetNamesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.facetNames = output.facetNames
            self.nextToken = output.nextToken
        } else {
            self.facetNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListFacetNamesOutputResponse: Equatable {
    /// <p>The names of facets that exist within the schema.</p>
    public let facetNames: [String]?
    /// <p>The pagination token.</p>
    public let nextToken: String?

    public init (
        facetNames: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.facetNames = facetNames
        self.nextToken = nextToken
    }
}

struct ListFacetNamesOutputResponseBody: Equatable {
    public let facetNames: [String]?
    public let nextToken: String?
}

extension ListFacetNamesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case facetNames = "FacetNames"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let facetNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .facetNames)
        var facetNamesDecoded0:[String]? = nil
        if let facetNamesContainer = facetNamesContainer {
            facetNamesDecoded0 = [String]()
            for string0 in facetNamesContainer {
                if let string0 = string0 {
                    facetNamesDecoded0?.append(string0)
                }
            }
        }
        facetNames = facetNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListIncomingTypedLinksInputBodyMiddleware: Middleware {
    public let id: String = "ListIncomingTypedLinksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIncomingTypedLinksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIncomingTypedLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIncomingTypedLinksInput>
    public typealias MOutput = OperationOutput<ListIncomingTypedLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIncomingTypedLinksOutputError>
}

extension ListIncomingTypedLinksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIncomingTypedLinksInput(consistencyLevel: \(String(describing: consistencyLevel)), directoryArn: \(String(describing: directoryArn)), filterAttributeRanges: \(String(describing: filterAttributeRanges)), filterTypedLink: \(String(describing: filterTypedLink)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), objectReference: \(String(describing: objectReference)))"}
}

extension ListIncomingTypedLinksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case consistencyLevel = "ConsistencyLevel"
        case filterAttributeRanges = "FilterAttributeRanges"
        case filterTypedLink = "FilterTypedLink"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consistencyLevel = consistencyLevel {
            try encodeContainer.encode(consistencyLevel.rawValue, forKey: .consistencyLevel)
        }
        if let filterAttributeRanges = filterAttributeRanges {
            var filterAttributeRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterAttributeRanges)
            for typedlinkattributerangelist0 in filterAttributeRanges {
                try filterAttributeRangesContainer.encode(typedlinkattributerangelist0)
            }
        }
        if let filterTypedLink = filterTypedLink {
            try encodeContainer.encode(filterTypedLink, forKey: .filterTypedLink)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct ListIncomingTypedLinksInputHeadersMiddleware: Middleware {
    public let id: String = "ListIncomingTypedLinksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIncomingTypedLinksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIncomingTypedLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIncomingTypedLinksInput>
    public typealias MOutput = OperationOutput<ListIncomingTypedLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIncomingTypedLinksOutputError>
}

public struct ListIncomingTypedLinksInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIncomingTypedLinksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIncomingTypedLinksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIncomingTypedLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIncomingTypedLinksInput>
    public typealias MOutput = OperationOutput<ListIncomingTypedLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIncomingTypedLinksOutputError>
}

public struct ListIncomingTypedLinksInput: Equatable {
    /// <p>The consistency level to execute the request at.</p>
    public let consistencyLevel: ConsistencyLevel?
    /// <p>The Amazon Resource Name (ARN) of the directory where you want to list the typed
    ///       links.</p>
    public let directoryArn: String?
    /// <p>Provides range filters for multiple attributes. When providing ranges to typed link
    ///       selection, any inexact ranges must be specified at the end. Any attributes that do not have a
    ///       range specified are presumed to match the entire range.</p>
    public let filterAttributeRanges: [TypedLinkAttributeRange]?
    /// <p>Filters are interpreted in the order of the attributes on the typed link facet, not the
    ///       order in which they are supplied to any API calls.</p>
    public let filterTypedLink: TypedLinkSchemaAndFacetName?
    /// <p>The maximum number of results to retrieve.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>Reference that identifies the object whose attributes will be listed.</p>
    public let objectReference: ObjectReference?

    public init (
        consistencyLevel: ConsistencyLevel? = nil,
        directoryArn: String? = nil,
        filterAttributeRanges: [TypedLinkAttributeRange]? = nil,
        filterTypedLink: TypedLinkSchemaAndFacetName? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        objectReference: ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.filterAttributeRanges = filterAttributeRanges
        self.filterTypedLink = filterTypedLink
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListIncomingTypedLinksInputBody: Equatable {
    public let objectReference: ObjectReference?
    public let filterAttributeRanges: [TypedLinkAttributeRange]?
    public let filterTypedLink: TypedLinkSchemaAndFacetName?
    public let nextToken: String?
    public let maxResults: Int?
    public let consistencyLevel: ConsistencyLevel?
}

extension ListIncomingTypedLinksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case consistencyLevel = "ConsistencyLevel"
        case filterAttributeRanges = "FilterAttributeRanges"
        case filterTypedLink = "FilterTypedLink"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let filterAttributeRangesContainer = try containerValues.decodeIfPresent([TypedLinkAttributeRange?].self, forKey: .filterAttributeRanges)
        var filterAttributeRangesDecoded0:[TypedLinkAttributeRange]? = nil
        if let filterAttributeRangesContainer = filterAttributeRangesContainer {
            filterAttributeRangesDecoded0 = [TypedLinkAttributeRange]()
            for structure0 in filterAttributeRangesContainer {
                if let structure0 = structure0 {
                    filterAttributeRangesDecoded0?.append(structure0)
                }
            }
        }
        filterAttributeRanges = filterAttributeRangesDecoded0
        let filterTypedLinkDecoded = try containerValues.decodeIfPresent(TypedLinkSchemaAndFacetName.self, forKey: .filterTypedLink)
        filterTypedLink = filterTypedLinkDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let consistencyLevelDecoded = try containerValues.decodeIfPresent(ConsistencyLevel.self, forKey: .consistencyLevel)
        consistencyLevel = consistencyLevelDecoded
    }
}

extension ListIncomingTypedLinksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIncomingTypedLinksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIncomingTypedLinksOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIncomingTypedLinksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIncomingTypedLinksOutputResponse(linkSpecifiers: \(String(describing: linkSpecifiers)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIncomingTypedLinksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListIncomingTypedLinksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.linkSpecifiers = output.linkSpecifiers
            self.nextToken = output.nextToken
        } else {
            self.linkSpecifiers = nil
            self.nextToken = nil
        }
    }
}

public struct ListIncomingTypedLinksOutputResponse: Equatable {
    /// <p>Returns one or more typed link specifiers as output.</p>
    public let linkSpecifiers: [TypedLinkSpecifier]?
    /// <p>The pagination token.</p>
    public let nextToken: String?

    public init (
        linkSpecifiers: [TypedLinkSpecifier]? = nil,
        nextToken: String? = nil
    )
    {
        self.linkSpecifiers = linkSpecifiers
        self.nextToken = nextToken
    }
}

struct ListIncomingTypedLinksOutputResponseBody: Equatable {
    public let linkSpecifiers: [TypedLinkSpecifier]?
    public let nextToken: String?
}

extension ListIncomingTypedLinksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case linkSpecifiers = "LinkSpecifiers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkSpecifiersContainer = try containerValues.decodeIfPresent([TypedLinkSpecifier?].self, forKey: .linkSpecifiers)
        var linkSpecifiersDecoded0:[TypedLinkSpecifier]? = nil
        if let linkSpecifiersContainer = linkSpecifiersContainer {
            linkSpecifiersDecoded0 = [TypedLinkSpecifier]()
            for structure0 in linkSpecifiersContainer {
                if let structure0 = structure0 {
                    linkSpecifiersDecoded0?.append(structure0)
                }
            }
        }
        linkSpecifiers = linkSpecifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListIndexInputBodyMiddleware: Middleware {
    public let id: String = "ListIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIndexInput>
    public typealias MOutput = OperationOutput<ListIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIndexOutputError>
}

extension ListIndexInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIndexInput(consistencyLevel: \(String(describing: consistencyLevel)), directoryArn: \(String(describing: directoryArn)), indexReference: \(String(describing: indexReference)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), rangesOnIndexedValues: \(String(describing: rangesOnIndexedValues)))"}
}

extension ListIndexInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexReference = "IndexReference"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case rangesOnIndexedValues = "RangesOnIndexedValues"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexReference = indexReference {
            try encodeContainer.encode(indexReference, forKey: .indexReference)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let rangesOnIndexedValues = rangesOnIndexedValues {
            var rangesOnIndexedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rangesOnIndexedValues)
            for objectattributerangelist0 in rangesOnIndexedValues {
                try rangesOnIndexedValuesContainer.encode(objectattributerangelist0)
            }
        }
    }
}

public struct ListIndexInputHeadersMiddleware: Middleware {
    public let id: String = "ListIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let consistencyLevel = input.operationInput.consistencyLevel {
            input.builder.withHeader(name: "x-amz-consistency-level", value: String(consistencyLevel.rawValue))
        }
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIndexInput>
    public typealias MOutput = OperationOutput<ListIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIndexOutputError>
}

public struct ListIndexInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIndexInput>
    public typealias MOutput = OperationOutput<ListIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIndexOutputError>
}

public struct ListIndexInput: Equatable {
    /// <p>The consistency level to execute the request at.</p>
    public let consistencyLevel: ConsistencyLevel?
    /// <p>The ARN of the directory that the index exists in.</p>
    public let directoryArn: String?
    /// <p>The reference to the index to list.</p>
    public let indexReference: ObjectReference?
    /// <p>The maximum number of objects in a single page to retrieve from the index during a request. For more information, see <a href="http://docs.aws.amazon.com/clouddirectory/latest/developerguide/limits.html">Amazon Cloud Directory Limits</a>.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>Specifies the ranges of indexed values that you want to query.</p>
    public let rangesOnIndexedValues: [ObjectAttributeRange]?

    public init (
        consistencyLevel: ConsistencyLevel? = nil,
        directoryArn: String? = nil,
        indexReference: ObjectReference? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        rangesOnIndexedValues: [ObjectAttributeRange]? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.indexReference = indexReference
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.rangesOnIndexedValues = rangesOnIndexedValues
    }
}

struct ListIndexInputBody: Equatable {
    public let rangesOnIndexedValues: [ObjectAttributeRange]?
    public let indexReference: ObjectReference?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListIndexInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexReference = "IndexReference"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case rangesOnIndexedValues = "RangesOnIndexedValues"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rangesOnIndexedValuesContainer = try containerValues.decodeIfPresent([ObjectAttributeRange?].self, forKey: .rangesOnIndexedValues)
        var rangesOnIndexedValuesDecoded0:[ObjectAttributeRange]? = nil
        if let rangesOnIndexedValuesContainer = rangesOnIndexedValuesContainer {
            rangesOnIndexedValuesDecoded0 = [ObjectAttributeRange]()
            for structure0 in rangesOnIndexedValuesContainer {
                if let structure0 = structure0 {
                    rangesOnIndexedValuesDecoded0?.append(structure0)
                }
            }
        }
        rangesOnIndexedValues = rangesOnIndexedValuesDecoded0
        let indexReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .indexReference)
        indexReference = indexReferenceDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIndexOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIndexOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotIndexException" : self = .notIndexException(try NotIndexException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIndexOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case notIndexException(NotIndexException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIndexOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIndexOutputResponse(indexAttachments: \(String(describing: indexAttachments)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIndexOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListIndexOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.indexAttachments = output.indexAttachments
            self.nextToken = output.nextToken
        } else {
            self.indexAttachments = nil
            self.nextToken = nil
        }
    }
}

public struct ListIndexOutputResponse: Equatable {
    /// <p>The objects and indexed values attached to the index.</p>
    public let indexAttachments: [IndexAttachment]?
    /// <p>The pagination token.</p>
    public let nextToken: String?

    public init (
        indexAttachments: [IndexAttachment]? = nil,
        nextToken: String? = nil
    )
    {
        self.indexAttachments = indexAttachments
        self.nextToken = nextToken
    }
}

struct ListIndexOutputResponseBody: Equatable {
    public let indexAttachments: [IndexAttachment]?
    public let nextToken: String?
}

extension ListIndexOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexAttachments = "IndexAttachments"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexAttachmentsContainer = try containerValues.decodeIfPresent([IndexAttachment?].self, forKey: .indexAttachments)
        var indexAttachmentsDecoded0:[IndexAttachment]? = nil
        if let indexAttachmentsContainer = indexAttachmentsContainer {
            indexAttachmentsDecoded0 = [IndexAttachment]()
            for structure0 in indexAttachmentsContainer {
                if let structure0 = structure0 {
                    indexAttachmentsDecoded0?.append(structure0)
                }
            }
        }
        indexAttachments = indexAttachmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListManagedSchemaArnsInputBodyMiddleware: Middleware {
    public let id: String = "ListManagedSchemaArnsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListManagedSchemaArnsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListManagedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListManagedSchemaArnsInput>
    public typealias MOutput = OperationOutput<ListManagedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListManagedSchemaArnsOutputError>
}

extension ListManagedSchemaArnsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListManagedSchemaArnsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), schemaArn: \(String(describing: schemaArn)))"}
}

extension ListManagedSchemaArnsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaArn = "SchemaArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

public struct ListManagedSchemaArnsInputHeadersMiddleware: Middleware {
    public let id: String = "ListManagedSchemaArnsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListManagedSchemaArnsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListManagedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListManagedSchemaArnsInput>
    public typealias MOutput = OperationOutput<ListManagedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListManagedSchemaArnsOutputError>
}

public struct ListManagedSchemaArnsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListManagedSchemaArnsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListManagedSchemaArnsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListManagedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListManagedSchemaArnsInput>
    public typealias MOutput = OperationOutput<ListManagedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListManagedSchemaArnsOutputError>
}

public struct ListManagedSchemaArnsInput: Equatable {
    /// <p>The maximum number of results to retrieve.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The response for ListManagedSchemaArns. When this parameter is used, all minor version ARNs for a major version are listed.</p>
    public let schemaArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        schemaArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListManagedSchemaArnsInputBody: Equatable {
    public let schemaArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListManagedSchemaArnsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaArn = "SchemaArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListManagedSchemaArnsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListManagedSchemaArnsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListManagedSchemaArnsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListManagedSchemaArnsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListManagedSchemaArnsOutputResponse(nextToken: \(String(describing: nextToken)), schemaArns: \(String(describing: schemaArns)))"}
}

extension ListManagedSchemaArnsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListManagedSchemaArnsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.schemaArns = output.schemaArns
        } else {
            self.nextToken = nil
            self.schemaArns = nil
        }
    }
}

public struct ListManagedSchemaArnsOutputResponse: Equatable {
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The ARNs for all AWS managed schemas.</p>
    public let schemaArns: [String]?

    public init (
        nextToken: String? = nil,
        schemaArns: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaArns = schemaArns
    }
}

struct ListManagedSchemaArnsOutputResponseBody: Equatable {
    public let schemaArns: [String]?
    public let nextToken: String?
}

extension ListManagedSchemaArnsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case schemaArns = "SchemaArns"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .schemaArns)
        var schemaArnsDecoded0:[String]? = nil
        if let schemaArnsContainer = schemaArnsContainer {
            schemaArnsDecoded0 = [String]()
            for string0 in schemaArnsContainer {
                if let string0 = string0 {
                    schemaArnsDecoded0?.append(string0)
                }
            }
        }
        schemaArns = schemaArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListObjectAttributesInputBodyMiddleware: Middleware {
    public let id: String = "ListObjectAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectAttributesInput>
    public typealias MOutput = OperationOutput<ListObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectAttributesOutputError>
}

extension ListObjectAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListObjectAttributesInput(consistencyLevel: \(String(describing: consistencyLevel)), directoryArn: \(String(describing: directoryArn)), facetFilter: \(String(describing: facetFilter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), objectReference: \(String(describing: objectReference)))"}
}

extension ListObjectAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case facetFilter = "FacetFilter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facetFilter = facetFilter {
            try encodeContainer.encode(facetFilter, forKey: .facetFilter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct ListObjectAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "ListObjectAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let consistencyLevel = input.operationInput.consistencyLevel {
            input.builder.withHeader(name: "x-amz-consistency-level", value: String(consistencyLevel.rawValue))
        }
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectAttributesInput>
    public typealias MOutput = OperationOutput<ListObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectAttributesOutputError>
}

public struct ListObjectAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListObjectAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectAttributesInput>
    public typealias MOutput = OperationOutput<ListObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectAttributesOutputError>
}

public struct ListObjectAttributesInput: Equatable {
    /// <p>Represents the manner and timing in which the successful write or update of an object
    ///       is reflected in a subsequent read operation of that same object.</p>
    public let consistencyLevel: ConsistencyLevel?
    /// <p>The Amazon Resource Name (ARN) that is associated with the <a>Directory</a>
    ///       where the object resides. For more information, see <a>arns</a>.</p>
    public let directoryArn: String?
    /// <p>Used to filter the list of object attributes that are associated with a certain
    ///       facet.</p>
    public let facetFilter: SchemaFacet?
    /// <p>The maximum number of items to be retrieved in a single call. This is an approximate
    ///       number.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The reference that identifies the object whose attributes will be listed.</p>
    public let objectReference: ObjectReference?

    public init (
        consistencyLevel: ConsistencyLevel? = nil,
        directoryArn: String? = nil,
        facetFilter: SchemaFacet? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        objectReference: ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.facetFilter = facetFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListObjectAttributesInputBody: Equatable {
    public let objectReference: ObjectReference?
    public let nextToken: String?
    public let maxResults: Int?
    public let facetFilter: SchemaFacet?
}

extension ListObjectAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case facetFilter = "FacetFilter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let facetFilterDecoded = try containerValues.decodeIfPresent(SchemaFacet.self, forKey: .facetFilter)
        facetFilter = facetFilterDecoded
    }
}

extension ListObjectAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListObjectAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListObjectAttributesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListObjectAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListObjectAttributesOutputResponse(attributes: \(String(describing: attributes)), nextToken: \(String(describing: nextToken)))"}
}

extension ListObjectAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListObjectAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributes = output.attributes
            self.nextToken = output.nextToken
        } else {
            self.attributes = nil
            self.nextToken = nil
        }
    }
}

public struct ListObjectAttributesOutputResponse: Equatable {
    /// <p>Attributes map that is associated with the object. <code>AttributeArn</code> is the
    ///       key, and attribute value is the value.</p>
    public let attributes: [AttributeKeyAndValue]?
    /// <p>The pagination token.</p>
    public let nextToken: String?

    public init (
        attributes: [AttributeKeyAndValue]? = nil,
        nextToken: String? = nil
    )
    {
        self.attributes = attributes
        self.nextToken = nextToken
    }
}

struct ListObjectAttributesOutputResponseBody: Equatable {
    public let attributes: [AttributeKeyAndValue]?
    public let nextToken: String?
}

extension ListObjectAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([AttributeKeyAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[AttributeKeyAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [AttributeKeyAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListObjectChildrenInputBodyMiddleware: Middleware {
    public let id: String = "ListObjectChildrenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectChildrenInput>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectChildrenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectChildrenInput>
    public typealias MOutput = OperationOutput<ListObjectChildrenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectChildrenOutputError>
}

extension ListObjectChildrenInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListObjectChildrenInput(consistencyLevel: \(String(describing: consistencyLevel)), directoryArn: \(String(describing: directoryArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), objectReference: \(String(describing: objectReference)))"}
}

extension ListObjectChildrenInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct ListObjectChildrenInputHeadersMiddleware: Middleware {
    public let id: String = "ListObjectChildrenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectChildrenInput>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectChildrenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let consistencyLevel = input.operationInput.consistencyLevel {
            input.builder.withHeader(name: "x-amz-consistency-level", value: String(consistencyLevel.rawValue))
        }
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectChildrenInput>
    public typealias MOutput = OperationOutput<ListObjectChildrenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectChildrenOutputError>
}

public struct ListObjectChildrenInputQueryItemMiddleware: Middleware {
    public let id: String = "ListObjectChildrenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectChildrenInput>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectChildrenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectChildrenInput>
    public typealias MOutput = OperationOutput<ListObjectChildrenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectChildrenOutputError>
}

public struct ListObjectChildrenInput: Equatable {
    /// <p>Represents the manner and timing in which the successful write or update of an object
    ///       is reflected in a subsequent read operation of that same object.</p>
    public let consistencyLevel: ConsistencyLevel?
    /// <p>The Amazon Resource Name (ARN) that is associated with the <a>Directory</a>
    ///       where the object resides. For more information, see <a>arns</a>.</p>
    public let directoryArn: String?
    /// <p>The maximum number of items to be retrieved in a single call. This is an approximate
    ///       number.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The reference that identifies the object for which child objects are being
    ///       listed.</p>
    public let objectReference: ObjectReference?

    public init (
        consistencyLevel: ConsistencyLevel? = nil,
        directoryArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        objectReference: ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListObjectChildrenInputBody: Equatable {
    public let objectReference: ObjectReference?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListObjectChildrenInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListObjectChildrenOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListObjectChildrenOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotNodeException" : self = .notNodeException(try NotNodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListObjectChildrenOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case notNodeException(NotNodeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListObjectChildrenOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListObjectChildrenOutputResponse(children: \(String(describing: children)), nextToken: \(String(describing: nextToken)))"}
}

extension ListObjectChildrenOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListObjectChildrenOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.children = output.children
            self.nextToken = output.nextToken
        } else {
            self.children = nil
            self.nextToken = nil
        }
    }
}

public struct ListObjectChildrenOutputResponse: Equatable {
    /// <p>Children structure, which is a map with key as the <code>LinkName</code> and
    ///         <code>ObjectIdentifier</code> as the value.</p>
    public let children: [String:String]?
    /// <p>The pagination token.</p>
    public let nextToken: String?

    public init (
        children: [String:String]? = nil,
        nextToken: String? = nil
    )
    {
        self.children = children
        self.nextToken = nextToken
    }
}

struct ListObjectChildrenOutputResponseBody: Equatable {
    public let children: [String:String]?
    public let nextToken: String?
}

extension ListObjectChildrenOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case children = "Children"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let childrenContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .children)
        var childrenDecoded0: [String:String]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [String:String]()
            for (key0, objectidentifier0) in childrenContainer {
                if let objectidentifier0 = objectidentifier0 {
                    childrenDecoded0?[key0] = objectidentifier0
                }
            }
        }
        children = childrenDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListObjectParentPathsInputBodyMiddleware: Middleware {
    public let id: String = "ListObjectParentPathsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectParentPathsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectParentPathsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectParentPathsInput>
    public typealias MOutput = OperationOutput<ListObjectParentPathsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectParentPathsOutputError>
}

extension ListObjectParentPathsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListObjectParentPathsInput(directoryArn: \(String(describing: directoryArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), objectReference: \(String(describing: objectReference)))"}
}

extension ListObjectParentPathsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct ListObjectParentPathsInputHeadersMiddleware: Middleware {
    public let id: String = "ListObjectParentPathsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectParentPathsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectParentPathsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectParentPathsInput>
    public typealias MOutput = OperationOutput<ListObjectParentPathsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectParentPathsOutputError>
}

public struct ListObjectParentPathsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListObjectParentPathsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectParentPathsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectParentPathsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectParentPathsInput>
    public typealias MOutput = OperationOutput<ListObjectParentPathsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectParentPathsOutputError>
}

public struct ListObjectParentPathsInput: Equatable {
    /// <p>The ARN of the directory to which the parent path applies.</p>
    public let directoryArn: String?
    /// <p>The maximum number of items to be retrieved in a single call. This is an approximate
    ///       number.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The reference that identifies the object whose parent paths are listed.</p>
    public let objectReference: ObjectReference?

    public init (
        directoryArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        objectReference: ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListObjectParentPathsInputBody: Equatable {
    public let objectReference: ObjectReference?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListObjectParentPathsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListObjectParentPathsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListObjectParentPathsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListObjectParentPathsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListObjectParentPathsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListObjectParentPathsOutputResponse(nextToken: \(String(describing: nextToken)), pathToObjectIdentifiersList: \(String(describing: pathToObjectIdentifiersList)))"}
}

extension ListObjectParentPathsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListObjectParentPathsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.pathToObjectIdentifiersList = output.pathToObjectIdentifiersList
        } else {
            self.nextToken = nil
            self.pathToObjectIdentifiersList = nil
        }
    }
}

public struct ListObjectParentPathsOutputResponse: Equatable {
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>Returns the path to the <code>ObjectIdentifiers</code> that are associated with the
    ///       directory.</p>
    public let pathToObjectIdentifiersList: [PathToObjectIdentifiers]?

    public init (
        nextToken: String? = nil,
        pathToObjectIdentifiersList: [PathToObjectIdentifiers]? = nil
    )
    {
        self.nextToken = nextToken
        self.pathToObjectIdentifiersList = pathToObjectIdentifiersList
    }
}

struct ListObjectParentPathsOutputResponseBody: Equatable {
    public let pathToObjectIdentifiersList: [PathToObjectIdentifiers]?
    public let nextToken: String?
}

extension ListObjectParentPathsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case pathToObjectIdentifiersList = "PathToObjectIdentifiersList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathToObjectIdentifiersListContainer = try containerValues.decodeIfPresent([PathToObjectIdentifiers?].self, forKey: .pathToObjectIdentifiersList)
        var pathToObjectIdentifiersListDecoded0:[PathToObjectIdentifiers]? = nil
        if let pathToObjectIdentifiersListContainer = pathToObjectIdentifiersListContainer {
            pathToObjectIdentifiersListDecoded0 = [PathToObjectIdentifiers]()
            for structure0 in pathToObjectIdentifiersListContainer {
                if let structure0 = structure0 {
                    pathToObjectIdentifiersListDecoded0?.append(structure0)
                }
            }
        }
        pathToObjectIdentifiersList = pathToObjectIdentifiersListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListObjectParentsInputBodyMiddleware: Middleware {
    public let id: String = "ListObjectParentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectParentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectParentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectParentsInput>
    public typealias MOutput = OperationOutput<ListObjectParentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectParentsOutputError>
}

extension ListObjectParentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListObjectParentsInput(consistencyLevel: \(String(describing: consistencyLevel)), directoryArn: \(String(describing: directoryArn)), includeAllLinksToEachParent: \(String(describing: includeAllLinksToEachParent)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), objectReference: \(String(describing: objectReference)))"}
}

extension ListObjectParentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case includeAllLinksToEachParent = "IncludeAllLinksToEachParent"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if includeAllLinksToEachParent != false {
            try encodeContainer.encode(includeAllLinksToEachParent, forKey: .includeAllLinksToEachParent)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct ListObjectParentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListObjectParentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectParentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectParentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let consistencyLevel = input.operationInput.consistencyLevel {
            input.builder.withHeader(name: "x-amz-consistency-level", value: String(consistencyLevel.rawValue))
        }
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectParentsInput>
    public typealias MOutput = OperationOutput<ListObjectParentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectParentsOutputError>
}

public struct ListObjectParentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListObjectParentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectParentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectParentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectParentsInput>
    public typealias MOutput = OperationOutput<ListObjectParentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectParentsOutputError>
}

public struct ListObjectParentsInput: Equatable {
    /// <p>Represents the manner and timing in which the successful write or update of an object
    ///       is reflected in a subsequent read operation of that same object.</p>
    public let consistencyLevel: ConsistencyLevel?
    /// <p>The Amazon Resource Name (ARN) that is associated with the <a>Directory</a>
    ///       where the object resides. For more information, see <a>arns</a>.</p>
    public let directoryArn: String?
    /// <p>When set to True, returns all <a>ListObjectParentsResponse$ParentLinks</a>. There could be multiple links between a parent-child pair.</p>
    public let includeAllLinksToEachParent: Bool
    /// <p>The maximum number of items to be retrieved in a single call. This is an approximate
    ///       number.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The reference that identifies the object for which parent objects are being
    ///       listed.</p>
    public let objectReference: ObjectReference?

    public init (
        consistencyLevel: ConsistencyLevel? = nil,
        directoryArn: String? = nil,
        includeAllLinksToEachParent: Bool = false,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        objectReference: ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.includeAllLinksToEachParent = includeAllLinksToEachParent
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListObjectParentsInputBody: Equatable {
    public let objectReference: ObjectReference?
    public let nextToken: String?
    public let maxResults: Int?
    public let includeAllLinksToEachParent: Bool
}

extension ListObjectParentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case includeAllLinksToEachParent = "IncludeAllLinksToEachParent"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let includeAllLinksToEachParentDecoded = try containerValues.decode(Bool.self, forKey: .includeAllLinksToEachParent)
        includeAllLinksToEachParent = includeAllLinksToEachParentDecoded
    }
}

extension ListObjectParentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListObjectParentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CannotListParentOfRootException" : self = .cannotListParentOfRootException(try CannotListParentOfRootException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListObjectParentsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case cannotListParentOfRootException(CannotListParentOfRootException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListObjectParentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListObjectParentsOutputResponse(nextToken: \(String(describing: nextToken)), parentLinks: \(String(describing: parentLinks)), parents: \(String(describing: parents)))"}
}

extension ListObjectParentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListObjectParentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.parentLinks = output.parentLinks
            self.parents = output.parents
        } else {
            self.nextToken = nil
            self.parentLinks = nil
            self.parents = nil
        }
    }
}

public struct ListObjectParentsOutputResponse: Equatable {
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>Returns a list of parent reference and LinkName Tuples.</p>
    public let parentLinks: [ObjectIdentifierAndLinkNameTuple]?
    /// <p>The parent structure, which is a map with key as the <code>ObjectIdentifier</code> and
    ///       LinkName as the value.</p>
    public let parents: [String:String]?

    public init (
        nextToken: String? = nil,
        parentLinks: [ObjectIdentifierAndLinkNameTuple]? = nil,
        parents: [String:String]? = nil
    )
    {
        self.nextToken = nextToken
        self.parentLinks = parentLinks
        self.parents = parents
    }
}

struct ListObjectParentsOutputResponseBody: Equatable {
    public let parents: [String:String]?
    public let nextToken: String?
    public let parentLinks: [ObjectIdentifierAndLinkNameTuple]?
}

extension ListObjectParentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case parentLinks = "ParentLinks"
        case parents = "Parents"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parents)
        var parentsDecoded0: [String:String]? = nil
        if let parentsContainer = parentsContainer {
            parentsDecoded0 = [String:String]()
            for (key0, linkname0) in parentsContainer {
                if let linkname0 = linkname0 {
                    parentsDecoded0?[key0] = linkname0
                }
            }
        }
        parents = parentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let parentLinksContainer = try containerValues.decodeIfPresent([ObjectIdentifierAndLinkNameTuple?].self, forKey: .parentLinks)
        var parentLinksDecoded0:[ObjectIdentifierAndLinkNameTuple]? = nil
        if let parentLinksContainer = parentLinksContainer {
            parentLinksDecoded0 = [ObjectIdentifierAndLinkNameTuple]()
            for structure0 in parentLinksContainer {
                if let structure0 = structure0 {
                    parentLinksDecoded0?.append(structure0)
                }
            }
        }
        parentLinks = parentLinksDecoded0
    }
}

public struct ListObjectPoliciesInputBodyMiddleware: Middleware {
    public let id: String = "ListObjectPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectPoliciesInput>
    public typealias MOutput = OperationOutput<ListObjectPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectPoliciesOutputError>
}

extension ListObjectPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListObjectPoliciesInput(consistencyLevel: \(String(describing: consistencyLevel)), directoryArn: \(String(describing: directoryArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), objectReference: \(String(describing: objectReference)))"}
}

extension ListObjectPoliciesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct ListObjectPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListObjectPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let consistencyLevel = input.operationInput.consistencyLevel {
            input.builder.withHeader(name: "x-amz-consistency-level", value: String(consistencyLevel.rawValue))
        }
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectPoliciesInput>
    public typealias MOutput = OperationOutput<ListObjectPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectPoliciesOutputError>
}

public struct ListObjectPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListObjectPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectPoliciesInput>
    public typealias MOutput = OperationOutput<ListObjectPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectPoliciesOutputError>
}

public struct ListObjectPoliciesInput: Equatable {
    /// <p>Represents the manner and timing in which the successful write or update of an object
    ///       is reflected in a subsequent read operation of that same object.</p>
    public let consistencyLevel: ConsistencyLevel?
    /// <p>The Amazon Resource Name (ARN) that is associated with the <a>Directory</a>
    ///       where objects reside. For more information, see <a>arns</a>.</p>
    public let directoryArn: String?
    /// <p>The maximum number of items to be retrieved in a single call. This is an approximate
    ///       number.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>Reference that identifies the object for which policies will be listed.</p>
    public let objectReference: ObjectReference?

    public init (
        consistencyLevel: ConsistencyLevel? = nil,
        directoryArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        objectReference: ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListObjectPoliciesInputBody: Equatable {
    public let objectReference: ObjectReference?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListObjectPoliciesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListObjectPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListObjectPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListObjectPoliciesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListObjectPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListObjectPoliciesOutputResponse(attachedPolicyIds: \(String(describing: attachedPolicyIds)), nextToken: \(String(describing: nextToken)))"}
}

extension ListObjectPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListObjectPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attachedPolicyIds = output.attachedPolicyIds
            self.nextToken = output.nextToken
        } else {
            self.attachedPolicyIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListObjectPoliciesOutputResponse: Equatable {
    /// <p>A list of policy <code>ObjectIdentifiers</code>, that are attached to the
    ///       object.</p>
    public let attachedPolicyIds: [String]?
    /// <p>The pagination token.</p>
    public let nextToken: String?

    public init (
        attachedPolicyIds: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.attachedPolicyIds = attachedPolicyIds
        self.nextToken = nextToken
    }
}

struct ListObjectPoliciesOutputResponseBody: Equatable {
    public let attachedPolicyIds: [String]?
    public let nextToken: String?
}

extension ListObjectPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attachedPolicyIds = "AttachedPolicyIds"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedPolicyIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .attachedPolicyIds)
        var attachedPolicyIdsDecoded0:[String]? = nil
        if let attachedPolicyIdsContainer = attachedPolicyIdsContainer {
            attachedPolicyIdsDecoded0 = [String]()
            for string0 in attachedPolicyIdsContainer {
                if let string0 = string0 {
                    attachedPolicyIdsDecoded0?.append(string0)
                }
            }
        }
        attachedPolicyIds = attachedPolicyIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListOutgoingTypedLinksInputBodyMiddleware: Middleware {
    public let id: String = "ListOutgoingTypedLinksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOutgoingTypedLinksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOutgoingTypedLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOutgoingTypedLinksInput>
    public typealias MOutput = OperationOutput<ListOutgoingTypedLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOutgoingTypedLinksOutputError>
}

extension ListOutgoingTypedLinksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOutgoingTypedLinksInput(consistencyLevel: \(String(describing: consistencyLevel)), directoryArn: \(String(describing: directoryArn)), filterAttributeRanges: \(String(describing: filterAttributeRanges)), filterTypedLink: \(String(describing: filterTypedLink)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), objectReference: \(String(describing: objectReference)))"}
}

extension ListOutgoingTypedLinksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case consistencyLevel = "ConsistencyLevel"
        case filterAttributeRanges = "FilterAttributeRanges"
        case filterTypedLink = "FilterTypedLink"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consistencyLevel = consistencyLevel {
            try encodeContainer.encode(consistencyLevel.rawValue, forKey: .consistencyLevel)
        }
        if let filterAttributeRanges = filterAttributeRanges {
            var filterAttributeRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterAttributeRanges)
            for typedlinkattributerangelist0 in filterAttributeRanges {
                try filterAttributeRangesContainer.encode(typedlinkattributerangelist0)
            }
        }
        if let filterTypedLink = filterTypedLink {
            try encodeContainer.encode(filterTypedLink, forKey: .filterTypedLink)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct ListOutgoingTypedLinksInputHeadersMiddleware: Middleware {
    public let id: String = "ListOutgoingTypedLinksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOutgoingTypedLinksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOutgoingTypedLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOutgoingTypedLinksInput>
    public typealias MOutput = OperationOutput<ListOutgoingTypedLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOutgoingTypedLinksOutputError>
}

public struct ListOutgoingTypedLinksInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOutgoingTypedLinksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOutgoingTypedLinksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOutgoingTypedLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOutgoingTypedLinksInput>
    public typealias MOutput = OperationOutput<ListOutgoingTypedLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOutgoingTypedLinksOutputError>
}

public struct ListOutgoingTypedLinksInput: Equatable {
    /// <p>The consistency level to execute the request at.</p>
    public let consistencyLevel: ConsistencyLevel?
    /// <p>The Amazon Resource Name (ARN) of the directory where you want to list the typed
    ///       links.</p>
    public let directoryArn: String?
    /// <p>Provides range filters for multiple attributes. When providing ranges to typed link
    ///       selection, any inexact ranges must be specified at the end. Any attributes that do not have a
    ///       range specified are presumed to match the entire range.</p>
    public let filterAttributeRanges: [TypedLinkAttributeRange]?
    /// <p>Filters are interpreted in the order of the attributes defined on the typed link facet,
    ///       not the order they are supplied to any API calls.</p>
    public let filterTypedLink: TypedLinkSchemaAndFacetName?
    /// <p>The maximum number of results to retrieve.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>A reference that identifies the object whose attributes will be listed.</p>
    public let objectReference: ObjectReference?

    public init (
        consistencyLevel: ConsistencyLevel? = nil,
        directoryArn: String? = nil,
        filterAttributeRanges: [TypedLinkAttributeRange]? = nil,
        filterTypedLink: TypedLinkSchemaAndFacetName? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        objectReference: ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.filterAttributeRanges = filterAttributeRanges
        self.filterTypedLink = filterTypedLink
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListOutgoingTypedLinksInputBody: Equatable {
    public let objectReference: ObjectReference?
    public let filterAttributeRanges: [TypedLinkAttributeRange]?
    public let filterTypedLink: TypedLinkSchemaAndFacetName?
    public let nextToken: String?
    public let maxResults: Int?
    public let consistencyLevel: ConsistencyLevel?
}

extension ListOutgoingTypedLinksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case consistencyLevel = "ConsistencyLevel"
        case filterAttributeRanges = "FilterAttributeRanges"
        case filterTypedLink = "FilterTypedLink"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let filterAttributeRangesContainer = try containerValues.decodeIfPresent([TypedLinkAttributeRange?].self, forKey: .filterAttributeRanges)
        var filterAttributeRangesDecoded0:[TypedLinkAttributeRange]? = nil
        if let filterAttributeRangesContainer = filterAttributeRangesContainer {
            filterAttributeRangesDecoded0 = [TypedLinkAttributeRange]()
            for structure0 in filterAttributeRangesContainer {
                if let structure0 = structure0 {
                    filterAttributeRangesDecoded0?.append(structure0)
                }
            }
        }
        filterAttributeRanges = filterAttributeRangesDecoded0
        let filterTypedLinkDecoded = try containerValues.decodeIfPresent(TypedLinkSchemaAndFacetName.self, forKey: .filterTypedLink)
        filterTypedLink = filterTypedLinkDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let consistencyLevelDecoded = try containerValues.decodeIfPresent(ConsistencyLevel.self, forKey: .consistencyLevel)
        consistencyLevel = consistencyLevelDecoded
    }
}

extension ListOutgoingTypedLinksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOutgoingTypedLinksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOutgoingTypedLinksOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOutgoingTypedLinksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOutgoingTypedLinksOutputResponse(nextToken: \(String(describing: nextToken)), typedLinkSpecifiers: \(String(describing: typedLinkSpecifiers)))"}
}

extension ListOutgoingTypedLinksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOutgoingTypedLinksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.typedLinkSpecifiers = output.typedLinkSpecifiers
        } else {
            self.nextToken = nil
            self.typedLinkSpecifiers = nil
        }
    }
}

public struct ListOutgoingTypedLinksOutputResponse: Equatable {
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>Returns a typed link specifier as output.</p>
    public let typedLinkSpecifiers: [TypedLinkSpecifier]?

    public init (
        nextToken: String? = nil,
        typedLinkSpecifiers: [TypedLinkSpecifier]? = nil
    )
    {
        self.nextToken = nextToken
        self.typedLinkSpecifiers = typedLinkSpecifiers
    }
}

struct ListOutgoingTypedLinksOutputResponseBody: Equatable {
    public let typedLinkSpecifiers: [TypedLinkSpecifier]?
    public let nextToken: String?
}

extension ListOutgoingTypedLinksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case typedLinkSpecifiers = "TypedLinkSpecifiers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifiersContainer = try containerValues.decodeIfPresent([TypedLinkSpecifier?].self, forKey: .typedLinkSpecifiers)
        var typedLinkSpecifiersDecoded0:[TypedLinkSpecifier]? = nil
        if let typedLinkSpecifiersContainer = typedLinkSpecifiersContainer {
            typedLinkSpecifiersDecoded0 = [TypedLinkSpecifier]()
            for structure0 in typedLinkSpecifiersContainer {
                if let structure0 = structure0 {
                    typedLinkSpecifiersDecoded0?.append(structure0)
                }
            }
        }
        typedLinkSpecifiers = typedLinkSpecifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPolicyAttachmentsInputBodyMiddleware: Middleware {
    public let id: String = "ListPolicyAttachmentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPolicyAttachmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPolicyAttachmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPolicyAttachmentsInput>
    public typealias MOutput = OperationOutput<ListPolicyAttachmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPolicyAttachmentsOutputError>
}

extension ListPolicyAttachmentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPolicyAttachmentsInput(consistencyLevel: \(String(describing: consistencyLevel)), directoryArn: \(String(describing: directoryArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), policyReference: \(String(describing: policyReference)))"}
}

extension ListPolicyAttachmentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case policyReference = "PolicyReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let policyReference = policyReference {
            try encodeContainer.encode(policyReference, forKey: .policyReference)
        }
    }
}

public struct ListPolicyAttachmentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPolicyAttachmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPolicyAttachmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPolicyAttachmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let consistencyLevel = input.operationInput.consistencyLevel {
            input.builder.withHeader(name: "x-amz-consistency-level", value: String(consistencyLevel.rawValue))
        }
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPolicyAttachmentsInput>
    public typealias MOutput = OperationOutput<ListPolicyAttachmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPolicyAttachmentsOutputError>
}

public struct ListPolicyAttachmentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPolicyAttachmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPolicyAttachmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPolicyAttachmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPolicyAttachmentsInput>
    public typealias MOutput = OperationOutput<ListPolicyAttachmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPolicyAttachmentsOutputError>
}

public struct ListPolicyAttachmentsInput: Equatable {
    /// <p>Represents the manner and timing in which the successful write or update of an object
    ///       is reflected in a subsequent read operation of that same object.</p>
    public let consistencyLevel: ConsistencyLevel?
    /// <p>The Amazon Resource Name (ARN) that is associated with the <a>Directory</a>
    ///       where objects reside. For more information, see <a>arns</a>.</p>
    public let directoryArn: String?
    /// <p>The maximum number of items to be retrieved in a single call. This is an approximate
    ///       number.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The reference that identifies the policy object.</p>
    public let policyReference: ObjectReference?

    public init (
        consistencyLevel: ConsistencyLevel? = nil,
        directoryArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        policyReference: ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyReference = policyReference
    }
}

struct ListPolicyAttachmentsInputBody: Equatable {
    public let policyReference: ObjectReference?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListPolicyAttachmentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case policyReference = "PolicyReference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .policyReference)
        policyReference = policyReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPolicyAttachmentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPolicyAttachmentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotPolicyException" : self = .notPolicyException(try NotPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPolicyAttachmentsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case notPolicyException(NotPolicyException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPolicyAttachmentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPolicyAttachmentsOutputResponse(nextToken: \(String(describing: nextToken)), objectIdentifiers: \(String(describing: objectIdentifiers)))"}
}

extension ListPolicyAttachmentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPolicyAttachmentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.objectIdentifiers = output.objectIdentifiers
        } else {
            self.nextToken = nil
            self.objectIdentifiers = nil
        }
    }
}

public struct ListPolicyAttachmentsOutputResponse: Equatable {
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>A list of <code>ObjectIdentifiers</code> to which the policy is attached.</p>
    public let objectIdentifiers: [String]?

    public init (
        nextToken: String? = nil,
        objectIdentifiers: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.objectIdentifiers = objectIdentifiers
    }
}

struct ListPolicyAttachmentsOutputResponseBody: Equatable {
    public let objectIdentifiers: [String]?
    public let nextToken: String?
}

extension ListPolicyAttachmentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case objectIdentifiers = "ObjectIdentifiers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifiersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .objectIdentifiers)
        var objectIdentifiersDecoded0:[String]? = nil
        if let objectIdentifiersContainer = objectIdentifiersContainer {
            objectIdentifiersDecoded0 = [String]()
            for string0 in objectIdentifiersContainer {
                if let string0 = string0 {
                    objectIdentifiersDecoded0?.append(string0)
                }
            }
        }
        objectIdentifiers = objectIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPublishedSchemaArnsInputBodyMiddleware: Middleware {
    public let id: String = "ListPublishedSchemaArnsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPublishedSchemaArnsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPublishedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPublishedSchemaArnsInput>
    public typealias MOutput = OperationOutput<ListPublishedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPublishedSchemaArnsOutputError>
}

extension ListPublishedSchemaArnsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPublishedSchemaArnsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), schemaArn: \(String(describing: schemaArn)))"}
}

extension ListPublishedSchemaArnsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaArn = "SchemaArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

public struct ListPublishedSchemaArnsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPublishedSchemaArnsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPublishedSchemaArnsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPublishedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPublishedSchemaArnsInput>
    public typealias MOutput = OperationOutput<ListPublishedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPublishedSchemaArnsOutputError>
}

public struct ListPublishedSchemaArnsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPublishedSchemaArnsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPublishedSchemaArnsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPublishedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPublishedSchemaArnsInput>
    public typealias MOutput = OperationOutput<ListPublishedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPublishedSchemaArnsOutputError>
}

public struct ListPublishedSchemaArnsInput: Equatable {
    /// <p>The maximum number of results to retrieve.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The response for <code>ListPublishedSchemaArns</code> when this parameter is used will list all minor version ARNs for a major version.</p>
    public let schemaArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        schemaArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListPublishedSchemaArnsInputBody: Equatable {
    public let schemaArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListPublishedSchemaArnsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaArn = "SchemaArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPublishedSchemaArnsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPublishedSchemaArnsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPublishedSchemaArnsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPublishedSchemaArnsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPublishedSchemaArnsOutputResponse(nextToken: \(String(describing: nextToken)), schemaArns: \(String(describing: schemaArns)))"}
}

extension ListPublishedSchemaArnsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPublishedSchemaArnsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.schemaArns = output.schemaArns
        } else {
            self.nextToken = nil
            self.schemaArns = nil
        }
    }
}

public struct ListPublishedSchemaArnsOutputResponse: Equatable {
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The ARNs of published schemas.</p>
    public let schemaArns: [String]?

    public init (
        nextToken: String? = nil,
        schemaArns: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaArns = schemaArns
    }
}

struct ListPublishedSchemaArnsOutputResponseBody: Equatable {
    public let schemaArns: [String]?
    public let nextToken: String?
}

extension ListPublishedSchemaArnsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case schemaArns = "SchemaArns"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .schemaArns)
        var schemaArnsDecoded0:[String]? = nil
        if let schemaArnsContainer = schemaArnsContainer {
            schemaArnsDecoded0 = [String]()
            for string0 in schemaArnsContainer {
                if let string0 = string0 {
                    schemaArnsDecoded0?.append(string0)
                }
            }
        }
        schemaArns = schemaArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The <code>MaxResults</code> parameter sets the maximum number of results returned in a
    ///       single page. This is for future use and is not supported currently.</p>
    public let maxResults: Int?
    /// <p>The pagination token. This is for future use. Currently pagination is not supported for
    ///       tagging.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the resource. Tagging is only supported for
    ///       directories.</p>
    public let resourceArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTaggingRequestException" : self = .invalidTaggingRequestException(try InvalidTaggingRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidTaggingRequestException(InvalidTaggingRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is null when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>A list of tag key value pairs that are associated with the response.</p>
    public let tags: [Tag]?

    public init (
        nextToken: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let nextToken: String?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTypedLinkFacetAttributesInputBodyMiddleware: Middleware {
    public let id: String = "ListTypedLinkFacetAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTypedLinkFacetAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTypedLinkFacetAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTypedLinkFacetAttributesInput>
    public typealias MOutput = OperationOutput<ListTypedLinkFacetAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTypedLinkFacetAttributesOutputError>
}

extension ListTypedLinkFacetAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTypedLinkFacetAttributesInput(maxResults: \(String(describing: maxResults)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)), schemaArn: \(String(describing: schemaArn)))"}
}

extension ListTypedLinkFacetAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTypedLinkFacetAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "ListTypedLinkFacetAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTypedLinkFacetAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTypedLinkFacetAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTypedLinkFacetAttributesInput>
    public typealias MOutput = OperationOutput<ListTypedLinkFacetAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTypedLinkFacetAttributesOutputError>
}

public struct ListTypedLinkFacetAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTypedLinkFacetAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTypedLinkFacetAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTypedLinkFacetAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTypedLinkFacetAttributesInput>
    public typealias MOutput = OperationOutput<ListTypedLinkFacetAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTypedLinkFacetAttributesOutputError>
}

public struct ListTypedLinkFacetAttributesInput: Equatable {
    /// <p>The maximum number of results to retrieve.</p>
    public let maxResults: Int?
    /// <p>The unique name of the typed link facet.</p>
    public let name: String?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) that is associated with the schema. For more
    ///       information, see <a>arns</a>.</p>
    public let schemaArn: String?

    public init (
        maxResults: Int? = nil,
        name: String? = nil,
        nextToken: String? = nil,
        schemaArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListTypedLinkFacetAttributesInputBody: Equatable {
    public let name: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListTypedLinkFacetAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTypedLinkFacetAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTypedLinkFacetAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetNotFoundException" : self = .facetNotFoundException(try FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTypedLinkFacetAttributesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case facetNotFoundException(FacetNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTypedLinkFacetAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTypedLinkFacetAttributesOutputResponse(attributes: \(String(describing: attributes)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTypedLinkFacetAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTypedLinkFacetAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributes = output.attributes
            self.nextToken = output.nextToken
        } else {
            self.attributes = nil
            self.nextToken = nil
        }
    }
}

public struct ListTypedLinkFacetAttributesOutputResponse: Equatable {
    /// <p>An ordered set of attributes associate with the typed link.</p>
    public let attributes: [TypedLinkAttributeDefinition]?
    /// <p>The pagination token.</p>
    public let nextToken: String?

    public init (
        attributes: [TypedLinkAttributeDefinition]? = nil,
        nextToken: String? = nil
    )
    {
        self.attributes = attributes
        self.nextToken = nextToken
    }
}

struct ListTypedLinkFacetAttributesOutputResponseBody: Equatable {
    public let attributes: [TypedLinkAttributeDefinition]?
    public let nextToken: String?
}

extension ListTypedLinkFacetAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([TypedLinkAttributeDefinition?].self, forKey: .attributes)
        var attributesDecoded0:[TypedLinkAttributeDefinition]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [TypedLinkAttributeDefinition]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTypedLinkFacetNamesInputBodyMiddleware: Middleware {
    public let id: String = "ListTypedLinkFacetNamesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTypedLinkFacetNamesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTypedLinkFacetNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTypedLinkFacetNamesInput>
    public typealias MOutput = OperationOutput<ListTypedLinkFacetNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTypedLinkFacetNamesOutputError>
}

extension ListTypedLinkFacetNamesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTypedLinkFacetNamesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), schemaArn: \(String(describing: schemaArn)))"}
}

extension ListTypedLinkFacetNamesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTypedLinkFacetNamesInputHeadersMiddleware: Middleware {
    public let id: String = "ListTypedLinkFacetNamesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTypedLinkFacetNamesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTypedLinkFacetNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTypedLinkFacetNamesInput>
    public typealias MOutput = OperationOutput<ListTypedLinkFacetNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTypedLinkFacetNamesOutputError>
}

public struct ListTypedLinkFacetNamesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTypedLinkFacetNamesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTypedLinkFacetNamesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTypedLinkFacetNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTypedLinkFacetNamesInput>
    public typealias MOutput = OperationOutput<ListTypedLinkFacetNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTypedLinkFacetNamesOutputError>
}

public struct ListTypedLinkFacetNamesInput: Equatable {
    /// <p>The maximum number of results to retrieve.</p>
    public let maxResults: Int?
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) that is associated with the schema. For more
    ///       information, see <a>arns</a>.</p>
    public let schemaArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        schemaArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListTypedLinkFacetNamesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListTypedLinkFacetNamesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTypedLinkFacetNamesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTypedLinkFacetNamesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTypedLinkFacetNamesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTypedLinkFacetNamesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTypedLinkFacetNamesOutputResponse(facetNames: \(String(describing: facetNames)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTypedLinkFacetNamesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTypedLinkFacetNamesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.facetNames = output.facetNames
            self.nextToken = output.nextToken
        } else {
            self.facetNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListTypedLinkFacetNamesOutputResponse: Equatable {
    /// <p>The names of typed link facets that exist within the schema.</p>
    public let facetNames: [String]?
    /// <p>The pagination token.</p>
    public let nextToken: String?

    public init (
        facetNames: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.facetNames = facetNames
        self.nextToken = nextToken
    }
}

struct ListTypedLinkFacetNamesOutputResponseBody: Equatable {
    public let facetNames: [String]?
    public let nextToken: String?
}

extension ListTypedLinkFacetNamesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case facetNames = "FacetNames"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let facetNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .facetNames)
        var facetNamesDecoded0:[String]? = nil
        if let facetNamesContainer = facetNamesContainer {
            facetNamesDecoded0 = [String]()
            for string0 in facetNamesContainer {
                if let string0 = string0 {
                    facetNamesDecoded0?.append(string0)
                }
            }
        }
        facetNames = facetNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct LookupPolicyInputBodyMiddleware: Middleware {
    public let id: String = "LookupPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<LookupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<LookupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<LookupPolicyInput>
    public typealias MOutput = OperationOutput<LookupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<LookupPolicyOutputError>
}

extension LookupPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LookupPolicyInput(directoryArn: \(String(describing: directoryArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), objectReference: \(String(describing: objectReference)))"}
}

extension LookupPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct LookupPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "LookupPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<LookupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<LookupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<LookupPolicyInput>
    public typealias MOutput = OperationOutput<LookupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<LookupPolicyOutputError>
}

public struct LookupPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "LookupPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<LookupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<LookupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<LookupPolicyInput>
    public typealias MOutput = OperationOutput<LookupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<LookupPolicyOutputError>
}

public struct LookupPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that is associated with the <a>Directory</a>.
    ///       For more information, see <a>arns</a>.</p>
    public let directoryArn: String?
    /// <p>The maximum number of items to be retrieved in a single call. This is an approximate
    ///       number.</p>
    public let maxResults: Int?
    /// <p>The token to request the next page of results.</p>
    public let nextToken: String?
    /// <p>Reference that identifies the object whose policies will be looked up.</p>
    public let objectReference: ObjectReference?

    public init (
        directoryArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        objectReference: ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct LookupPolicyInputBody: Equatable {
    public let objectReference: ObjectReference?
    public let nextToken: String?
    public let maxResults: Int?
}

extension LookupPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension LookupPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension LookupPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum LookupPolicyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension LookupPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LookupPolicyOutputResponse(nextToken: \(String(describing: nextToken)), policyToPathList: \(String(describing: policyToPathList)))"}
}

extension LookupPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LookupPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.policyToPathList = output.policyToPathList
        } else {
            self.nextToken = nil
            self.policyToPathList = nil
        }
    }
}

public struct LookupPolicyOutputResponse: Equatable {
    /// <p>The pagination token.</p>
    public let nextToken: String?
    /// <p>Provides list of path to policies. Policies contain <code>PolicyId</code>, <code>ObjectIdentifier</code>, and
    ///       <code>PolicyType</code>. For more
    ///       information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies">Policies</a>.</p>
    public let policyToPathList: [PolicyToPath]?

    public init (
        nextToken: String? = nil,
        policyToPathList: [PolicyToPath]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyToPathList = policyToPathList
    }
}

struct LookupPolicyOutputResponseBody: Equatable {
    public let policyToPathList: [PolicyToPath]?
    public let nextToken: String?
}

extension LookupPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case policyToPathList = "PolicyToPathList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyToPathListContainer = try containerValues.decodeIfPresent([PolicyToPath?].self, forKey: .policyToPathList)
        var policyToPathListDecoded0:[PolicyToPath]? = nil
        if let policyToPathListContainer = policyToPathListContainer {
            policyToPathListDecoded0 = [PolicyToPath]()
            for structure0 in policyToPathListContainer {
                if let structure0 = structure0 {
                    policyToPathListDecoded0?.append(structure0)
                }
            }
        }
        policyToPathList = policyToPathListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension NotIndexException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotIndexException(message: \(String(describing: message)))"}
}

extension NotIndexException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotIndexExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the requested operation can only operate on index objects.</p>
public struct NotIndexException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotIndexExceptionBody: Equatable {
    public let message: String?
}

extension NotIndexExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotNodeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotNodeException(message: \(String(describing: message)))"}
}

extension NotNodeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotNodeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Occurs when any invalid operations are performed on an object that is not a node, such
///       as calling <code>ListObjectChildren</code> for a leaf node object.</p>
public struct NotNodeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotNodeExceptionBody: Equatable {
    public let message: String?
}

extension NotNodeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotPolicyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotPolicyException(message: \(String(describing: message)))"}
}

extension NotPolicyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotPolicyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the requested operation can only operate on policy objects.</p>
public struct NotPolicyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotPolicyExceptionBody: Equatable {
    public let message: String?
}

extension NotPolicyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ObjectAlreadyDetachedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectAlreadyDetachedException(message: \(String(describing: message)))"}
}

extension ObjectAlreadyDetachedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ObjectAlreadyDetachedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the object is not attached to the index.</p>
public struct ObjectAlreadyDetachedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ObjectAlreadyDetachedExceptionBody: Equatable {
    public let message: String?
}

extension ObjectAlreadyDetachedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ObjectAttributeAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectAttributeActionType = "ObjectAttributeActionType"
        case objectAttributeUpdateValue = "ObjectAttributeUpdateValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectAttributeActionType = objectAttributeActionType {
            try encodeContainer.encode(objectAttributeActionType.rawValue, forKey: .objectAttributeActionType)
        }
        if let objectAttributeUpdateValue = objectAttributeUpdateValue {
            try encodeContainer.encode(objectAttributeUpdateValue, forKey: .objectAttributeUpdateValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectAttributeActionTypeDecoded = try containerValues.decodeIfPresent(UpdateActionType.self, forKey: .objectAttributeActionType)
        objectAttributeActionType = objectAttributeActionTypeDecoded
        let objectAttributeUpdateValueDecoded = try containerValues.decodeIfPresent(TypedAttributeValue.self, forKey: .objectAttributeUpdateValue)
        objectAttributeUpdateValue = objectAttributeUpdateValueDecoded
    }
}

extension ObjectAttributeAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectAttributeAction(objectAttributeActionType: \(String(describing: objectAttributeActionType)), objectAttributeUpdateValue: \(String(describing: objectAttributeUpdateValue)))"}
}

/// <p>The action to take on the object attribute.</p>
public struct ObjectAttributeAction: Equatable {
    /// <p>A type that can be either <code>Update</code> or <code>Delete</code>.</p>
    public let objectAttributeActionType: UpdateActionType?
    /// <p>The value that you want to update to.</p>
    public let objectAttributeUpdateValue: TypedAttributeValue?

    public init (
        objectAttributeActionType: UpdateActionType? = nil,
        objectAttributeUpdateValue: TypedAttributeValue? = nil
    )
    {
        self.objectAttributeActionType = objectAttributeActionType
        self.objectAttributeUpdateValue = objectAttributeUpdateValue
    }
}

extension ObjectAttributeRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeKey = "AttributeKey"
        case range = "Range"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeKey = attributeKey {
            try encodeContainer.encode(attributeKey, forKey: .attributeKey)
        }
        if let range = range {
            try encodeContainer.encode(range, forKey: .range)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeKeyDecoded = try containerValues.decodeIfPresent(AttributeKey.self, forKey: .attributeKey)
        attributeKey = attributeKeyDecoded
        let rangeDecoded = try containerValues.decodeIfPresent(TypedAttributeValueRange.self, forKey: .range)
        range = rangeDecoded
    }
}

extension ObjectAttributeRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectAttributeRange(attributeKey: \(String(describing: attributeKey)), range: \(String(describing: range)))"}
}

/// <p>A range of attributes.</p>
public struct ObjectAttributeRange: Equatable {
    /// <p>The key of the attribute that the attribute range covers.</p>
    public let attributeKey: AttributeKey?
    /// <p>The range of attribute values being selected.</p>
    public let range: TypedAttributeValueRange?

    public init (
        attributeKey: AttributeKey? = nil,
        range: TypedAttributeValueRange? = nil
    )
    {
        self.attributeKey = attributeKey
        self.range = range
    }
}

extension ObjectAttributeUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectAttributeAction = "ObjectAttributeAction"
        case objectAttributeKey = "ObjectAttributeKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectAttributeAction = objectAttributeAction {
            try encodeContainer.encode(objectAttributeAction, forKey: .objectAttributeAction)
        }
        if let objectAttributeKey = objectAttributeKey {
            try encodeContainer.encode(objectAttributeKey, forKey: .objectAttributeKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectAttributeKeyDecoded = try containerValues.decodeIfPresent(AttributeKey.self, forKey: .objectAttributeKey)
        objectAttributeKey = objectAttributeKeyDecoded
        let objectAttributeActionDecoded = try containerValues.decodeIfPresent(ObjectAttributeAction.self, forKey: .objectAttributeAction)
        objectAttributeAction = objectAttributeActionDecoded
    }
}

extension ObjectAttributeUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectAttributeUpdate(objectAttributeAction: \(String(describing: objectAttributeAction)), objectAttributeKey: \(String(describing: objectAttributeKey)))"}
}

/// <p>Structure that contains attribute update information.</p>
public struct ObjectAttributeUpdate: Equatable {
    /// <p>The action to perform as part of the attribute update.</p>
    public let objectAttributeAction: ObjectAttributeAction?
    /// <p>The key of the attribute being updated.</p>
    public let objectAttributeKey: AttributeKey?

    public init (
        objectAttributeAction: ObjectAttributeAction? = nil,
        objectAttributeKey: AttributeKey? = nil
    )
    {
        self.objectAttributeAction = objectAttributeAction
        self.objectAttributeKey = objectAttributeKey
    }
}

extension ObjectIdentifierAndLinkNameTuple: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case linkName = "LinkName"
        case objectIdentifier = "ObjectIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linkName = linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let objectIdentifier = objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkName)
        linkName = linkNameDecoded
    }
}

extension ObjectIdentifierAndLinkNameTuple: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectIdentifierAndLinkNameTuple(linkName: \(String(describing: linkName)), objectIdentifier: \(String(describing: objectIdentifier)))"}
}

/// <p>A pair of ObjectIdentifier and LinkName.</p>
public struct ObjectIdentifierAndLinkNameTuple: Equatable {
    /// <p>The name of the link between the parent and the child object.</p>
    public let linkName: String?
    /// <p>The ID that is associated with the object.</p>
    public let objectIdentifier: String?

    public init (
        linkName: String? = nil,
        objectIdentifier: String? = nil
    )
    {
        self.linkName = linkName
        self.objectIdentifier = objectIdentifier
    }
}

extension ObjectNotDetachedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectNotDetachedException(message: \(String(describing: message)))"}
}

extension ObjectNotDetachedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ObjectNotDetachedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the requested operation cannot be completed because the object has not
///       been detached from the tree.</p>
public struct ObjectNotDetachedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ObjectNotDetachedExceptionBody: Equatable {
    public let message: String?
}

extension ObjectNotDetachedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ObjectReference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case selector = "Selector"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let selector = selector {
            try encodeContainer.encode(selector, forKey: .selector)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .selector)
        selector = selectorDecoded
    }
}

extension ObjectReference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectReference(selector: \(String(describing: selector)))"}
}

/// <p>The reference that identifies an object.</p>
public struct ObjectReference: Equatable {
    /// <p>A path selector supports easy selection of an object by the parent/child links leading to it from the directory root. Use the link names from each parent/child link to construct the path. Path selectors start with a slash (/) and link names are separated by slashes. For more information about paths, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_access_objects.html">Access Objects</a>. You can identify an object in one of the following ways:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <i>$ObjectIdentifier</i> - An object identifier is an opaque string provided by Amazon Cloud Directory. When creating objects, the system will provide you with the identifier of the created object. An object’s identifier is immutable and no two objects will ever share the same object identifier</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>/some/path</i> - Identifies the object based on path</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>#SomeBatchReference</i> - Identifies the object in a batch call</p>
    ///             </li>
    ///          </ul>
    public let selector: String?

    public init (
        selector: String? = nil
    )
    {
        self.selector = selector
    }
}

public enum ObjectType {
    case index
    case leafNode
    case node
    case policy
    case sdkUnknown(String)
}

extension ObjectType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ObjectType] {
        return [
            .index,
            .leafNode,
            .node,
            .policy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .index: return "INDEX"
        case .leafNode: return "LEAF_NODE"
        case .node: return "NODE"
        case .policy: return "POLICY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ObjectType(rawValue: rawValue) ?? ObjectType.sdkUnknown(rawValue)
    }
}

extension PathToObjectIdentifiers: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectIdentifiers = "ObjectIdentifiers"
        case path = "Path"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectIdentifiers = objectIdentifiers {
            var objectIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectIdentifiers)
            for objectidentifierlist0 in objectIdentifiers {
                try objectIdentifiersContainer.encode(objectidentifierlist0)
            }
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let objectIdentifiersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .objectIdentifiers)
        var objectIdentifiersDecoded0:[String]? = nil
        if let objectIdentifiersContainer = objectIdentifiersContainer {
            objectIdentifiersDecoded0 = [String]()
            for string0 in objectIdentifiersContainer {
                if let string0 = string0 {
                    objectIdentifiersDecoded0?.append(string0)
                }
            }
        }
        objectIdentifiers = objectIdentifiersDecoded0
    }
}

extension PathToObjectIdentifiers: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PathToObjectIdentifiers(objectIdentifiers: \(String(describing: objectIdentifiers)), path: \(String(describing: path)))"}
}

/// <p>Returns the path to the <code>ObjectIdentifiers</code> that is associated with the
///       directory.</p>
public struct PathToObjectIdentifiers: Equatable {
    /// <p>Lists <code>ObjectIdentifiers</code> starting from directory root to the object in the
    ///       request.</p>
    public let objectIdentifiers: [String]?
    /// <p>The path that is used to identify the object starting from directory root.</p>
    public let path: String?

    public init (
        objectIdentifiers: [String]? = nil,
        path: String? = nil
    )
    {
        self.objectIdentifiers = objectIdentifiers
        self.path = path
    }
}

extension PolicyAttachment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectIdentifier = "ObjectIdentifier"
        case policyId = "PolicyId"
        case policyType = "PolicyType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectIdentifier = objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyType = policyType {
            try encodeContainer.encode(policyType, forKey: .policyType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
        let policyTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyType)
        policyType = policyTypeDecoded
    }
}

extension PolicyAttachment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyAttachment(objectIdentifier: \(String(describing: objectIdentifier)), policyId: \(String(describing: policyId)), policyType: \(String(describing: policyType)))"}
}

/// <p>Contains the <code>PolicyType</code>, <code>PolicyId</code>, and the <code>ObjectIdentifier</code> to which it is
///       attached. For more
///       information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies">Policies</a>.</p>
public struct PolicyAttachment: Equatable {
    /// <p>The <code>ObjectIdentifier</code> that is associated with
    ///       <code>PolicyAttachment</code>.</p>
    public let objectIdentifier: String?
    /// <p>The ID of <code>PolicyAttachment</code>.</p>
    public let policyId: String?
    /// <p>The type of policy that can be associated with <code>PolicyAttachment</code>.</p>
    public let policyType: String?

    public init (
        objectIdentifier: String? = nil,
        policyId: String? = nil,
        policyType: String? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
        self.policyId = policyId
        self.policyType = policyType
    }
}

extension PolicyToPath: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case path = "Path"
        case policies = "Policies"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let policies = policies {
            var policiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policies)
            for policyattachmentlist0 in policies {
                try policiesContainer.encode(policyattachmentlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let policiesContainer = try containerValues.decodeIfPresent([PolicyAttachment?].self, forKey: .policies)
        var policiesDecoded0:[PolicyAttachment]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [PolicyAttachment]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
    }
}

extension PolicyToPath: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyToPath(path: \(String(describing: path)), policies: \(String(describing: policies)))"}
}

/// <p>Used when a regular object exists in a <a>Directory</a> and you want to find
///       all of the policies that are associated with that object and the parent to that
///       object.</p>
public struct PolicyToPath: Equatable {
    /// <p>The path that is referenced from the root.</p>
    public let path: String?
    /// <p>List of policy objects.</p>
    public let policies: [PolicyAttachment]?

    public init (
        path: String? = nil,
        policies: [PolicyAttachment]? = nil
    )
    {
        self.path = path
        self.policies = policies
    }
}

public struct PublishSchemaInputBodyMiddleware: Middleware {
    public let id: String = "PublishSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PublishSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<PublishSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PublishSchemaInput>
    public typealias MOutput = OperationOutput<PublishSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PublishSchemaOutputError>
}

extension PublishSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublishSchemaInput(developmentSchemaArn: \(String(describing: developmentSchemaArn)), minorVersion: \(String(describing: minorVersion)), name: \(String(describing: name)), version: \(String(describing: version)))"}
}

extension PublishSchemaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case minorVersion = "MinorVersion"
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let minorVersion = minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

public struct PublishSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "PublishSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PublishSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<PublishSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let developmentSchemaArn = input.operationInput.developmentSchemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(developmentSchemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PublishSchemaInput>
    public typealias MOutput = OperationOutput<PublishSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PublishSchemaOutputError>
}

public struct PublishSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "PublishSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PublishSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<PublishSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PublishSchemaInput>
    public typealias MOutput = OperationOutput<PublishSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PublishSchemaOutputError>
}

public struct PublishSchemaInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that is associated with the development schema. For
    ///       more information, see <a>arns</a>.</p>
    public let developmentSchemaArn: String?
    /// <p>The minor version under which the schema will be published. This parameter is recommended. Schemas have both a major and minor version associated with them.</p>
    public let minorVersion: String?
    /// <p>The new name under which the schema will be published. If this is not provided, the
    ///       development schema is considered.</p>
    public let name: String?
    /// <p>The major version under which the schema will be published. Schemas have both a major and minor version associated with them.</p>
    public let version: String?

    public init (
        developmentSchemaArn: String? = nil,
        minorVersion: String? = nil,
        name: String? = nil,
        version: String? = nil
    )
    {
        self.developmentSchemaArn = developmentSchemaArn
        self.minorVersion = minorVersion
        self.name = name
        self.version = version
    }
}

struct PublishSchemaInputBody: Equatable {
    public let version: String?
    public let minorVersion: String?
    public let name: String?
}

extension PublishSchemaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case minorVersion = "MinorVersion"
        case name = "Name"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension PublishSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PublishSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SchemaAlreadyPublishedException" : self = .schemaAlreadyPublishedException(try SchemaAlreadyPublishedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PublishSchemaOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case schemaAlreadyPublishedException(SchemaAlreadyPublishedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublishSchemaOutputResponse(publishedSchemaArn: \(String(describing: publishedSchemaArn)))"}
}

extension PublishSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PublishSchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.publishedSchemaArn = output.publishedSchemaArn
        } else {
            self.publishedSchemaArn = nil
        }
    }
}

public struct PublishSchemaOutputResponse: Equatable {
    /// <p>The ARN that is associated with the published schema. For more information, see <a>arns</a>.</p>
    public let publishedSchemaArn: String?

    public init (
        publishedSchemaArn: String? = nil
    )
    {
        self.publishedSchemaArn = publishedSchemaArn
    }
}

struct PublishSchemaOutputResponseBody: Equatable {
    public let publishedSchemaArn: String?
}

extension PublishSchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publishedSchemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publishedSchemaArn)
        publishedSchemaArn = publishedSchemaArnDecoded
    }
}

public struct PutSchemaFromJsonInputBodyMiddleware: Middleware {
    public let id: String = "PutSchemaFromJsonInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSchemaFromJsonInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSchemaFromJsonOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSchemaFromJsonInput>
    public typealias MOutput = OperationOutput<PutSchemaFromJsonOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSchemaFromJsonOutputError>
}

extension PutSchemaFromJsonInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutSchemaFromJsonInput(document: \(String(describing: document)), schemaArn: \(String(describing: schemaArn)))"}
}

extension PutSchemaFromJsonInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case document = "Document"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = document {
            try encodeContainer.encode(document, forKey: .document)
        }
    }
}

public struct PutSchemaFromJsonInputHeadersMiddleware: Middleware {
    public let id: String = "PutSchemaFromJsonInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSchemaFromJsonInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSchemaFromJsonOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSchemaFromJsonInput>
    public typealias MOutput = OperationOutput<PutSchemaFromJsonOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSchemaFromJsonOutputError>
}

public struct PutSchemaFromJsonInputQueryItemMiddleware: Middleware {
    public let id: String = "PutSchemaFromJsonInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSchemaFromJsonInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSchemaFromJsonOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSchemaFromJsonInput>
    public typealias MOutput = OperationOutput<PutSchemaFromJsonOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSchemaFromJsonOutputError>
}

public struct PutSchemaFromJsonInput: Equatable {
    /// <p>The replacement JSON schema.</p>
    public let document: String?
    /// <p>The ARN of the schema to update.</p>
    public let schemaArn: String?

    public init (
        document: String? = nil,
        schemaArn: String? = nil
    )
    {
        self.document = document
        self.schemaArn = schemaArn
    }
}

struct PutSchemaFromJsonInputBody: Equatable {
    public let document: String?
}

extension PutSchemaFromJsonInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case document = "Document"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .document)
        document = documentDecoded
    }
}

extension PutSchemaFromJsonOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSchemaFromJsonOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRuleException" : self = .invalidRuleException(try InvalidRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSchemaDocException" : self = .invalidSchemaDocException(try InvalidSchemaDocException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutSchemaFromJsonOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidRuleException(InvalidRuleException)
    case invalidSchemaDocException(InvalidSchemaDocException)
    case limitExceededException(LimitExceededException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSchemaFromJsonOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutSchemaFromJsonOutputResponse(arn: \(String(describing: arn)))"}
}

extension PutSchemaFromJsonOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutSchemaFromJsonOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct PutSchemaFromJsonOutputResponse: Equatable {
    /// <p>The ARN of the schema to update.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct PutSchemaFromJsonOutputResponseBody: Equatable {
    public let arn: String?
}

extension PutSchemaFromJsonOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public enum RangeMode {
    case exclusive
    case first
    case inclusive
    case last
    case lastBeforeMissingValues
    case sdkUnknown(String)
}

extension RangeMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RangeMode] {
        return [
            .exclusive,
            .first,
            .inclusive,
            .last,
            .lastBeforeMissingValues,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .exclusive: return "EXCLUSIVE"
        case .first: return "FIRST"
        case .inclusive: return "INCLUSIVE"
        case .last: return "LAST"
        case .lastBeforeMissingValues: return "LAST_BEFORE_MISSING_VALUES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RangeMode(rawValue: rawValue) ?? RangeMode.sdkUnknown(rawValue)
    }
}

public struct RemoveFacetFromObjectInputBodyMiddleware: Middleware {
    public let id: String = "RemoveFacetFromObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveFacetFromObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveFacetFromObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveFacetFromObjectInput>
    public typealias MOutput = OperationOutput<RemoveFacetFromObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveFacetFromObjectOutputError>
}

extension RemoveFacetFromObjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveFacetFromObjectInput(directoryArn: \(String(describing: directoryArn)), objectReference: \(String(describing: objectReference)), schemaFacet: \(String(describing: schemaFacet)))"}
}

extension RemoveFacetFromObjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let schemaFacet = schemaFacet {
            try encodeContainer.encode(schemaFacet, forKey: .schemaFacet)
        }
    }
}

public struct RemoveFacetFromObjectInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveFacetFromObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveFacetFromObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveFacetFromObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveFacetFromObjectInput>
    public typealias MOutput = OperationOutput<RemoveFacetFromObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveFacetFromObjectOutputError>
}

public struct RemoveFacetFromObjectInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveFacetFromObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveFacetFromObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveFacetFromObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveFacetFromObjectInput>
    public typealias MOutput = OperationOutput<RemoveFacetFromObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveFacetFromObjectOutputError>
}

public struct RemoveFacetFromObjectInput: Equatable {
    /// <p>The ARN of the directory in which the object resides.</p>
    public let directoryArn: String?
    /// <p>A reference to the object to remove the facet from.</p>
    public let objectReference: ObjectReference?
    /// <p>The facet to remove. See <a>SchemaFacet</a> for details.</p>
    public let schemaFacet: SchemaFacet?

    public init (
        directoryArn: String? = nil,
        objectReference: ObjectReference? = nil,
        schemaFacet: SchemaFacet? = nil
    )
    {
        self.directoryArn = directoryArn
        self.objectReference = objectReference
        self.schemaFacet = schemaFacet
    }
}

struct RemoveFacetFromObjectInputBody: Equatable {
    public let schemaFacet: SchemaFacet?
    public let objectReference: ObjectReference?
}

extension RemoveFacetFromObjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetDecoded = try containerValues.decodeIfPresent(SchemaFacet.self, forKey: .schemaFacet)
        schemaFacet = schemaFacetDecoded
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension RemoveFacetFromObjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveFacetFromObjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveFacetFromObjectOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveFacetFromObjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveFacetFromObjectOutputResponse()"}
}

extension RemoveFacetFromObjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveFacetFromObjectOutputResponse: Equatable {

    public init() {}
}

struct RemoveFacetFromObjectOutputResponseBody: Equatable {
}

extension RemoveFacetFromObjectOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum RequiredAttributeBehavior {
    case notRequired
    case requiredAlways
    case sdkUnknown(String)
}

extension RequiredAttributeBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RequiredAttributeBehavior] {
        return [
            .notRequired,
            .requiredAlways,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .notRequired: return "NOT_REQUIRED"
        case .requiredAlways: return "REQUIRED_ALWAYS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RequiredAttributeBehavior(rawValue: rawValue) ?? RequiredAttributeBehavior.sdkUnknown(rawValue)
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource could not be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RetryableConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetryableConflictException(message: \(String(describing: message)))"}
}

extension RetryableConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RetryableConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Occurs when a conflict with a previous successful write is detected. For example, if a write operation occurs on an object and then an attempt is made to read the object using “SERIALIZABLE” consistency, this exception may result. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
public struct RetryableConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RetryableConflictExceptionBody: Equatable {
    public let message: String?
}

extension RetryableConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Rule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameters = "Parameters"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, ruleparametermap0) in parameters {
                try parametersContainer.encode(ruleparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(RuleType.self, forKey: .type)
        type = typeDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, ruleparametervalue0) in parametersContainer {
                if let ruleparametervalue0 = ruleparametervalue0 {
                    parametersDecoded0?[key0] = ruleparametervalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension Rule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Rule(parameters: \(String(describing: parameters)), type: \(String(describing: type)))"}
}

/// <p>Contains an Amazon Resource Name (ARN) and parameters that are associated with the
///       rule.</p>
public struct Rule: Equatable {
    /// <p>The minimum and maximum parameters that are associated with the rule.</p>
    public let parameters: [String:String]?
    /// <p>The type of attribute validation rule.</p>
    public let type: RuleType?

    public init (
        parameters: [String:String]? = nil,
        type: RuleType? = nil
    )
    {
        self.parameters = parameters
        self.type = type
    }
}

public enum RuleType {
    case binaryLength
    case numberComparison
    case stringFromSet
    case stringLength
    case sdkUnknown(String)
}

extension RuleType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RuleType] {
        return [
            .binaryLength,
            .numberComparison,
            .stringFromSet,
            .stringLength,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .binaryLength: return "BINARY_LENGTH"
        case .numberComparison: return "NUMBER_COMPARISON"
        case .stringFromSet: return "STRING_FROM_SET"
        case .stringLength: return "STRING_LENGTH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RuleType(rawValue: rawValue) ?? RuleType.sdkUnknown(rawValue)
    }
}

extension SchemaAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SchemaAlreadyExistsException(message: \(String(describing: message)))"}
}

extension SchemaAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SchemaAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a schema could not be created due to a naming conflict. Please select a
///       different name and then try again.</p>
public struct SchemaAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SchemaAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension SchemaAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SchemaAlreadyPublishedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SchemaAlreadyPublishedException(message: \(String(describing: message)))"}
}

extension SchemaAlreadyPublishedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SchemaAlreadyPublishedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a schema is already published.</p>
public struct SchemaAlreadyPublishedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SchemaAlreadyPublishedExceptionBody: Equatable {
    public let message: String?
}

extension SchemaAlreadyPublishedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SchemaFacet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case facetName = "FacetName"
        case schemaArn = "SchemaArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facetName = facetName {
            try encodeContainer.encode(facetName, forKey: .facetName)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let facetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .facetName)
        facetName = facetNameDecoded
    }
}

extension SchemaFacet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SchemaFacet(facetName: \(String(describing: facetName)), schemaArn: \(String(describing: schemaArn)))"}
}

/// <p>A facet.</p>
public struct SchemaFacet: Equatable {
    /// <p>The name of the facet.</p>
    public let facetName: String?
    /// <p>The ARN of the schema that contains the facet with no minor component. See <a>arns</a> and <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_inplaceschemaupgrade.html">In-Place Schema Upgrade</a> for a description of when to provide minor versions.</p>
    public let schemaArn: String?

    public init (
        facetName: String? = nil,
        schemaArn: String? = nil
    )
    {
        self.facetName = facetName
        self.schemaArn = schemaArn
    }
}

extension StillContainsLinksException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StillContainsLinksException(message: \(String(describing: message)))"}
}

extension StillContainsLinksException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StillContainsLinksExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The object could not be deleted because links still exist. Remove the links and then
///       try the operation again.</p>
public struct StillContainsLinksException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StillContainsLinksExceptionBody: Equatable {
    public let message: String?
}

extension StillContainsLinksExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>The tag structure that contains a tag key and value.</p>
public struct Tag: Equatable {
    /// <p>The key that is associated with the tag.</p>
    public let key: String?
    /// <p>The value that is associated with the tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource. Tagging is only supported for
    ///       directories.</p>
    public let resourceArn: String?
    /// <p>A list of tag key-value pairs.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTaggingRequestException" : self = .invalidTaggingRequestException(try InvalidTaggingRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidTaggingRequestException(InvalidTaggingRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TypedAttributeValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case binaryValue = "BinaryValue"
        case booleanValue = "BooleanValue"
        case datetimeValue = "DatetimeValue"
        case numberValue = "NumberValue"
        case stringValue = "StringValue"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .binaryValue(binaryValue):
                if let binaryValue = binaryValue {
                    try container.encode(binaryValue.base64EncodedString(), forKey: .binaryValue)
                }
            case let .booleanValue(booleanValue):
                if let booleanValue = booleanValue {
                    try container.encode(booleanValue, forKey: .booleanValue)
                }
            case let .datetimeValue(datetimeValue):
                if let datetimeValue = datetimeValue {
                    try container.encode(datetimeValue.timeIntervalSince1970, forKey: .datetimeValue)
                }
            case let .numberValue(numberValue):
                if let numberValue = numberValue {
                    try container.encode(numberValue, forKey: .numberValue)
                }
            case let .stringValue(stringValue):
                if let stringValue = stringValue {
                    try container.encode(stringValue, forKey: .stringValue)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let stringValueDecoded = try values.decodeIfPresent(String.self, forKey: .stringValue)
        if let stringValue = stringValueDecoded {
            self = .stringValue(stringValue)
            return
        }
        let binaryValueDecoded = try values.decodeIfPresent(Data.self, forKey: .binaryValue)
        if let binaryValue = binaryValueDecoded {
            self = .binaryValue(binaryValue)
            return
        }
        let booleanValueDecoded = try values.decodeIfPresent(Bool.self, forKey: .booleanValue)
        if let booleanValue = booleanValueDecoded {
            self = .booleanValue(booleanValue)
            return
        }
        let numberValueDecoded = try values.decodeIfPresent(String.self, forKey: .numberValue)
        if let numberValue = numberValueDecoded {
            self = .numberValue(numberValue)
            return
        }
        let datetimeValueDecoded = try values.decodeIfPresent(Date.self, forKey: .datetimeValue)
        if let datetimeValue = datetimeValueDecoded {
            self = .datetimeValue(datetimeValue)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Represents the data for a typed attribute. You can set one, and only one, of the
///       elements. Each attribute in an item is a name-value pair. Attributes have a single
///       value.</p>
public enum TypedAttributeValue: Equatable {
    /// <p>A string data value.</p>
    case stringValue(String?)
    /// <p>A binary data value.</p>
    case binaryValue(Data?)
    /// <p>A Boolean data value.</p>
    case booleanValue(Bool?)
    /// <p>A number data value.</p>
    case numberValue(String?)
    /// <p>A date and time value.</p>
    case datetimeValue(Date?)
    case sdkUnknown(String?)
}

extension TypedAttributeValueRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endMode = "EndMode"
        case endValue = "EndValue"
        case startMode = "StartMode"
        case startValue = "StartValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endMode = endMode {
            try encodeContainer.encode(endMode.rawValue, forKey: .endMode)
        }
        if let endValue = endValue {
            try encodeContainer.encode(endValue, forKey: .endValue)
        }
        if let startMode = startMode {
            try encodeContainer.encode(startMode.rawValue, forKey: .startMode)
        }
        if let startValue = startValue {
            try encodeContainer.encode(startValue, forKey: .startValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startModeDecoded = try containerValues.decodeIfPresent(RangeMode.self, forKey: .startMode)
        startMode = startModeDecoded
        let startValueDecoded = try containerValues.decodeIfPresent(TypedAttributeValue.self, forKey: .startValue)
        startValue = startValueDecoded
        let endModeDecoded = try containerValues.decodeIfPresent(RangeMode.self, forKey: .endMode)
        endMode = endModeDecoded
        let endValueDecoded = try containerValues.decodeIfPresent(TypedAttributeValue.self, forKey: .endValue)
        endValue = endValueDecoded
    }
}

extension TypedAttributeValueRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TypedAttributeValueRange(endMode: \(String(describing: endMode)), endValue: \(String(describing: endValue)), startMode: \(String(describing: startMode)), startValue: \(String(describing: startValue)))"}
}

/// <p>A range of attribute values. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_range_filters.html">Range Filters</a>.</p>
public struct TypedAttributeValueRange: Equatable {
    /// <p>The inclusive or exclusive range end.</p>
    public let endMode: RangeMode?
    /// <p>The attribute value to terminate the range at.</p>
    public let endValue: TypedAttributeValue?
    /// <p>The inclusive or exclusive range start.</p>
    public let startMode: RangeMode?
    /// <p>The value to start the range at.</p>
    public let startValue: TypedAttributeValue?

    public init (
        endMode: RangeMode? = nil,
        endValue: TypedAttributeValue? = nil,
        startMode: RangeMode? = nil,
        startValue: TypedAttributeValue? = nil
    )
    {
        self.endMode = endMode
        self.endValue = endValue
        self.startMode = startMode
        self.startValue = startValue
    }
}

extension TypedLinkAttributeDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValue = "DefaultValue"
        case isImmutable = "IsImmutable"
        case name = "Name"
        case requiredBehavior = "RequiredBehavior"
        case rules = "Rules"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if isImmutable != false {
            try encodeContainer.encode(isImmutable, forKey: .isImmutable)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requiredBehavior = requiredBehavior {
            try encodeContainer.encode(requiredBehavior.rawValue, forKey: .requiredBehavior)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .rules)
            for (dictKey0, rulemap0) in rules {
                try rulesContainer.encode(rulemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(FacetAttributeType.self, forKey: .type)
        type = typeDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(TypedAttributeValue.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let isImmutableDecoded = try containerValues.decode(Bool.self, forKey: .isImmutable)
        isImmutable = isImmutableDecoded
        let rulesContainer = try containerValues.decodeIfPresent([String: Rule?].self, forKey: .rules)
        var rulesDecoded0: [String:Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [String:Rule]()
            for (key0, rule0) in rulesContainer {
                if let rule0 = rule0 {
                    rulesDecoded0?[key0] = rule0
                }
            }
        }
        rules = rulesDecoded0
        let requiredBehaviorDecoded = try containerValues.decodeIfPresent(RequiredAttributeBehavior.self, forKey: .requiredBehavior)
        requiredBehavior = requiredBehaviorDecoded
    }
}

extension TypedLinkAttributeDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TypedLinkAttributeDefinition(defaultValue: \(String(describing: defaultValue)), isImmutable: \(String(describing: isImmutable)), name: \(String(describing: name)), requiredBehavior: \(String(describing: requiredBehavior)), rules: \(String(describing: rules)), type: \(String(describing: type)))"}
}

/// <p>A typed link attribute definition.</p>
public struct TypedLinkAttributeDefinition: Equatable {
    /// <p>The default value of the attribute (if configured).</p>
    public let defaultValue: TypedAttributeValue?
    /// <p>Whether the attribute is mutable or not.</p>
    public let isImmutable: Bool
    /// <p>The unique name of the typed link attribute.</p>
    public let name: String?
    /// <p>The required behavior of the <code>TypedLinkAttributeDefinition</code>.</p>
    public let requiredBehavior: RequiredAttributeBehavior?
    /// <p>Validation rules that are attached to the attribute definition.</p>
    public let rules: [String:Rule]?
    /// <p>The type of the attribute.</p>
    public let type: FacetAttributeType?

    public init (
        defaultValue: TypedAttributeValue? = nil,
        isImmutable: Bool = false,
        name: String? = nil,
        requiredBehavior: RequiredAttributeBehavior? = nil,
        rules: [String:Rule]? = nil,
        type: FacetAttributeType? = nil
    )
    {
        self.defaultValue = defaultValue
        self.isImmutable = isImmutable
        self.name = name
        self.requiredBehavior = requiredBehavior
        self.rules = rules
        self.type = type
    }
}

extension TypedLinkAttributeRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "AttributeName"
        case range = "Range"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let range = range {
            try encodeContainer.encode(range, forKey: .range)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let rangeDecoded = try containerValues.decodeIfPresent(TypedAttributeValueRange.self, forKey: .range)
        range = rangeDecoded
    }
}

extension TypedLinkAttributeRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TypedLinkAttributeRange(attributeName: \(String(describing: attributeName)), range: \(String(describing: range)))"}
}

/// <p>Identifies the range of attributes that are used by a specified filter.</p>
public struct TypedLinkAttributeRange: Equatable {
    /// <p>The unique name of the typed link attribute.</p>
    public let attributeName: String?
    /// <p>The range of attribute values that are being selected.</p>
    public let range: TypedAttributeValueRange?

    public init (
        attributeName: String? = nil,
        range: TypedAttributeValueRange? = nil
    )
    {
        self.attributeName = attributeName
        self.range = range
    }
}

extension TypedLinkFacet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case identityAttributeOrder = "IdentityAttributeOrder"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for typedlinkattributedefinitionlist0 in attributes {
                try attributesContainer.encode(typedlinkattributedefinitionlist0)
            }
        }
        if let identityAttributeOrder = identityAttributeOrder {
            var identityAttributeOrderContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identityAttributeOrder)
            for attributenamelist0 in identityAttributeOrder {
                try identityAttributeOrderContainer.encode(attributenamelist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([TypedLinkAttributeDefinition?].self, forKey: .attributes)
        var attributesDecoded0:[TypedLinkAttributeDefinition]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [TypedLinkAttributeDefinition]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let identityAttributeOrderContainer = try containerValues.decodeIfPresent([String?].self, forKey: .identityAttributeOrder)
        var identityAttributeOrderDecoded0:[String]? = nil
        if let identityAttributeOrderContainer = identityAttributeOrderContainer {
            identityAttributeOrderDecoded0 = [String]()
            for string0 in identityAttributeOrderContainer {
                if let string0 = string0 {
                    identityAttributeOrderDecoded0?.append(string0)
                }
            }
        }
        identityAttributeOrder = identityAttributeOrderDecoded0
    }
}

extension TypedLinkFacet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TypedLinkFacet(attributes: \(String(describing: attributes)), identityAttributeOrder: \(String(describing: identityAttributeOrder)), name: \(String(describing: name)))"}
}

/// <p>Defines the typed links structure and its attributes. To create a typed link facet, use
///       the <a>CreateTypedLinkFacet</a> API.</p>
public struct TypedLinkFacet: Equatable {
    /// <p>A set of key-value pairs associated with the typed link. Typed link attributes are used when you have data values that are related to the link itself, and not to one of the two objects being linked. Identity attributes also serve to distinguish the link from others of the same type between the same objects.</p>
    public let attributes: [TypedLinkAttributeDefinition]?
    /// <p>The set of attributes that distinguish links made from this facet from each other, in the order of significance. Listing typed links can filter on the values of these attributes. See <a>ListOutgoingTypedLinks</a> and <a>ListIncomingTypedLinks</a> for details.</p>
    public let identityAttributeOrder: [String]?
    /// <p>The unique name of the typed link facet.</p>
    public let name: String?

    public init (
        attributes: [TypedLinkAttributeDefinition]? = nil,
        identityAttributeOrder: [String]? = nil,
        name: String? = nil
    )
    {
        self.attributes = attributes
        self.identityAttributeOrder = identityAttributeOrder
        self.name = name
    }
}

extension TypedLinkFacetAttributeUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case attribute = "Attribute"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let attribute = attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(TypedLinkAttributeDefinition.self, forKey: .attribute)
        attribute = attributeDecoded
        let actionDecoded = try containerValues.decodeIfPresent(UpdateActionType.self, forKey: .action)
        action = actionDecoded
    }
}

extension TypedLinkFacetAttributeUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TypedLinkFacetAttributeUpdate(action: \(String(describing: action)), attribute: \(String(describing: attribute)))"}
}

/// <p>A typed link facet attribute update.</p>
public struct TypedLinkFacetAttributeUpdate: Equatable {
    /// <p>The action to perform when updating the attribute.</p>
    public let action: UpdateActionType?
    /// <p>The attribute to update.</p>
    public let attribute: TypedLinkAttributeDefinition?

    public init (
        action: UpdateActionType? = nil,
        attribute: TypedLinkAttributeDefinition? = nil
    )
    {
        self.action = action
        self.attribute = attribute
    }
}

extension TypedLinkSchemaAndFacetName: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case schemaArn = "SchemaArn"
        case typedLinkName = "TypedLinkName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let typedLinkName = typedLinkName {
            try encodeContainer.encode(typedLinkName, forKey: .typedLinkName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let typedLinkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typedLinkName)
        typedLinkName = typedLinkNameDecoded
    }
}

extension TypedLinkSchemaAndFacetName: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TypedLinkSchemaAndFacetName(schemaArn: \(String(describing: schemaArn)), typedLinkName: \(String(describing: typedLinkName)))"}
}

/// <p>Identifies the schema Amazon Resource Name (ARN) and facet name for the typed
///       link.</p>
public struct TypedLinkSchemaAndFacetName: Equatable {
    /// <p>The Amazon Resource Name (ARN) that is associated with the schema. For more
    ///       information, see <a>arns</a>.</p>
    public let schemaArn: String?
    /// <p>The unique name of the typed link facet.</p>
    public let typedLinkName: String?

    public init (
        schemaArn: String? = nil,
        typedLinkName: String? = nil
    )
    {
        self.schemaArn = schemaArn
        self.typedLinkName = typedLinkName
    }
}

extension TypedLinkSpecifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityAttributeValues = "IdentityAttributeValues"
        case sourceObjectReference = "SourceObjectReference"
        case targetObjectReference = "TargetObjectReference"
        case typedLinkFacet = "TypedLinkFacet"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityAttributeValues = identityAttributeValues {
            var identityAttributeValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identityAttributeValues)
            for attributenameandvaluelist0 in identityAttributeValues {
                try identityAttributeValuesContainer.encode(attributenameandvaluelist0)
            }
        }
        if let sourceObjectReference = sourceObjectReference {
            try encodeContainer.encode(sourceObjectReference, forKey: .sourceObjectReference)
        }
        if let targetObjectReference = targetObjectReference {
            try encodeContainer.encode(targetObjectReference, forKey: .targetObjectReference)
        }
        if let typedLinkFacet = typedLinkFacet {
            try encodeContainer.encode(typedLinkFacet, forKey: .typedLinkFacet)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkFacetDecoded = try containerValues.decodeIfPresent(TypedLinkSchemaAndFacetName.self, forKey: .typedLinkFacet)
        typedLinkFacet = typedLinkFacetDecoded
        let sourceObjectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .sourceObjectReference)
        sourceObjectReference = sourceObjectReferenceDecoded
        let targetObjectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .targetObjectReference)
        targetObjectReference = targetObjectReferenceDecoded
        let identityAttributeValuesContainer = try containerValues.decodeIfPresent([AttributeNameAndValue?].self, forKey: .identityAttributeValues)
        var identityAttributeValuesDecoded0:[AttributeNameAndValue]? = nil
        if let identityAttributeValuesContainer = identityAttributeValuesContainer {
            identityAttributeValuesDecoded0 = [AttributeNameAndValue]()
            for structure0 in identityAttributeValuesContainer {
                if let structure0 = structure0 {
                    identityAttributeValuesDecoded0?.append(structure0)
                }
            }
        }
        identityAttributeValues = identityAttributeValuesDecoded0
    }
}

extension TypedLinkSpecifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TypedLinkSpecifier(identityAttributeValues: \(String(describing: identityAttributeValues)), sourceObjectReference: \(String(describing: sourceObjectReference)), targetObjectReference: \(String(describing: targetObjectReference)), typedLinkFacet: \(String(describing: typedLinkFacet)))"}
}

/// <p>Contains all the information that is used to uniquely identify a typed link. The
///       parameters discussed in this topic are used to uniquely specify the typed link being operated
///       on. The <a>AttachTypedLink</a> API returns a typed link specifier while the <a>DetachTypedLink</a> API accepts one as input. Similarly, the <a>ListIncomingTypedLinks</a> and <a>ListOutgoingTypedLinks</a> API
///       operations provide typed link specifiers as output. You can also construct a typed link
///       specifier from scratch.</p>
public struct TypedLinkSpecifier: Equatable {
    /// <p>Identifies the attribute value to update.</p>
    public let identityAttributeValues: [AttributeNameAndValue]?
    /// <p>Identifies the source object that the typed link will attach to.</p>
    public let sourceObjectReference: ObjectReference?
    /// <p>Identifies the target object that the typed link will attach to.</p>
    public let targetObjectReference: ObjectReference?
    /// <p>Identifies the typed link facet that is associated with the typed link.</p>
    public let typedLinkFacet: TypedLinkSchemaAndFacetName?

    public init (
        identityAttributeValues: [AttributeNameAndValue]? = nil,
        sourceObjectReference: ObjectReference? = nil,
        targetObjectReference: ObjectReference? = nil,
        typedLinkFacet: TypedLinkSchemaAndFacetName? = nil
    )
    {
        self.identityAttributeValues = identityAttributeValues
        self.sourceObjectReference = sourceObjectReference
        self.targetObjectReference = targetObjectReference
        self.typedLinkFacet = typedLinkFacet
    }
}

extension UnsupportedIndexTypeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedIndexTypeException(message: \(String(describing: message)))"}
}

extension UnsupportedIndexTypeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedIndexTypeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the requested index type is not supported.</p>
public struct UnsupportedIndexTypeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedIndexTypeExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedIndexTypeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource. Tagging is only supported for
    ///       directories.</p>
    public let resourceArn: String?
    /// <p>Keys of the tag that need to be removed from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTaggingRequestException" : self = .invalidTaggingRequestException(try InvalidTaggingRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidTaggingRequestException(InvalidTaggingRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum UpdateActionType {
    case createOrUpdate
    case delete
    case sdkUnknown(String)
}

extension UpdateActionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UpdateActionType] {
        return [
            .createOrUpdate,
            .delete,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createOrUpdate: return "CREATE_OR_UPDATE"
        case .delete: return "DELETE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UpdateActionType(rawValue: rawValue) ?? UpdateActionType.sdkUnknown(rawValue)
    }
}

public struct UpdateFacetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFacetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFacetInput>
    public typealias MOutput = OperationOutput<UpdateFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFacetOutputError>
}

extension UpdateFacetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFacetInput(attributeUpdates: \(String(describing: attributeUpdates)), name: \(String(describing: name)), objectType: \(String(describing: objectType)), schemaArn: \(String(describing: schemaArn)))"}
}

extension UpdateFacetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case name = "Name"
        case objectType = "ObjectType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdates = attributeUpdates {
            var attributeUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeUpdates)
            for facetattributeupdatelist0 in attributeUpdates {
                try attributeUpdatesContainer.encode(facetattributeupdatelist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let objectType = objectType {
            try encodeContainer.encode(objectType.rawValue, forKey: .objectType)
        }
    }
}

public struct UpdateFacetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFacetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFacetInput>
    public typealias MOutput = OperationOutput<UpdateFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFacetOutputError>
}

public struct UpdateFacetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFacetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFacetInput>
    public typealias MOutput = OperationOutput<UpdateFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFacetOutputError>
}

public struct UpdateFacetInput: Equatable {
    /// <p>List of attributes that need to be updated in a given schema <a>Facet</a>.
    ///       Each attribute is followed by <code>AttributeAction</code>, which specifies the type of update
    ///       operation to perform. </p>
    public let attributeUpdates: [FacetAttributeUpdate]?
    /// <p>The name of the facet.</p>
    public let name: String?
    /// <p>The object type that is associated with the facet. See <a>CreateFacetRequest$ObjectType</a> for more details.</p>
    public let objectType: ObjectType?
    /// <p>The Amazon Resource Name (ARN) that is associated with the <a>Facet</a>.
    ///       For more information, see <a>arns</a>.</p>
    public let schemaArn: String?

    public init (
        attributeUpdates: [FacetAttributeUpdate]? = nil,
        name: String? = nil,
        objectType: ObjectType? = nil,
        schemaArn: String? = nil
    )
    {
        self.attributeUpdates = attributeUpdates
        self.name = name
        self.objectType = objectType
        self.schemaArn = schemaArn
    }
}

struct UpdateFacetInputBody: Equatable {
    public let name: String?
    public let attributeUpdates: [FacetAttributeUpdate]?
    public let objectType: ObjectType?
}

extension UpdateFacetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case name = "Name"
        case objectType = "ObjectType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let attributeUpdatesContainer = try containerValues.decodeIfPresent([FacetAttributeUpdate?].self, forKey: .attributeUpdates)
        var attributeUpdatesDecoded0:[FacetAttributeUpdate]? = nil
        if let attributeUpdatesContainer = attributeUpdatesContainer {
            attributeUpdatesDecoded0 = [FacetAttributeUpdate]()
            for structure0 in attributeUpdatesContainer {
                if let structure0 = structure0 {
                    attributeUpdatesDecoded0?.append(structure0)
                }
            }
        }
        attributeUpdates = attributeUpdatesDecoded0
        let objectTypeDecoded = try containerValues.decodeIfPresent(ObjectType.self, forKey: .objectType)
        objectType = objectTypeDecoded
    }
}

extension UpdateFacetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFacetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetNotFoundException" : self = .facetNotFoundException(try FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFacetUpdateException" : self = .invalidFacetUpdateException(try InvalidFacetUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRuleException" : self = .invalidRuleException(try InvalidRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFacetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case facetNotFoundException(FacetNotFoundException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidFacetUpdateException(InvalidFacetUpdateException)
    case invalidRuleException(InvalidRuleException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFacetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFacetOutputResponse()"}
}

extension UpdateFacetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFacetOutputResponse: Equatable {

    public init() {}
}

struct UpdateFacetOutputResponseBody: Equatable {
}

extension UpdateFacetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateLinkAttributesInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLinkAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLinkAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLinkAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLinkAttributesInput>
    public typealias MOutput = OperationOutput<UpdateLinkAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLinkAttributesOutputError>
}

extension UpdateLinkAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLinkAttributesInput(attributeUpdates: \(String(describing: attributeUpdates)), directoryArn: \(String(describing: directoryArn)), typedLinkSpecifier: \(String(describing: typedLinkSpecifier)))"}
}

extension UpdateLinkAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdates = attributeUpdates {
            var attributeUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeUpdates)
            for linkattributeupdatelist0 in attributeUpdates {
                try attributeUpdatesContainer.encode(linkattributeupdatelist0)
            }
        }
        if let typedLinkSpecifier = typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }
}

public struct UpdateLinkAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLinkAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLinkAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLinkAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLinkAttributesInput>
    public typealias MOutput = OperationOutput<UpdateLinkAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLinkAttributesOutputError>
}

public struct UpdateLinkAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLinkAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLinkAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLinkAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLinkAttributesInput>
    public typealias MOutput = OperationOutput<UpdateLinkAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLinkAttributesOutputError>
}

public struct UpdateLinkAttributesInput: Equatable {
    /// <p>The attributes update structure.</p>
    public let attributeUpdates: [LinkAttributeUpdate]?
    /// <p>The Amazon Resource Name (ARN) that is associated with the Directory where the updated typed link resides. For more information, see <a>arns</a> or <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
    public let directoryArn: String?
    /// <p>Allows a typed link specifier to be accepted as input.</p>
    public let typedLinkSpecifier: TypedLinkSpecifier?

    public init (
        attributeUpdates: [LinkAttributeUpdate]? = nil,
        directoryArn: String? = nil,
        typedLinkSpecifier: TypedLinkSpecifier? = nil
    )
    {
        self.attributeUpdates = attributeUpdates
        self.directoryArn = directoryArn
        self.typedLinkSpecifier = typedLinkSpecifier
    }
}

struct UpdateLinkAttributesInputBody: Equatable {
    public let typedLinkSpecifier: TypedLinkSpecifier?
    public let attributeUpdates: [LinkAttributeUpdate]?
}

extension UpdateLinkAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
        let attributeUpdatesContainer = try containerValues.decodeIfPresent([LinkAttributeUpdate?].self, forKey: .attributeUpdates)
        var attributeUpdatesDecoded0:[LinkAttributeUpdate]? = nil
        if let attributeUpdatesContainer = attributeUpdatesContainer {
            attributeUpdatesDecoded0 = [LinkAttributeUpdate]()
            for structure0 in attributeUpdatesContainer {
                if let structure0 = structure0 {
                    attributeUpdatesDecoded0?.append(structure0)
                }
            }
        }
        attributeUpdates = attributeUpdatesDecoded0
    }
}

extension UpdateLinkAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLinkAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLinkAttributesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLinkAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLinkAttributesOutputResponse()"}
}

extension UpdateLinkAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLinkAttributesOutputResponse: Equatable {

    public init() {}
}

struct UpdateLinkAttributesOutputResponseBody: Equatable {
}

extension UpdateLinkAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateObjectAttributesInputBodyMiddleware: Middleware {
    public let id: String = "UpdateObjectAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateObjectAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateObjectAttributesInput>
    public typealias MOutput = OperationOutput<UpdateObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateObjectAttributesOutputError>
}

extension UpdateObjectAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateObjectAttributesInput(attributeUpdates: \(String(describing: attributeUpdates)), directoryArn: \(String(describing: directoryArn)), objectReference: \(String(describing: objectReference)))"}
}

extension UpdateObjectAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdates = attributeUpdates {
            var attributeUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeUpdates)
            for objectattributeupdatelist0 in attributeUpdates {
                try attributeUpdatesContainer.encode(objectattributeupdatelist0)
            }
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct UpdateObjectAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateObjectAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateObjectAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateObjectAttributesInput>
    public typealias MOutput = OperationOutput<UpdateObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateObjectAttributesOutputError>
}

public struct UpdateObjectAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateObjectAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateObjectAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateObjectAttributesInput>
    public typealias MOutput = OperationOutput<UpdateObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateObjectAttributesOutputError>
}

public struct UpdateObjectAttributesInput: Equatable {
    /// <p>The attributes update structure.</p>
    public let attributeUpdates: [ObjectAttributeUpdate]?
    /// <p>The Amazon Resource Name (ARN) that is associated with the <a>Directory</a>
    ///       where the object resides. For more information, see <a>arns</a>.</p>
    public let directoryArn: String?
    /// <p>The reference that identifies the object.</p>
    public let objectReference: ObjectReference?

    public init (
        attributeUpdates: [ObjectAttributeUpdate]? = nil,
        directoryArn: String? = nil,
        objectReference: ObjectReference? = nil
    )
    {
        self.attributeUpdates = attributeUpdates
        self.directoryArn = directoryArn
        self.objectReference = objectReference
    }
}

struct UpdateObjectAttributesInputBody: Equatable {
    public let objectReference: ObjectReference?
    public let attributeUpdates: [ObjectAttributeUpdate]?
}

extension UpdateObjectAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let attributeUpdatesContainer = try containerValues.decodeIfPresent([ObjectAttributeUpdate?].self, forKey: .attributeUpdates)
        var attributeUpdatesDecoded0:[ObjectAttributeUpdate]? = nil
        if let attributeUpdatesContainer = attributeUpdatesContainer {
            attributeUpdatesDecoded0 = [ObjectAttributeUpdate]()
            for structure0 in attributeUpdatesContainer {
                if let structure0 = structure0 {
                    attributeUpdatesDecoded0?.append(structure0)
                }
            }
        }
        attributeUpdates = attributeUpdatesDecoded0
    }
}

extension UpdateObjectAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateObjectAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LinkNameAlreadyInUseException" : self = .linkNameAlreadyInUseException(try LinkNameAlreadyInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateObjectAttributesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case linkNameAlreadyInUseException(LinkNameAlreadyInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateObjectAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateObjectAttributesOutputResponse(objectIdentifier: \(String(describing: objectIdentifier)))"}
}

extension UpdateObjectAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateObjectAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.objectIdentifier = output.objectIdentifier
        } else {
            self.objectIdentifier = nil
        }
    }
}

public struct UpdateObjectAttributesOutputResponse: Equatable {
    /// <p>The <code>ObjectIdentifier</code> of the updated object.</p>
    public let objectIdentifier: String?

    public init (
        objectIdentifier: String? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
    }
}

struct UpdateObjectAttributesOutputResponseBody: Equatable {
    public let objectIdentifier: String?
}

extension UpdateObjectAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case objectIdentifier = "ObjectIdentifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

public struct UpdateSchemaInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSchemaInput>
    public typealias MOutput = OperationOutput<UpdateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSchemaOutputError>
}

extension UpdateSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSchemaInput(name: \(String(describing: name)), schemaArn: \(String(describing: schemaArn)))"}
}

extension UpdateSchemaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSchemaInput>
    public typealias MOutput = OperationOutput<UpdateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSchemaOutputError>
}

public struct UpdateSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSchemaInput>
    public typealias MOutput = OperationOutput<UpdateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSchemaOutputError>
}

public struct UpdateSchemaInput: Equatable {
    /// <p>The name of the schema.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the development schema. For more information, see
    ///         <a>arns</a>.</p>
    public let schemaArn: String?

    public init (
        name: String? = nil,
        schemaArn: String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct UpdateSchemaInputBody: Equatable {
    public let name: String?
}

extension UpdateSchemaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSchemaOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSchemaOutputResponse(schemaArn: \(String(describing: schemaArn)))"}
}

extension UpdateSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.schemaArn = output.schemaArn
        } else {
            self.schemaArn = nil
        }
    }
}

public struct UpdateSchemaOutputResponse: Equatable {
    /// <p>The ARN that is associated with the updated schema. For more information, see <a>arns</a>.</p>
    public let schemaArn: String?

    public init (
        schemaArn: String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct UpdateSchemaOutputResponseBody: Equatable {
    public let schemaArn: String?
}

extension UpdateSchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case schemaArn = "SchemaArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

public struct UpdateTypedLinkFacetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTypedLinkFacetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTypedLinkFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTypedLinkFacetInput>
    public typealias MOutput = OperationOutput<UpdateTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTypedLinkFacetOutputError>
}

extension UpdateTypedLinkFacetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTypedLinkFacetInput(attributeUpdates: \(String(describing: attributeUpdates)), identityAttributeOrder: \(String(describing: identityAttributeOrder)), name: \(String(describing: name)), schemaArn: \(String(describing: schemaArn)))"}
}

extension UpdateTypedLinkFacetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case identityAttributeOrder = "IdentityAttributeOrder"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdates = attributeUpdates {
            var attributeUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeUpdates)
            for typedlinkfacetattributeupdatelist0 in attributeUpdates {
                try attributeUpdatesContainer.encode(typedlinkfacetattributeupdatelist0)
            }
        }
        if let identityAttributeOrder = identityAttributeOrder {
            var identityAttributeOrderContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identityAttributeOrder)
            for attributenamelist0 in identityAttributeOrder {
                try identityAttributeOrderContainer.encode(attributenamelist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateTypedLinkFacetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTypedLinkFacetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTypedLinkFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTypedLinkFacetInput>
    public typealias MOutput = OperationOutput<UpdateTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTypedLinkFacetOutputError>
}

public struct UpdateTypedLinkFacetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTypedLinkFacetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTypedLinkFacetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTypedLinkFacetInput>
    public typealias MOutput = OperationOutput<UpdateTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTypedLinkFacetOutputError>
}

public struct UpdateTypedLinkFacetInput: Equatable {
    /// <p>Attributes update structure.</p>
    public let attributeUpdates: [TypedLinkFacetAttributeUpdate]?
    /// <p>The order of identity attributes for the facet, from most significant to least significant. The ability to filter typed
    ///       links considers the order that the attributes are defined on the typed link facet.  When
    ///       providing ranges to a typed link selection, any inexact ranges must be specified at the end.
    ///       Any attributes that do not have a range specified are presumed to match the entire range.
    ///       Filters are interpreted in the order of the attributes on the typed link facet, not the order
    ///       in which they are supplied to any API calls. For more information about identity attributes, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
    public let identityAttributeOrder: [String]?
    /// <p>The unique name of the typed link facet.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) that is associated with the schema. For more
    ///       information, see <a>arns</a>.</p>
    public let schemaArn: String?

    public init (
        attributeUpdates: [TypedLinkFacetAttributeUpdate]? = nil,
        identityAttributeOrder: [String]? = nil,
        name: String? = nil,
        schemaArn: String? = nil
    )
    {
        self.attributeUpdates = attributeUpdates
        self.identityAttributeOrder = identityAttributeOrder
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct UpdateTypedLinkFacetInputBody: Equatable {
    public let name: String?
    public let attributeUpdates: [TypedLinkFacetAttributeUpdate]?
    public let identityAttributeOrder: [String]?
}

extension UpdateTypedLinkFacetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case identityAttributeOrder = "IdentityAttributeOrder"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let attributeUpdatesContainer = try containerValues.decodeIfPresent([TypedLinkFacetAttributeUpdate?].self, forKey: .attributeUpdates)
        var attributeUpdatesDecoded0:[TypedLinkFacetAttributeUpdate]? = nil
        if let attributeUpdatesContainer = attributeUpdatesContainer {
            attributeUpdatesDecoded0 = [TypedLinkFacetAttributeUpdate]()
            for structure0 in attributeUpdatesContainer {
                if let structure0 = structure0 {
                    attributeUpdatesDecoded0?.append(structure0)
                }
            }
        }
        attributeUpdates = attributeUpdatesDecoded0
        let identityAttributeOrderContainer = try containerValues.decodeIfPresent([String?].self, forKey: .identityAttributeOrder)
        var identityAttributeOrderDecoded0:[String]? = nil
        if let identityAttributeOrderContainer = identityAttributeOrderContainer {
            identityAttributeOrderDecoded0 = [String]()
            for string0 in identityAttributeOrderContainer {
                if let string0 = string0 {
                    identityAttributeOrderDecoded0?.append(string0)
                }
            }
        }
        identityAttributeOrder = identityAttributeOrderDecoded0
    }
}

extension UpdateTypedLinkFacetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTypedLinkFacetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetNotFoundException" : self = .facetNotFoundException(try FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFacetUpdateException" : self = .invalidFacetUpdateException(try InvalidFacetUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRuleException" : self = .invalidRuleException(try InvalidRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTypedLinkFacetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case facetNotFoundException(FacetNotFoundException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidFacetUpdateException(InvalidFacetUpdateException)
    case invalidRuleException(InvalidRuleException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTypedLinkFacetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTypedLinkFacetOutputResponse()"}
}

extension UpdateTypedLinkFacetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateTypedLinkFacetOutputResponse: Equatable {

    public init() {}
}

struct UpdateTypedLinkFacetOutputResponseBody: Equatable {
}

extension UpdateTypedLinkFacetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpgradeAppliedSchemaInputBodyMiddleware: Middleware {
    public let id: String = "UpgradeAppliedSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpgradeAppliedSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<UpgradeAppliedSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpgradeAppliedSchemaInput>
    public typealias MOutput = OperationOutput<UpgradeAppliedSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpgradeAppliedSchemaOutputError>
}

extension UpgradeAppliedSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpgradeAppliedSchemaInput(directoryArn: \(String(describing: directoryArn)), dryRun: \(String(describing: dryRun)), publishedSchemaArn: \(String(describing: publishedSchemaArn)))"}
}

extension UpgradeAppliedSchemaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryArn = "DirectoryArn"
        case dryRun = "DryRun"
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryArn = directoryArn {
            try encodeContainer.encode(directoryArn, forKey: .directoryArn)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let publishedSchemaArn = publishedSchemaArn {
            try encodeContainer.encode(publishedSchemaArn, forKey: .publishedSchemaArn)
        }
    }
}

public struct UpgradeAppliedSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "UpgradeAppliedSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpgradeAppliedSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<UpgradeAppliedSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpgradeAppliedSchemaInput>
    public typealias MOutput = OperationOutput<UpgradeAppliedSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpgradeAppliedSchemaOutputError>
}

public struct UpgradeAppliedSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "UpgradeAppliedSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpgradeAppliedSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<UpgradeAppliedSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpgradeAppliedSchemaInput>
    public typealias MOutput = OperationOutput<UpgradeAppliedSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpgradeAppliedSchemaOutputError>
}

public struct UpgradeAppliedSchemaInput: Equatable {
    /// <p>The ARN for the directory to which the upgraded schema will be applied.</p>
    public let directoryArn: String?
    /// <p>Used for testing whether the major version schemas are backward compatible or not. If schema compatibility fails, an exception would be thrown else the call would succeed but no changes will be saved. This parameter is optional.</p>
    public let dryRun: Bool
    /// <p>The revision of the published schema to upgrade the directory to.</p>
    public let publishedSchemaArn: String?

    public init (
        directoryArn: String? = nil,
        dryRun: Bool = false,
        publishedSchemaArn: String? = nil
    )
    {
        self.directoryArn = directoryArn
        self.dryRun = dryRun
        self.publishedSchemaArn = publishedSchemaArn
    }
}

struct UpgradeAppliedSchemaInputBody: Equatable {
    public let publishedSchemaArn: String?
    public let directoryArn: String?
    public let dryRun: Bool
}

extension UpgradeAppliedSchemaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryArn = "DirectoryArn"
        case dryRun = "DryRun"
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publishedSchemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publishedSchemaArn)
        publishedSchemaArn = publishedSchemaArnDecoded
        let directoryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension UpgradeAppliedSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpgradeAppliedSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleSchemaException" : self = .incompatibleSchemaException(try IncompatibleSchemaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAttachmentException" : self = .invalidAttachmentException(try InvalidAttachmentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SchemaAlreadyExistsException" : self = .schemaAlreadyExistsException(try SchemaAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpgradeAppliedSchemaOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleSchemaException(IncompatibleSchemaException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidAttachmentException(InvalidAttachmentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case schemaAlreadyExistsException(SchemaAlreadyExistsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpgradeAppliedSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpgradeAppliedSchemaOutputResponse(directoryArn: \(String(describing: directoryArn)), upgradedSchemaArn: \(String(describing: upgradedSchemaArn)))"}
}

extension UpgradeAppliedSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpgradeAppliedSchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.directoryArn = output.directoryArn
            self.upgradedSchemaArn = output.upgradedSchemaArn
        } else {
            self.directoryArn = nil
            self.upgradedSchemaArn = nil
        }
    }
}

public struct UpgradeAppliedSchemaOutputResponse: Equatable {
    /// <p>The ARN of the directory that is returned as part of the response.</p>
    public let directoryArn: String?
    /// <p>The ARN of the upgraded schema that is returned as part of the response.</p>
    public let upgradedSchemaArn: String?

    public init (
        directoryArn: String? = nil,
        upgradedSchemaArn: String? = nil
    )
    {
        self.directoryArn = directoryArn
        self.upgradedSchemaArn = upgradedSchemaArn
    }
}

struct UpgradeAppliedSchemaOutputResponseBody: Equatable {
    public let upgradedSchemaArn: String?
    public let directoryArn: String?
}

extension UpgradeAppliedSchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryArn = "DirectoryArn"
        case upgradedSchemaArn = "UpgradedSchemaArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let upgradedSchemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .upgradedSchemaArn)
        upgradedSchemaArn = upgradedSchemaArnDecoded
        let directoryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
    }
}

public struct UpgradePublishedSchemaInputBodyMiddleware: Middleware {
    public let id: String = "UpgradePublishedSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpgradePublishedSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<UpgradePublishedSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpgradePublishedSchemaInput>
    public typealias MOutput = OperationOutput<UpgradePublishedSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpgradePublishedSchemaOutputError>
}

extension UpgradePublishedSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpgradePublishedSchemaInput(developmentSchemaArn: \(String(describing: developmentSchemaArn)), dryRun: \(String(describing: dryRun)), minorVersion: \(String(describing: minorVersion)), publishedSchemaArn: \(String(describing: publishedSchemaArn)))"}
}

extension UpgradePublishedSchemaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case developmentSchemaArn = "DevelopmentSchemaArn"
        case dryRun = "DryRun"
        case minorVersion = "MinorVersion"
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let developmentSchemaArn = developmentSchemaArn {
            try encodeContainer.encode(developmentSchemaArn, forKey: .developmentSchemaArn)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let minorVersion = minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let publishedSchemaArn = publishedSchemaArn {
            try encodeContainer.encode(publishedSchemaArn, forKey: .publishedSchemaArn)
        }
    }
}

public struct UpgradePublishedSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "UpgradePublishedSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpgradePublishedSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<UpgradePublishedSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpgradePublishedSchemaInput>
    public typealias MOutput = OperationOutput<UpgradePublishedSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpgradePublishedSchemaOutputError>
}

public struct UpgradePublishedSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "UpgradePublishedSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpgradePublishedSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<UpgradePublishedSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpgradePublishedSchemaInput>
    public typealias MOutput = OperationOutput<UpgradePublishedSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpgradePublishedSchemaOutputError>
}

public struct UpgradePublishedSchemaInput: Equatable {
    /// <p>The ARN of the development schema with the changes used for the upgrade.</p>
    public let developmentSchemaArn: String?
    /// <p>Used for testing whether the Development schema provided is backwards compatible, or not, with the publish schema provided by the user to be upgraded. If schema compatibility fails, an exception would be thrown else the call would succeed. This parameter is optional and defaults to false.</p>
    public let dryRun: Bool
    /// <p>Identifies the minor version of the published schema that will be created. This parameter is NOT optional.</p>
    public let minorVersion: String?
    /// <p>The ARN of the published schema to be upgraded.</p>
    public let publishedSchemaArn: String?

    public init (
        developmentSchemaArn: String? = nil,
        dryRun: Bool = false,
        minorVersion: String? = nil,
        publishedSchemaArn: String? = nil
    )
    {
        self.developmentSchemaArn = developmentSchemaArn
        self.dryRun = dryRun
        self.minorVersion = minorVersion
        self.publishedSchemaArn = publishedSchemaArn
    }
}

struct UpgradePublishedSchemaInputBody: Equatable {
    public let developmentSchemaArn: String?
    public let publishedSchemaArn: String?
    public let minorVersion: String?
    public let dryRun: Bool
}

extension UpgradePublishedSchemaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case developmentSchemaArn = "DevelopmentSchemaArn"
        case dryRun = "DryRun"
        case minorVersion = "MinorVersion"
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let developmentSchemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .developmentSchemaArn)
        developmentSchemaArn = developmentSchemaArnDecoded
        let publishedSchemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publishedSchemaArn)
        publishedSchemaArn = publishedSchemaArnDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension UpgradePublishedSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpgradePublishedSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleSchemaException" : self = .incompatibleSchemaException(try IncompatibleSchemaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAttachmentException" : self = .invalidAttachmentException(try InvalidAttachmentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpgradePublishedSchemaOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleSchemaException(IncompatibleSchemaException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidAttachmentException(InvalidAttachmentException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpgradePublishedSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpgradePublishedSchemaOutputResponse(upgradedSchemaArn: \(String(describing: upgradedSchemaArn)))"}
}

extension UpgradePublishedSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpgradePublishedSchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.upgradedSchemaArn = output.upgradedSchemaArn
        } else {
            self.upgradedSchemaArn = nil
        }
    }
}

public struct UpgradePublishedSchemaOutputResponse: Equatable {
    /// <p>The ARN of the upgraded schema that is returned as part of the response.</p>
    public let upgradedSchemaArn: String?

    public init (
        upgradedSchemaArn: String? = nil
    )
    {
        self.upgradedSchemaArn = upgradedSchemaArn
    }
}

struct UpgradePublishedSchemaOutputResponseBody: Equatable {
    public let upgradedSchemaArn: String?
}

extension UpgradePublishedSchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case upgradedSchemaArn = "UpgradedSchemaArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let upgradedSchemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .upgradedSchemaArn)
        upgradedSchemaArn = upgradedSchemaArnDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that your request is malformed in some manner. See the exception
///       message.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
