// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptAdministratorInvitationInputBodyMiddleware: Middleware {
    public let id: String = "AcceptAdministratorInvitationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptAdministratorInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptAdministratorInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptAdministratorInvitationInput>
    public typealias MOutput = OperationOutput<AcceptAdministratorInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptAdministratorInvitationOutputError>
}

extension AcceptAdministratorInvitationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptAdministratorInvitationInput(administratorId: \(String(describing: administratorId)), invitationId: \(String(describing: invitationId)))"}
}

extension AcceptAdministratorInvitationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case administratorId = "AdministratorId"
        case invitationId = "InvitationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let administratorId = administratorId {
            try encodeContainer.encode(administratorId, forKey: .administratorId)
        }
        if let invitationId = invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
    }
}

public struct AcceptAdministratorInvitationInputHeadersMiddleware: Middleware {
    public let id: String = "AcceptAdministratorInvitationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptAdministratorInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptAdministratorInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptAdministratorInvitationInput>
    public typealias MOutput = OperationOutput<AcceptAdministratorInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptAdministratorInvitationOutputError>
}

public struct AcceptAdministratorInvitationInputQueryItemMiddleware: Middleware {
    public let id: String = "AcceptAdministratorInvitationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptAdministratorInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptAdministratorInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptAdministratorInvitationInput>
    public typealias MOutput = OperationOutput<AcceptAdministratorInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptAdministratorInvitationOutputError>
}

public struct AcceptAdministratorInvitationInput: Equatable {
    /// <p>The account ID of the Security Hub administrator account that sent the invitation.</p>
    public let administratorId: String?
    /// <p>The identifier of the invitation sent from the Security Hub administrator account.</p>
    public let invitationId: String?

    public init (
        administratorId: String? = nil,
        invitationId: String? = nil
    )
    {
        self.administratorId = administratorId
        self.invitationId = invitationId
    }
}

struct AcceptAdministratorInvitationInputBody: Equatable {
    public let administratorId: String?
    public let invitationId: String?
}

extension AcceptAdministratorInvitationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case administratorId = "AdministratorId"
        case invitationId = "InvitationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let administratorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .administratorId)
        administratorId = administratorIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
    }
}

extension AcceptAdministratorInvitationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptAdministratorInvitationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptAdministratorInvitationOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptAdministratorInvitationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptAdministratorInvitationOutputResponse()"}
}

extension AcceptAdministratorInvitationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AcceptAdministratorInvitationOutputResponse: Equatable {

    public init() {}
}

struct AcceptAdministratorInvitationOutputResponseBody: Equatable {
}

extension AcceptAdministratorInvitationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AcceptInvitationInputBodyMiddleware: Middleware {
    public let id: String = "AcceptInvitationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptInvitationInput>
    public typealias MOutput = OperationOutput<AcceptInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptInvitationOutputError>
}

extension AcceptInvitationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptInvitationInput(invitationId: \(String(describing: invitationId)), masterId: \(String(describing: masterId)))"}
}

extension AcceptInvitationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case invitationId = "InvitationId"
        case masterId = "MasterId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invitationId = invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let masterId = masterId {
            try encodeContainer.encode(masterId, forKey: .masterId)
        }
    }
}

public struct AcceptInvitationInputHeadersMiddleware: Middleware {
    public let id: String = "AcceptInvitationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptInvitationInput>
    public typealias MOutput = OperationOutput<AcceptInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptInvitationOutputError>
}

public struct AcceptInvitationInputQueryItemMiddleware: Middleware {
    public let id: String = "AcceptInvitationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptInvitationInput>
    public typealias MOutput = OperationOutput<AcceptInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptInvitationOutputError>
}

public struct AcceptInvitationInput: Equatable {
    /// <p>The identifier of the invitation sent from the Security Hub administrator account.</p>
    public let invitationId: String?
    /// <p>The account ID of the Security Hub administrator account that sent the invitation.</p>
    public let masterId: String?

    public init (
        invitationId: String? = nil,
        masterId: String? = nil
    )
    {
        self.invitationId = invitationId
        self.masterId = masterId
    }
}

struct AcceptInvitationInputBody: Equatable {
    public let masterId: String?
    public let invitationId: String?
}

extension AcceptInvitationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invitationId = "InvitationId"
        case masterId = "MasterId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let masterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterId)
        masterId = masterIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
    }
}

extension AcceptInvitationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptInvitationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptInvitationOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptInvitationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptInvitationOutputResponse()"}
}

extension AcceptInvitationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AcceptInvitationOutputResponse: Equatable {

    public init() {}
}

struct AcceptInvitationOutputResponseBody: Equatable {
}

extension AcceptInvitationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You don't have permission to perform the action specified in the request.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension AccountDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case email = "Email"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
    }
}

extension AccountDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountDetails(accountId: \(String(describing: accountId)), email: \(String(describing: email)))"}
}

/// <p>The details of an AWS account.</p>
public struct AccountDetails: Equatable {
    /// <p>The ID of an AWS account.</p>
    public let accountId: String?
    /// <p>The email of an AWS account.</p>
    public let email: String?

    public init (
        accountId: String? = nil,
        email: String? = nil
    )
    {
        self.accountId = accountId
        self.email = email
    }
}

extension Action: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionType = "ActionType"
        case awsApiCallAction = "AwsApiCallAction"
        case dnsRequestAction = "DnsRequestAction"
        case networkConnectionAction = "NetworkConnectionAction"
        case portProbeAction = "PortProbeAction"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionType = actionType {
            try encodeContainer.encode(actionType, forKey: .actionType)
        }
        if let awsApiCallAction = awsApiCallAction {
            try encodeContainer.encode(awsApiCallAction, forKey: .awsApiCallAction)
        }
        if let dnsRequestAction = dnsRequestAction {
            try encodeContainer.encode(dnsRequestAction, forKey: .dnsRequestAction)
        }
        if let networkConnectionAction = networkConnectionAction {
            try encodeContainer.encode(networkConnectionAction, forKey: .networkConnectionAction)
        }
        if let portProbeAction = portProbeAction {
            try encodeContainer.encode(portProbeAction, forKey: .portProbeAction)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let networkConnectionActionDecoded = try containerValues.decodeIfPresent(NetworkConnectionAction.self, forKey: .networkConnectionAction)
        networkConnectionAction = networkConnectionActionDecoded
        let awsApiCallActionDecoded = try containerValues.decodeIfPresent(AwsApiCallAction.self, forKey: .awsApiCallAction)
        awsApiCallAction = awsApiCallActionDecoded
        let dnsRequestActionDecoded = try containerValues.decodeIfPresent(DnsRequestAction.self, forKey: .dnsRequestAction)
        dnsRequestAction = dnsRequestActionDecoded
        let portProbeActionDecoded = try containerValues.decodeIfPresent(PortProbeAction.self, forKey: .portProbeAction)
        portProbeAction = portProbeActionDecoded
    }
}

extension Action: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Action(actionType: \(String(describing: actionType)), awsApiCallAction: \(String(describing: awsApiCallAction)), dnsRequestAction: \(String(describing: dnsRequestAction)), networkConnectionAction: \(String(describing: networkConnectionAction)), portProbeAction: \(String(describing: portProbeAction)))"}
}

/// <p>Provides details about one of the following actions that affects or that was taken on a resource:</p>
///          <ul>
///             <li>
///                <p>A remote IP address issued an AWS API call</p>
///             </li>
///             <li>
///                <p>A DNS request was received</p>
///             </li>
///             <li>
///                <p>A remote IP address attempted to connect to an EC2 instance</p>
///             </li>
///             <li>
///                <p>A remote IP address attempted a port probe on an EC2 instance</p>
///             </li>
///          </ul>
public struct Action: Equatable {
    /// <p>The type of action that was detected. The possible action types are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>NETWORK_CONNECTION</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AWS_API_CALL</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DNS_REQUEST</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PORT_PROBE</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let actionType: String?
    /// <p>Included if <code>ActionType</code> is <code>AWS_API_CALL</code>. Provides details about
    ///          the API call that was detected. </p>
    public let awsApiCallAction: AwsApiCallAction?
    /// <p>Included if <code>ActionType</code> is <code>DNS_REQUEST</code>. Provides details about
    ///          the DNS request that was detected. </p>
    public let dnsRequestAction: DnsRequestAction?
    /// <p>Included if <code>ActionType</code> is <code>NETWORK_CONNECTION</code>. Provides details
    ///          about the network connection that was detected.</p>
    public let networkConnectionAction: NetworkConnectionAction?
    /// <p>Included if <code>ActionType</code> is <code>PORT_PROBE</code>. Provides details about
    ///          the port probe that was detected. </p>
    public let portProbeAction: PortProbeAction?

    public init (
        actionType: String? = nil,
        awsApiCallAction: AwsApiCallAction? = nil,
        dnsRequestAction: DnsRequestAction? = nil,
        networkConnectionAction: NetworkConnectionAction? = nil,
        portProbeAction: PortProbeAction? = nil
    )
    {
        self.actionType = actionType
        self.awsApiCallAction = awsApiCallAction
        self.dnsRequestAction = dnsRequestAction
        self.networkConnectionAction = networkConnectionAction
        self.portProbeAction = portProbeAction
    }
}

extension ActionLocalIpDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ipAddressV4 = "IpAddressV4"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddressV4 = ipAddressV4 {
            try encodeContainer.encode(ipAddressV4, forKey: .ipAddressV4)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressV4Decoded = try containerValues.decodeIfPresent(String.self, forKey: .ipAddressV4)
        ipAddressV4 = ipAddressV4Decoded
    }
}

extension ActionLocalIpDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionLocalIpDetails(ipAddressV4: \(String(describing: ipAddressV4)))"}
}

/// <p>Provides information about the IP address where the scanned port is located.</p>
public struct ActionLocalIpDetails: Equatable {
    /// <p>The IP address.</p>
    public let ipAddressV4: String?

    public init (
        ipAddressV4: String? = nil
    )
    {
        self.ipAddressV4 = ipAddressV4
    }
}

extension ActionLocalPortDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case port = "Port"
        case portName = "PortName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let portName = portName {
            try encodeContainer.encode(portName, forKey: .portName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let portNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portName)
        portName = portNameDecoded
    }
}

extension ActionLocalPortDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionLocalPortDetails(port: \(String(describing: port)), portName: \(String(describing: portName)))"}
}

/// <p>For <code>NetworkConnectionAction</code> and <code>PortProbeDetails</code>,
///             <code>LocalPortDetails</code> provides information about the local port that was
///          involved in the action.</p>
public struct ActionLocalPortDetails: Equatable {
    /// <p>The number of the port.</p>
    public let port: Int
    /// <p>The port name of the local connection.</p>
    public let portName: String?

    public init (
        port: Int = 0,
        portName: String? = nil
    )
    {
        self.port = port
        self.portName = portName
    }
}

extension ActionRemoteIpDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case city = "City"
        case country = "Country"
        case geoLocation = "GeoLocation"
        case ipAddressV4 = "IpAddressV4"
        case organization = "Organization"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let city = city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let geoLocation = geoLocation {
            try encodeContainer.encode(geoLocation, forKey: .geoLocation)
        }
        if let ipAddressV4 = ipAddressV4 {
            try encodeContainer.encode(ipAddressV4, forKey: .ipAddressV4)
        }
        if let organization = organization {
            try encodeContainer.encode(organization, forKey: .organization)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressV4Decoded = try containerValues.decodeIfPresent(String.self, forKey: .ipAddressV4)
        ipAddressV4 = ipAddressV4Decoded
        let organizationDecoded = try containerValues.decodeIfPresent(IpOrganizationDetails.self, forKey: .organization)
        organization = organizationDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Country.self, forKey: .country)
        country = countryDecoded
        let cityDecoded = try containerValues.decodeIfPresent(City.self, forKey: .city)
        city = cityDecoded
        let geoLocationDecoded = try containerValues.decodeIfPresent(GeoLocation.self, forKey: .geoLocation)
        geoLocation = geoLocationDecoded
    }
}

extension ActionRemoteIpDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionRemoteIpDetails(city: \(String(describing: city)), country: \(String(describing: country)), geoLocation: \(String(describing: geoLocation)), ipAddressV4: \(String(describing: ipAddressV4)), organization: \(String(describing: organization)))"}
}

/// <p>For <code>AwsApiAction</code>, <code>NetworkConnectionAction</code>, and
///             <code>PortProbeAction</code>, <code>RemoteIpDetails</code> provides information about
///          the remote IP address that was involved in the action.</p>
public struct ActionRemoteIpDetails: Equatable {
    /// <p>The city where the remote IP address is located.</p>
    public let city: City?
    /// <p>The country where the remote IP address is located.</p>
    public let country: Country?
    /// <p>The coordinates of the location of the remote IP address.</p>
    public let geoLocation: GeoLocation?
    /// <p>The IP address.</p>
    public let ipAddressV4: String?
    /// <p>The internet service provider (ISP) organization associated with the remote IP
    ///          address.</p>
    public let organization: IpOrganizationDetails?

    public init (
        city: City? = nil,
        country: Country? = nil,
        geoLocation: GeoLocation? = nil,
        ipAddressV4: String? = nil,
        organization: IpOrganizationDetails? = nil
    )
    {
        self.city = city
        self.country = country
        self.geoLocation = geoLocation
        self.ipAddressV4 = ipAddressV4
        self.organization = organization
    }
}

extension ActionRemotePortDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case port = "Port"
        case portName = "PortName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let portName = portName {
            try encodeContainer.encode(portName, forKey: .portName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let portNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portName)
        portName = portNameDecoded
    }
}

extension ActionRemotePortDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionRemotePortDetails(port: \(String(describing: port)), portName: \(String(describing: portName)))"}
}

/// <p>Provides information about the remote port that was involved in an attempted network
///          connection.</p>
public struct ActionRemotePortDetails: Equatable {
    /// <p>The number of the port.</p>
    public let port: Int
    /// <p>The port name of the remote connection.</p>
    public let portName: String?

    public init (
        port: Int = 0,
        portName: String? = nil
    )
    {
        self.port = port
        self.portName = portName
    }
}

extension ActionTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionTargetArn = "ActionTargetArn"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionTargetArn = actionTargetArn {
            try encodeContainer.encode(actionTargetArn, forKey: .actionTargetArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTargetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionTargetArn)
        actionTargetArn = actionTargetArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ActionTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionTarget(actionTargetArn: \(String(describing: actionTargetArn)), description: \(String(describing: description)), name: \(String(describing: name)))"}
}

/// <p>An <code>ActionTarget</code> object.</p>
public struct ActionTarget: Equatable {
    /// <p>The ARN for the target action.</p>
    public let actionTargetArn: String?
    /// <p>The description of the target action.</p>
    public let description: String?
    /// <p>The name of the action target.</p>
    public let name: String?

    public init (
        actionTargetArn: String? = nil,
        description: String? = nil,
        name: String? = nil
    )
    {
        self.actionTargetArn = actionTargetArn
        self.description = description
        self.name = name
    }
}

extension AdminAccount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AdminStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AdminAccount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminAccount(accountId: \(String(describing: accountId)), status: \(String(describing: status)))"}
}

/// <p>Represents a Security Hub administrator account designated by an organization management
///          account.</p>
public struct AdminAccount: Equatable {
    /// <p>The AWS account identifier of the Security Hub administrator account.</p>
    public let accountId: String?
    /// <p>The current status of the Security Hub administrator account. Indicates whether the account is
    ///          currently enabled as a Security Hub administrator.</p>
    public let status: AdminStatus?

    public init (
        accountId: String? = nil,
        status: AdminStatus? = nil
    )
    {
        self.accountId = accountId
        self.status = status
    }
}

public enum AdminStatus {
    case disableInProgress
    case enabled
    case sdkUnknown(String)
}

extension AdminStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AdminStatus] {
        return [
            .disableInProgress,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disableInProgress: return "DISABLE_IN_PROGRESS"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AdminStatus(rawValue: rawValue) ?? AdminStatus.sdkUnknown(rawValue)
    }
}

extension AvailabilityZone: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case subnetId = "SubnetId"
        case zoneName = "ZoneName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let zoneName = zoneName {
            try encodeContainer.encode(zoneName, forKey: .zoneName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zoneNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .zoneName)
        zoneName = zoneNameDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
    }
}

extension AvailabilityZone: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AvailabilityZone(subnetId: \(String(describing: subnetId)), zoneName: \(String(describing: zoneName)))"}
}

/// <p>Information about an Availability Zone.</p>
public struct AvailabilityZone: Equatable {
    /// <p>The ID of the subnet. You can specify one subnet per Availability Zone.</p>
    public let subnetId: String?
    /// <p>The name of the Availability Zone.</p>
    public let zoneName: String?

    public init (
        subnetId: String? = nil,
        zoneName: String? = nil
    )
    {
        self.subnetId = subnetId
        self.zoneName = zoneName
    }
}

extension AwsApiCallAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case affectedResources = "AffectedResources"
        case api = "Api"
        case callerType = "CallerType"
        case domainDetails = "DomainDetails"
        case firstSeen = "FirstSeen"
        case lastSeen = "LastSeen"
        case remoteIpDetails = "RemoteIpDetails"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let affectedResources = affectedResources {
            var affectedResourcesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .affectedResources)
            for (dictKey0, fieldmap0) in affectedResources {
                try affectedResourcesContainer.encode(fieldmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let api = api {
            try encodeContainer.encode(api, forKey: .api)
        }
        if let callerType = callerType {
            try encodeContainer.encode(callerType, forKey: .callerType)
        }
        if let domainDetails = domainDetails {
            try encodeContainer.encode(domainDetails, forKey: .domainDetails)
        }
        if let firstSeen = firstSeen {
            try encodeContainer.encode(firstSeen, forKey: .firstSeen)
        }
        if let lastSeen = lastSeen {
            try encodeContainer.encode(lastSeen, forKey: .lastSeen)
        }
        if let remoteIpDetails = remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDecoded = try containerValues.decodeIfPresent(String.self, forKey: .api)
        api = apiDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let callerTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .callerType)
        callerType = callerTypeDecoded
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(ActionRemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
        let domainDetailsDecoded = try containerValues.decodeIfPresent(AwsApiCallActionDomainDetails.self, forKey: .domainDetails)
        domainDetails = domainDetailsDecoded
        let affectedResourcesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .affectedResources)
        var affectedResourcesDecoded0: [String:String]? = nil
        if let affectedResourcesContainer = affectedResourcesContainer {
            affectedResourcesDecoded0 = [String:String]()
            for (key0, nonemptystring0) in affectedResourcesContainer {
                if let nonemptystring0 = nonemptystring0 {
                    affectedResourcesDecoded0?[key0] = nonemptystring0
                }
            }
        }
        affectedResources = affectedResourcesDecoded0
        let firstSeenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firstSeen)
        firstSeen = firstSeenDecoded
        let lastSeenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastSeen)
        lastSeen = lastSeenDecoded
    }
}

extension AwsApiCallAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsApiCallAction(affectedResources: \(String(describing: affectedResources)), api: \(String(describing: api)), callerType: \(String(describing: callerType)), domainDetails: \(String(describing: domainDetails)), firstSeen: \(String(describing: firstSeen)), lastSeen: \(String(describing: lastSeen)), remoteIpDetails: \(String(describing: remoteIpDetails)), serviceName: \(String(describing: serviceName)))"}
}

/// <p>Provided if <code>ActionType</code> is <code>AWS_API_CALL</code>. It provides details
///          about the API call that was detected.</p>
public struct AwsApiCallAction: Equatable {
    /// <p>Identifies the resources that were affected by the API call.</p>
    public let affectedResources: [String:String]?
    /// <p>The name of the API method that was issued.</p>
    public let api: String?
    /// <p>Indicates whether the API call originated from a remote IP address
    ///             (<code>remoteip</code>) or from a DNS domain (<code>domain</code>).</p>
    public let callerType: String?
    /// <p>Provided if <code>CallerType</code> is <code>domain</code>. Provides information about
    ///          the DNS domain that the API call originated from.</p>
    public let domainDetails: AwsApiCallActionDomainDetails?
    /// <p>An ISO8601-formatted timestamp that indicates when the API call was first
    ///          observed.</p>
    public let firstSeen: String?
    /// <p>An ISO8601-formatted timestamp that indicates when the API call was most recently
    ///          observed.</p>
    public let lastSeen: String?
    /// <p>Provided if <code>CallerType</code> is <code>remoteIp</code>. Provides information about
    ///          the remote IP address that the API call originated from.</p>
    public let remoteIpDetails: ActionRemoteIpDetails?
    /// <p>The name of the AWS service that the API method belongs to.</p>
    public let serviceName: String?

    public init (
        affectedResources: [String:String]? = nil,
        api: String? = nil,
        callerType: String? = nil,
        domainDetails: AwsApiCallActionDomainDetails? = nil,
        firstSeen: String? = nil,
        lastSeen: String? = nil,
        remoteIpDetails: ActionRemoteIpDetails? = nil,
        serviceName: String? = nil
    )
    {
        self.affectedResources = affectedResources
        self.api = api
        self.callerType = callerType
        self.domainDetails = domainDetails
        self.firstSeen = firstSeen
        self.lastSeen = lastSeen
        self.remoteIpDetails = remoteIpDetails
        self.serviceName = serviceName
    }
}

extension AwsApiCallActionDomainDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domain = "Domain"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension AwsApiCallActionDomainDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsApiCallActionDomainDetails(domain: \(String(describing: domain)))"}
}

/// <p>Provided if <code>CallerType</code> is <code>domain</code>. It provides information
///          about the DNS domain that issued the API call.</p>
public struct AwsApiCallActionDomainDetails: Equatable {
    /// <p>The name of the DNS domain that issued the API call.</p>
    public let domain: String?

    public init (
        domain: String? = nil
    )
    {
        self.domain = domain
    }
}

extension AwsApiGatewayAccessLogSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationArn = "DestinationArn"
        case format = "Format"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationArn = destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .format)
        format = formatDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
    }
}

extension AwsApiGatewayAccessLogSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsApiGatewayAccessLogSettings(destinationArn: \(String(describing: destinationArn)), format: \(String(describing: format)))"}
}

/// <p>Contains information about settings for logging access for the stage.</p>
public struct AwsApiGatewayAccessLogSettings: Equatable {
    /// <p>The ARN of the CloudWatch Logs log group that receives the access logs.</p>
    public let destinationArn: String?
    /// <p>A single-line format of the access logs of data, as specified by selected
    ///             <code>$context</code> variables. The format must include at least
    ///             <code>$context.requestId</code>.</p>
    public let format: String?

    public init (
        destinationArn: String? = nil,
        format: String? = nil
    )
    {
        self.destinationArn = destinationArn
        self.format = format
    }
}

extension AwsApiGatewayCanarySettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deploymentId = "DeploymentId"
        case percentTraffic = "PercentTraffic"
        case stageVariableOverrides = "StageVariableOverrides"
        case useStageCache = "UseStageCache"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if percentTraffic != 0.0 {
            try encodeContainer.encode(percentTraffic, forKey: .percentTraffic)
        }
        if let stageVariableOverrides = stageVariableOverrides {
            var stageVariableOverridesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .stageVariableOverrides)
            for (dictKey0, fieldmap0) in stageVariableOverrides {
                try stageVariableOverridesContainer.encode(fieldmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if useStageCache != false {
            try encodeContainer.encode(useStageCache, forKey: .useStageCache)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentTrafficDecoded = try containerValues.decode(Double.self, forKey: .percentTraffic)
        percentTraffic = percentTrafficDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let stageVariableOverridesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stageVariableOverrides)
        var stageVariableOverridesDecoded0: [String:String]? = nil
        if let stageVariableOverridesContainer = stageVariableOverridesContainer {
            stageVariableOverridesDecoded0 = [String:String]()
            for (key0, nonemptystring0) in stageVariableOverridesContainer {
                if let nonemptystring0 = nonemptystring0 {
                    stageVariableOverridesDecoded0?[key0] = nonemptystring0
                }
            }
        }
        stageVariableOverrides = stageVariableOverridesDecoded0
        let useStageCacheDecoded = try containerValues.decode(Bool.self, forKey: .useStageCache)
        useStageCache = useStageCacheDecoded
    }
}

extension AwsApiGatewayCanarySettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsApiGatewayCanarySettings(deploymentId: \(String(describing: deploymentId)), percentTraffic: \(String(describing: percentTraffic)), stageVariableOverrides: \(String(describing: stageVariableOverrides)), useStageCache: \(String(describing: useStageCache)))"}
}

/// <p>Contains information about settings for canary deployment in the stage.</p>
public struct AwsApiGatewayCanarySettings: Equatable {
    /// <p>The deployment identifier for the canary deployment.</p>
    public let deploymentId: String?
    /// <p>The percentage of traffic that is diverted to a canary deployment.</p>
    public let percentTraffic: Double
    /// <p>Stage variables that are overridden in the canary release deployment. The variables
    ///          include new stage variables that are introduced in the canary.</p>
    ///          <p>Each variable is represented as a string-to-string map between the stage variable name
    ///          and the variable value.</p>
    public let stageVariableOverrides: [String:String]?
    /// <p>Indicates whether the canary deployment uses the stage cache.</p>
    public let useStageCache: Bool

    public init (
        deploymentId: String? = nil,
        percentTraffic: Double = 0.0,
        stageVariableOverrides: [String:String]? = nil,
        useStageCache: Bool = false
    )
    {
        self.deploymentId = deploymentId
        self.percentTraffic = percentTraffic
        self.stageVariableOverrides = stageVariableOverrides
        self.useStageCache = useStageCache
    }
}

extension AwsApiGatewayEndpointConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case types = "Types"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let types = types {
            var typesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .types)
            for nonemptystringlist0 in types {
                try typesContainer.encode(nonemptystringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .types)
        var typesDecoded0:[String]? = nil
        if let typesContainer = typesContainer {
            typesDecoded0 = [String]()
            for string0 in typesContainer {
                if let string0 = string0 {
                    typesDecoded0?.append(string0)
                }
            }
        }
        types = typesDecoded0
    }
}

extension AwsApiGatewayEndpointConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsApiGatewayEndpointConfiguration(types: \(String(describing: types)))"}
}

/// <p>Contains information about the endpoints for the API.</p>
public struct AwsApiGatewayEndpointConfiguration: Equatable {
    /// <p>A list of endpoint types for the REST API.</p>
    ///          <p>For an edge-optimized API, the endpoint type is <code>EDGE</code>. For a Regional API,
    ///          the endpoint type is <code>REGIONAL</code>. For a private API, the endpoint type is
    ///             <code>PRIVATE</code>.</p>
    public let types: [String]?

    public init (
        types: [String]? = nil
    )
    {
        self.types = types
    }
}

extension AwsApiGatewayMethodSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cacheDataEncrypted = "CacheDataEncrypted"
        case cacheTtlInSeconds = "CacheTtlInSeconds"
        case cachingEnabled = "CachingEnabled"
        case dataTraceEnabled = "DataTraceEnabled"
        case httpMethod = "HttpMethod"
        case loggingLevel = "LoggingLevel"
        case metricsEnabled = "MetricsEnabled"
        case requireAuthorizationForCacheControl = "RequireAuthorizationForCacheControl"
        case resourcePath = "ResourcePath"
        case throttlingBurstLimit = "ThrottlingBurstLimit"
        case throttlingRateLimit = "ThrottlingRateLimit"
        case unauthorizedCacheControlHeaderStrategy = "UnauthorizedCacheControlHeaderStrategy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cacheDataEncrypted != false {
            try encodeContainer.encode(cacheDataEncrypted, forKey: .cacheDataEncrypted)
        }
        if cacheTtlInSeconds != 0 {
            try encodeContainer.encode(cacheTtlInSeconds, forKey: .cacheTtlInSeconds)
        }
        if cachingEnabled != false {
            try encodeContainer.encode(cachingEnabled, forKey: .cachingEnabled)
        }
        if dataTraceEnabled != false {
            try encodeContainer.encode(dataTraceEnabled, forKey: .dataTraceEnabled)
        }
        if let httpMethod = httpMethod {
            try encodeContainer.encode(httpMethod, forKey: .httpMethod)
        }
        if let loggingLevel = loggingLevel {
            try encodeContainer.encode(loggingLevel, forKey: .loggingLevel)
        }
        if metricsEnabled != false {
            try encodeContainer.encode(metricsEnabled, forKey: .metricsEnabled)
        }
        if requireAuthorizationForCacheControl != false {
            try encodeContainer.encode(requireAuthorizationForCacheControl, forKey: .requireAuthorizationForCacheControl)
        }
        if let resourcePath = resourcePath {
            try encodeContainer.encode(resourcePath, forKey: .resourcePath)
        }
        if throttlingBurstLimit != 0 {
            try encodeContainer.encode(throttlingBurstLimit, forKey: .throttlingBurstLimit)
        }
        if throttlingRateLimit != 0.0 {
            try encodeContainer.encode(throttlingRateLimit, forKey: .throttlingRateLimit)
        }
        if let unauthorizedCacheControlHeaderStrategy = unauthorizedCacheControlHeaderStrategy {
            try encodeContainer.encode(unauthorizedCacheControlHeaderStrategy, forKey: .unauthorizedCacheControlHeaderStrategy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricsEnabledDecoded = try containerValues.decode(Bool.self, forKey: .metricsEnabled)
        metricsEnabled = metricsEnabledDecoded
        let loggingLevelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loggingLevel)
        loggingLevel = loggingLevelDecoded
        let dataTraceEnabledDecoded = try containerValues.decode(Bool.self, forKey: .dataTraceEnabled)
        dataTraceEnabled = dataTraceEnabledDecoded
        let throttlingBurstLimitDecoded = try containerValues.decode(Int.self, forKey: .throttlingBurstLimit)
        throttlingBurstLimit = throttlingBurstLimitDecoded
        let throttlingRateLimitDecoded = try containerValues.decode(Double.self, forKey: .throttlingRateLimit)
        throttlingRateLimit = throttlingRateLimitDecoded
        let cachingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .cachingEnabled)
        cachingEnabled = cachingEnabledDecoded
        let cacheTtlInSecondsDecoded = try containerValues.decode(Int.self, forKey: .cacheTtlInSeconds)
        cacheTtlInSeconds = cacheTtlInSecondsDecoded
        let cacheDataEncryptedDecoded = try containerValues.decode(Bool.self, forKey: .cacheDataEncrypted)
        cacheDataEncrypted = cacheDataEncryptedDecoded
        let requireAuthorizationForCacheControlDecoded = try containerValues.decode(Bool.self, forKey: .requireAuthorizationForCacheControl)
        requireAuthorizationForCacheControl = requireAuthorizationForCacheControlDecoded
        let unauthorizedCacheControlHeaderStrategyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unauthorizedCacheControlHeaderStrategy)
        unauthorizedCacheControlHeaderStrategy = unauthorizedCacheControlHeaderStrategyDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let resourcePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourcePath)
        resourcePath = resourcePathDecoded
    }
}

extension AwsApiGatewayMethodSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsApiGatewayMethodSettings(cacheDataEncrypted: \(String(describing: cacheDataEncrypted)), cacheTtlInSeconds: \(String(describing: cacheTtlInSeconds)), cachingEnabled: \(String(describing: cachingEnabled)), dataTraceEnabled: \(String(describing: dataTraceEnabled)), httpMethod: \(String(describing: httpMethod)), loggingLevel: \(String(describing: loggingLevel)), metricsEnabled: \(String(describing: metricsEnabled)), requireAuthorizationForCacheControl: \(String(describing: requireAuthorizationForCacheControl)), resourcePath: \(String(describing: resourcePath)), throttlingBurstLimit: \(String(describing: throttlingBurstLimit)), throttlingRateLimit: \(String(describing: throttlingRateLimit)), unauthorizedCacheControlHeaderStrategy: \(String(describing: unauthorizedCacheControlHeaderStrategy)))"}
}

/// <p>Defines settings for a method for the stage.</p>
public struct AwsApiGatewayMethodSettings: Equatable {
    /// <p>Indicates whether the cached responses are encrypted. </p>
    public let cacheDataEncrypted: Bool
    /// <p>Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL,
    ///          the longer the response is cached.</p>
    public let cacheTtlInSeconds: Int
    /// <p>Indicates whether responses are cached and returned for requests. For responses to be
    ///          cached, a cache cluster must be enabled on the stage.</p>
    public let cachingEnabled: Bool
    /// <p>Indicates whether data trace logging is enabled for the method. Data trace logging
    ///          affects the log entries that are pushed to CloudWatch Logs.</p>
    public let dataTraceEnabled: Bool
    /// <p>The HTTP method. You can use an asterisk (*) as a wildcard to apply method settings to
    ///          multiple methods.</p>
    public let httpMethod: String?
    /// <p>The logging level for this method. The logging level affects the log entries that are
    ///          pushed to CloudWatch Logs.</p>
    ///          <p>If the logging level is <code>ERROR</code>, then the logs only include error-level
    ///          entries.</p>
    ///          <p>If the logging level is <code>INFO</code>, then the logs include both <code>ERROR</code>
    ///          events and extra informational events.</p>
    ///          <p>Valid values: <code>OFF</code> | <code>ERROR</code> | <code>INFO</code>
    ///          </p>
    public let loggingLevel: String?
    /// <p>Indicates whether CloudWatch metrics are enabled for the method. </p>
    public let metricsEnabled: Bool
    /// <p>Indicates whether authorization is required for a cache invalidation request.</p>
    public let requireAuthorizationForCacheControl: Bool
    /// <p>The resource path for this method. Forward slashes (/) are encoded as ~1 . The initial
    ///          slash must include a forward slash.</p>
    ///          <p>For example, the path value <code>/resource/subresource</code> must be encoded as
    ///             <code>/~1resource~1subresource</code>.</p>
    ///          <p>To specify the root path, use only a slash (/). You can use an asterisk (*) as a
    ///          wildcard to apply method settings to multiple methods.</p>
    public let resourcePath: String?
    /// <p>The throttling burst limit for the method.</p>
    public let throttlingBurstLimit: Int
    /// <p>The throttling rate limit for the method.</p>
    public let throttlingRateLimit: Double
    /// <p>Indicates how to handle unauthorized requests for cache invalidation.</p>
    ///          <p>Valid values: <code>FAIL_WITH_403</code> | <code>SUCCEED_WITH_RESPONSE_HEADER</code> |
    ///             <code>SUCCEED_WITHOUT_RESPONSE_HEADER</code>
    ///          </p>
    public let unauthorizedCacheControlHeaderStrategy: String?

    public init (
        cacheDataEncrypted: Bool = false,
        cacheTtlInSeconds: Int = 0,
        cachingEnabled: Bool = false,
        dataTraceEnabled: Bool = false,
        httpMethod: String? = nil,
        loggingLevel: String? = nil,
        metricsEnabled: Bool = false,
        requireAuthorizationForCacheControl: Bool = false,
        resourcePath: String? = nil,
        throttlingBurstLimit: Int = 0,
        throttlingRateLimit: Double = 0.0,
        unauthorizedCacheControlHeaderStrategy: String? = nil
    )
    {
        self.cacheDataEncrypted = cacheDataEncrypted
        self.cacheTtlInSeconds = cacheTtlInSeconds
        self.cachingEnabled = cachingEnabled
        self.dataTraceEnabled = dataTraceEnabled
        self.httpMethod = httpMethod
        self.loggingLevel = loggingLevel
        self.metricsEnabled = metricsEnabled
        self.requireAuthorizationForCacheControl = requireAuthorizationForCacheControl
        self.resourcePath = resourcePath
        self.throttlingBurstLimit = throttlingBurstLimit
        self.throttlingRateLimit = throttlingRateLimit
        self.unauthorizedCacheControlHeaderStrategy = unauthorizedCacheControlHeaderStrategy
    }
}

extension AwsApiGatewayRestApiDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKeySource = "ApiKeySource"
        case binaryMediaTypes = "BinaryMediaTypes"
        case createdDate = "CreatedDate"
        case description = "Description"
        case endpointConfiguration = "EndpointConfiguration"
        case id = "Id"
        case minimumCompressionSize = "MinimumCompressionSize"
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeySource = apiKeySource {
            try encodeContainer.encode(apiKeySource, forKey: .apiKeySource)
        }
        if let binaryMediaTypes = binaryMediaTypes {
            var binaryMediaTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .binaryMediaTypes)
            for nonemptystringlist0 in binaryMediaTypes {
                try binaryMediaTypesContainer.encode(nonemptystringlist0)
            }
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endpointConfiguration = endpointConfiguration {
            try encodeContainer.encode(endpointConfiguration, forKey: .endpointConfiguration)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if minimumCompressionSize != 0 {
            try encodeContainer.encode(minimumCompressionSize, forKey: .minimumCompressionSize)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decode(Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(AwsApiGatewayEndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
    }
}

extension AwsApiGatewayRestApiDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsApiGatewayRestApiDetails(apiKeySource: \(String(describing: apiKeySource)), binaryMediaTypes: \(String(describing: binaryMediaTypes)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), endpointConfiguration: \(String(describing: endpointConfiguration)), id: \(String(describing: id)), minimumCompressionSize: \(String(describing: minimumCompressionSize)), name: \(String(describing: name)), version: \(String(describing: version)))"}
}

/// <p>Contains information about a REST API in version 1 of Amazon API Gateway.</p>
public struct AwsApiGatewayRestApiDetails: Equatable {
    /// <p>The source of the API key for metering requests according to a usage plan.</p>
    ///          <p>
    ///             <code>HEADER</code> indicates whether to read the API key from the X-API-Key header of a
    ///          request.</p>
    ///          <p>
    ///             <code>AUTHORIZER</code> indicates whether to read the API key from the
    ///             <code>UsageIdentifierKey</code> from a custom authorizer.</p>
    public let apiKeySource: String?
    /// <p>The list of binary media types supported by the REST API.</p>
    public let binaryMediaTypes: [String]?
    /// <p>Indicates when the API was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let createdDate: String?
    /// <p>A description of the REST API.</p>
    public let description: String?
    /// <p>The endpoint configuration of the REST API.</p>
    public let endpointConfiguration: AwsApiGatewayEndpointConfiguration?
    /// <p>The identifier of the REST API.</p>
    public let id: String?
    /// <p>The minimum size in bytes of a payload before compression is enabled.</p>
    ///          <p>If <code>null</code>, then compression is disabled.</p>
    ///          <p>If 0, then all payloads are compressed.</p>
    public let minimumCompressionSize: Int
    /// <p>The name of the REST API.</p>
    public let name: String?
    /// <p>The version identifier for the REST API.</p>
    public let version: String?

    public init (
        apiKeySource: String? = nil,
        binaryMediaTypes: [String]? = nil,
        createdDate: String? = nil,
        description: String? = nil,
        endpointConfiguration: AwsApiGatewayEndpointConfiguration? = nil,
        id: String? = nil,
        minimumCompressionSize: Int = 0,
        name: String? = nil,
        version: String? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.version = version
    }
}

extension AwsApiGatewayStageDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessLogSettings = "AccessLogSettings"
        case cacheClusterEnabled = "CacheClusterEnabled"
        case cacheClusterSize = "CacheClusterSize"
        case cacheClusterStatus = "CacheClusterStatus"
        case canarySettings = "CanarySettings"
        case clientCertificateId = "ClientCertificateId"
        case createdDate = "CreatedDate"
        case deploymentId = "DeploymentId"
        case description = "Description"
        case documentationVersion = "DocumentationVersion"
        case lastUpdatedDate = "LastUpdatedDate"
        case methodSettings = "MethodSettings"
        case stageName = "StageName"
        case tracingEnabled = "TracingEnabled"
        case variables = "Variables"
        case webAclArn = "WebAclArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLogSettings = accessLogSettings {
            try encodeContainer.encode(accessLogSettings, forKey: .accessLogSettings)
        }
        if cacheClusterEnabled != false {
            try encodeContainer.encode(cacheClusterEnabled, forKey: .cacheClusterEnabled)
        }
        if let cacheClusterSize = cacheClusterSize {
            try encodeContainer.encode(cacheClusterSize, forKey: .cacheClusterSize)
        }
        if let cacheClusterStatus = cacheClusterStatus {
            try encodeContainer.encode(cacheClusterStatus, forKey: .cacheClusterStatus)
        }
        if let canarySettings = canarySettings {
            try encodeContainer.encode(canarySettings, forKey: .canarySettings)
        }
        if let clientCertificateId = clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let documentationVersion = documentationVersion {
            try encodeContainer.encode(documentationVersion, forKey: .documentationVersion)
        }
        if let lastUpdatedDate = lastUpdatedDate {
            try encodeContainer.encode(lastUpdatedDate, forKey: .lastUpdatedDate)
        }
        if let methodSettings = methodSettings {
            var methodSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .methodSettings)
            for awsapigatewaymethodsettingslist0 in methodSettings {
                try methodSettingsContainer.encode(awsapigatewaymethodsettingslist0)
            }
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if tracingEnabled != false {
            try encodeContainer.encode(tracingEnabled, forKey: .tracingEnabled)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .variables)
            for (dictKey0, fieldmap0) in variables {
                try variablesContainer.encode(fieldmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let webAclArn = webAclArn {
            try encodeContainer.encode(webAclArn, forKey: .webAclArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let cacheClusterEnabledDecoded = try containerValues.decode(Bool.self, forKey: .cacheClusterEnabled)
        cacheClusterEnabled = cacheClusterEnabledDecoded
        let cacheClusterSizeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cacheClusterSize)
        cacheClusterSize = cacheClusterSizeDecoded
        let cacheClusterStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cacheClusterStatus)
        cacheClusterStatus = cacheClusterStatusDecoded
        let methodSettingsContainer = try containerValues.decodeIfPresent([AwsApiGatewayMethodSettings?].self, forKey: .methodSettings)
        var methodSettingsDecoded0:[AwsApiGatewayMethodSettings]? = nil
        if let methodSettingsContainer = methodSettingsContainer {
            methodSettingsDecoded0 = [AwsApiGatewayMethodSettings]()
            for structure0 in methodSettingsContainer {
                if let structure0 = structure0 {
                    methodSettingsDecoded0?.append(structure0)
                }
            }
        }
        methodSettings = methodSettingsDecoded0
        let variablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .variables)
        var variablesDecoded0: [String:String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [String:String]()
            for (key0, nonemptystring0) in variablesContainer {
                if let nonemptystring0 = nonemptystring0 {
                    variablesDecoded0?[key0] = nonemptystring0
                }
            }
        }
        variables = variablesDecoded0
        let documentationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentationVersion)
        documentationVersion = documentationVersionDecoded
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(AwsApiGatewayAccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let canarySettingsDecoded = try containerValues.decodeIfPresent(AwsApiGatewayCanarySettings.self, forKey: .canarySettings)
        canarySettings = canarySettingsDecoded
        let tracingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .tracingEnabled)
        tracingEnabled = tracingEnabledDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let webAclArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webAclArn)
        webAclArn = webAclArnDecoded
    }
}

extension AwsApiGatewayStageDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsApiGatewayStageDetails(accessLogSettings: \(String(describing: accessLogSettings)), cacheClusterEnabled: \(String(describing: cacheClusterEnabled)), cacheClusterSize: \(String(describing: cacheClusterSize)), cacheClusterStatus: \(String(describing: cacheClusterStatus)), canarySettings: \(String(describing: canarySettings)), clientCertificateId: \(String(describing: clientCertificateId)), createdDate: \(String(describing: createdDate)), deploymentId: \(String(describing: deploymentId)), description: \(String(describing: description)), documentationVersion: \(String(describing: documentationVersion)), lastUpdatedDate: \(String(describing: lastUpdatedDate)), methodSettings: \(String(describing: methodSettings)), stageName: \(String(describing: stageName)), tracingEnabled: \(String(describing: tracingEnabled)), variables: \(String(describing: variables)), webAclArn: \(String(describing: webAclArn)))"}
}

/// <p>Provides information about a version 1 Amazon API Gateway stage.</p>
public struct AwsApiGatewayStageDetails: Equatable {
    /// <p>Settings for logging access for the stage.</p>
    public let accessLogSettings: AwsApiGatewayAccessLogSettings?
    /// <p>Indicates whether a cache cluster is enabled for the stage.</p>
    public let cacheClusterEnabled: Bool
    /// <p>If a cache cluster is enabled, the size of the cache cluster.</p>
    public let cacheClusterSize: String?
    /// <p>If a cache cluster is enabled, the status of the cache cluster.</p>
    public let cacheClusterStatus: String?
    /// <p>Information about settings for canary deployment in the stage.</p>
    public let canarySettings: AwsApiGatewayCanarySettings?
    /// <p>The identifier of the client certificate for the stage.</p>
    public let clientCertificateId: String?
    /// <p>Indicates when the stage was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let createdDate: String?
    /// <p>The identifier of the deployment that the stage points to.</p>
    public let deploymentId: String?
    /// <p>A description of the stage.</p>
    public let description: String?
    /// <p>The version of the API documentation that is associated with the stage.</p>
    public let documentationVersion: String?
    /// <p>Indicates when the stage was most recently updated.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let lastUpdatedDate: String?
    /// <p>Defines the method settings for the stage.</p>
    public let methodSettings: [AwsApiGatewayMethodSettings]?
    /// <p>The name of the stage.</p>
    public let stageName: String?
    /// <p>Indicates whether active tracing with AWS X-Ray is enabled for the stage.</p>
    public let tracingEnabled: Bool
    /// <p>A map that defines the stage variables for the stage.</p>
    ///          <p>Variable names can have alphanumeric and underscore characters.</p>
    ///          <p>Variable values can contain the following characters:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Uppercase and lowercase letters</p>
    ///             </li>
    ///             <li>
    ///                <p>Numbers</p>
    ///             </li>
    ///             <li>
    ///                <p>Special characters -._~:/?#&=,</p>
    ///             </li>
    ///          </ul>
    public let variables: [String:String]?
    /// <p>The ARN of the web ACL associated with the stage.</p>
    public let webAclArn: String?

    public init (
        accessLogSettings: AwsApiGatewayAccessLogSettings? = nil,
        cacheClusterEnabled: Bool = false,
        cacheClusterSize: String? = nil,
        cacheClusterStatus: String? = nil,
        canarySettings: AwsApiGatewayCanarySettings? = nil,
        clientCertificateId: String? = nil,
        createdDate: String? = nil,
        deploymentId: String? = nil,
        description: String? = nil,
        documentationVersion: String? = nil,
        lastUpdatedDate: String? = nil,
        methodSettings: [AwsApiGatewayMethodSettings]? = nil,
        stageName: String? = nil,
        tracingEnabled: Bool = false,
        variables: [String:String]? = nil,
        webAclArn: String? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.cacheClusterStatus = cacheClusterStatus
        self.canarySettings = canarySettings
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.description = description
        self.documentationVersion = documentationVersion
        self.lastUpdatedDate = lastUpdatedDate
        self.methodSettings = methodSettings
        self.stageName = stageName
        self.tracingEnabled = tracingEnabled
        self.variables = variables
        self.webAclArn = webAclArn
    }
}

extension AwsApiGatewayV2ApiDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiEndpoint = "ApiEndpoint"
        case apiId = "ApiId"
        case apiKeySelectionExpression = "ApiKeySelectionExpression"
        case corsConfiguration = "CorsConfiguration"
        case createdDate = "CreatedDate"
        case description = "Description"
        case name = "Name"
        case protocolType = "ProtocolType"
        case routeSelectionExpression = "RouteSelectionExpression"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiEndpoint = apiEndpoint {
            try encodeContainer.encode(apiEndpoint, forKey: .apiEndpoint)
        }
        if let apiId = apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiKeySelectionExpression = apiKeySelectionExpression {
            try encodeContainer.encode(apiKeySelectionExpression, forKey: .apiKeySelectionExpression)
        }
        if let corsConfiguration = corsConfiguration {
            try encodeContainer.encode(corsConfiguration, forKey: .corsConfiguration)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protocolType = protocolType {
            try encodeContainer.encode(protocolType, forKey: .protocolType)
        }
        if let routeSelectionExpression = routeSelectionExpression {
            try encodeContainer.encode(routeSelectionExpression, forKey: .routeSelectionExpression)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(AwsCorsConfiguration.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
    }
}

extension AwsApiGatewayV2ApiDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsApiGatewayV2ApiDetails(apiEndpoint: \(String(describing: apiEndpoint)), apiId: \(String(describing: apiId)), apiKeySelectionExpression: \(String(describing: apiKeySelectionExpression)), corsConfiguration: \(String(describing: corsConfiguration)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), name: \(String(describing: name)), protocolType: \(String(describing: protocolType)), routeSelectionExpression: \(String(describing: routeSelectionExpression)), version: \(String(describing: version)))"}
}

/// <p>Contains information about a version 2 API in Amazon API Gateway.</p>
public struct AwsApiGatewayV2ApiDetails: Equatable {
    /// <p>The URI of the API. </p>
    ///          <p>Uses the format
    ///                <code>
    ///                <i><api-id></i>.execute-api.<i><region></i>.amazonaws.com</code>
    ///          </p>
    ///          <p>The stage name is typically appended to the URI to form a complete path to a deployed
    ///          API stage.</p>
    public let apiEndpoint: String?
    /// <p>The identifier of the API.</p>
    public let apiId: String?
    /// <p>An API key selection expression. Supported only for WebSocket APIs. </p>
    public let apiKeySelectionExpression: String?
    /// <p>A cross-origin resource sharing (CORS) configuration. Supported only for HTTP
    ///          APIs.</p>
    public let corsConfiguration: AwsCorsConfiguration?
    /// <p>Indicates when the API was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let createdDate: String?
    /// <p>A description of the API.</p>
    public let description: String?
    /// <p>The name of the API.</p>
    public let name: String?
    /// <p>The API protocol for the API.</p>
    ///          <p>Valid values: <code>WEBSOCKET</code> | <code>HTTP</code>
    ///          </p>
    public let protocolType: String?
    /// <p>The route selection expression for the API.</p>
    ///          <p>For HTTP APIs, must be <code>${request.method} ${request.path}</code>. This is the
    ///          default value for HTTP APIs.</p>
    ///          <p>For WebSocket APIs, there is no default value.</p>
    public let routeSelectionExpression: String?
    /// <p>The version identifier for the API.</p>
    public let version: String?

    public init (
        apiEndpoint: String? = nil,
        apiId: String? = nil,
        apiKeySelectionExpression: String? = nil,
        corsConfiguration: AwsCorsConfiguration? = nil,
        createdDate: String? = nil,
        description: String? = nil,
        name: String? = nil,
        protocolType: String? = nil,
        routeSelectionExpression: String? = nil,
        version: String? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.version = version
    }
}

extension AwsApiGatewayV2RouteSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataTraceEnabled = "DataTraceEnabled"
        case detailedMetricsEnabled = "DetailedMetricsEnabled"
        case loggingLevel = "LoggingLevel"
        case throttlingBurstLimit = "ThrottlingBurstLimit"
        case throttlingRateLimit = "ThrottlingRateLimit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dataTraceEnabled != false {
            try encodeContainer.encode(dataTraceEnabled, forKey: .dataTraceEnabled)
        }
        if detailedMetricsEnabled != false {
            try encodeContainer.encode(detailedMetricsEnabled, forKey: .detailedMetricsEnabled)
        }
        if let loggingLevel = loggingLevel {
            try encodeContainer.encode(loggingLevel, forKey: .loggingLevel)
        }
        if throttlingBurstLimit != 0 {
            try encodeContainer.encode(throttlingBurstLimit, forKey: .throttlingBurstLimit)
        }
        if throttlingRateLimit != 0.0 {
            try encodeContainer.encode(throttlingRateLimit, forKey: .throttlingRateLimit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMetricsEnabledDecoded = try containerValues.decode(Bool.self, forKey: .detailedMetricsEnabled)
        detailedMetricsEnabled = detailedMetricsEnabledDecoded
        let loggingLevelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loggingLevel)
        loggingLevel = loggingLevelDecoded
        let dataTraceEnabledDecoded = try containerValues.decode(Bool.self, forKey: .dataTraceEnabled)
        dataTraceEnabled = dataTraceEnabledDecoded
        let throttlingBurstLimitDecoded = try containerValues.decode(Int.self, forKey: .throttlingBurstLimit)
        throttlingBurstLimit = throttlingBurstLimitDecoded
        let throttlingRateLimitDecoded = try containerValues.decode(Double.self, forKey: .throttlingRateLimit)
        throttlingRateLimit = throttlingRateLimitDecoded
    }
}

extension AwsApiGatewayV2RouteSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsApiGatewayV2RouteSettings(dataTraceEnabled: \(String(describing: dataTraceEnabled)), detailedMetricsEnabled: \(String(describing: detailedMetricsEnabled)), loggingLevel: \(String(describing: loggingLevel)), throttlingBurstLimit: \(String(describing: throttlingBurstLimit)), throttlingRateLimit: \(String(describing: throttlingRateLimit)))"}
}

/// <p>Contains route settings for a stage.</p>
public struct AwsApiGatewayV2RouteSettings: Equatable {
    /// <p>Indicates whether data trace logging is enabled. Data trace logging affects the log
    ///          entries that are pushed to CloudWatch Logs. Supported only for WebSocket APIs.</p>
    public let dataTraceEnabled: Bool
    /// <p>Indicates whether detailed metrics are enabled.</p>
    public let detailedMetricsEnabled: Bool
    /// <p>The logging level. The logging level affects the log entries that are pushed to
    ///          CloudWatch Logs. Supported only for WebSocket APIs.</p>
    ///          <p>If the logging level is <code>ERROR</code>, then the logs only include error-level
    ///          entries.</p>
    ///          <p>If the logging level is <code>INFO</code>, then the logs include both <code>ERROR</code>
    ///          events and extra informational events.</p>
    ///          <p>Valid values: <code>OFF</code> | <code>ERROR</code> | <code>INFO</code>
    ///          </p>
    public let loggingLevel: String?
    /// <p>The throttling burst limit.</p>
    public let throttlingBurstLimit: Int
    /// <p>The throttling rate limit.</p>
    public let throttlingRateLimit: Double

    public init (
        dataTraceEnabled: Bool = false,
        detailedMetricsEnabled: Bool = false,
        loggingLevel: String? = nil,
        throttlingBurstLimit: Int = 0,
        throttlingRateLimit: Double = 0.0
    )
    {
        self.dataTraceEnabled = dataTraceEnabled
        self.detailedMetricsEnabled = detailedMetricsEnabled
        self.loggingLevel = loggingLevel
        self.throttlingBurstLimit = throttlingBurstLimit
        self.throttlingRateLimit = throttlingRateLimit
    }
}

extension AwsApiGatewayV2StageDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessLogSettings = "AccessLogSettings"
        case apiGatewayManaged = "ApiGatewayManaged"
        case autoDeploy = "AutoDeploy"
        case createdDate = "CreatedDate"
        case defaultRouteSettings = "DefaultRouteSettings"
        case deploymentId = "DeploymentId"
        case description = "Description"
        case lastDeploymentStatusMessage = "LastDeploymentStatusMessage"
        case lastUpdatedDate = "LastUpdatedDate"
        case routeSettings = "RouteSettings"
        case stageName = "StageName"
        case stageVariables = "StageVariables"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLogSettings = accessLogSettings {
            try encodeContainer.encode(accessLogSettings, forKey: .accessLogSettings)
        }
        if apiGatewayManaged != false {
            try encodeContainer.encode(apiGatewayManaged, forKey: .apiGatewayManaged)
        }
        if autoDeploy != false {
            try encodeContainer.encode(autoDeploy, forKey: .autoDeploy)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let defaultRouteSettings = defaultRouteSettings {
            try encodeContainer.encode(defaultRouteSettings, forKey: .defaultRouteSettings)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastDeploymentStatusMessage = lastDeploymentStatusMessage {
            try encodeContainer.encode(lastDeploymentStatusMessage, forKey: .lastDeploymentStatusMessage)
        }
        if let lastUpdatedDate = lastUpdatedDate {
            try encodeContainer.encode(lastUpdatedDate, forKey: .lastUpdatedDate)
        }
        if let routeSettings = routeSettings {
            try encodeContainer.encode(routeSettings, forKey: .routeSettings)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let stageVariables = stageVariables {
            var stageVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .stageVariables)
            for (dictKey0, fieldmap0) in stageVariables {
                try stageVariablesContainer.encode(fieldmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let defaultRouteSettingsDecoded = try containerValues.decodeIfPresent(AwsApiGatewayV2RouteSettings.self, forKey: .defaultRouteSettings)
        defaultRouteSettings = defaultRouteSettingsDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let routeSettingsDecoded = try containerValues.decodeIfPresent(AwsApiGatewayV2RouteSettings.self, forKey: .routeSettings)
        routeSettings = routeSettingsDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [String:String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [String:String]()
            for (key0, nonemptystring0) in stageVariablesContainer {
                if let nonemptystring0 = nonemptystring0 {
                    stageVariablesDecoded0?[key0] = nonemptystring0
                }
            }
        }
        stageVariables = stageVariablesDecoded0
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(AwsApiGatewayAccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let autoDeployDecoded = try containerValues.decode(Bool.self, forKey: .autoDeploy)
        autoDeploy = autoDeployDecoded
        let lastDeploymentStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastDeploymentStatusMessage)
        lastDeploymentStatusMessage = lastDeploymentStatusMessageDecoded
        let apiGatewayManagedDecoded = try containerValues.decode(Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
    }
}

extension AwsApiGatewayV2StageDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsApiGatewayV2StageDetails(accessLogSettings: \(String(describing: accessLogSettings)), apiGatewayManaged: \(String(describing: apiGatewayManaged)), autoDeploy: \(String(describing: autoDeploy)), createdDate: \(String(describing: createdDate)), defaultRouteSettings: \(String(describing: defaultRouteSettings)), deploymentId: \(String(describing: deploymentId)), description: \(String(describing: description)), lastDeploymentStatusMessage: \(String(describing: lastDeploymentStatusMessage)), lastUpdatedDate: \(String(describing: lastUpdatedDate)), routeSettings: \(String(describing: routeSettings)), stageName: \(String(describing: stageName)), stageVariables: \(String(describing: stageVariables)))"}
}

/// <p>Contains information about a version 2 stage for Amazon API Gateway.</p>
public struct AwsApiGatewayV2StageDetails: Equatable {
    /// <p>Information about settings for logging access for the stage.</p>
    public let accessLogSettings: AwsApiGatewayAccessLogSettings?
    /// <p>Indicates whether the stage is managed by API Gateway.</p>
    public let apiGatewayManaged: Bool
    /// <p>Indicates whether updates to an API automatically trigger a new deployment.</p>
    public let autoDeploy: Bool
    /// <p>Indicates when the stage was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let createdDate: String?
    /// <p>Default route settings for the stage.</p>
    public let defaultRouteSettings: AwsApiGatewayV2RouteSettings?
    /// <p>The identifier of the deployment that the stage is associated with. </p>
    public let deploymentId: String?
    /// <p>The description of the stage.</p>
    public let description: String?
    /// <p>The status of the last deployment of a stage. Supported only if the stage has automatic
    ///          deployment enabled.</p>
    public let lastDeploymentStatusMessage: String?
    /// <p>Indicates when the stage was most recently updated.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let lastUpdatedDate: String?
    /// <p>The route settings for the stage.</p>
    public let routeSettings: AwsApiGatewayV2RouteSettings?
    /// <p>The name of the stage.</p>
    public let stageName: String?
    /// <p>A map that defines the stage variables for the stage.</p>
    ///          <p>Variable names can have alphanumeric and underscore characters.</p>
    ///          <p>Variable values can contain the following characters:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Uppercase and lowercase letters</p>
    ///             </li>
    ///             <li>
    ///                <p>Numbers</p>
    ///             </li>
    ///             <li>
    ///                <p>Special characters -._~:/?#&=,</p>
    ///             </li>
    ///          </ul>
    public let stageVariables: [String:String]?

    public init (
        accessLogSettings: AwsApiGatewayAccessLogSettings? = nil,
        apiGatewayManaged: Bool = false,
        autoDeploy: Bool = false,
        createdDate: String? = nil,
        defaultRouteSettings: AwsApiGatewayV2RouteSettings? = nil,
        deploymentId: String? = nil,
        description: String? = nil,
        lastDeploymentStatusMessage: String? = nil,
        lastUpdatedDate: String? = nil,
        routeSettings: AwsApiGatewayV2RouteSettings? = nil,
        stageName: String? = nil,
        stageVariables: [String:String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiGatewayManaged = apiGatewayManaged
        self.autoDeploy = autoDeploy
        self.createdDate = createdDate
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
        self.lastUpdatedDate = lastUpdatedDate
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
    }
}

extension AwsAutoScalingAutoScalingGroupDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case healthCheckGracePeriod = "HealthCheckGracePeriod"
        case healthCheckType = "HealthCheckType"
        case launchConfigurationName = "LaunchConfigurationName"
        case loadBalancerNames = "LoadBalancerNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if healthCheckGracePeriod != 0 {
            try encodeContainer.encode(healthCheckGracePeriod, forKey: .healthCheckGracePeriod)
        }
        if let healthCheckType = healthCheckType {
            try encodeContainer.encode(healthCheckType, forKey: .healthCheckType)
        }
        if let launchConfigurationName = launchConfigurationName {
            try encodeContainer.encode(launchConfigurationName, forKey: .launchConfigurationName)
        }
        if let loadBalancerNames = loadBalancerNames {
            var loadBalancerNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loadBalancerNames)
            for stringlist0 in loadBalancerNames {
                try loadBalancerNamesContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchConfigurationName)
        launchConfigurationName = launchConfigurationNameDecoded
        let loadBalancerNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .loadBalancerNames)
        var loadBalancerNamesDecoded0:[String]? = nil
        if let loadBalancerNamesContainer = loadBalancerNamesContainer {
            loadBalancerNamesDecoded0 = [String]()
            for string0 in loadBalancerNamesContainer {
                if let string0 = string0 {
                    loadBalancerNamesDecoded0?.append(string0)
                }
            }
        }
        loadBalancerNames = loadBalancerNamesDecoded0
        let healthCheckTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .healthCheckType)
        healthCheckType = healthCheckTypeDecoded
        let healthCheckGracePeriodDecoded = try containerValues.decode(Int.self, forKey: .healthCheckGracePeriod)
        healthCheckGracePeriod = healthCheckGracePeriodDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension AwsAutoScalingAutoScalingGroupDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsAutoScalingAutoScalingGroupDetails(createdTime: \(String(describing: createdTime)), healthCheckGracePeriod: \(String(describing: healthCheckGracePeriod)), healthCheckType: \(String(describing: healthCheckType)), launchConfigurationName: \(String(describing: launchConfigurationName)), loadBalancerNames: \(String(describing: loadBalancerNames)))"}
}

/// <p>Provides details about an auto scaling group.</p>
public struct AwsAutoScalingAutoScalingGroupDetails: Equatable {
    /// <p>Indicates when the auto scaling group was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let createdTime: String?
    /// <p>The amount of time, in seconds, that Amazon EC2 Auto Scaling waits before it checks the
    ///          health status of an EC2 instance that has come into service.</p>
    public let healthCheckGracePeriod: Int
    /// <p>The service to use for the health checks.</p>
    public let healthCheckType: String?
    /// <p>The name of the launch configuration.</p>
    public let launchConfigurationName: String?
    /// <p>The list of load balancers associated with the group.</p>
    public let loadBalancerNames: [String]?

    public init (
        createdTime: String? = nil,
        healthCheckGracePeriod: Int = 0,
        healthCheckType: String? = nil,
        launchConfigurationName: String? = nil,
        loadBalancerNames: [String]? = nil
    )
    {
        self.createdTime = createdTime
        self.healthCheckGracePeriod = healthCheckGracePeriod
        self.healthCheckType = healthCheckType
        self.launchConfigurationName = launchConfigurationName
        self.loadBalancerNames = loadBalancerNames
    }
}

extension AwsCertificateManagerCertificateDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case createdAt = "CreatedAt"
        case domainName = "DomainName"
        case domainValidationOptions = "DomainValidationOptions"
        case extendedKeyUsages = "ExtendedKeyUsages"
        case failureReason = "FailureReason"
        case importedAt = "ImportedAt"
        case inUseBy = "InUseBy"
        case issuedAt = "IssuedAt"
        case issuer = "Issuer"
        case keyAlgorithm = "KeyAlgorithm"
        case keyUsages = "KeyUsages"
        case notAfter = "NotAfter"
        case notBefore = "NotBefore"
        case options = "Options"
        case renewalEligibility = "RenewalEligibility"
        case renewalSummary = "RenewalSummary"
        case serial = "Serial"
        case signatureAlgorithm = "SignatureAlgorithm"
        case status = "Status"
        case subject = "Subject"
        case subjectAlternativeNames = "SubjectAlternativeNames"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainValidationOptions = domainValidationOptions {
            var domainValidationOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainValidationOptions)
            for awscertificatemanagercertificatedomainvalidationoptions0 in domainValidationOptions {
                try domainValidationOptionsContainer.encode(awscertificatemanagercertificatedomainvalidationoptions0)
            }
        }
        if let extendedKeyUsages = extendedKeyUsages {
            var extendedKeyUsagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .extendedKeyUsages)
            for awscertificatemanagercertificateextendedkeyusages0 in extendedKeyUsages {
                try extendedKeyUsagesContainer.encode(awscertificatemanagercertificateextendedkeyusages0)
            }
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let importedAt = importedAt {
            try encodeContainer.encode(importedAt, forKey: .importedAt)
        }
        if let inUseBy = inUseBy {
            var inUseByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inUseBy)
            for stringlist0 in inUseBy {
                try inUseByContainer.encode(stringlist0)
            }
        }
        if let issuedAt = issuedAt {
            try encodeContainer.encode(issuedAt, forKey: .issuedAt)
        }
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let keyAlgorithm = keyAlgorithm {
            try encodeContainer.encode(keyAlgorithm, forKey: .keyAlgorithm)
        }
        if let keyUsages = keyUsages {
            var keyUsagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keyUsages)
            for awscertificatemanagercertificatekeyusages0 in keyUsages {
                try keyUsagesContainer.encode(awscertificatemanagercertificatekeyusages0)
            }
        }
        if let notAfter = notAfter {
            try encodeContainer.encode(notAfter, forKey: .notAfter)
        }
        if let notBefore = notBefore {
            try encodeContainer.encode(notBefore, forKey: .notBefore)
        }
        if let options = options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let renewalEligibility = renewalEligibility {
            try encodeContainer.encode(renewalEligibility, forKey: .renewalEligibility)
        }
        if let renewalSummary = renewalSummary {
            try encodeContainer.encode(renewalSummary, forKey: .renewalSummary)
        }
        if let serial = serial {
            try encodeContainer.encode(serial, forKey: .serial)
        }
        if let signatureAlgorithm = signatureAlgorithm {
            try encodeContainer.encode(signatureAlgorithm, forKey: .signatureAlgorithm)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let subjectAlternativeNames = subjectAlternativeNames {
            var subjectAlternativeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subjectAlternativeNames)
            for stringlist0 in subjectAlternativeNames {
                try subjectAlternativeNamesContainer.encode(stringlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainValidationOptionsContainer = try containerValues.decodeIfPresent([AwsCertificateManagerCertificateDomainValidationOption?].self, forKey: .domainValidationOptions)
        var domainValidationOptionsDecoded0:[AwsCertificateManagerCertificateDomainValidationOption]? = nil
        if let domainValidationOptionsContainer = domainValidationOptionsContainer {
            domainValidationOptionsDecoded0 = [AwsCertificateManagerCertificateDomainValidationOption]()
            for structure0 in domainValidationOptionsContainer {
                if let structure0 = structure0 {
                    domainValidationOptionsDecoded0?.append(structure0)
                }
            }
        }
        domainValidationOptions = domainValidationOptionsDecoded0
        let extendedKeyUsagesContainer = try containerValues.decodeIfPresent([AwsCertificateManagerCertificateExtendedKeyUsage?].self, forKey: .extendedKeyUsages)
        var extendedKeyUsagesDecoded0:[AwsCertificateManagerCertificateExtendedKeyUsage]? = nil
        if let extendedKeyUsagesContainer = extendedKeyUsagesContainer {
            extendedKeyUsagesDecoded0 = [AwsCertificateManagerCertificateExtendedKeyUsage]()
            for structure0 in extendedKeyUsagesContainer {
                if let structure0 = structure0 {
                    extendedKeyUsagesDecoded0?.append(structure0)
                }
            }
        }
        extendedKeyUsages = extendedKeyUsagesDecoded0
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let importedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importedAt)
        importedAt = importedAtDecoded
        let inUseByContainer = try containerValues.decodeIfPresent([String?].self, forKey: .inUseBy)
        var inUseByDecoded0:[String]? = nil
        if let inUseByContainer = inUseByContainer {
            inUseByDecoded0 = [String]()
            for string0 in inUseByContainer {
                if let string0 = string0 {
                    inUseByDecoded0?.append(string0)
                }
            }
        }
        inUseBy = inUseByDecoded0
        let issuedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .issuedAt)
        issuedAt = issuedAtDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .issuer)
        issuer = issuerDecoded
        let keyAlgorithmDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyAlgorithm)
        keyAlgorithm = keyAlgorithmDecoded
        let keyUsagesContainer = try containerValues.decodeIfPresent([AwsCertificateManagerCertificateKeyUsage?].self, forKey: .keyUsages)
        var keyUsagesDecoded0:[AwsCertificateManagerCertificateKeyUsage]? = nil
        if let keyUsagesContainer = keyUsagesContainer {
            keyUsagesDecoded0 = [AwsCertificateManagerCertificateKeyUsage]()
            for structure0 in keyUsagesContainer {
                if let structure0 = structure0 {
                    keyUsagesDecoded0?.append(structure0)
                }
            }
        }
        keyUsages = keyUsagesDecoded0
        let notAfterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notAfter)
        notAfter = notAfterDecoded
        let notBeforeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notBefore)
        notBefore = notBeforeDecoded
        let optionsDecoded = try containerValues.decodeIfPresent(AwsCertificateManagerCertificateOptions.self, forKey: .options)
        options = optionsDecoded
        let renewalEligibilityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .renewalEligibility)
        renewalEligibility = renewalEligibilityDecoded
        let renewalSummaryDecoded = try containerValues.decodeIfPresent(AwsCertificateManagerCertificateRenewalSummary.self, forKey: .renewalSummary)
        renewalSummary = renewalSummaryDecoded
        let serialDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serial)
        serial = serialDecoded
        let signatureAlgorithmDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signatureAlgorithm)
        signatureAlgorithm = signatureAlgorithmDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let subjectAlternativeNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subjectAlternativeNames)
        var subjectAlternativeNamesDecoded0:[String]? = nil
        if let subjectAlternativeNamesContainer = subjectAlternativeNamesContainer {
            subjectAlternativeNamesDecoded0 = [String]()
            for string0 in subjectAlternativeNamesContainer {
                if let string0 = string0 {
                    subjectAlternativeNamesDecoded0?.append(string0)
                }
            }
        }
        subjectAlternativeNames = subjectAlternativeNamesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension AwsCertificateManagerCertificateDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCertificateManagerCertificateDetails(certificateAuthorityArn: \(String(describing: certificateAuthorityArn)), createdAt: \(String(describing: createdAt)), domainName: \(String(describing: domainName)), domainValidationOptions: \(String(describing: domainValidationOptions)), extendedKeyUsages: \(String(describing: extendedKeyUsages)), failureReason: \(String(describing: failureReason)), importedAt: \(String(describing: importedAt)), inUseBy: \(String(describing: inUseBy)), issuedAt: \(String(describing: issuedAt)), issuer: \(String(describing: issuer)), keyAlgorithm: \(String(describing: keyAlgorithm)), keyUsages: \(String(describing: keyUsages)), notAfter: \(String(describing: notAfter)), notBefore: \(String(describing: notBefore)), options: \(String(describing: options)), renewalEligibility: \(String(describing: renewalEligibility)), renewalSummary: \(String(describing: renewalSummary)), serial: \(String(describing: serial)), signatureAlgorithm: \(String(describing: signatureAlgorithm)), status: \(String(describing: status)), subject: \(String(describing: subject)), subjectAlternativeNames: \(String(describing: subjectAlternativeNames)), type: \(String(describing: type)))"}
}

/// <p>Provides details about an AWS Certificate Manager certificate.</p>
public struct AwsCertificateManagerCertificateDetails: Equatable {
    /// <p>The ARN of the private certificate authority (CA) that will be used to issue the
    ///          certificate.</p>
    public let certificateAuthorityArn: String?
    /// <p>Indicates when the certificate was requested.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let createdAt: String?
    /// <p>The fully qualified domain name (FQDN), such as www.example.com, that is secured by the
    ///          certificate.</p>
    public let domainName: String?
    /// <p>Contains information about the initial validation of each domain name that occurs as a
    ///          result of the <code>RequestCertificate</code> request.</p>
    ///          <p>Only provided if the certificate type is <code>AMAZON_ISSUED</code>.</p>
    public let domainValidationOptions: [AwsCertificateManagerCertificateDomainValidationOption]?
    /// <p>Contains a list of Extended Key Usage X.509 v3 extension objects. Each object specifies
    ///          a purpose for which the certificate public key can be used and consists of a name and an
    ///          object identifier (OID).</p>
    public let extendedKeyUsages: [AwsCertificateManagerCertificateExtendedKeyUsage]?
    /// <p>For a failed certificate request, the reason for the failure.</p>
    ///          <p>Valid values: <code>NO_AVAILABLE_CONTACTS</code> |
    ///             <code>ADDITIONAL_VERIFICATION_REQUIRED</code> | <code>DOMAIN_NOT_ALLOWED</code> |
    ///             <code>INVALID_PUBLIC_DOMAIN</code> | <code>DOMAIN_VALIDATION_DENIED</code> |
    ///             <code>CAA_ERROR</code> | <code>PCA_LIMIT_EXCEEDED</code> | <code>PCA_INVALID_ARN</code>
    ///          | <code>PCA_INVALID_STATE</code> | <code>PCA_REQUEST_FAILED</code> |
    ///             <code>PCA_NAME_CONSTRAINTS_VALIDATION</code> | <code>PCA_RESOURCE_NOT_FOUND</code> |
    ///             <code>PCA_INVALID_ARGS</code> | <code>PCA_INVALID_DURATION</code> |
    ///             <code>PCA_ACCESS_DENIED</code> | <code>SLR_NOT_FOUND</code> | <code>OTHER</code>
    ///          </p>
    public let failureReason: String?
    /// <p>Indicates when the certificate was imported. Provided if the certificate type is
    ///             <code>IMPORTED</code>.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let importedAt: String?
    /// <p>The list of ARNs for the AWS resources that use the certificate.</p>
    public let inUseBy: [String]?
    /// <p>Indicates when the certificate was issued. Provided if the certificate type is
    ///             <code>AMAZON_ISSUED</code>.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let issuedAt: String?
    /// <p>The name of the certificate authority that issued and signed the certificate.</p>
    public let issuer: String?
    /// <p>The algorithm that was used to generate the public-private key pair.</p>
    ///          <p>Valid values: <code>RSA_2048</code> | <code>RSA_1024</code> |<code> RSA_4096</code> |
    ///             <code>EC_prime256v1</code> | <code>EC_secp384r1</code> |
    ///          <code>EC_secp521r1</code>
    ///          </p>
    public let keyAlgorithm: String?
    /// <p>A list of key usage X.509 v3 extension objects.</p>
    public let keyUsages: [AwsCertificateManagerCertificateKeyUsage]?
    /// <p>The time after which the certificate becomes invalid.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let notAfter: String?
    /// <p>The time before which the certificate is not valid.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let notBefore: String?
    /// <p>Provides a value that specifies whether to add the certificate to a transparency
    ///          log.</p>
    public let options: AwsCertificateManagerCertificateOptions?
    /// <p>Whether the certificate is eligible for renewal.</p>
    ///          <p>Valid values: <code>ELIGIBLE</code> | <code>INELIGIBLE</code>
    ///          </p>
    public let renewalEligibility: String?
    /// <p>Information about the status of the AWS Certificate Manager managed renewal for the
    ///          certificate. Provided only when the certificate type is <code>AMAZON_ISSUED</code>.</p>
    public let renewalSummary: AwsCertificateManagerCertificateRenewalSummary?
    /// <p>The serial number of the certificate.</p>
    public let serial: String?
    /// <p>The algorithm that was used to sign the certificate.</p>
    public let signatureAlgorithm: String?
    /// <p>The status of the certificate.</p>
    ///          <p>Valid values: <code>PENDING_VALIDATION</code> | <code>ISSUED</code> |
    ///             <code>INACTIVE</code> | <code>EXPIRED</code> | <code>VALIDATION_TIMED_OUT</code> |
    ///             <code>REVOKED</code> | <code>FAILED</code>
    ///          </p>
    public let status: String?
    /// <p>The name of the entity that is associated with the public key contained in the
    ///          certificate.</p>
    public let subject: String?
    /// <p>One or more domain names (subject alternative names) included in the certificate. This
    ///          list contains the domain names that are bound to the public key that is contained in the
    ///          certificate.</p>
    ///          <p>The subject alternative names include the canonical domain name (CN) of the certificate
    ///          and additional domain names that can be used to connect to the website.</p>
    public let subjectAlternativeNames: [String]?
    /// <p>The source of the certificate. For certificates that AWS Certificate Manager provides,
    ///             <code>Type</code> is <code>AMAZON_ISSUED</code>. For certificates that are imported with
    ///             <code>ImportCertificate</code>, <code>Type</code> is <code>IMPORTED</code>.</p>
    ///          <p>Valid values: <code>IMPORTED</code> | <code>AMAZON_ISSUED</code> |
    ///          <code>PRIVATE</code>
    ///          </p>
    public let type: String?

    public init (
        certificateAuthorityArn: String? = nil,
        createdAt: String? = nil,
        domainName: String? = nil,
        domainValidationOptions: [AwsCertificateManagerCertificateDomainValidationOption]? = nil,
        extendedKeyUsages: [AwsCertificateManagerCertificateExtendedKeyUsage]? = nil,
        failureReason: String? = nil,
        importedAt: String? = nil,
        inUseBy: [String]? = nil,
        issuedAt: String? = nil,
        issuer: String? = nil,
        keyAlgorithm: String? = nil,
        keyUsages: [AwsCertificateManagerCertificateKeyUsage]? = nil,
        notAfter: String? = nil,
        notBefore: String? = nil,
        options: AwsCertificateManagerCertificateOptions? = nil,
        renewalEligibility: String? = nil,
        renewalSummary: AwsCertificateManagerCertificateRenewalSummary? = nil,
        serial: String? = nil,
        signatureAlgorithm: String? = nil,
        status: String? = nil,
        subject: String? = nil,
        subjectAlternativeNames: [String]? = nil,
        type: String? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.createdAt = createdAt
        self.domainName = domainName
        self.domainValidationOptions = domainValidationOptions
        self.extendedKeyUsages = extendedKeyUsages
        self.failureReason = failureReason
        self.importedAt = importedAt
        self.inUseBy = inUseBy
        self.issuedAt = issuedAt
        self.issuer = issuer
        self.keyAlgorithm = keyAlgorithm
        self.keyUsages = keyUsages
        self.notAfter = notAfter
        self.notBefore = notBefore
        self.options = options
        self.renewalEligibility = renewalEligibility
        self.renewalSummary = renewalSummary
        self.serial = serial
        self.signatureAlgorithm = signatureAlgorithm
        self.status = status
        self.subject = subject
        self.subjectAlternativeNames = subjectAlternativeNames
        self.type = type
    }
}

extension AwsCertificateManagerCertificateDomainValidationOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case resourceRecord = "ResourceRecord"
        case validationDomain = "ValidationDomain"
        case validationEmails = "ValidationEmails"
        case validationMethod = "ValidationMethod"
        case validationStatus = "ValidationStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let resourceRecord = resourceRecord {
            try encodeContainer.encode(resourceRecord, forKey: .resourceRecord)
        }
        if let validationDomain = validationDomain {
            try encodeContainer.encode(validationDomain, forKey: .validationDomain)
        }
        if let validationEmails = validationEmails {
            var validationEmailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validationEmails)
            for stringlist0 in validationEmails {
                try validationEmailsContainer.encode(stringlist0)
            }
        }
        if let validationMethod = validationMethod {
            try encodeContainer.encode(validationMethod, forKey: .validationMethod)
        }
        if let validationStatus = validationStatus {
            try encodeContainer.encode(validationStatus, forKey: .validationStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let resourceRecordDecoded = try containerValues.decodeIfPresent(AwsCertificateManagerCertificateResourceRecord.self, forKey: .resourceRecord)
        resourceRecord = resourceRecordDecoded
        let validationDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .validationDomain)
        validationDomain = validationDomainDecoded
        let validationEmailsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .validationEmails)
        var validationEmailsDecoded0:[String]? = nil
        if let validationEmailsContainer = validationEmailsContainer {
            validationEmailsDecoded0 = [String]()
            for string0 in validationEmailsContainer {
                if let string0 = string0 {
                    validationEmailsDecoded0?.append(string0)
                }
            }
        }
        validationEmails = validationEmailsDecoded0
        let validationMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .validationMethod)
        validationMethod = validationMethodDecoded
        let validationStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .validationStatus)
        validationStatus = validationStatusDecoded
    }
}

extension AwsCertificateManagerCertificateDomainValidationOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCertificateManagerCertificateDomainValidationOption(domainName: \(String(describing: domainName)), resourceRecord: \(String(describing: resourceRecord)), validationDomain: \(String(describing: validationDomain)), validationEmails: \(String(describing: validationEmails)), validationMethod: \(String(describing: validationMethod)), validationStatus: \(String(describing: validationStatus)))"}
}

/// <p>Contains information about one of the following:</p>
///          <ul>
///             <li>
///                <p>The initial validation of each domain name that occurs as a result of the
///                   <code>RequestCertificate</code> request</p>
///             </li>
///             <li>
///                <p>The validation of each domain name in the certificate, as it pertains to AWS
///                Certificate Manager managed renewal</p>
///             </li>
///          </ul>
public struct AwsCertificateManagerCertificateDomainValidationOption: Equatable {
    /// <p>A fully qualified domain name (FQDN) in the certificate.</p>
    public let domainName: String?
    /// <p>The CNAME record that is added to the DNS database for domain validation.</p>
    public let resourceRecord: AwsCertificateManagerCertificateResourceRecord?
    /// <p>The domain name that AWS Certificate Manager uses to send domain validation
    ///          emails.</p>
    public let validationDomain: String?
    /// <p>A list of email addresses that AWS Certificate Manager uses to send domain validation
    ///          emails.</p>
    public let validationEmails: [String]?
    /// <p>The method used to validate the domain name.</p>
    public let validationMethod: String?
    /// <p>The validation status of the domain name.</p>
    public let validationStatus: String?

    public init (
        domainName: String? = nil,
        resourceRecord: AwsCertificateManagerCertificateResourceRecord? = nil,
        validationDomain: String? = nil,
        validationEmails: [String]? = nil,
        validationMethod: String? = nil,
        validationStatus: String? = nil
    )
    {
        self.domainName = domainName
        self.resourceRecord = resourceRecord
        self.validationDomain = validationDomain
        self.validationEmails = validationEmails
        self.validationMethod = validationMethod
        self.validationStatus = validationStatus
    }
}

extension AwsCertificateManagerCertificateExtendedKeyUsage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case oId = "OId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let oId = oId {
            try encodeContainer.encode(oId, forKey: .oId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let oIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .oId)
        oId = oIdDecoded
    }
}

extension AwsCertificateManagerCertificateExtendedKeyUsage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCertificateManagerCertificateExtendedKeyUsage(name: \(String(describing: name)), oId: \(String(describing: oId)))"}
}

/// <p>Contains information about an extended key usage X.509 v3 extension object.</p>
public struct AwsCertificateManagerCertificateExtendedKeyUsage: Equatable {
    /// <p>The name of an extension value. Indicates the purpose for which the certificate public
    ///          key can be used.</p>
    public let name: String?
    /// <p>An object identifier (OID) for the extension value.</p>
    ///          <p>The format is numbers separated by periods.</p>
    public let oId: String?

    public init (
        name: String? = nil,
        oId: String? = nil
    )
    {
        self.name = name
        self.oId = oId
    }
}

extension AwsCertificateManagerCertificateKeyUsage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AwsCertificateManagerCertificateKeyUsage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCertificateManagerCertificateKeyUsage(name: \(String(describing: name)))"}
}

/// <p>Contains information about a key usage X.509 v3 extension object.</p>
public struct AwsCertificateManagerCertificateKeyUsage: Equatable {
    /// <p>The key usage extension name.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension AwsCertificateManagerCertificateOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateTransparencyLoggingPreference = "CertificateTransparencyLoggingPreference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateTransparencyLoggingPreference = certificateTransparencyLoggingPreference {
            try encodeContainer.encode(certificateTransparencyLoggingPreference, forKey: .certificateTransparencyLoggingPreference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateTransparencyLoggingPreferenceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateTransparencyLoggingPreference)
        certificateTransparencyLoggingPreference = certificateTransparencyLoggingPreferenceDecoded
    }
}

extension AwsCertificateManagerCertificateOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCertificateManagerCertificateOptions(certificateTransparencyLoggingPreference: \(String(describing: certificateTransparencyLoggingPreference)))"}
}

/// <p>Contains other options for the certificate.</p>
public struct AwsCertificateManagerCertificateOptions: Equatable {
    /// <p>Whether to add the certificate to a transparency log.</p>
    ///          <p>Valid values: <code>DISABLED</code> | <code>ENABLED</code>
    ///          </p>
    public let certificateTransparencyLoggingPreference: String?

    public init (
        certificateTransparencyLoggingPreference: String? = nil
    )
    {
        self.certificateTransparencyLoggingPreference = certificateTransparencyLoggingPreference
    }
}

extension AwsCertificateManagerCertificateRenewalSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainValidationOptions = "DomainValidationOptions"
        case renewalStatus = "RenewalStatus"
        case renewalStatusReason = "RenewalStatusReason"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainValidationOptions = domainValidationOptions {
            var domainValidationOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainValidationOptions)
            for awscertificatemanagercertificatedomainvalidationoptions0 in domainValidationOptions {
                try domainValidationOptionsContainer.encode(awscertificatemanagercertificatedomainvalidationoptions0)
            }
        }
        if let renewalStatus = renewalStatus {
            try encodeContainer.encode(renewalStatus, forKey: .renewalStatus)
        }
        if let renewalStatusReason = renewalStatusReason {
            try encodeContainer.encode(renewalStatusReason, forKey: .renewalStatusReason)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainValidationOptionsContainer = try containerValues.decodeIfPresent([AwsCertificateManagerCertificateDomainValidationOption?].self, forKey: .domainValidationOptions)
        var domainValidationOptionsDecoded0:[AwsCertificateManagerCertificateDomainValidationOption]? = nil
        if let domainValidationOptionsContainer = domainValidationOptionsContainer {
            domainValidationOptionsDecoded0 = [AwsCertificateManagerCertificateDomainValidationOption]()
            for structure0 in domainValidationOptionsContainer {
                if let structure0 = structure0 {
                    domainValidationOptionsDecoded0?.append(structure0)
                }
            }
        }
        domainValidationOptions = domainValidationOptionsDecoded0
        let renewalStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .renewalStatus)
        renewalStatus = renewalStatusDecoded
        let renewalStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .renewalStatusReason)
        renewalStatusReason = renewalStatusReasonDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension AwsCertificateManagerCertificateRenewalSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCertificateManagerCertificateRenewalSummary(domainValidationOptions: \(String(describing: domainValidationOptions)), renewalStatus: \(String(describing: renewalStatus)), renewalStatusReason: \(String(describing: renewalStatusReason)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>Contains information about the AWS Certificate Manager managed renewal for an
///             <code>AMAZON_ISSUED</code> certificate.</p>
public struct AwsCertificateManagerCertificateRenewalSummary: Equatable {
    /// <p>Information about the validation of each domain name in the certificate, as it pertains
    ///          to AWS Certificate Manager managed renewal. Provided only when the certificate type is
    ///             <code>AMAZON_ISSUED</code>.</p>
    public let domainValidationOptions: [AwsCertificateManagerCertificateDomainValidationOption]?
    /// <p>The status of the AWS Certificate Manager managed renewal of the certificate.</p>
    ///          <p>Valid values: <code>PENDING_AUTO_RENEWAL</code> | <code>PENDING_VALIDATION</code> |
    ///             <code>SUCCESS</code> | <code>FAILED</code>
    ///          </p>
    public let renewalStatus: String?
    /// <p>The reason that a renewal request was unsuccessful.</p>
    ///          <p>Valid values: <code>NO_AVAILABLE_CONTACTS</code> |
    ///             <code>ADDITIONAL_VERIFICATION_REQUIRED</code> | <code>DOMAIN_NOT_ALLOWED</code> |
    ///             <code>INVALID_PUBLIC_DOMAIN</code> | <code>DOMAIN_VALIDATION_DENIED</code> |
    ///             <code>CAA_ERROR</code> | <code>PCA_LIMIT_EXCEEDED</code> | <code>PCA_INVALID_ARN</code>
    ///          | <code>PCA_INVALID_STATE</code> | <code>PCA_REQUEST_FAILED</code> |
    ///             <code>PCA_NAME_CONSTRAINTS_VALIDATION</code> | <code>PCA_RESOURCE_NOT_FOUND</code> |
    ///             <code>PCA_INVALID_ARGS</code> | <code>PCA_INVALID_DURATION</code> |
    ///             <code>PCA_ACCESS_DENIED</code> | <code>SLR_NOT_FOUND</code> | <code>OTHER</code>
    ///          </p>
    public let renewalStatusReason: String?
    /// <p>Indicates when the renewal summary was last updated.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let updatedAt: String?

    public init (
        domainValidationOptions: [AwsCertificateManagerCertificateDomainValidationOption]? = nil,
        renewalStatus: String? = nil,
        renewalStatusReason: String? = nil,
        updatedAt: String? = nil
    )
    {
        self.domainValidationOptions = domainValidationOptions
        self.renewalStatus = renewalStatus
        self.renewalStatusReason = renewalStatusReason
        self.updatedAt = updatedAt
    }
}

extension AwsCertificateManagerCertificateResourceRecord: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AwsCertificateManagerCertificateResourceRecord: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCertificateManagerCertificateResourceRecord(name: \(String(describing: name)), type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>Provides details about the CNAME record that is added to the DNS database for domain
///          validation.</p>
public struct AwsCertificateManagerCertificateResourceRecord: Equatable {
    /// <p>The name of the resource.</p>
    public let name: String?
    /// <p>The type of resource.</p>
    public let type: String?
    /// <p>The value of the resource.</p>
    public let value: String?

    public init (
        name: String? = nil,
        type: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.type = type
        self.value = value
    }
}

extension AwsCloudFrontDistributionCacheBehavior: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case viewerProtocolPolicy = "ViewerProtocolPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let viewerProtocolPolicy = viewerProtocolPolicy {
            try encodeContainer.encode(viewerProtocolPolicy, forKey: .viewerProtocolPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let viewerProtocolPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .viewerProtocolPolicy)
        viewerProtocolPolicy = viewerProtocolPolicyDecoded
    }
}

extension AwsCloudFrontDistributionCacheBehavior: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCloudFrontDistributionCacheBehavior(viewerProtocolPolicy: \(String(describing: viewerProtocolPolicy)))"}
}

/// <p>Information about a cache behavior for the distribution.</p>
public struct AwsCloudFrontDistributionCacheBehavior: Equatable {
    /// <p>The protocol that viewers can use to access the files in an origin. You can specify the
    ///          following options:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>allow-all</code> - Viewers can use HTTP or HTTPS.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>redirect-to-https</code> - CloudFront responds to HTTP requests with an HTTP
    ///                status code of 301 (Moved Permanently) and the HTTPS URL. The viewer then uses the
    ///                new URL to resubmit.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>https-only</code> - CloudFront responds to HTTP request with an HTTP status
    ///                code of 403 (Forbidden).</p>
    ///             </li>
    ///          </ul>
    public let viewerProtocolPolicy: String?

    public init (
        viewerProtocolPolicy: String? = nil
    )
    {
        self.viewerProtocolPolicy = viewerProtocolPolicy
    }
}

extension AwsCloudFrontDistributionCacheBehaviors: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for awscloudfrontdistributioncachebehaviorsitemlist0 in items {
                try itemsContainer.encode(awscloudfrontdistributioncachebehaviorsitemlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AwsCloudFrontDistributionCacheBehavior?].self, forKey: .items)
        var itemsDecoded0:[AwsCloudFrontDistributionCacheBehavior]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AwsCloudFrontDistributionCacheBehavior]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension AwsCloudFrontDistributionCacheBehaviors: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCloudFrontDistributionCacheBehaviors(items: \(String(describing: items)))"}
}

/// <p>Provides information about caching for the distribution.</p>
public struct AwsCloudFrontDistributionCacheBehaviors: Equatable {
    /// <p>The cache behaviors for the distribution.</p>
    public let items: [AwsCloudFrontDistributionCacheBehavior]?

    public init (
        items: [AwsCloudFrontDistributionCacheBehavior]? = nil
    )
    {
        self.items = items
    }
}

extension AwsCloudFrontDistributionDefaultCacheBehavior: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case viewerProtocolPolicy = "ViewerProtocolPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let viewerProtocolPolicy = viewerProtocolPolicy {
            try encodeContainer.encode(viewerProtocolPolicy, forKey: .viewerProtocolPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let viewerProtocolPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .viewerProtocolPolicy)
        viewerProtocolPolicy = viewerProtocolPolicyDecoded
    }
}

extension AwsCloudFrontDistributionDefaultCacheBehavior: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCloudFrontDistributionDefaultCacheBehavior(viewerProtocolPolicy: \(String(describing: viewerProtocolPolicy)))"}
}

/// <p>Contains information about the default cache configuration for the distribution.</p>
public struct AwsCloudFrontDistributionDefaultCacheBehavior: Equatable {
    /// <p>The protocol that viewers can use to access the files in an origin. You can specify the
    ///          following options:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>allow-all</code> - Viewers can use HTTP or HTTPS.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>redirect-to-https</code> - CloudFront responds to HTTP requests with an HTTP
    ///                status code of 301 (Moved Permanently) and the HTTPS URL. The viewer then uses the
    ///                new URL to resubmit.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>https-only</code> - CloudFront responds to HTTP request with an HTTP status
    ///                code of 403 (Forbidden).</p>
    ///             </li>
    ///          </ul>
    public let viewerProtocolPolicy: String?

    public init (
        viewerProtocolPolicy: String? = nil
    )
    {
        self.viewerProtocolPolicy = viewerProtocolPolicy
    }
}

extension AwsCloudFrontDistributionDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cacheBehaviors = "CacheBehaviors"
        case defaultCacheBehavior = "DefaultCacheBehavior"
        case defaultRootObject = "DefaultRootObject"
        case domainName = "DomainName"
        case eTag = "ETag"
        case lastModifiedTime = "LastModifiedTime"
        case logging = "Logging"
        case originGroups = "OriginGroups"
        case origins = "Origins"
        case status = "Status"
        case webAclId = "WebAclId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheBehaviors = cacheBehaviors {
            try encodeContainer.encode(cacheBehaviors, forKey: .cacheBehaviors)
        }
        if let defaultCacheBehavior = defaultCacheBehavior {
            try encodeContainer.encode(defaultCacheBehavior, forKey: .defaultCacheBehavior)
        }
        if let defaultRootObject = defaultRootObject {
            try encodeContainer.encode(defaultRootObject, forKey: .defaultRootObject)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let eTag = eTag {
            try encodeContainer.encode(eTag, forKey: .eTag)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let logging = logging {
            try encodeContainer.encode(logging, forKey: .logging)
        }
        if let originGroups = originGroups {
            try encodeContainer.encode(originGroups, forKey: .originGroups)
        }
        if let origins = origins {
            try encodeContainer.encode(origins, forKey: .origins)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let webAclId = webAclId {
            try encodeContainer.encode(webAclId, forKey: .webAclId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cacheBehaviorsDecoded = try containerValues.decodeIfPresent(AwsCloudFrontDistributionCacheBehaviors.self, forKey: .cacheBehaviors)
        cacheBehaviors = cacheBehaviorsDecoded
        let defaultCacheBehaviorDecoded = try containerValues.decodeIfPresent(AwsCloudFrontDistributionDefaultCacheBehavior.self, forKey: .defaultCacheBehavior)
        defaultCacheBehavior = defaultCacheBehaviorDecoded
        let defaultRootObjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultRootObject)
        defaultRootObject = defaultRootObjectDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let eTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eTag)
        eTag = eTagDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(AwsCloudFrontDistributionLogging.self, forKey: .logging)
        logging = loggingDecoded
        let originsDecoded = try containerValues.decodeIfPresent(AwsCloudFrontDistributionOrigins.self, forKey: .origins)
        origins = originsDecoded
        let originGroupsDecoded = try containerValues.decodeIfPresent(AwsCloudFrontDistributionOriginGroups.self, forKey: .originGroups)
        originGroups = originGroupsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let webAclIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webAclId)
        webAclId = webAclIdDecoded
    }
}

extension AwsCloudFrontDistributionDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCloudFrontDistributionDetails(cacheBehaviors: \(String(describing: cacheBehaviors)), defaultCacheBehavior: \(String(describing: defaultCacheBehavior)), defaultRootObject: \(String(describing: defaultRootObject)), domainName: \(String(describing: domainName)), eTag: \(String(describing: eTag)), lastModifiedTime: \(String(describing: lastModifiedTime)), logging: \(String(describing: logging)), originGroups: \(String(describing: originGroups)), origins: \(String(describing: origins)), status: \(String(describing: status)), webAclId: \(String(describing: webAclId)))"}
}

/// <p>A distribution configuration.</p>
public struct AwsCloudFrontDistributionDetails: Equatable {
    /// <p>Provides information about the cache configuration for the distribution.</p>
    public let cacheBehaviors: AwsCloudFrontDistributionCacheBehaviors?
    /// <p>The default cache behavior for the configuration.</p>
    public let defaultCacheBehavior: AwsCloudFrontDistributionDefaultCacheBehavior?
    /// <p>The object that CloudFront sends in response to requests from the origin (for example,
    ///          index.html) when a viewer requests the root URL for the distribution
    ///          (http://www.example.com) instead of an object in your distribution
    ///          (http://www.example.com/product-description.html). </p>
    public let defaultRootObject: String?
    /// <p>The domain name corresponding to the distribution.</p>
    public let domainName: String?
    /// <p>The entity tag is a hash of the object.</p>
    public let eTag: String?
    /// <p>Indicates when that the distribution was last modified.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let lastModifiedTime: String?
    /// <p>A complex type that controls whether access logs are written for the distribution.</p>
    public let logging: AwsCloudFrontDistributionLogging?
    /// <p>Provides information about the origin groups in the distribution.</p>
    public let originGroups: AwsCloudFrontDistributionOriginGroups?
    /// <p>A complex type that contains information about origins for this distribution.</p>
    public let origins: AwsCloudFrontDistributionOrigins?
    /// <p>Indicates the current status of the distribution.</p>
    public let status: String?
    /// <p>A unique identifier that specifies the AWS WAF web ACL, if any, to associate with this distribution.</p>
    public let webAclId: String?

    public init (
        cacheBehaviors: AwsCloudFrontDistributionCacheBehaviors? = nil,
        defaultCacheBehavior: AwsCloudFrontDistributionDefaultCacheBehavior? = nil,
        defaultRootObject: String? = nil,
        domainName: String? = nil,
        eTag: String? = nil,
        lastModifiedTime: String? = nil,
        logging: AwsCloudFrontDistributionLogging? = nil,
        originGroups: AwsCloudFrontDistributionOriginGroups? = nil,
        origins: AwsCloudFrontDistributionOrigins? = nil,
        status: String? = nil,
        webAclId: String? = nil
    )
    {
        self.cacheBehaviors = cacheBehaviors
        self.defaultCacheBehavior = defaultCacheBehavior
        self.defaultRootObject = defaultRootObject
        self.domainName = domainName
        self.eTag = eTag
        self.lastModifiedTime = lastModifiedTime
        self.logging = logging
        self.originGroups = originGroups
        self.origins = origins
        self.status = status
        self.webAclId = webAclId
    }
}

extension AwsCloudFrontDistributionLogging: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case enabled = "Enabled"
        case includeCookies = "IncludeCookies"
        case prefix = "Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if includeCookies != false {
            try encodeContainer.encode(includeCookies, forKey: .includeCookies)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let includeCookiesDecoded = try containerValues.decode(Bool.self, forKey: .includeCookies)
        includeCookies = includeCookiesDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension AwsCloudFrontDistributionLogging: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCloudFrontDistributionLogging(bucket: \(String(describing: bucket)), enabled: \(String(describing: enabled)), includeCookies: \(String(describing: includeCookies)), prefix: \(String(describing: prefix)))"}
}

/// <p>A complex type that controls whether access logs are written for the distribution.</p>
public struct AwsCloudFrontDistributionLogging: Equatable {
    /// <p>The Amazon S3 bucket to store the access logs in.</p>
    public let bucket: String?
    /// <p>With this field, you can enable or disable the selected distribution.</p>
    public let enabled: Bool
    /// <p>Specifies whether you want CloudFront to include cookies in access logs.</p>
    public let includeCookies: Bool
    /// <p>An optional string that you want CloudFront to use as a prefix to the access log
    ///          filenames for this distribution.</p>
    public let prefix: String?

    public init (
        bucket: String? = nil,
        enabled: Bool = false,
        includeCookies: Bool = false,
        prefix: String? = nil
    )
    {
        self.bucket = bucket
        self.enabled = enabled
        self.includeCookies = includeCookies
        self.prefix = prefix
    }
}

extension AwsCloudFrontDistributionOriginGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failoverCriteria = "FailoverCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failoverCriteria = failoverCriteria {
            try encodeContainer.encode(failoverCriteria, forKey: .failoverCriteria)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failoverCriteriaDecoded = try containerValues.decodeIfPresent(AwsCloudFrontDistributionOriginGroupFailover.self, forKey: .failoverCriteria)
        failoverCriteria = failoverCriteriaDecoded
    }
}

extension AwsCloudFrontDistributionOriginGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCloudFrontDistributionOriginGroup(failoverCriteria: \(String(describing: failoverCriteria)))"}
}

/// <p>Information about an origin group for the distribution.</p>
public struct AwsCloudFrontDistributionOriginGroup: Equatable {
    /// <p>Provides the criteria for an origin group to fail over.</p>
    public let failoverCriteria: AwsCloudFrontDistributionOriginGroupFailover?

    public init (
        failoverCriteria: AwsCloudFrontDistributionOriginGroupFailover? = nil
    )
    {
        self.failoverCriteria = failoverCriteria
    }
}

extension AwsCloudFrontDistributionOriginGroupFailover: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case statusCodes = "StatusCodes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statusCodes = statusCodes {
            try encodeContainer.encode(statusCodes, forKey: .statusCodes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodesDecoded = try containerValues.decodeIfPresent(AwsCloudFrontDistributionOriginGroupFailoverStatusCodes.self, forKey: .statusCodes)
        statusCodes = statusCodesDecoded
    }
}

extension AwsCloudFrontDistributionOriginGroupFailover: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCloudFrontDistributionOriginGroupFailover(statusCodes: \(String(describing: statusCodes)))"}
}

/// <p>Provides information about when an origin group fails over.</p>
public struct AwsCloudFrontDistributionOriginGroupFailover: Equatable {
    /// <p>Information about the status codes that cause an origin group to fail over.</p>
    public let statusCodes: AwsCloudFrontDistributionOriginGroupFailoverStatusCodes?

    public init (
        statusCodes: AwsCloudFrontDistributionOriginGroupFailoverStatusCodes? = nil
    )
    {
        self.statusCodes = statusCodes
    }
}

extension AwsCloudFrontDistributionOriginGroupFailoverStatusCodes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for awscloudfrontdistributionorigingroupfailoverstatuscodesitemlist0 in items {
                try itemsContainer.encode(awscloudfrontdistributionorigingroupfailoverstatuscodesitemlist0)
            }
        }
        if quantity != 0 {
            try encodeContainer.encode(quantity, forKey: .quantity)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Int?].self, forKey: .items)
        var itemsDecoded0:[Int]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Int]()
            for integer0 in itemsContainer {
                if let integer0 = integer0 {
                    itemsDecoded0?.append(integer0)
                }
            }
        }
        items = itemsDecoded0
        let quantityDecoded = try containerValues.decode(Int.self, forKey: .quantity)
        quantity = quantityDecoded
    }
}

extension AwsCloudFrontDistributionOriginGroupFailoverStatusCodes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCloudFrontDistributionOriginGroupFailoverStatusCodes(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

/// <p>The status codes that cause an origin group to fail over.</p>
public struct AwsCloudFrontDistributionOriginGroupFailoverStatusCodes: Equatable {
    /// <p>The list of status code values that can cause a failover to the next origin.</p>
    public let items: [Int]?
    /// <p>The number of status codes that can cause a failover.</p>
    public let quantity: Int

    public init (
        items: [Int]? = nil,
        quantity: Int = 0
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

extension AwsCloudFrontDistributionOriginGroups: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for awscloudfrontdistributionorigingroupsitemlist0 in items {
                try itemsContainer.encode(awscloudfrontdistributionorigingroupsitemlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AwsCloudFrontDistributionOriginGroup?].self, forKey: .items)
        var itemsDecoded0:[AwsCloudFrontDistributionOriginGroup]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AwsCloudFrontDistributionOriginGroup]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension AwsCloudFrontDistributionOriginGroups: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCloudFrontDistributionOriginGroups(items: \(String(describing: items)))"}
}

/// <p>Provides information about origin groups that are associated with the
///          distribution.</p>
public struct AwsCloudFrontDistributionOriginGroups: Equatable {
    /// <p>The list of origin groups.</p>
    public let items: [AwsCloudFrontDistributionOriginGroup]?

    public init (
        items: [AwsCloudFrontDistributionOriginGroup]? = nil
    )
    {
        self.items = items
    }
}

extension AwsCloudFrontDistributionOriginItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case id = "Id"
        case originPath = "OriginPath"
        case s3OriginConfig = "S3OriginConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let originPath = originPath {
            try encodeContainer.encode(originPath, forKey: .originPath)
        }
        if let s3OriginConfig = s3OriginConfig {
            try encodeContainer.encode(s3OriginConfig, forKey: .s3OriginConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let originPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originPath)
        originPath = originPathDecoded
        let s3OriginConfigDecoded = try containerValues.decodeIfPresent(AwsCloudFrontDistributionOriginS3OriginConfig.self, forKey: .s3OriginConfig)
        s3OriginConfig = s3OriginConfigDecoded
    }
}

extension AwsCloudFrontDistributionOriginItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCloudFrontDistributionOriginItem(domainName: \(String(describing: domainName)), id: \(String(describing: id)), originPath: \(String(describing: originPath)), s3OriginConfig: \(String(describing: s3OriginConfig)))"}
}

/// <p>A complex type that describes the Amazon S3 bucket, HTTP server (for example, a web
///          server), Amazon Elemental MediaStore, or other server from which CloudFront gets your
///          files.</p>
public struct AwsCloudFrontDistributionOriginItem: Equatable {
    /// <p>Amazon S3 origins: The DNS name of the Amazon S3 bucket from which you want CloudFront to get objects for this origin.</p>
    public let domainName: String?
    /// <p>A unique identifier for the origin or origin group.</p>
    public let id: String?
    /// <p>An optional element that causes CloudFront to request your content from a directory in your Amazon S3 bucket or your custom origin.</p>
    public let originPath: String?
    /// <p>An origin that is an S3 bucket that is not configured with static website
    ///          hosting.</p>
    public let s3OriginConfig: AwsCloudFrontDistributionOriginS3OriginConfig?

    public init (
        domainName: String? = nil,
        id: String? = nil,
        originPath: String? = nil,
        s3OriginConfig: AwsCloudFrontDistributionOriginS3OriginConfig? = nil
    )
    {
        self.domainName = domainName
        self.id = id
        self.originPath = originPath
        self.s3OriginConfig = s3OriginConfig
    }
}

extension AwsCloudFrontDistributionOriginS3OriginConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case originAccessIdentity = "OriginAccessIdentity"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let originAccessIdentity = originAccessIdentity {
            try encodeContainer.encode(originAccessIdentity, forKey: .originAccessIdentity)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originAccessIdentityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originAccessIdentity)
        originAccessIdentity = originAccessIdentityDecoded
    }
}

extension AwsCloudFrontDistributionOriginS3OriginConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCloudFrontDistributionOriginS3OriginConfig(originAccessIdentity: \(String(describing: originAccessIdentity)))"}
}

/// <p>Information about an origin that is an S3 bucket that is not configured with static
///          website hosting.</p>
public struct AwsCloudFrontDistributionOriginS3OriginConfig: Equatable {
    /// <p>The CloudFront origin access identity to associate with the origin.</p>
    public let originAccessIdentity: String?

    public init (
        originAccessIdentity: String? = nil
    )
    {
        self.originAccessIdentity = originAccessIdentity
    }
}

extension AwsCloudFrontDistributionOrigins: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for awscloudfrontdistributionoriginitemlist0 in items {
                try itemsContainer.encode(awscloudfrontdistributionoriginitemlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AwsCloudFrontDistributionOriginItem?].self, forKey: .items)
        var itemsDecoded0:[AwsCloudFrontDistributionOriginItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AwsCloudFrontDistributionOriginItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension AwsCloudFrontDistributionOrigins: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCloudFrontDistributionOrigins(items: \(String(describing: items)))"}
}

/// <p>A complex type that contains information about origins and origin groups for this distribution.</p>
public struct AwsCloudFrontDistributionOrigins: Equatable {
    /// <p>A complex type that contains origins or origin groups for this distribution.</p>
    public let items: [AwsCloudFrontDistributionOriginItem]?

    public init (
        items: [AwsCloudFrontDistributionOriginItem]? = nil
    )
    {
        self.items = items
    }
}

extension AwsCloudTrailTrailDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case hasCustomEventSelectors = "HasCustomEventSelectors"
        case homeRegion = "HomeRegion"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case logFileValidationEnabled = "LogFileValidationEnabled"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicArn = "SnsTopicArn"
        case snsTopicName = "SnsTopicName"
        case trailArn = "TrailArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn {
            try encodeContainer.encode(cloudWatchLogsLogGroupArn, forKey: .cloudWatchLogsLogGroupArn)
        }
        if let cloudWatchLogsRoleArn = cloudWatchLogsRoleArn {
            try encodeContainer.encode(cloudWatchLogsRoleArn, forKey: .cloudWatchLogsRoleArn)
        }
        if hasCustomEventSelectors != false {
            try encodeContainer.encode(hasCustomEventSelectors, forKey: .hasCustomEventSelectors)
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if includeGlobalServiceEvents != false {
            try encodeContainer.encode(includeGlobalServiceEvents, forKey: .includeGlobalServiceEvents)
        }
        if isMultiRegionTrail != false {
            try encodeContainer.encode(isMultiRegionTrail, forKey: .isMultiRegionTrail)
        }
        if isOrganizationTrail != false {
            try encodeContainer.encode(isOrganizationTrail, forKey: .isOrganizationTrail)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if logFileValidationEnabled != false {
            try encodeContainer.encode(logFileValidationEnabled, forKey: .logFileValidationEnabled)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let snsTopicName = snsTopicName {
            try encodeContainer.encode(snsTopicName, forKey: .snsTopicName)
        }
        if let trailArn = trailArn {
            try encodeContainer.encode(trailArn, forKey: .trailArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let hasCustomEventSelectorsDecoded = try containerValues.decode(Bool.self, forKey: .hasCustomEventSelectors)
        hasCustomEventSelectors = hasCustomEventSelectorsDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decode(Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decode(Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let isOrganizationTrailDecoded = try containerValues.decode(Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let logFileValidationEnabledDecoded = try containerValues.decode(Bool.self, forKey: .logFileValidationEnabled)
        logFileValidationEnabled = logFileValidationEnabledDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let trailArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trailArn)
        trailArn = trailArnDecoded
    }
}

extension AwsCloudTrailTrailDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCloudTrailTrailDetails(cloudWatchLogsLogGroupArn: \(String(describing: cloudWatchLogsLogGroupArn)), cloudWatchLogsRoleArn: \(String(describing: cloudWatchLogsRoleArn)), hasCustomEventSelectors: \(String(describing: hasCustomEventSelectors)), homeRegion: \(String(describing: homeRegion)), includeGlobalServiceEvents: \(String(describing: includeGlobalServiceEvents)), isMultiRegionTrail: \(String(describing: isMultiRegionTrail)), isOrganizationTrail: \(String(describing: isOrganizationTrail)), kmsKeyId: \(String(describing: kmsKeyId)), logFileValidationEnabled: \(String(describing: logFileValidationEnabled)), name: \(String(describing: name)), s3BucketName: \(String(describing: s3BucketName)), s3KeyPrefix: \(String(describing: s3KeyPrefix)), snsTopicArn: \(String(describing: snsTopicArn)), snsTopicName: \(String(describing: snsTopicName)), trailArn: \(String(describing: trailArn)))"}
}

/// <p>Provides details about a CloudTrail trail.</p>
public struct AwsCloudTrailTrailDetails: Equatable {
    /// <p>The ARN of the log group that CloudTrail logs are delivered to.</p>
    public let cloudWatchLogsLogGroupArn: String?
    /// <p>The ARN of the role that the CloudWatch Logs endpoint assumes when it writes to the log
    ///          group.</p>
    public let cloudWatchLogsRoleArn: String?
    /// <p>Indicates whether the trail has custom event selectors.</p>
    public let hasCustomEventSelectors: Bool
    /// <p>The Region where the trail was created.</p>
    public let homeRegion: String?
    /// <p>Indicates whether the trail publishes events from global services such as IAM to the log
    ///          files.</p>
    public let includeGlobalServiceEvents: Bool
    /// <p>Indicates whether the trail applies only to the current Region or to all Regions.</p>
    public let isMultiRegionTrail: Bool
    /// <p>Whether the trail is created for all accounts in an organization in AWS Organizations,
    ///          or only for the current AWS account.</p>
    public let isOrganizationTrail: Bool
    /// <p>The AWS KMS key ID to use to encrypt the logs.</p>
    public let kmsKeyId: String?
    /// <p>Indicates whether CloudTrail log file validation is enabled.</p>
    public let logFileValidationEnabled: Bool
    /// <p>The name of the trail.</p>
    public let name: String?
    /// <p>The name of the S3 bucket where the log files are published.</p>
    public let s3BucketName: String?
    /// <p>The S3 key prefix. The key prefix is added after the name of the S3 bucket where the log
    ///          files are published.</p>
    public let s3KeyPrefix: String?
    /// <p>The ARN of the SNS topic that is used for notifications of log file delivery.</p>
    public let snsTopicArn: String?
    /// <p>The name of the SNS topic that is used for notifications of log file delivery.</p>
    public let snsTopicName: String?
    /// <p>The ARN of the trail.</p>
    public let trailArn: String?

    public init (
        cloudWatchLogsLogGroupArn: String? = nil,
        cloudWatchLogsRoleArn: String? = nil,
        hasCustomEventSelectors: Bool = false,
        homeRegion: String? = nil,
        includeGlobalServiceEvents: Bool = false,
        isMultiRegionTrail: Bool = false,
        isOrganizationTrail: Bool = false,
        kmsKeyId: String? = nil,
        logFileValidationEnabled: Bool = false,
        name: String? = nil,
        s3BucketName: String? = nil,
        s3KeyPrefix: String? = nil,
        snsTopicArn: String? = nil,
        snsTopicName: String? = nil,
        trailArn: String? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.hasCustomEventSelectors = hasCustomEventSelectors
        self.homeRegion = homeRegion
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.logFileValidationEnabled = logFileValidationEnabled
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicArn = snsTopicArn
        self.snsTopicName = snsTopicName
        self.trailArn = trailArn
    }
}

extension AwsCodeBuildProjectDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionKey = "EncryptionKey"
        case environment = "Environment"
        case name = "Name"
        case serviceRole = "ServiceRole"
        case source = "Source"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serviceRole = serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(AwsCodeBuildProjectEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(AwsCodeBuildProjectSource.self, forKey: .source)
        source = sourceDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(AwsCodeBuildProjectVpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension AwsCodeBuildProjectDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCodeBuildProjectDetails(encryptionKey: \(String(describing: encryptionKey)), environment: \(String(describing: environment)), name: \(String(describing: name)), serviceRole: \(String(describing: serviceRole)), source: \(String(describing: source)), vpcConfig: \(String(describing: vpcConfig)))"}
}

/// <p>Information about an AWS CodeBuild project.</p>
public struct AwsCodeBuildProjectDetails: Equatable {
    /// <p>The AWS Key Management Service (AWS KMS) customer master key (CMK) used to encrypt the
    ///          build output artifacts.</p>
    ///          <p>You can specify either the Amazon Resource Name (ARN) of the CMK or, if available, the
    ///          CMK alias (using the format alias/alias-name). </p>
    public let encryptionKey: String?
    /// <p>Information about the build environment for this build project.</p>
    public let environment: AwsCodeBuildProjectEnvironment?
    /// <p>The name of the build project.</p>
    public let name: String?
    /// <p>The ARN of the IAM role that enables AWS CodeBuild to interact with dependent AWS
    ///          services on behalf of the AWS account.</p>
    public let serviceRole: String?
    /// <p>Information about the build input source code for this build project.</p>
    public let source: AwsCodeBuildProjectSource?
    /// <p>Information about the VPC configuration that AWS CodeBuild accesses.</p>
    public let vpcConfig: AwsCodeBuildProjectVpcConfig?

    public init (
        encryptionKey: String? = nil,
        environment: AwsCodeBuildProjectEnvironment? = nil,
        name: String? = nil,
        serviceRole: String? = nil,
        source: AwsCodeBuildProjectSource? = nil,
        vpcConfig: AwsCodeBuildProjectVpcConfig? = nil
    )
    {
        self.encryptionKey = encryptionKey
        self.environment = environment
        self.name = name
        self.serviceRole = serviceRole
        self.source = source
        self.vpcConfig = vpcConfig
    }
}

extension AwsCodeBuildProjectEnvironment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
        case imagePullCredentialsType = "ImagePullCredentialsType"
        case registryCredential = "RegistryCredential"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let imagePullCredentialsType = imagePullCredentialsType {
            try encodeContainer.encode(imagePullCredentialsType, forKey: .imagePullCredentialsType)
        }
        if let registryCredential = registryCredential {
            try encodeContainer.encode(registryCredential, forKey: .registryCredential)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificate)
        certificate = certificateDecoded
        let imagePullCredentialsTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imagePullCredentialsType)
        imagePullCredentialsType = imagePullCredentialsTypeDecoded
        let registryCredentialDecoded = try containerValues.decodeIfPresent(AwsCodeBuildProjectEnvironmentRegistryCredential.self, forKey: .registryCredential)
        registryCredential = registryCredentialDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension AwsCodeBuildProjectEnvironment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCodeBuildProjectEnvironment(certificate: \(String(describing: certificate)), imagePullCredentialsType: \(String(describing: imagePullCredentialsType)), registryCredential: \(String(describing: registryCredential)), type: \(String(describing: type)))"}
}

/// <p>Information about the build environment for this build project.</p>
public struct AwsCodeBuildProjectEnvironment: Equatable {
    /// <p>The certificate to use with this build project.</p>
    public let certificate: String?
    /// <p>The type of credentials AWS CodeBuild uses to pull images in your build.</p>
    ///          <p>Valid values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CODEBUILD</code> specifies that AWS CodeBuild uses its own credentials. This
    ///                requires that you modify your ECR repository policy to trust the AWS CodeBuild
    ///                service principal.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SERVICE_ROLE</code> specifies that AWS CodeBuild uses your build project's
    ///                service role.</p>
    ///             </li>
    ///          </ul>
    ///          <p>When you use a cross-account or private registry image, you must use
    ///             <code>SERVICE_ROLE</code> credentials. When you use an AWS CodeBuild curated image, you
    ///          must use <code>CODEBUILD</code> credentials.</p>
    public let imagePullCredentialsType: String?
    /// <p>The credentials for access to a private registry.</p>
    public let registryCredential: AwsCodeBuildProjectEnvironmentRegistryCredential?
    /// <p>The type of build environment to use for related builds.</p>
    ///          <p>The environment type <code>ARM_CONTAINER</code> is available only in Regions US East (N.
    ///          Virginia), US East (Ohio), US West (Oregon), Europe (Ireland), Asia Pacific (Mumbai), Asia
    ///          Pacific (Tokyo), Asia Pacific (Sydney), and Europe (Frankfurt).</p>
    ///          <p>The environment type <code>LINUX_CONTAINER</code> with compute type
    ///          build.general1.2xlarge is available only in Regions US East (N. Virginia), US East (N.
    ///          Virginia), US West (Oregon), Canada (Central), Europe (Ireland), Europe (London), Europe
    ///          (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia
    ///          Pacific (Sydney), China (Beijing), and China (Ningxia).</p>
    ///          <p>The environment type <code>LINUX_GPU_CONTAINER</code> is available only in Regions US
    ///          East (N. Virginia), US East (N. Virginia), US West (Oregon), Canada (Central), Europe
    ///          (Ireland), Europe (London), Europe (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul),
    ///          Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China
    ///          (Ningxia).</p>
    ///          <p>Valid values: <code>WINDOWS_CONTAINER</code> | <code>LINUX_CONTAINER</code> |
    ///             <code>LINUX_GPU_CONTAINER</code> | <code>ARM_CONTAINER</code>
    ///          </p>
    public let type: String?

    public init (
        certificate: String? = nil,
        imagePullCredentialsType: String? = nil,
        registryCredential: AwsCodeBuildProjectEnvironmentRegistryCredential? = nil,
        type: String? = nil
    )
    {
        self.certificate = certificate
        self.imagePullCredentialsType = imagePullCredentialsType
        self.registryCredential = registryCredential
        self.type = type
    }
}

extension AwsCodeBuildProjectEnvironmentRegistryCredential: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case credential = "Credential"
        case credentialProvider = "CredentialProvider"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credential = credential {
            try encodeContainer.encode(credential, forKey: .credential)
        }
        if let credentialProvider = credentialProvider {
            try encodeContainer.encode(credentialProvider, forKey: .credentialProvider)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialDecoded = try containerValues.decodeIfPresent(String.self, forKey: .credential)
        credential = credentialDecoded
        let credentialProviderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .credentialProvider)
        credentialProvider = credentialProviderDecoded
    }
}

extension AwsCodeBuildProjectEnvironmentRegistryCredential: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCodeBuildProjectEnvironmentRegistryCredential(credential: \(String(describing: credential)), credentialProvider: \(String(describing: credentialProvider)))"}
}

/// <p>The credentials for access to a private registry.</p>
public struct AwsCodeBuildProjectEnvironmentRegistryCredential: Equatable {
    /// <p>The Amazon Resource Name (ARN) or name of credentials created using AWS Secrets
    ///          Manager.</p>
    ///          <note>
    ///             <p>The credential can use the name of the credentials only if they exist in your current
    ///             AWS Region. </p>
    ///          </note>
    public let credential: String?
    /// <p>The service that created the credentials to access a private Docker registry.</p>
    ///          <p>The valid value,<code> SECRETS_MANAGER</code>, is for AWS Secrets Manager.</p>
    public let credentialProvider: String?

    public init (
        credential: String? = nil,
        credentialProvider: String? = nil
    )
    {
        self.credential = credential
        self.credentialProvider = credentialProvider
    }
}

extension AwsCodeBuildProjectSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gitCloneDepth = "GitCloneDepth"
        case insecureSsl = "InsecureSsl"
        case location = "Location"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if gitCloneDepth != 0 {
            try encodeContainer.encode(gitCloneDepth, forKey: .gitCloneDepth)
        }
        if insecureSsl != false {
            try encodeContainer.encode(insecureSsl, forKey: .insecureSsl)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let gitCloneDepthDecoded = try containerValues.decode(Int.self, forKey: .gitCloneDepth)
        gitCloneDepth = gitCloneDepthDecoded
        let insecureSslDecoded = try containerValues.decode(Bool.self, forKey: .insecureSsl)
        insecureSsl = insecureSslDecoded
    }
}

extension AwsCodeBuildProjectSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCodeBuildProjectSource(gitCloneDepth: \(String(describing: gitCloneDepth)), insecureSsl: \(String(describing: insecureSsl)), location: \(String(describing: location)), type: \(String(describing: type)))"}
}

/// <p>Information about the build input source code for this build project.</p>
public struct AwsCodeBuildProjectSource: Equatable {
    /// <p>Information about the Git clone depth for the build project.</p>
    public let gitCloneDepth: Int
    /// <p>Whether to ignore SSL warnings while connecting to the project source code.</p>
    public let insecureSsl: Bool
    /// <p>Information about the location of the source code to be built.</p>
    ///          <p>Valid values include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>For source code settings that are specified in the source action of a pipeline in
    ///                AWS CodePipeline, location should not be specified. If it is specified, AWS
    ///                CodePipeline ignores it. This is because AWS CodePipeline uses the settings in a
    ///                pipeline's source action instead of this value.</p>
    ///             </li>
    ///             <li>
    ///                <p>For source code in an AWS CodeCommit repository, the HTTPS clone URL to the
    ///                repository that contains the source code and the build spec file (for example,
    ///                   <code>https://git-codecommit.region-ID.amazonaws.com/v1/repos/repo-name</code>
    ///                ).</p>
    ///             </li>
    ///             <li>
    ///                <p>For source code in an S3 input bucket, one of the following.</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>The path to the ZIP file that contains the source code (for example,
    ///                         <code>bucket-name/path/to/object-name.zip</code>).</p>
    ///                   </li>
    ///                   <li>
    ///                      <p> The path to the folder that contains the source code (for example,
    ///                         <code>bucket-name/path/to/source-code/folder/</code>).</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>For source code in a GitHub repository, the HTTPS clone URL to the repository that
    ///                contains the source and the build spec file.</p>
    ///             </li>
    ///             <li>
    ///                <p>For source code in a Bitbucket repository, the HTTPS clone URL to the repository
    ///                that contains the source and the build spec file. </p>
    ///             </li>
    ///          </ul>
    public let location: String?
    /// <p>The type of repository that contains the source code to be built. Valid values
    ///          are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>BITBUCKET</code> - The source code is in a Bitbucket repository.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CODECOMMIT</code> - The source code is in an AWS CodeCommit
    ///                repository.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CODEPIPELINE</code> - The source code settings are specified in the source
    ///                action of a pipeline in AWS CodePipeline.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>GITHUB</code> - The source code is in a GitHub repository.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>GITHUB_ENTERPRISE</code> - The source code is in a GitHub Enterprise
    ///                repository.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NO_SOURCE</code> - The project does not have input source code.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>S3</code> - The source code is in an S3 input bucket. </p>
    ///             </li>
    ///          </ul>
    public let type: String?

    public init (
        gitCloneDepth: Int = 0,
        insecureSsl: Bool = false,
        location: String? = nil,
        type: String? = nil
    )
    {
        self.gitCloneDepth = gitCloneDepth
        self.insecureSsl = insecureSsl
        self.location = location
        self.type = type
    }
}

extension AwsCodeBuildProjectVpcConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnets = "Subnets"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for nonemptystringlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(nonemptystringlist0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for nonemptystringlist0 in subnets {
                try subnetsContainer.encode(nonemptystringlist0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnets)
        var subnetsDecoded0:[String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension AwsCodeBuildProjectVpcConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCodeBuildProjectVpcConfig(securityGroupIds: \(String(describing: securityGroupIds)), subnets: \(String(describing: subnets)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Information about the VPC configuration that AWS CodeBuild accesses.</p>
public struct AwsCodeBuildProjectVpcConfig: Equatable {
    /// <p>A list of one or more security group IDs in your Amazon VPC.</p>
    public let securityGroupIds: [String]?
    /// <p>A list of one or more subnet IDs in your Amazon VPC.</p>
    public let subnets: [String]?
    /// <p>The ID of the VPC.</p>
    public let vpcId: String?

    public init (
        securityGroupIds: [String]? = nil,
        subnets: [String]? = nil,
        vpcId: String? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.subnets = subnets
        self.vpcId = vpcId
    }
}

extension AwsCorsConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowCredentials = "AllowCredentials"
        case allowHeaders = "AllowHeaders"
        case allowMethods = "AllowMethods"
        case allowOrigins = "AllowOrigins"
        case exposeHeaders = "ExposeHeaders"
        case maxAge = "MaxAge"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowCredentials != false {
            try encodeContainer.encode(allowCredentials, forKey: .allowCredentials)
        }
        if let allowHeaders = allowHeaders {
            var allowHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowHeaders)
            for nonemptystringlist0 in allowHeaders {
                try allowHeadersContainer.encode(nonemptystringlist0)
            }
        }
        if let allowMethods = allowMethods {
            var allowMethodsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowMethods)
            for nonemptystringlist0 in allowMethods {
                try allowMethodsContainer.encode(nonemptystringlist0)
            }
        }
        if let allowOrigins = allowOrigins {
            var allowOriginsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowOrigins)
            for nonemptystringlist0 in allowOrigins {
                try allowOriginsContainer.encode(nonemptystringlist0)
            }
        }
        if let exposeHeaders = exposeHeaders {
            var exposeHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exposeHeaders)
            for nonemptystringlist0 in exposeHeaders {
                try exposeHeadersContainer.encode(nonemptystringlist0)
            }
        }
        if maxAge != 0 {
            try encodeContainer.encode(maxAge, forKey: .maxAge)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowOriginsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .allowOrigins)
        var allowOriginsDecoded0:[String]? = nil
        if let allowOriginsContainer = allowOriginsContainer {
            allowOriginsDecoded0 = [String]()
            for string0 in allowOriginsContainer {
                if let string0 = string0 {
                    allowOriginsDecoded0?.append(string0)
                }
            }
        }
        allowOrigins = allowOriginsDecoded0
        let allowCredentialsDecoded = try containerValues.decode(Bool.self, forKey: .allowCredentials)
        allowCredentials = allowCredentialsDecoded
        let exposeHeadersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .exposeHeaders)
        var exposeHeadersDecoded0:[String]? = nil
        if let exposeHeadersContainer = exposeHeadersContainer {
            exposeHeadersDecoded0 = [String]()
            for string0 in exposeHeadersContainer {
                if let string0 = string0 {
                    exposeHeadersDecoded0?.append(string0)
                }
            }
        }
        exposeHeaders = exposeHeadersDecoded0
        let maxAgeDecoded = try containerValues.decode(Int.self, forKey: .maxAge)
        maxAge = maxAgeDecoded
        let allowMethodsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .allowMethods)
        var allowMethodsDecoded0:[String]? = nil
        if let allowMethodsContainer = allowMethodsContainer {
            allowMethodsDecoded0 = [String]()
            for string0 in allowMethodsContainer {
                if let string0 = string0 {
                    allowMethodsDecoded0?.append(string0)
                }
            }
        }
        allowMethods = allowMethodsDecoded0
        let allowHeadersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .allowHeaders)
        var allowHeadersDecoded0:[String]? = nil
        if let allowHeadersContainer = allowHeadersContainer {
            allowHeadersDecoded0 = [String]()
            for string0 in allowHeadersContainer {
                if let string0 = string0 {
                    allowHeadersDecoded0?.append(string0)
                }
            }
        }
        allowHeaders = allowHeadersDecoded0
    }
}

extension AwsCorsConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCorsConfiguration(allowCredentials: \(String(describing: allowCredentials)), allowHeaders: \(String(describing: allowHeaders)), allowMethods: \(String(describing: allowMethods)), allowOrigins: \(String(describing: allowOrigins)), exposeHeaders: \(String(describing: exposeHeaders)), maxAge: \(String(describing: maxAge)))"}
}

/// <p>Contains the cross-origin resource sharing (CORS) configuration for the API. CORS is
///          only supported for HTTP APIs.</p>
public struct AwsCorsConfiguration: Equatable {
    /// <p>Indicates whether the CORS request includes credentials.</p>
    public let allowCredentials: Bool
    /// <p>The allowed headers for CORS requests.</p>
    public let allowHeaders: [String]?
    /// <p>The allowed methods for CORS requests.</p>
    public let allowMethods: [String]?
    /// <p>The allowed origins for CORS requests.</p>
    public let allowOrigins: [String]?
    /// <p>The exposed headers for CORS requests.</p>
    public let exposeHeaders: [String]?
    /// <p>The number of seconds for which the browser caches preflight request results.</p>
    public let maxAge: Int

    public init (
        allowCredentials: Bool = false,
        allowHeaders: [String]? = nil,
        allowMethods: [String]? = nil,
        allowOrigins: [String]? = nil,
        exposeHeaders: [String]? = nil,
        maxAge: Int = 0
    )
    {
        self.allowCredentials = allowCredentials
        self.allowHeaders = allowHeaders
        self.allowMethods = allowMethods
        self.allowOrigins = allowOrigins
        self.exposeHeaders = exposeHeaders
        self.maxAge = maxAge
    }
}

extension AwsDynamoDbTableAttributeDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "AttributeName"
        case attributeType = "AttributeType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let attributeType = attributeType {
            try encodeContainer.encode(attributeType, forKey: .attributeType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let attributeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeType)
        attributeType = attributeTypeDecoded
    }
}

extension AwsDynamoDbTableAttributeDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsDynamoDbTableAttributeDefinition(attributeName: \(String(describing: attributeName)), attributeType: \(String(describing: attributeType)))"}
}

/// <p>Contains a definition of an attribute for the table.</p>
public struct AwsDynamoDbTableAttributeDefinition: Equatable {
    /// <p>The name of the attribute.</p>
    public let attributeName: String?
    /// <p>The type of the attribute.</p>
    public let attributeType: String?

    public init (
        attributeName: String? = nil,
        attributeType: String? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeType = attributeType
    }
}

extension AwsDynamoDbTableBillingModeSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case billingMode = "BillingMode"
        case lastUpdateToPayPerRequestDateTime = "LastUpdateToPayPerRequestDateTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingMode = billingMode {
            try encodeContainer.encode(billingMode, forKey: .billingMode)
        }
        if let lastUpdateToPayPerRequestDateTime = lastUpdateToPayPerRequestDateTime {
            try encodeContainer.encode(lastUpdateToPayPerRequestDateTime, forKey: .lastUpdateToPayPerRequestDateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .billingMode)
        billingMode = billingModeDecoded
        let lastUpdateToPayPerRequestDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdateToPayPerRequestDateTime)
        lastUpdateToPayPerRequestDateTime = lastUpdateToPayPerRequestDateTimeDecoded
    }
}

extension AwsDynamoDbTableBillingModeSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsDynamoDbTableBillingModeSummary(billingMode: \(String(describing: billingMode)), lastUpdateToPayPerRequestDateTime: \(String(describing: lastUpdateToPayPerRequestDateTime)))"}
}

/// <p>Provides information about the billing for read/write capacity on the table.</p>
public struct AwsDynamoDbTableBillingModeSummary: Equatable {
    /// <p>The method used to charge for read and write throughput and to manage capacity.</p>
    public let billingMode: String?
    /// <p>If the billing mode is <code>PAY_PER_REQUEST</code>, indicates when the billing mode was
    ///          set to that value.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let lastUpdateToPayPerRequestDateTime: String?

    public init (
        billingMode: String? = nil,
        lastUpdateToPayPerRequestDateTime: String? = nil
    )
    {
        self.billingMode = billingMode
        self.lastUpdateToPayPerRequestDateTime = lastUpdateToPayPerRequestDateTime
    }
}

extension AwsDynamoDbTableDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeDefinitions = "AttributeDefinitions"
        case billingModeSummary = "BillingModeSummary"
        case creationDateTime = "CreationDateTime"
        case globalSecondaryIndexes = "GlobalSecondaryIndexes"
        case globalTableVersion = "GlobalTableVersion"
        case itemCount = "ItemCount"
        case keySchema = "KeySchema"
        case latestStreamArn = "LatestStreamArn"
        case latestStreamLabel = "LatestStreamLabel"
        case localSecondaryIndexes = "LocalSecondaryIndexes"
        case provisionedThroughput = "ProvisionedThroughput"
        case replicas = "Replicas"
        case restoreSummary = "RestoreSummary"
        case sseDescription = "SseDescription"
        case streamSpecification = "StreamSpecification"
        case tableId = "TableId"
        case tableName = "TableName"
        case tableSizeBytes = "TableSizeBytes"
        case tableStatus = "TableStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeDefinitions = attributeDefinitions {
            var attributeDefinitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeDefinitions)
            for awsdynamodbtableattributedefinitionlist0 in attributeDefinitions {
                try attributeDefinitionsContainer.encode(awsdynamodbtableattributedefinitionlist0)
            }
        }
        if let billingModeSummary = billingModeSummary {
            try encodeContainer.encode(billingModeSummary, forKey: .billingModeSummary)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime, forKey: .creationDateTime)
        }
        if let globalSecondaryIndexes = globalSecondaryIndexes {
            var globalSecondaryIndexesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .globalSecondaryIndexes)
            for awsdynamodbtableglobalsecondaryindexlist0 in globalSecondaryIndexes {
                try globalSecondaryIndexesContainer.encode(awsdynamodbtableglobalsecondaryindexlist0)
            }
        }
        if let globalTableVersion = globalTableVersion {
            try encodeContainer.encode(globalTableVersion, forKey: .globalTableVersion)
        }
        if itemCount != 0 {
            try encodeContainer.encode(itemCount, forKey: .itemCount)
        }
        if let keySchema = keySchema {
            var keySchemaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keySchema)
            for awsdynamodbtablekeyschemalist0 in keySchema {
                try keySchemaContainer.encode(awsdynamodbtablekeyschemalist0)
            }
        }
        if let latestStreamArn = latestStreamArn {
            try encodeContainer.encode(latestStreamArn, forKey: .latestStreamArn)
        }
        if let latestStreamLabel = latestStreamLabel {
            try encodeContainer.encode(latestStreamLabel, forKey: .latestStreamLabel)
        }
        if let localSecondaryIndexes = localSecondaryIndexes {
            var localSecondaryIndexesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .localSecondaryIndexes)
            for awsdynamodbtablelocalsecondaryindexlist0 in localSecondaryIndexes {
                try localSecondaryIndexesContainer.encode(awsdynamodbtablelocalsecondaryindexlist0)
            }
        }
        if let provisionedThroughput = provisionedThroughput {
            try encodeContainer.encode(provisionedThroughput, forKey: .provisionedThroughput)
        }
        if let replicas = replicas {
            var replicasContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicas)
            for awsdynamodbtablereplicalist0 in replicas {
                try replicasContainer.encode(awsdynamodbtablereplicalist0)
            }
        }
        if let restoreSummary = restoreSummary {
            try encodeContainer.encode(restoreSummary, forKey: .restoreSummary)
        }
        if let sseDescription = sseDescription {
            try encodeContainer.encode(sseDescription, forKey: .sseDescription)
        }
        if let streamSpecification = streamSpecification {
            try encodeContainer.encode(streamSpecification, forKey: .streamSpecification)
        }
        if let tableId = tableId {
            try encodeContainer.encode(tableId, forKey: .tableId)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if tableSizeBytes != 0 {
            try encodeContainer.encode(tableSizeBytes, forKey: .tableSizeBytes)
        }
        if let tableStatus = tableStatus {
            try encodeContainer.encode(tableStatus, forKey: .tableStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDefinitionsContainer = try containerValues.decodeIfPresent([AwsDynamoDbTableAttributeDefinition?].self, forKey: .attributeDefinitions)
        var attributeDefinitionsDecoded0:[AwsDynamoDbTableAttributeDefinition]? = nil
        if let attributeDefinitionsContainer = attributeDefinitionsContainer {
            attributeDefinitionsDecoded0 = [AwsDynamoDbTableAttributeDefinition]()
            for structure0 in attributeDefinitionsContainer {
                if let structure0 = structure0 {
                    attributeDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        attributeDefinitions = attributeDefinitionsDecoded0
        let billingModeSummaryDecoded = try containerValues.decodeIfPresent(AwsDynamoDbTableBillingModeSummary.self, forKey: .billingModeSummary)
        billingModeSummary = billingModeSummaryDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let globalSecondaryIndexesContainer = try containerValues.decodeIfPresent([AwsDynamoDbTableGlobalSecondaryIndex?].self, forKey: .globalSecondaryIndexes)
        var globalSecondaryIndexesDecoded0:[AwsDynamoDbTableGlobalSecondaryIndex]? = nil
        if let globalSecondaryIndexesContainer = globalSecondaryIndexesContainer {
            globalSecondaryIndexesDecoded0 = [AwsDynamoDbTableGlobalSecondaryIndex]()
            for structure0 in globalSecondaryIndexesContainer {
                if let structure0 = structure0 {
                    globalSecondaryIndexesDecoded0?.append(structure0)
                }
            }
        }
        globalSecondaryIndexes = globalSecondaryIndexesDecoded0
        let globalTableVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .globalTableVersion)
        globalTableVersion = globalTableVersionDecoded
        let itemCountDecoded = try containerValues.decode(Int.self, forKey: .itemCount)
        itemCount = itemCountDecoded
        let keySchemaContainer = try containerValues.decodeIfPresent([AwsDynamoDbTableKeySchema?].self, forKey: .keySchema)
        var keySchemaDecoded0:[AwsDynamoDbTableKeySchema]? = nil
        if let keySchemaContainer = keySchemaContainer {
            keySchemaDecoded0 = [AwsDynamoDbTableKeySchema]()
            for structure0 in keySchemaContainer {
                if let structure0 = structure0 {
                    keySchemaDecoded0?.append(structure0)
                }
            }
        }
        keySchema = keySchemaDecoded0
        let latestStreamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestStreamArn)
        latestStreamArn = latestStreamArnDecoded
        let latestStreamLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestStreamLabel)
        latestStreamLabel = latestStreamLabelDecoded
        let localSecondaryIndexesContainer = try containerValues.decodeIfPresent([AwsDynamoDbTableLocalSecondaryIndex?].self, forKey: .localSecondaryIndexes)
        var localSecondaryIndexesDecoded0:[AwsDynamoDbTableLocalSecondaryIndex]? = nil
        if let localSecondaryIndexesContainer = localSecondaryIndexesContainer {
            localSecondaryIndexesDecoded0 = [AwsDynamoDbTableLocalSecondaryIndex]()
            for structure0 in localSecondaryIndexesContainer {
                if let structure0 = structure0 {
                    localSecondaryIndexesDecoded0?.append(structure0)
                }
            }
        }
        localSecondaryIndexes = localSecondaryIndexesDecoded0
        let provisionedThroughputDecoded = try containerValues.decodeIfPresent(AwsDynamoDbTableProvisionedThroughput.self, forKey: .provisionedThroughput)
        provisionedThroughput = provisionedThroughputDecoded
        let replicasContainer = try containerValues.decodeIfPresent([AwsDynamoDbTableReplica?].self, forKey: .replicas)
        var replicasDecoded0:[AwsDynamoDbTableReplica]? = nil
        if let replicasContainer = replicasContainer {
            replicasDecoded0 = [AwsDynamoDbTableReplica]()
            for structure0 in replicasContainer {
                if let structure0 = structure0 {
                    replicasDecoded0?.append(structure0)
                }
            }
        }
        replicas = replicasDecoded0
        let restoreSummaryDecoded = try containerValues.decodeIfPresent(AwsDynamoDbTableRestoreSummary.self, forKey: .restoreSummary)
        restoreSummary = restoreSummaryDecoded
        let sseDescriptionDecoded = try containerValues.decodeIfPresent(AwsDynamoDbTableSseDescription.self, forKey: .sseDescription)
        sseDescription = sseDescriptionDecoded
        let streamSpecificationDecoded = try containerValues.decodeIfPresent(AwsDynamoDbTableStreamSpecification.self, forKey: .streamSpecification)
        streamSpecification = streamSpecificationDecoded
        let tableIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableId)
        tableId = tableIdDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let tableSizeBytesDecoded = try containerValues.decode(Int.self, forKey: .tableSizeBytes)
        tableSizeBytes = tableSizeBytesDecoded
        let tableStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableStatus)
        tableStatus = tableStatusDecoded
    }
}

extension AwsDynamoDbTableDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsDynamoDbTableDetails(attributeDefinitions: \(String(describing: attributeDefinitions)), billingModeSummary: \(String(describing: billingModeSummary)), creationDateTime: \(String(describing: creationDateTime)), globalSecondaryIndexes: \(String(describing: globalSecondaryIndexes)), globalTableVersion: \(String(describing: globalTableVersion)), itemCount: \(String(describing: itemCount)), keySchema: \(String(describing: keySchema)), latestStreamArn: \(String(describing: latestStreamArn)), latestStreamLabel: \(String(describing: latestStreamLabel)), localSecondaryIndexes: \(String(describing: localSecondaryIndexes)), provisionedThroughput: \(String(describing: provisionedThroughput)), replicas: \(String(describing: replicas)), restoreSummary: \(String(describing: restoreSummary)), sseDescription: \(String(describing: sseDescription)), streamSpecification: \(String(describing: streamSpecification)), tableId: \(String(describing: tableId)), tableName: \(String(describing: tableName)), tableSizeBytes: \(String(describing: tableSizeBytes)), tableStatus: \(String(describing: tableStatus)))"}
}

/// <p>Provides details about a DynamoDB table.</p>
public struct AwsDynamoDbTableDetails: Equatable {
    /// <p>A list of attribute definitions for the table.</p>
    public let attributeDefinitions: [AwsDynamoDbTableAttributeDefinition]?
    /// <p>Information about the billing for read/write capacity on the table.</p>
    public let billingModeSummary: AwsDynamoDbTableBillingModeSummary?
    /// <p>Indicates when the table was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let creationDateTime: String?
    /// <p>List of global secondary indexes for the table.</p>
    public let globalSecondaryIndexes: [AwsDynamoDbTableGlobalSecondaryIndex]?
    /// <p>The version of global tables being used.</p>
    public let globalTableVersion: String?
    /// <p>The number of items in the table.</p>
    public let itemCount: Int
    /// <p>The primary key structure for the table.</p>
    public let keySchema: [AwsDynamoDbTableKeySchema]?
    /// <p>The ARN of the latest stream for the table.</p>
    public let latestStreamArn: String?
    /// <p>The label of the latest stream. The label is not a unique identifier.</p>
    public let latestStreamLabel: String?
    /// <p>The list of local secondary indexes for the table.</p>
    public let localSecondaryIndexes: [AwsDynamoDbTableLocalSecondaryIndex]?
    /// <p>Information about the provisioned throughput for the table.</p>
    public let provisionedThroughput: AwsDynamoDbTableProvisionedThroughput?
    /// <p>The list of replicas of this table.</p>
    public let replicas: [AwsDynamoDbTableReplica]?
    /// <p>Information about the restore for the table.</p>
    public let restoreSummary: AwsDynamoDbTableRestoreSummary?
    /// <p>Information about the server-side encryption for the table.</p>
    public let sseDescription: AwsDynamoDbTableSseDescription?
    /// <p>The current DynamoDB Streams configuration for the table.</p>
    public let streamSpecification: AwsDynamoDbTableStreamSpecification?
    /// <p>The identifier of the table.</p>
    public let tableId: String?
    /// <p>The name of the table.</p>
    public let tableName: String?
    /// <p>The total size of the table in bytes.</p>
    public let tableSizeBytes: Int
    /// <p>The current status of the table.</p>
    public let tableStatus: String?

    public init (
        attributeDefinitions: [AwsDynamoDbTableAttributeDefinition]? = nil,
        billingModeSummary: AwsDynamoDbTableBillingModeSummary? = nil,
        creationDateTime: String? = nil,
        globalSecondaryIndexes: [AwsDynamoDbTableGlobalSecondaryIndex]? = nil,
        globalTableVersion: String? = nil,
        itemCount: Int = 0,
        keySchema: [AwsDynamoDbTableKeySchema]? = nil,
        latestStreamArn: String? = nil,
        latestStreamLabel: String? = nil,
        localSecondaryIndexes: [AwsDynamoDbTableLocalSecondaryIndex]? = nil,
        provisionedThroughput: AwsDynamoDbTableProvisionedThroughput? = nil,
        replicas: [AwsDynamoDbTableReplica]? = nil,
        restoreSummary: AwsDynamoDbTableRestoreSummary? = nil,
        sseDescription: AwsDynamoDbTableSseDescription? = nil,
        streamSpecification: AwsDynamoDbTableStreamSpecification? = nil,
        tableId: String? = nil,
        tableName: String? = nil,
        tableSizeBytes: Int = 0,
        tableStatus: String? = nil
    )
    {
        self.attributeDefinitions = attributeDefinitions
        self.billingModeSummary = billingModeSummary
        self.creationDateTime = creationDateTime
        self.globalSecondaryIndexes = globalSecondaryIndexes
        self.globalTableVersion = globalTableVersion
        self.itemCount = itemCount
        self.keySchema = keySchema
        self.latestStreamArn = latestStreamArn
        self.latestStreamLabel = latestStreamLabel
        self.localSecondaryIndexes = localSecondaryIndexes
        self.provisionedThroughput = provisionedThroughput
        self.replicas = replicas
        self.restoreSummary = restoreSummary
        self.sseDescription = sseDescription
        self.streamSpecification = streamSpecification
        self.tableId = tableId
        self.tableName = tableName
        self.tableSizeBytes = tableSizeBytes
        self.tableStatus = tableStatus
    }
}

extension AwsDynamoDbTableGlobalSecondaryIndex: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backfilling = "Backfilling"
        case indexArn = "IndexArn"
        case indexName = "IndexName"
        case indexSizeBytes = "IndexSizeBytes"
        case indexStatus = "IndexStatus"
        case itemCount = "ItemCount"
        case keySchema = "KeySchema"
        case projection = "Projection"
        case provisionedThroughput = "ProvisionedThroughput"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if backfilling != false {
            try encodeContainer.encode(backfilling, forKey: .backfilling)
        }
        if let indexArn = indexArn {
            try encodeContainer.encode(indexArn, forKey: .indexArn)
        }
        if let indexName = indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if indexSizeBytes != 0 {
            try encodeContainer.encode(indexSizeBytes, forKey: .indexSizeBytes)
        }
        if let indexStatus = indexStatus {
            try encodeContainer.encode(indexStatus, forKey: .indexStatus)
        }
        if itemCount != 0 {
            try encodeContainer.encode(itemCount, forKey: .itemCount)
        }
        if let keySchema = keySchema {
            var keySchemaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keySchema)
            for awsdynamodbtablekeyschemalist0 in keySchema {
                try keySchemaContainer.encode(awsdynamodbtablekeyschemalist0)
            }
        }
        if let projection = projection {
            try encodeContainer.encode(projection, forKey: .projection)
        }
        if let provisionedThroughput = provisionedThroughput {
            try encodeContainer.encode(provisionedThroughput, forKey: .provisionedThroughput)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backfillingDecoded = try containerValues.decode(Bool.self, forKey: .backfilling)
        backfilling = backfillingDecoded
        let indexArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexArn)
        indexArn = indexArnDecoded
        let indexNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let indexSizeBytesDecoded = try containerValues.decode(Int.self, forKey: .indexSizeBytes)
        indexSizeBytes = indexSizeBytesDecoded
        let indexStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexStatus)
        indexStatus = indexStatusDecoded
        let itemCountDecoded = try containerValues.decode(Int.self, forKey: .itemCount)
        itemCount = itemCountDecoded
        let keySchemaContainer = try containerValues.decodeIfPresent([AwsDynamoDbTableKeySchema?].self, forKey: .keySchema)
        var keySchemaDecoded0:[AwsDynamoDbTableKeySchema]? = nil
        if let keySchemaContainer = keySchemaContainer {
            keySchemaDecoded0 = [AwsDynamoDbTableKeySchema]()
            for structure0 in keySchemaContainer {
                if let structure0 = structure0 {
                    keySchemaDecoded0?.append(structure0)
                }
            }
        }
        keySchema = keySchemaDecoded0
        let projectionDecoded = try containerValues.decodeIfPresent(AwsDynamoDbTableProjection.self, forKey: .projection)
        projection = projectionDecoded
        let provisionedThroughputDecoded = try containerValues.decodeIfPresent(AwsDynamoDbTableProvisionedThroughput.self, forKey: .provisionedThroughput)
        provisionedThroughput = provisionedThroughputDecoded
    }
}

extension AwsDynamoDbTableGlobalSecondaryIndex: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsDynamoDbTableGlobalSecondaryIndex(backfilling: \(String(describing: backfilling)), indexArn: \(String(describing: indexArn)), indexName: \(String(describing: indexName)), indexSizeBytes: \(String(describing: indexSizeBytes)), indexStatus: \(String(describing: indexStatus)), itemCount: \(String(describing: itemCount)), keySchema: \(String(describing: keySchema)), projection: \(String(describing: projection)), provisionedThroughput: \(String(describing: provisionedThroughput)))"}
}

/// <p>Information abut a global secondary index for the table.</p>
public struct AwsDynamoDbTableGlobalSecondaryIndex: Equatable {
    /// <p>Whether the index is currently backfilling.</p>
    public let backfilling: Bool
    /// <p>The ARN of the index.</p>
    public let indexArn: String?
    /// <p>The name of the index.</p>
    public let indexName: String?
    /// <p>The total size in bytes of the index.</p>
    public let indexSizeBytes: Int
    /// <p>The current status of the index.</p>
    public let indexStatus: String?
    /// <p>The number of items in the index.</p>
    public let itemCount: Int
    /// <p>The key schema for the index.</p>
    public let keySchema: [AwsDynamoDbTableKeySchema]?
    /// <p>Attributes that are copied from the table into an index.</p>
    public let projection: AwsDynamoDbTableProjection?
    /// <p>Information about the provisioned throughput settings for the indexes.</p>
    public let provisionedThroughput: AwsDynamoDbTableProvisionedThroughput?

    public init (
        backfilling: Bool = false,
        indexArn: String? = nil,
        indexName: String? = nil,
        indexSizeBytes: Int = 0,
        indexStatus: String? = nil,
        itemCount: Int = 0,
        keySchema: [AwsDynamoDbTableKeySchema]? = nil,
        projection: AwsDynamoDbTableProjection? = nil,
        provisionedThroughput: AwsDynamoDbTableProvisionedThroughput? = nil
    )
    {
        self.backfilling = backfilling
        self.indexArn = indexArn
        self.indexName = indexName
        self.indexSizeBytes = indexSizeBytes
        self.indexStatus = indexStatus
        self.itemCount = itemCount
        self.keySchema = keySchema
        self.projection = projection
        self.provisionedThroughput = provisionedThroughput
    }
}

extension AwsDynamoDbTableKeySchema: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "AttributeName"
        case keyType = "KeyType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let keyType = keyType {
            try encodeContainer.encode(keyType, forKey: .keyType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyType)
        keyType = keyTypeDecoded
    }
}

extension AwsDynamoDbTableKeySchema: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsDynamoDbTableKeySchema(attributeName: \(String(describing: attributeName)), keyType: \(String(describing: keyType)))"}
}

/// <p>A component of the key schema for the DynamoDB table, a global secondary index, or a
///          local secondary index.</p>
public struct AwsDynamoDbTableKeySchema: Equatable {
    /// <p>The name of the key schema attribute.</p>
    public let attributeName: String?
    /// <p>The type of key used for the key schema attribute.</p>
    public let keyType: String?

    public init (
        attributeName: String? = nil,
        keyType: String? = nil
    )
    {
        self.attributeName = attributeName
        self.keyType = keyType
    }
}

extension AwsDynamoDbTableLocalSecondaryIndex: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexArn = "IndexArn"
        case indexName = "IndexName"
        case keySchema = "KeySchema"
        case projection = "Projection"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexArn = indexArn {
            try encodeContainer.encode(indexArn, forKey: .indexArn)
        }
        if let indexName = indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let keySchema = keySchema {
            var keySchemaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keySchema)
            for awsdynamodbtablekeyschemalist0 in keySchema {
                try keySchemaContainer.encode(awsdynamodbtablekeyschemalist0)
            }
        }
        if let projection = projection {
            try encodeContainer.encode(projection, forKey: .projection)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexArn)
        indexArn = indexArnDecoded
        let indexNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let keySchemaContainer = try containerValues.decodeIfPresent([AwsDynamoDbTableKeySchema?].self, forKey: .keySchema)
        var keySchemaDecoded0:[AwsDynamoDbTableKeySchema]? = nil
        if let keySchemaContainer = keySchemaContainer {
            keySchemaDecoded0 = [AwsDynamoDbTableKeySchema]()
            for structure0 in keySchemaContainer {
                if let structure0 = structure0 {
                    keySchemaDecoded0?.append(structure0)
                }
            }
        }
        keySchema = keySchemaDecoded0
        let projectionDecoded = try containerValues.decodeIfPresent(AwsDynamoDbTableProjection.self, forKey: .projection)
        projection = projectionDecoded
    }
}

extension AwsDynamoDbTableLocalSecondaryIndex: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsDynamoDbTableLocalSecondaryIndex(indexArn: \(String(describing: indexArn)), indexName: \(String(describing: indexName)), keySchema: \(String(describing: keySchema)), projection: \(String(describing: projection)))"}
}

/// <p>Information about a local secondary index for a DynamoDB table.</p>
public struct AwsDynamoDbTableLocalSecondaryIndex: Equatable {
    /// <p>The ARN of the index.</p>
    public let indexArn: String?
    /// <p>The name of the index.</p>
    public let indexName: String?
    /// <p>The complete key schema for the index.</p>
    public let keySchema: [AwsDynamoDbTableKeySchema]?
    /// <p>Attributes that are copied from the table into the index. These are in addition to the
    ///          primary key attributes and index key attributes, which are automatically projected.</p>
    public let projection: AwsDynamoDbTableProjection?

    public init (
        indexArn: String? = nil,
        indexName: String? = nil,
        keySchema: [AwsDynamoDbTableKeySchema]? = nil,
        projection: AwsDynamoDbTableProjection? = nil
    )
    {
        self.indexArn = indexArn
        self.indexName = indexName
        self.keySchema = keySchema
        self.projection = projection
    }
}

extension AwsDynamoDbTableProjection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nonKeyAttributes = "NonKeyAttributes"
        case projectionType = "ProjectionType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nonKeyAttributes = nonKeyAttributes {
            var nonKeyAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nonKeyAttributes)
            for stringlist0 in nonKeyAttributes {
                try nonKeyAttributesContainer.encode(stringlist0)
            }
        }
        if let projectionType = projectionType {
            try encodeContainer.encode(projectionType, forKey: .projectionType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nonKeyAttributesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .nonKeyAttributes)
        var nonKeyAttributesDecoded0:[String]? = nil
        if let nonKeyAttributesContainer = nonKeyAttributesContainer {
            nonKeyAttributesDecoded0 = [String]()
            for string0 in nonKeyAttributesContainer {
                if let string0 = string0 {
                    nonKeyAttributesDecoded0?.append(string0)
                }
            }
        }
        nonKeyAttributes = nonKeyAttributesDecoded0
        let projectionTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectionType)
        projectionType = projectionTypeDecoded
    }
}

extension AwsDynamoDbTableProjection: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsDynamoDbTableProjection(nonKeyAttributes: \(String(describing: nonKeyAttributes)), projectionType: \(String(describing: projectionType)))"}
}

/// <p>For global and local secondary indexes, identifies the attributes that are copied from
///          the table into the index.</p>
public struct AwsDynamoDbTableProjection: Equatable {
    /// <p>The nonkey attributes that are projected into the index. For each attribute, provide the
    ///          attribute name.</p>
    public let nonKeyAttributes: [String]?
    /// <p>The types of attributes that are projected into the index.</p>
    public let projectionType: String?

    public init (
        nonKeyAttributes: [String]? = nil,
        projectionType: String? = nil
    )
    {
        self.nonKeyAttributes = nonKeyAttributes
        self.projectionType = projectionType
    }
}

extension AwsDynamoDbTableProvisionedThroughput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastDecreaseDateTime = "LastDecreaseDateTime"
        case lastIncreaseDateTime = "LastIncreaseDateTime"
        case numberOfDecreasesToday = "NumberOfDecreasesToday"
        case readCapacityUnits = "ReadCapacityUnits"
        case writeCapacityUnits = "WriteCapacityUnits"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastDecreaseDateTime = lastDecreaseDateTime {
            try encodeContainer.encode(lastDecreaseDateTime, forKey: .lastDecreaseDateTime)
        }
        if let lastIncreaseDateTime = lastIncreaseDateTime {
            try encodeContainer.encode(lastIncreaseDateTime, forKey: .lastIncreaseDateTime)
        }
        if numberOfDecreasesToday != 0 {
            try encodeContainer.encode(numberOfDecreasesToday, forKey: .numberOfDecreasesToday)
        }
        if readCapacityUnits != 0 {
            try encodeContainer.encode(readCapacityUnits, forKey: .readCapacityUnits)
        }
        if writeCapacityUnits != 0 {
            try encodeContainer.encode(writeCapacityUnits, forKey: .writeCapacityUnits)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastDecreaseDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastDecreaseDateTime)
        lastDecreaseDateTime = lastDecreaseDateTimeDecoded
        let lastIncreaseDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastIncreaseDateTime)
        lastIncreaseDateTime = lastIncreaseDateTimeDecoded
        let numberOfDecreasesTodayDecoded = try containerValues.decode(Int.self, forKey: .numberOfDecreasesToday)
        numberOfDecreasesToday = numberOfDecreasesTodayDecoded
        let readCapacityUnitsDecoded = try containerValues.decode(Int.self, forKey: .readCapacityUnits)
        readCapacityUnits = readCapacityUnitsDecoded
        let writeCapacityUnitsDecoded = try containerValues.decode(Int.self, forKey: .writeCapacityUnits)
        writeCapacityUnits = writeCapacityUnitsDecoded
    }
}

extension AwsDynamoDbTableProvisionedThroughput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsDynamoDbTableProvisionedThroughput(lastDecreaseDateTime: \(String(describing: lastDecreaseDateTime)), lastIncreaseDateTime: \(String(describing: lastIncreaseDateTime)), numberOfDecreasesToday: \(String(describing: numberOfDecreasesToday)), readCapacityUnits: \(String(describing: readCapacityUnits)), writeCapacityUnits: \(String(describing: writeCapacityUnits)))"}
}

/// <p>Information about the provisioned throughput for the table or for a global secondary
///          index.</p>
public struct AwsDynamoDbTableProvisionedThroughput: Equatable {
    /// <p>Indicates when the provisioned throughput was last decreased.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let lastDecreaseDateTime: String?
    /// <p>Indicates when the provisioned throughput was last increased.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let lastIncreaseDateTime: String?
    /// <p>The number of times during the current UTC calendar day that the provisioned throughput
    ///          was decreased.</p>
    public let numberOfDecreasesToday: Int
    /// <p>The maximum number of strongly consistent reads consumed per second before DynamoDB
    ///          returns a <code>ThrottlingException</code>.</p>
    public let readCapacityUnits: Int
    /// <p>The maximum number of writes consumed per second before DynamoDB returns a
    ///             <code>ThrottlingException</code>.</p>
    public let writeCapacityUnits: Int

    public init (
        lastDecreaseDateTime: String? = nil,
        lastIncreaseDateTime: String? = nil,
        numberOfDecreasesToday: Int = 0,
        readCapacityUnits: Int = 0,
        writeCapacityUnits: Int = 0
    )
    {
        self.lastDecreaseDateTime = lastDecreaseDateTime
        self.lastIncreaseDateTime = lastIncreaseDateTime
        self.numberOfDecreasesToday = numberOfDecreasesToday
        self.readCapacityUnits = readCapacityUnits
        self.writeCapacityUnits = writeCapacityUnits
    }
}

extension AwsDynamoDbTableProvisionedThroughputOverride: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case readCapacityUnits = "ReadCapacityUnits"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if readCapacityUnits != 0 {
            try encodeContainer.encode(readCapacityUnits, forKey: .readCapacityUnits)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readCapacityUnitsDecoded = try containerValues.decode(Int.self, forKey: .readCapacityUnits)
        readCapacityUnits = readCapacityUnitsDecoded
    }
}

extension AwsDynamoDbTableProvisionedThroughputOverride: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsDynamoDbTableProvisionedThroughputOverride(readCapacityUnits: \(String(describing: readCapacityUnits)))"}
}

/// <p>Replica-specific configuration for the provisioned throughput.</p>
public struct AwsDynamoDbTableProvisionedThroughputOverride: Equatable {
    /// <p>The read capacity units for the replica.</p>
    public let readCapacityUnits: Int

    public init (
        readCapacityUnits: Int = 0
    )
    {
        self.readCapacityUnits = readCapacityUnits
    }
}

extension AwsDynamoDbTableReplica: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case globalSecondaryIndexes = "GlobalSecondaryIndexes"
        case kmsMasterKeyId = "KmsMasterKeyId"
        case provisionedThroughputOverride = "ProvisionedThroughputOverride"
        case regionName = "RegionName"
        case replicaStatus = "ReplicaStatus"
        case replicaStatusDescription = "ReplicaStatusDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let globalSecondaryIndexes = globalSecondaryIndexes {
            var globalSecondaryIndexesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .globalSecondaryIndexes)
            for awsdynamodbtablereplicaglobalsecondaryindexlist0 in globalSecondaryIndexes {
                try globalSecondaryIndexesContainer.encode(awsdynamodbtablereplicaglobalsecondaryindexlist0)
            }
        }
        if let kmsMasterKeyId = kmsMasterKeyId {
            try encodeContainer.encode(kmsMasterKeyId, forKey: .kmsMasterKeyId)
        }
        if let provisionedThroughputOverride = provisionedThroughputOverride {
            try encodeContainer.encode(provisionedThroughputOverride, forKey: .provisionedThroughputOverride)
        }
        if let regionName = regionName {
            try encodeContainer.encode(regionName, forKey: .regionName)
        }
        if let replicaStatus = replicaStatus {
            try encodeContainer.encode(replicaStatus, forKey: .replicaStatus)
        }
        if let replicaStatusDescription = replicaStatusDescription {
            try encodeContainer.encode(replicaStatusDescription, forKey: .replicaStatusDescription)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalSecondaryIndexesContainer = try containerValues.decodeIfPresent([AwsDynamoDbTableReplicaGlobalSecondaryIndex?].self, forKey: .globalSecondaryIndexes)
        var globalSecondaryIndexesDecoded0:[AwsDynamoDbTableReplicaGlobalSecondaryIndex]? = nil
        if let globalSecondaryIndexesContainer = globalSecondaryIndexesContainer {
            globalSecondaryIndexesDecoded0 = [AwsDynamoDbTableReplicaGlobalSecondaryIndex]()
            for structure0 in globalSecondaryIndexesContainer {
                if let structure0 = structure0 {
                    globalSecondaryIndexesDecoded0?.append(structure0)
                }
            }
        }
        globalSecondaryIndexes = globalSecondaryIndexesDecoded0
        let kmsMasterKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsMasterKeyId)
        kmsMasterKeyId = kmsMasterKeyIdDecoded
        let provisionedThroughputOverrideDecoded = try containerValues.decodeIfPresent(AwsDynamoDbTableProvisionedThroughputOverride.self, forKey: .provisionedThroughputOverride)
        provisionedThroughputOverride = provisionedThroughputOverrideDecoded
        let regionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let replicaStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicaStatus)
        replicaStatus = replicaStatusDecoded
        let replicaStatusDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicaStatusDescription)
        replicaStatusDescription = replicaStatusDescriptionDecoded
    }
}

extension AwsDynamoDbTableReplica: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsDynamoDbTableReplica(globalSecondaryIndexes: \(String(describing: globalSecondaryIndexes)), kmsMasterKeyId: \(String(describing: kmsMasterKeyId)), provisionedThroughputOverride: \(String(describing: provisionedThroughputOverride)), regionName: \(String(describing: regionName)), replicaStatus: \(String(describing: replicaStatus)), replicaStatusDescription: \(String(describing: replicaStatusDescription)))"}
}

/// <p>Information about a replica of a DynamoDB table.</p>
public struct AwsDynamoDbTableReplica: Equatable {
    /// <p>List of global secondary indexes for the replica.</p>
    public let globalSecondaryIndexes: [AwsDynamoDbTableReplicaGlobalSecondaryIndex]?
    /// <p>The identifier of the AWS KMS customer master key (CMK) that will be used for AWS KMS
    ///          encryption for the replica.</p>
    public let kmsMasterKeyId: String?
    /// <p>Replica-specific configuration for the provisioned throughput.</p>
    public let provisionedThroughputOverride: AwsDynamoDbTableProvisionedThroughputOverride?
    /// <p>The name of the Region where the replica is located.</p>
    public let regionName: String?
    /// <p>The current status of the replica.</p>
    public let replicaStatus: String?
    /// <p>Detailed information about the replica status.</p>
    public let replicaStatusDescription: String?

    public init (
        globalSecondaryIndexes: [AwsDynamoDbTableReplicaGlobalSecondaryIndex]? = nil,
        kmsMasterKeyId: String? = nil,
        provisionedThroughputOverride: AwsDynamoDbTableProvisionedThroughputOverride? = nil,
        regionName: String? = nil,
        replicaStatus: String? = nil,
        replicaStatusDescription: String? = nil
    )
    {
        self.globalSecondaryIndexes = globalSecondaryIndexes
        self.kmsMasterKeyId = kmsMasterKeyId
        self.provisionedThroughputOverride = provisionedThroughputOverride
        self.regionName = regionName
        self.replicaStatus = replicaStatus
        self.replicaStatusDescription = replicaStatusDescription
    }
}

extension AwsDynamoDbTableReplicaGlobalSecondaryIndex: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexName = "IndexName"
        case provisionedThroughputOverride = "ProvisionedThroughputOverride"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexName = indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let provisionedThroughputOverride = provisionedThroughputOverride {
            try encodeContainer.encode(provisionedThroughputOverride, forKey: .provisionedThroughputOverride)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let provisionedThroughputOverrideDecoded = try containerValues.decodeIfPresent(AwsDynamoDbTableProvisionedThroughputOverride.self, forKey: .provisionedThroughputOverride)
        provisionedThroughputOverride = provisionedThroughputOverrideDecoded
    }
}

extension AwsDynamoDbTableReplicaGlobalSecondaryIndex: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsDynamoDbTableReplicaGlobalSecondaryIndex(indexName: \(String(describing: indexName)), provisionedThroughputOverride: \(String(describing: provisionedThroughputOverride)))"}
}

/// <p>Information about a global secondary index for a DynamoDB table replica.</p>
public struct AwsDynamoDbTableReplicaGlobalSecondaryIndex: Equatable {
    /// <p>The name of the index.</p>
    public let indexName: String?
    /// <p>Replica-specific configuration for the provisioned throughput for the index.</p>
    public let provisionedThroughputOverride: AwsDynamoDbTableProvisionedThroughputOverride?

    public init (
        indexName: String? = nil,
        provisionedThroughputOverride: AwsDynamoDbTableProvisionedThroughputOverride? = nil
    )
    {
        self.indexName = indexName
        self.provisionedThroughputOverride = provisionedThroughputOverride
    }
}

extension AwsDynamoDbTableRestoreSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case restoreDateTime = "RestoreDateTime"
        case restoreInProgress = "RestoreInProgress"
        case sourceBackupArn = "SourceBackupArn"
        case sourceTableArn = "SourceTableArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let restoreDateTime = restoreDateTime {
            try encodeContainer.encode(restoreDateTime, forKey: .restoreDateTime)
        }
        if restoreInProgress != false {
            try encodeContainer.encode(restoreInProgress, forKey: .restoreInProgress)
        }
        if let sourceBackupArn = sourceBackupArn {
            try encodeContainer.encode(sourceBackupArn, forKey: .sourceBackupArn)
        }
        if let sourceTableArn = sourceTableArn {
            try encodeContainer.encode(sourceTableArn, forKey: .sourceTableArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceBackupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceBackupArn)
        sourceBackupArn = sourceBackupArnDecoded
        let sourceTableArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceTableArn)
        sourceTableArn = sourceTableArnDecoded
        let restoreDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .restoreDateTime)
        restoreDateTime = restoreDateTimeDecoded
        let restoreInProgressDecoded = try containerValues.decode(Bool.self, forKey: .restoreInProgress)
        restoreInProgress = restoreInProgressDecoded
    }
}

extension AwsDynamoDbTableRestoreSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsDynamoDbTableRestoreSummary(restoreDateTime: \(String(describing: restoreDateTime)), restoreInProgress: \(String(describing: restoreInProgress)), sourceBackupArn: \(String(describing: sourceBackupArn)), sourceTableArn: \(String(describing: sourceTableArn)))"}
}

/// <p>Information about the restore for the table.</p>
public struct AwsDynamoDbTableRestoreSummary: Equatable {
    /// <p>Indicates the point in time that the table was restored to.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let restoreDateTime: String?
    /// <p>Whether a restore is currently in progress.</p>
    public let restoreInProgress: Bool
    /// <p>The ARN of the source backup from which the table was restored.</p>
    public let sourceBackupArn: String?
    /// <p>The ARN of the source table for the backup.</p>
    public let sourceTableArn: String?

    public init (
        restoreDateTime: String? = nil,
        restoreInProgress: Bool = false,
        sourceBackupArn: String? = nil,
        sourceTableArn: String? = nil
    )
    {
        self.restoreDateTime = restoreDateTime
        self.restoreInProgress = restoreInProgress
        self.sourceBackupArn = sourceBackupArn
        self.sourceTableArn = sourceTableArn
    }
}

extension AwsDynamoDbTableSseDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inaccessibleEncryptionDateTime = "InaccessibleEncryptionDateTime"
        case kmsMasterKeyArn = "KmsMasterKeyArn"
        case sseType = "SseType"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inaccessibleEncryptionDateTime = inaccessibleEncryptionDateTime {
            try encodeContainer.encode(inaccessibleEncryptionDateTime, forKey: .inaccessibleEncryptionDateTime)
        }
        if let kmsMasterKeyArn = kmsMasterKeyArn {
            try encodeContainer.encode(kmsMasterKeyArn, forKey: .kmsMasterKeyArn)
        }
        if let sseType = sseType {
            try encodeContainer.encode(sseType, forKey: .sseType)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inaccessibleEncryptionDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inaccessibleEncryptionDateTime)
        inaccessibleEncryptionDateTime = inaccessibleEncryptionDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let sseTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sseType)
        sseType = sseTypeDecoded
        let kmsMasterKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsMasterKeyArn)
        kmsMasterKeyArn = kmsMasterKeyArnDecoded
    }
}

extension AwsDynamoDbTableSseDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsDynamoDbTableSseDescription(inaccessibleEncryptionDateTime: \(String(describing: inaccessibleEncryptionDateTime)), kmsMasterKeyArn: \(String(describing: kmsMasterKeyArn)), sseType: \(String(describing: sseType)), status: \(String(describing: status)))"}
}

/// <p>Information about the server-side encryption for the table.</p>
public struct AwsDynamoDbTableSseDescription: Equatable {
    /// <p>If the key is inaccessible, the date and time when DynamoDB detected that the key was
    ///          inaccessible.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let inaccessibleEncryptionDateTime: String?
    /// <p>The ARN of the AWS KMS customer master key (CMK) that is used for the AWS KMS
    ///          encryption.</p>
    public let kmsMasterKeyArn: String?
    /// <p>The type of server-side encryption.</p>
    public let sseType: String?
    /// <p>The status of the server-side encryption.</p>
    public let status: String?

    public init (
        inaccessibleEncryptionDateTime: String? = nil,
        kmsMasterKeyArn: String? = nil,
        sseType: String? = nil,
        status: String? = nil
    )
    {
        self.inaccessibleEncryptionDateTime = inaccessibleEncryptionDateTime
        self.kmsMasterKeyArn = kmsMasterKeyArn
        self.sseType = sseType
        self.status = status
    }
}

extension AwsDynamoDbTableStreamSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case streamEnabled = "StreamEnabled"
        case streamViewType = "StreamViewType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if streamEnabled != false {
            try encodeContainer.encode(streamEnabled, forKey: .streamEnabled)
        }
        if let streamViewType = streamViewType {
            try encodeContainer.encode(streamViewType, forKey: .streamViewType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamEnabledDecoded = try containerValues.decode(Bool.self, forKey: .streamEnabled)
        streamEnabled = streamEnabledDecoded
        let streamViewTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamViewType)
        streamViewType = streamViewTypeDecoded
    }
}

extension AwsDynamoDbTableStreamSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsDynamoDbTableStreamSpecification(streamEnabled: \(String(describing: streamEnabled)), streamViewType: \(String(describing: streamViewType)))"}
}

/// <p>The current DynamoDB Streams configuration for the table.</p>
public struct AwsDynamoDbTableStreamSpecification: Equatable {
    /// <p>Indicates whether DynamoDB Streams is enabled on the table.</p>
    public let streamEnabled: Bool
    /// <p>Determines the information that is written to the table.</p>
    public let streamViewType: String?

    public init (
        streamEnabled: Bool = false,
        streamViewType: String? = nil
    )
    {
        self.streamEnabled = streamEnabled
        self.streamViewType = streamViewType
    }
}

extension AwsEc2EipDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocationId = "AllocationId"
        case associationId = "AssociationId"
        case domain = "Domain"
        case instanceId = "InstanceId"
        case networkBorderGroup = "NetworkBorderGroup"
        case networkInterfaceId = "NetworkInterfaceId"
        case networkInterfaceOwnerId = "NetworkInterfaceOwnerId"
        case privateIpAddress = "PrivateIpAddress"
        case publicIp = "PublicIp"
        case publicIpv4Pool = "PublicIpv4Pool"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocationId = allocationId {
            try encodeContainer.encode(allocationId, forKey: .allocationId)
        }
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let networkBorderGroup = networkBorderGroup {
            try encodeContainer.encode(networkBorderGroup, forKey: .networkBorderGroup)
        }
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let networkInterfaceOwnerId = networkInterfaceOwnerId {
            try encodeContainer.encode(networkInterfaceOwnerId, forKey: .networkInterfaceOwnerId)
        }
        if let privateIpAddress = privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
        if let publicIp = publicIp {
            try encodeContainer.encode(publicIp, forKey: .publicIp)
        }
        if let publicIpv4Pool = publicIpv4Pool {
            try encodeContainer.encode(publicIpv4Pool, forKey: .publicIpv4Pool)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let publicIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicIp)
        publicIp = publicIpDecoded
        let allocationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .allocationId)
        allocationId = allocationIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
        let publicIpv4PoolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicIpv4Pool)
        publicIpv4Pool = publicIpv4PoolDecoded
        let networkBorderGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkBorderGroup)
        networkBorderGroup = networkBorderGroupDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let networkInterfaceOwnerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkInterfaceOwnerId)
        networkInterfaceOwnerId = networkInterfaceOwnerIdDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
    }
}

extension AwsEc2EipDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2EipDetails(allocationId: \(String(describing: allocationId)), associationId: \(String(describing: associationId)), domain: \(String(describing: domain)), instanceId: \(String(describing: instanceId)), networkBorderGroup: \(String(describing: networkBorderGroup)), networkInterfaceId: \(String(describing: networkInterfaceId)), networkInterfaceOwnerId: \(String(describing: networkInterfaceOwnerId)), privateIpAddress: \(String(describing: privateIpAddress)), publicIp: \(String(describing: publicIp)), publicIpv4Pool: \(String(describing: publicIpv4Pool)))"}
}

/// <p>Information about an Elastic IP address.</p>
public struct AwsEc2EipDetails: Equatable {
    /// <p>The identifier that AWS assigns to represent the allocation of the Elastic IP address
    ///          for use with Amazon VPC.</p>
    public let allocationId: String?
    /// <p>The identifier that represents the association of the Elastic IP address with an EC2
    ///          instance.</p>
    public let associationId: String?
    /// <p>The domain in which to allocate the address.</p>
    ///          <p>If the address is for use with EC2 instances in a VPC, then <code>Domain</code> is
    ///             <code>vpc</code>. Otherwise, <code>Domain</code> is <code>standard</code>. </p>
    public let domain: String?
    /// <p>The identifier of the EC2 instance.</p>
    public let instanceId: String?
    /// <p>The name of the location from which the Elastic IP address is advertised.</p>
    public let networkBorderGroup: String?
    /// <p>The identifier of the network interface.</p>
    public let networkInterfaceId: String?
    /// <p>The AWS account ID of the owner of the network interface.</p>
    public let networkInterfaceOwnerId: String?
    /// <p>The private IP address that is associated with the Elastic IP address.</p>
    public let privateIpAddress: String?
    /// <p>A public IP address that is associated with the EC2 instance.</p>
    public let publicIp: String?
    /// <p>The identifier of an IP address pool. This parameter allows Amazon EC2 to select an IP
    ///          address from the address pool.</p>
    public let publicIpv4Pool: String?

    public init (
        allocationId: String? = nil,
        associationId: String? = nil,
        domain: String? = nil,
        instanceId: String? = nil,
        networkBorderGroup: String? = nil,
        networkInterfaceId: String? = nil,
        networkInterfaceOwnerId: String? = nil,
        privateIpAddress: String? = nil,
        publicIp: String? = nil,
        publicIpv4Pool: String? = nil
    )
    {
        self.allocationId = allocationId
        self.associationId = associationId
        self.domain = domain
        self.instanceId = instanceId
        self.networkBorderGroup = networkBorderGroup
        self.networkInterfaceId = networkInterfaceId
        self.networkInterfaceOwnerId = networkInterfaceOwnerId
        self.privateIpAddress = privateIpAddress
        self.publicIp = publicIp
        self.publicIpv4Pool = publicIpv4Pool
    }
}

extension AwsEc2InstanceDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iamInstanceProfileArn = "IamInstanceProfileArn"
        case imageId = "ImageId"
        case ipV4Addresses = "IpV4Addresses"
        case ipV6Addresses = "IpV6Addresses"
        case keyName = "KeyName"
        case launchedAt = "LaunchedAt"
        case subnetId = "SubnetId"
        case type = "Type"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamInstanceProfileArn = iamInstanceProfileArn {
            try encodeContainer.encode(iamInstanceProfileArn, forKey: .iamInstanceProfileArn)
        }
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let ipV4Addresses = ipV4Addresses {
            var ipV4AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipV4Addresses)
            for stringlist0 in ipV4Addresses {
                try ipV4AddressesContainer.encode(stringlist0)
            }
        }
        if let ipV6Addresses = ipV6Addresses {
            var ipV6AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipV6Addresses)
            for stringlist0 in ipV6Addresses {
                try ipV6AddressesContainer.encode(stringlist0)
            }
        }
        if let keyName = keyName {
            try encodeContainer.encode(keyName, forKey: .keyName)
        }
        if let launchedAt = launchedAt {
            try encodeContainer.encode(launchedAt, forKey: .launchedAt)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let ipV4AddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ipV4Addresses)
        var ipV4AddressesDecoded0:[String]? = nil
        if let ipV4AddressesContainer = ipV4AddressesContainer {
            ipV4AddressesDecoded0 = [String]()
            for string0 in ipV4AddressesContainer {
                if let string0 = string0 {
                    ipV4AddressesDecoded0?.append(string0)
                }
            }
        }
        ipV4Addresses = ipV4AddressesDecoded0
        let ipV6AddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ipV6Addresses)
        var ipV6AddressesDecoded0:[String]? = nil
        if let ipV6AddressesContainer = ipV6AddressesContainer {
            ipV6AddressesDecoded0 = [String]()
            for string0 in ipV6AddressesContainer {
                if let string0 = string0 {
                    ipV6AddressesDecoded0?.append(string0)
                }
            }
        }
        ipV6Addresses = ipV6AddressesDecoded0
        let keyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let iamInstanceProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamInstanceProfileArn)
        iamInstanceProfileArn = iamInstanceProfileArnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let launchedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchedAt)
        launchedAt = launchedAtDecoded
    }
}

extension AwsEc2InstanceDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2InstanceDetails(iamInstanceProfileArn: \(String(describing: iamInstanceProfileArn)), imageId: \(String(describing: imageId)), ipV4Addresses: \(String(describing: ipV4Addresses)), ipV6Addresses: \(String(describing: ipV6Addresses)), keyName: \(String(describing: keyName)), launchedAt: \(String(describing: launchedAt)), subnetId: \(String(describing: subnetId)), type: \(String(describing: type)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>The details of an Amazon EC2 instance.</p>
public struct AwsEc2InstanceDetails: Equatable {
    /// <p>The IAM profile ARN of the instance.</p>
    public let iamInstanceProfileArn: String?
    /// <p>The Amazon Machine Image (AMI) ID of the instance.</p>
    public let imageId: String?
    /// <p>The IPv4 addresses associated with the instance.</p>
    public let ipV4Addresses: [String]?
    /// <p>The IPv6 addresses associated with the instance.</p>
    public let ipV6Addresses: [String]?
    /// <p>The key name associated with the instance.</p>
    public let keyName: String?
    /// <p>Indicates when the instance was launched.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let launchedAt: String?
    /// <p>The identifier of the subnet that the instance was launched in.</p>
    public let subnetId: String?
    /// <p>The instance type of the instance. </p>
    public let type: String?
    /// <p>The identifier of the VPC that the instance was launched in.</p>
    public let vpcId: String?

    public init (
        iamInstanceProfileArn: String? = nil,
        imageId: String? = nil,
        ipV4Addresses: [String]? = nil,
        ipV6Addresses: [String]? = nil,
        keyName: String? = nil,
        launchedAt: String? = nil,
        subnetId: String? = nil,
        type: String? = nil,
        vpcId: String? = nil
    )
    {
        self.iamInstanceProfileArn = iamInstanceProfileArn
        self.imageId = imageId
        self.ipV4Addresses = ipV4Addresses
        self.ipV6Addresses = ipV6Addresses
        self.keyName = keyName
        self.launchedAt = launchedAt
        self.subnetId = subnetId
        self.type = type
        self.vpcId = vpcId
    }
}

extension AwsEc2NetworkAclAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case networkAclAssociationId = "NetworkAclAssociationId"
        case networkAclId = "NetworkAclId"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkAclAssociationId = networkAclAssociationId {
            try encodeContainer.encode(networkAclAssociationId, forKey: .networkAclAssociationId)
        }
        if let networkAclId = networkAclId {
            try encodeContainer.encode(networkAclId, forKey: .networkAclId)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkAclAssociationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkAclAssociationId)
        networkAclAssociationId = networkAclAssociationIdDecoded
        let networkAclIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkAclId)
        networkAclId = networkAclIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
    }
}

extension AwsEc2NetworkAclAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2NetworkAclAssociation(networkAclAssociationId: \(String(describing: networkAclAssociationId)), networkAclId: \(String(describing: networkAclId)), subnetId: \(String(describing: subnetId)))"}
}

/// <p>An association between the network ACL and a subnet.</p>
public struct AwsEc2NetworkAclAssociation: Equatable {
    /// <p>The identifier of the association between the network ACL and the subnet.</p>
    public let networkAclAssociationId: String?
    /// <p>The identifier of the network ACL.</p>
    public let networkAclId: String?
    /// <p>The identifier of the subnet that is associated with the network ACL.</p>
    public let subnetId: String?

    public init (
        networkAclAssociationId: String? = nil,
        networkAclId: String? = nil,
        subnetId: String? = nil
    )
    {
        self.networkAclAssociationId = networkAclAssociationId
        self.networkAclId = networkAclId
        self.subnetId = subnetId
    }
}

extension AwsEc2NetworkAclDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associations = "Associations"
        case entries = "Entries"
        case isDefault = "IsDefault"
        case networkAclId = "NetworkAclId"
        case ownerId = "OwnerId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associations = associations {
            var associationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associations)
            for awsec2networkaclassociationlist0 in associations {
                try associationsContainer.encode(awsec2networkaclassociationlist0)
            }
        }
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for awsec2networkaclentrylist0 in entries {
                try entriesContainer.encode(awsec2networkaclentrylist0)
            }
        }
        if isDefault != false {
            try encodeContainer.encode(isDefault, forKey: .isDefault)
        }
        if let networkAclId = networkAclId {
            try encodeContainer.encode(networkAclId, forKey: .networkAclId)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isDefaultDecoded = try containerValues.decode(Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let networkAclIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkAclId)
        networkAclId = networkAclIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let associationsContainer = try containerValues.decodeIfPresent([AwsEc2NetworkAclAssociation?].self, forKey: .associations)
        var associationsDecoded0:[AwsEc2NetworkAclAssociation]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [AwsEc2NetworkAclAssociation]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
        let entriesContainer = try containerValues.decodeIfPresent([AwsEc2NetworkAclEntry?].self, forKey: .entries)
        var entriesDecoded0:[AwsEc2NetworkAclEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [AwsEc2NetworkAclEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension AwsEc2NetworkAclDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2NetworkAclDetails(associations: \(String(describing: associations)), entries: \(String(describing: entries)), isDefault: \(String(describing: isDefault)), networkAclId: \(String(describing: networkAclId)), ownerId: \(String(describing: ownerId)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Contains details about an EC2 network access control list (ACL).</p>
public struct AwsEc2NetworkAclDetails: Equatable {
    /// <p>Associations between the network ACL and subnets.</p>
    public let associations: [AwsEc2NetworkAclAssociation]?
    /// <p>The set of rules in the network ACL.</p>
    public let entries: [AwsEc2NetworkAclEntry]?
    /// <p>Whether this is the default network ACL for the VPC.</p>
    public let isDefault: Bool
    /// <p>The identifier of the network ACL.</p>
    public let networkAclId: String?
    /// <p>The identifier of the AWS account that owns the network ACL.</p>
    public let ownerId: String?
    /// <p>The identifier of the VPC for the network ACL.</p>
    public let vpcId: String?

    public init (
        associations: [AwsEc2NetworkAclAssociation]? = nil,
        entries: [AwsEc2NetworkAclEntry]? = nil,
        isDefault: Bool = false,
        networkAclId: String? = nil,
        ownerId: String? = nil,
        vpcId: String? = nil
    )
    {
        self.associations = associations
        self.entries = entries
        self.isDefault = isDefault
        self.networkAclId = networkAclId
        self.ownerId = ownerId
        self.vpcId = vpcId
    }
}

extension AwsEc2NetworkAclEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cidrBlock = "CidrBlock"
        case egress = "Egress"
        case icmpTypeCode = "IcmpTypeCode"
        case ipv6CidrBlock = "Ipv6CidrBlock"
        case portRange = "PortRange"
        case `protocol` = "Protocol"
        case ruleAction = "RuleAction"
        case ruleNumber = "RuleNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrBlock = cidrBlock {
            try encodeContainer.encode(cidrBlock, forKey: .cidrBlock)
        }
        if egress != false {
            try encodeContainer.encode(egress, forKey: .egress)
        }
        if let icmpTypeCode = icmpTypeCode {
            try encodeContainer.encode(icmpTypeCode, forKey: .icmpTypeCode)
        }
        if let ipv6CidrBlock = ipv6CidrBlock {
            try encodeContainer.encode(ipv6CidrBlock, forKey: .ipv6CidrBlock)
        }
        if let portRange = portRange {
            try encodeContainer.encode(portRange, forKey: .portRange)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
        if let ruleAction = ruleAction {
            try encodeContainer.encode(ruleAction, forKey: .ruleAction)
        }
        if ruleNumber != 0 {
            try encodeContainer.encode(ruleNumber, forKey: .ruleNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrBlockDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cidrBlock)
        cidrBlock = cidrBlockDecoded
        let egressDecoded = try containerValues.decode(Bool.self, forKey: .egress)
        egress = egressDecoded
        let icmpTypeCodeDecoded = try containerValues.decodeIfPresent(IcmpTypeCode.self, forKey: .icmpTypeCode)
        icmpTypeCode = icmpTypeCodeDecoded
        let ipv6CidrBlockDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipv6CidrBlock)
        ipv6CidrBlock = ipv6CidrBlockDecoded
        let portRangeDecoded = try containerValues.decodeIfPresent(PortRangeFromTo.self, forKey: .portRange)
        portRange = portRangeDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let ruleActionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleAction)
        ruleAction = ruleActionDecoded
        let ruleNumberDecoded = try containerValues.decode(Int.self, forKey: .ruleNumber)
        ruleNumber = ruleNumberDecoded
    }
}

extension AwsEc2NetworkAclEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2NetworkAclEntry(cidrBlock: \(String(describing: cidrBlock)), egress: \(String(describing: egress)), icmpTypeCode: \(String(describing: icmpTypeCode)), ipv6CidrBlock: \(String(describing: ipv6CidrBlock)), portRange: \(String(describing: portRange)), protocol: \(String(describing: `protocol`)), ruleAction: \(String(describing: ruleAction)), ruleNumber: \(String(describing: ruleNumber)))"}
}

/// <p>A rule for the network ACL. Each rule allows or denies access based on the IP address, traffic direction, port, and protocol.</p>
public struct AwsEc2NetworkAclEntry: Equatable {
    /// <p>The protocol that the rule applies to. To deny or allow access to all protocols, use the value -1.</p>
    public let `protocol`: String?
    /// <p>The IPV4 network range for which to deny or allow access.</p>
    public let cidrBlock: String?
    /// <p>Whether the rule is an egress rule. An egress rule is a rule that applies to traffic that leaves the subnet.</p>
    public let egress: Bool
    /// <p>The Internet Control Message Protocol (ICMP) type and code for which to deny or allow access.</p>
    public let icmpTypeCode: IcmpTypeCode?
    /// <p>The IPV6 network range for which to deny or allow access.</p>
    public let ipv6CidrBlock: String?
    /// <p>For TCP or UDP protocols, the range of ports that the rule applies to.</p>
    public let portRange: PortRangeFromTo?
    /// <p>Whether the rule is used to allow access or deny access.</p>
    public let ruleAction: String?
    /// <p>The rule number. The rules are processed in order by their number.</p>
    public let ruleNumber: Int

    public init (
        `protocol`: String? = nil,
        cidrBlock: String? = nil,
        egress: Bool = false,
        icmpTypeCode: IcmpTypeCode? = nil,
        ipv6CidrBlock: String? = nil,
        portRange: PortRangeFromTo? = nil,
        ruleAction: String? = nil,
        ruleNumber: Int = 0
    )
    {
        self.`protocol` = `protocol`
        self.cidrBlock = cidrBlock
        self.egress = egress
        self.icmpTypeCode = icmpTypeCode
        self.ipv6CidrBlock = ipv6CidrBlock
        self.portRange = portRange
        self.ruleAction = ruleAction
        self.ruleNumber = ruleNumber
    }
}

extension AwsEc2NetworkInterfaceAttachment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachTime = "AttachTime"
        case attachmentId = "AttachmentId"
        case deleteOnTermination = "DeleteOnTermination"
        case deviceIndex = "DeviceIndex"
        case instanceId = "InstanceId"
        case instanceOwnerId = "InstanceOwnerId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachTime = attachTime {
            try encodeContainer.encode(attachTime, forKey: .attachTime)
        }
        if let attachmentId = attachmentId {
            try encodeContainer.encode(attachmentId, forKey: .attachmentId)
        }
        if deleteOnTermination != false {
            try encodeContainer.encode(deleteOnTermination, forKey: .deleteOnTermination)
        }
        if deviceIndex != 0 {
            try encodeContainer.encode(deviceIndex, forKey: .deviceIndex)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceOwnerId = instanceOwnerId {
            try encodeContainer.encode(instanceOwnerId, forKey: .instanceOwnerId)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachTime)
        attachTime = attachTimeDecoded
        let attachmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
        let deleteOnTerminationDecoded = try containerValues.decode(Bool.self, forKey: .deleteOnTermination)
        deleteOnTermination = deleteOnTerminationDecoded
        let deviceIndexDecoded = try containerValues.decode(Int.self, forKey: .deviceIndex)
        deviceIndex = deviceIndexDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let instanceOwnerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceOwnerId)
        instanceOwnerId = instanceOwnerIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AwsEc2NetworkInterfaceAttachment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2NetworkInterfaceAttachment(attachTime: \(String(describing: attachTime)), attachmentId: \(String(describing: attachmentId)), deleteOnTermination: \(String(describing: deleteOnTermination)), deviceIndex: \(String(describing: deviceIndex)), instanceId: \(String(describing: instanceId)), instanceOwnerId: \(String(describing: instanceOwnerId)), status: \(String(describing: status)))"}
}

/// <p>Information about the network interface attachment.</p>
public struct AwsEc2NetworkInterfaceAttachment: Equatable {
    /// <p>Indicates when the attachment initiated.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let attachTime: String?
    /// <p>The identifier of the network interface attachment</p>
    public let attachmentId: String?
    /// <p>Indicates whether the network interface is deleted when the instance is
    ///          terminated.</p>
    public let deleteOnTermination: Bool
    /// <p>The device index of the network interface attachment on the instance.</p>
    public let deviceIndex: Int
    /// <p>The ID of the instance.</p>
    public let instanceId: String?
    /// <p>The AWS account ID of the owner of the instance.</p>
    public let instanceOwnerId: String?
    /// <p>The attachment state.</p>
    ///          <p>Valid values: <code>attaching</code> | <code>attached</code> | <code>detaching</code> |
    ///             <code>detached</code>
    ///          </p>
    public let status: String?

    public init (
        attachTime: String? = nil,
        attachmentId: String? = nil,
        deleteOnTermination: Bool = false,
        deviceIndex: Int = 0,
        instanceId: String? = nil,
        instanceOwnerId: String? = nil,
        status: String? = nil
    )
    {
        self.attachTime = attachTime
        self.attachmentId = attachmentId
        self.deleteOnTermination = deleteOnTermination
        self.deviceIndex = deviceIndex
        self.instanceId = instanceId
        self.instanceOwnerId = instanceOwnerId
        self.status = status
    }
}

extension AwsEc2NetworkInterfaceDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachment = "Attachment"
        case ipV6Addresses = "IpV6Addresses"
        case networkInterfaceId = "NetworkInterfaceId"
        case privateIpAddresses = "PrivateIpAddresses"
        case publicDnsName = "PublicDnsName"
        case publicIp = "PublicIp"
        case securityGroups = "SecurityGroups"
        case sourceDestCheck = "SourceDestCheck"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachment = attachment {
            try encodeContainer.encode(attachment, forKey: .attachment)
        }
        if let ipV6Addresses = ipV6Addresses {
            var ipV6AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipV6Addresses)
            for awsec2networkinterfaceipv6addresslist0 in ipV6Addresses {
                try ipV6AddressesContainer.encode(awsec2networkinterfaceipv6addresslist0)
            }
        }
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let privateIpAddresses = privateIpAddresses {
            var privateIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .privateIpAddresses)
            for awsec2networkinterfaceprivateipaddresslist0 in privateIpAddresses {
                try privateIpAddressesContainer.encode(awsec2networkinterfaceprivateipaddresslist0)
            }
        }
        if let publicDnsName = publicDnsName {
            try encodeContainer.encode(publicDnsName, forKey: .publicDnsName)
        }
        if let publicIp = publicIp {
            try encodeContainer.encode(publicIp, forKey: .publicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for awsec2networkinterfacesecuritygrouplist0 in securityGroups {
                try securityGroupsContainer.encode(awsec2networkinterfacesecuritygrouplist0)
            }
        }
        if sourceDestCheck != false {
            try encodeContainer.encode(sourceDestCheck, forKey: .sourceDestCheck)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentDecoded = try containerValues.decodeIfPresent(AwsEc2NetworkInterfaceAttachment.self, forKey: .attachment)
        attachment = attachmentDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([AwsEc2NetworkInterfaceSecurityGroup?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[AwsEc2NetworkInterfaceSecurityGroup]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [AwsEc2NetworkInterfaceSecurityGroup]()
            for structure0 in securityGroupsContainer {
                if let structure0 = structure0 {
                    securityGroupsDecoded0?.append(structure0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let sourceDestCheckDecoded = try containerValues.decode(Bool.self, forKey: .sourceDestCheck)
        sourceDestCheck = sourceDestCheckDecoded
        let ipV6AddressesContainer = try containerValues.decodeIfPresent([AwsEc2NetworkInterfaceIpV6AddressDetail?].self, forKey: .ipV6Addresses)
        var ipV6AddressesDecoded0:[AwsEc2NetworkInterfaceIpV6AddressDetail]? = nil
        if let ipV6AddressesContainer = ipV6AddressesContainer {
            ipV6AddressesDecoded0 = [AwsEc2NetworkInterfaceIpV6AddressDetail]()
            for structure0 in ipV6AddressesContainer {
                if let structure0 = structure0 {
                    ipV6AddressesDecoded0?.append(structure0)
                }
            }
        }
        ipV6Addresses = ipV6AddressesDecoded0
        let privateIpAddressesContainer = try containerValues.decodeIfPresent([AwsEc2NetworkInterfacePrivateIpAddressDetail?].self, forKey: .privateIpAddresses)
        var privateIpAddressesDecoded0:[AwsEc2NetworkInterfacePrivateIpAddressDetail]? = nil
        if let privateIpAddressesContainer = privateIpAddressesContainer {
            privateIpAddressesDecoded0 = [AwsEc2NetworkInterfacePrivateIpAddressDetail]()
            for structure0 in privateIpAddressesContainer {
                if let structure0 = structure0 {
                    privateIpAddressesDecoded0?.append(structure0)
                }
            }
        }
        privateIpAddresses = privateIpAddressesDecoded0
        let publicDnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicDnsName)
        publicDnsName = publicDnsNameDecoded
        let publicIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicIp)
        publicIp = publicIpDecoded
    }
}

extension AwsEc2NetworkInterfaceDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2NetworkInterfaceDetails(attachment: \(String(describing: attachment)), ipV6Addresses: \(String(describing: ipV6Addresses)), networkInterfaceId: \(String(describing: networkInterfaceId)), privateIpAddresses: \(String(describing: privateIpAddresses)), publicDnsName: \(String(describing: publicDnsName)), publicIp: \(String(describing: publicIp)), securityGroups: \(String(describing: securityGroups)), sourceDestCheck: \(String(describing: sourceDestCheck)))"}
}

/// <p>Details about the network interface</p>
public struct AwsEc2NetworkInterfaceDetails: Equatable {
    /// <p>The network interface attachment.</p>
    public let attachment: AwsEc2NetworkInterfaceAttachment?
    /// <p>The IPv6 addresses associated with the network interface.</p>
    public let ipV6Addresses: [AwsEc2NetworkInterfaceIpV6AddressDetail]?
    /// <p>The ID of the network interface.</p>
    public let networkInterfaceId: String?
    /// <p>The private IPv4 addresses associated with the network interface.</p>
    public let privateIpAddresses: [AwsEc2NetworkInterfacePrivateIpAddressDetail]?
    /// <p>The public DNS name of the network interface.</p>
    public let publicDnsName: String?
    /// <p>The address of the Elastic IP address bound to the network interface.</p>
    public let publicIp: String?
    /// <p>Security groups for the network interface.</p>
    public let securityGroups: [AwsEc2NetworkInterfaceSecurityGroup]?
    /// <p>Indicates whether traffic to or from the instance is validated.</p>
    public let sourceDestCheck: Bool

    public init (
        attachment: AwsEc2NetworkInterfaceAttachment? = nil,
        ipV6Addresses: [AwsEc2NetworkInterfaceIpV6AddressDetail]? = nil,
        networkInterfaceId: String? = nil,
        privateIpAddresses: [AwsEc2NetworkInterfacePrivateIpAddressDetail]? = nil,
        publicDnsName: String? = nil,
        publicIp: String? = nil,
        securityGroups: [AwsEc2NetworkInterfaceSecurityGroup]? = nil,
        sourceDestCheck: Bool = false
    )
    {
        self.attachment = attachment
        self.ipV6Addresses = ipV6Addresses
        self.networkInterfaceId = networkInterfaceId
        self.privateIpAddresses = privateIpAddresses
        self.publicDnsName = publicDnsName
        self.publicIp = publicIp
        self.securityGroups = securityGroups
        self.sourceDestCheck = sourceDestCheck
    }
}

extension AwsEc2NetworkInterfaceIpV6AddressDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ipV6Address = "IpV6Address"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipV6Address = ipV6Address {
            try encodeContainer.encode(ipV6Address, forKey: .ipV6Address)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipV6AddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipV6Address)
        ipV6Address = ipV6AddressDecoded
    }
}

extension AwsEc2NetworkInterfaceIpV6AddressDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2NetworkInterfaceIpV6AddressDetail(ipV6Address: \(String(describing: ipV6Address)))"}
}

/// <p>Provides information about an IPV6 address that is associated with the network
///          interface.</p>
public struct AwsEc2NetworkInterfaceIpV6AddressDetail: Equatable {
    /// <p>The IPV6 address.</p>
    public let ipV6Address: String?

    public init (
        ipV6Address: String? = nil
    )
    {
        self.ipV6Address = ipV6Address
    }
}

extension AwsEc2NetworkInterfacePrivateIpAddressDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case privateDnsName = "PrivateDnsName"
        case privateIpAddress = "PrivateIpAddress"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let privateDnsName = privateDnsName {
            try encodeContainer.encode(privateDnsName, forKey: .privateDnsName)
        }
        if let privateIpAddress = privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
    }
}

extension AwsEc2NetworkInterfacePrivateIpAddressDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2NetworkInterfacePrivateIpAddressDetail(privateDnsName: \(String(describing: privateDnsName)), privateIpAddress: \(String(describing: privateIpAddress)))"}
}

/// <p>Provides information about a private IPv4 address that is with the network
///          interface.</p>
public struct AwsEc2NetworkInterfacePrivateIpAddressDetail: Equatable {
    /// <p>The private DNS name for the IP address.</p>
    public let privateDnsName: String?
    /// <p>The IP address.</p>
    public let privateIpAddress: String?

    public init (
        privateDnsName: String? = nil,
        privateIpAddress: String? = nil
    )
    {
        self.privateDnsName = privateDnsName
        self.privateIpAddress = privateIpAddress
    }
}

extension AwsEc2NetworkInterfaceSecurityGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension AwsEc2NetworkInterfaceSecurityGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2NetworkInterfaceSecurityGroup(groupId: \(String(describing: groupId)), groupName: \(String(describing: groupName)))"}
}

/// <p>A security group associated with the network interface.</p>
public struct AwsEc2NetworkInterfaceSecurityGroup: Equatable {
    /// <p>The ID of the security group.</p>
    public let groupId: String?
    /// <p>The name of the security group.</p>
    public let groupName: String?

    public init (
        groupId: String? = nil,
        groupName: String? = nil
    )
    {
        self.groupId = groupId
        self.groupName = groupName
    }
}

extension AwsEc2SecurityGroupDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
        case groupName = "GroupName"
        case ipPermissions = "IpPermissions"
        case ipPermissionsEgress = "IpPermissionsEgress"
        case ownerId = "OwnerId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let ipPermissions = ipPermissions {
            var ipPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipPermissions)
            for awsec2securitygroupippermissionlist0 in ipPermissions {
                try ipPermissionsContainer.encode(awsec2securitygroupippermissionlist0)
            }
        }
        if let ipPermissionsEgress = ipPermissionsEgress {
            var ipPermissionsEgressContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipPermissionsEgress)
            for awsec2securitygroupippermissionlist0 in ipPermissionsEgress {
                try ipPermissionsEgressContainer.encode(awsec2securitygroupippermissionlist0)
            }
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let ipPermissionsContainer = try containerValues.decodeIfPresent([AwsEc2SecurityGroupIpPermission?].self, forKey: .ipPermissions)
        var ipPermissionsDecoded0:[AwsEc2SecurityGroupIpPermission]? = nil
        if let ipPermissionsContainer = ipPermissionsContainer {
            ipPermissionsDecoded0 = [AwsEc2SecurityGroupIpPermission]()
            for structure0 in ipPermissionsContainer {
                if let structure0 = structure0 {
                    ipPermissionsDecoded0?.append(structure0)
                }
            }
        }
        ipPermissions = ipPermissionsDecoded0
        let ipPermissionsEgressContainer = try containerValues.decodeIfPresent([AwsEc2SecurityGroupIpPermission?].self, forKey: .ipPermissionsEgress)
        var ipPermissionsEgressDecoded0:[AwsEc2SecurityGroupIpPermission]? = nil
        if let ipPermissionsEgressContainer = ipPermissionsEgressContainer {
            ipPermissionsEgressDecoded0 = [AwsEc2SecurityGroupIpPermission]()
            for structure0 in ipPermissionsEgressContainer {
                if let structure0 = structure0 {
                    ipPermissionsEgressDecoded0?.append(structure0)
                }
            }
        }
        ipPermissionsEgress = ipPermissionsEgressDecoded0
    }
}

extension AwsEc2SecurityGroupDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2SecurityGroupDetails(groupId: \(String(describing: groupId)), groupName: \(String(describing: groupName)), ipPermissions: \(String(describing: ipPermissions)), ipPermissionsEgress: \(String(describing: ipPermissionsEgress)), ownerId: \(String(describing: ownerId)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Details about an EC2 security group.</p>
public struct AwsEc2SecurityGroupDetails: Equatable {
    /// <p>The ID of the security group.</p>
    public let groupId: String?
    /// <p>The name of the security group.</p>
    public let groupName: String?
    /// <p>The inbound rules associated with the security group.</p>
    public let ipPermissions: [AwsEc2SecurityGroupIpPermission]?
    /// <p>[VPC only] The outbound rules associated with the security group.</p>
    public let ipPermissionsEgress: [AwsEc2SecurityGroupIpPermission]?
    /// <p>The AWS account ID of the owner of the security group.</p>
    public let ownerId: String?
    /// <p>[VPC only] The ID of the VPC for the security group.</p>
    public let vpcId: String?

    public init (
        groupId: String? = nil,
        groupName: String? = nil,
        ipPermissions: [AwsEc2SecurityGroupIpPermission]? = nil,
        ipPermissionsEgress: [AwsEc2SecurityGroupIpPermission]? = nil,
        ownerId: String? = nil,
        vpcId: String? = nil
    )
    {
        self.groupId = groupId
        self.groupName = groupName
        self.ipPermissions = ipPermissions
        self.ipPermissionsEgress = ipPermissionsEgress
        self.ownerId = ownerId
        self.vpcId = vpcId
    }
}

extension AwsEc2SecurityGroupIpPermission: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fromPort = "FromPort"
        case ipProtocol = "IpProtocol"
        case ipRanges = "IpRanges"
        case ipv6Ranges = "Ipv6Ranges"
        case prefixListIds = "PrefixListIds"
        case toPort = "ToPort"
        case userIdGroupPairs = "UserIdGroupPairs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if fromPort != 0 {
            try encodeContainer.encode(fromPort, forKey: .fromPort)
        }
        if let ipProtocol = ipProtocol {
            try encodeContainer.encode(ipProtocol, forKey: .ipProtocol)
        }
        if let ipRanges = ipRanges {
            var ipRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipRanges)
            for awsec2securitygroupiprangelist0 in ipRanges {
                try ipRangesContainer.encode(awsec2securitygroupiprangelist0)
            }
        }
        if let ipv6Ranges = ipv6Ranges {
            var ipv6RangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipv6Ranges)
            for awsec2securitygroupipv6rangelist0 in ipv6Ranges {
                try ipv6RangesContainer.encode(awsec2securitygroupipv6rangelist0)
            }
        }
        if let prefixListIds = prefixListIds {
            var prefixListIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .prefixListIds)
            for awsec2securitygroupprefixlistidlist0 in prefixListIds {
                try prefixListIdsContainer.encode(awsec2securitygroupprefixlistidlist0)
            }
        }
        if toPort != 0 {
            try encodeContainer.encode(toPort, forKey: .toPort)
        }
        if let userIdGroupPairs = userIdGroupPairs {
            var userIdGroupPairsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIdGroupPairs)
            for awsec2securitygroupuseridgrouppairlist0 in userIdGroupPairs {
                try userIdGroupPairsContainer.encode(awsec2securitygroupuseridgrouppairlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipProtocolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipProtocol)
        ipProtocol = ipProtocolDecoded
        let fromPortDecoded = try containerValues.decode(Int.self, forKey: .fromPort)
        fromPort = fromPortDecoded
        let toPortDecoded = try containerValues.decode(Int.self, forKey: .toPort)
        toPort = toPortDecoded
        let userIdGroupPairsContainer = try containerValues.decodeIfPresent([AwsEc2SecurityGroupUserIdGroupPair?].self, forKey: .userIdGroupPairs)
        var userIdGroupPairsDecoded0:[AwsEc2SecurityGroupUserIdGroupPair]? = nil
        if let userIdGroupPairsContainer = userIdGroupPairsContainer {
            userIdGroupPairsDecoded0 = [AwsEc2SecurityGroupUserIdGroupPair]()
            for structure0 in userIdGroupPairsContainer {
                if let structure0 = structure0 {
                    userIdGroupPairsDecoded0?.append(structure0)
                }
            }
        }
        userIdGroupPairs = userIdGroupPairsDecoded0
        let ipRangesContainer = try containerValues.decodeIfPresent([AwsEc2SecurityGroupIpRange?].self, forKey: .ipRanges)
        var ipRangesDecoded0:[AwsEc2SecurityGroupIpRange]? = nil
        if let ipRangesContainer = ipRangesContainer {
            ipRangesDecoded0 = [AwsEc2SecurityGroupIpRange]()
            for structure0 in ipRangesContainer {
                if let structure0 = structure0 {
                    ipRangesDecoded0?.append(structure0)
                }
            }
        }
        ipRanges = ipRangesDecoded0
        let ipv6RangesContainer = try containerValues.decodeIfPresent([AwsEc2SecurityGroupIpv6Range?].self, forKey: .ipv6Ranges)
        var ipv6RangesDecoded0:[AwsEc2SecurityGroupIpv6Range]? = nil
        if let ipv6RangesContainer = ipv6RangesContainer {
            ipv6RangesDecoded0 = [AwsEc2SecurityGroupIpv6Range]()
            for structure0 in ipv6RangesContainer {
                if let structure0 = structure0 {
                    ipv6RangesDecoded0?.append(structure0)
                }
            }
        }
        ipv6Ranges = ipv6RangesDecoded0
        let prefixListIdsContainer = try containerValues.decodeIfPresent([AwsEc2SecurityGroupPrefixListId?].self, forKey: .prefixListIds)
        var prefixListIdsDecoded0:[AwsEc2SecurityGroupPrefixListId]? = nil
        if let prefixListIdsContainer = prefixListIdsContainer {
            prefixListIdsDecoded0 = [AwsEc2SecurityGroupPrefixListId]()
            for structure0 in prefixListIdsContainer {
                if let structure0 = structure0 {
                    prefixListIdsDecoded0?.append(structure0)
                }
            }
        }
        prefixListIds = prefixListIdsDecoded0
    }
}

extension AwsEc2SecurityGroupIpPermission: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2SecurityGroupIpPermission(fromPort: \(String(describing: fromPort)), ipProtocol: \(String(describing: ipProtocol)), ipRanges: \(String(describing: ipRanges)), ipv6Ranges: \(String(describing: ipv6Ranges)), prefixListIds: \(String(describing: prefixListIds)), toPort: \(String(describing: toPort)), userIdGroupPairs: \(String(describing: userIdGroupPairs)))"}
}

/// <p>An IP permission for an EC2 security group.</p>
public struct AwsEc2SecurityGroupIpPermission: Equatable {
    /// <p>The start of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type
    ///          number.</p>
    ///          <p>A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you
    ///          must specify all codes. </p>
    public let fromPort: Int
    /// <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>,
    ///             <code>icmpv6</code>) or number.</p>
    ///          <p>[VPC only] Use <code>-1</code> to specify all protocols.</p>
    ///          <p>When authorizing security group rules, specifying -1 or a protocol number other than
    ///             <code>tcp</code>, <code>udp</code>, <code>icmp</code>, or <code>icmpv6</code> allows
    ///          traffic on all ports, regardless of any port range you specify.</p>
    ///          <p>For <code>tcp</code>, <code>udp</code>, and <code>icmp</code>, you must specify a port
    ///          range.</p>
    ///          <p>For <code>icmpv6</code>, the port range is optional. If you omit the port range, traffic
    ///          for all types and codes is allowed. </p>
    public let ipProtocol: String?
    /// <p>The IPv4 ranges.</p>
    public let ipRanges: [AwsEc2SecurityGroupIpRange]?
    /// <p>The IPv6 ranges.</p>
    public let ipv6Ranges: [AwsEc2SecurityGroupIpv6Range]?
    /// <p>[VPC only] The prefix list IDs for an AWS service. With outbound rules, this is the AWS
    ///          service to access through a VPC endpoint from instances associated with the security
    ///          group.</p>
    public let prefixListIds: [AwsEc2SecurityGroupPrefixListId]?
    /// <p>The end of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code.</p>
    ///          <p>A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you
    ///          must specify all codes.</p>
    public let toPort: Int
    /// <p>The security group and AWS account ID pairs.</p>
    public let userIdGroupPairs: [AwsEc2SecurityGroupUserIdGroupPair]?

    public init (
        fromPort: Int = 0,
        ipProtocol: String? = nil,
        ipRanges: [AwsEc2SecurityGroupIpRange]? = nil,
        ipv6Ranges: [AwsEc2SecurityGroupIpv6Range]? = nil,
        prefixListIds: [AwsEc2SecurityGroupPrefixListId]? = nil,
        toPort: Int = 0,
        userIdGroupPairs: [AwsEc2SecurityGroupUserIdGroupPair]? = nil
    )
    {
        self.fromPort = fromPort
        self.ipProtocol = ipProtocol
        self.ipRanges = ipRanges
        self.ipv6Ranges = ipv6Ranges
        self.prefixListIds = prefixListIds
        self.toPort = toPort
        self.userIdGroupPairs = userIdGroupPairs
    }
}

extension AwsEc2SecurityGroupIpRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cidrIp = "CidrIp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrIp = cidrIp {
            try encodeContainer.encode(cidrIp, forKey: .cidrIp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cidrIp)
        cidrIp = cidrIpDecoded
    }
}

extension AwsEc2SecurityGroupIpRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2SecurityGroupIpRange(cidrIp: \(String(describing: cidrIp)))"}
}

/// <p>A range of IPv4 addresses.</p>
public struct AwsEc2SecurityGroupIpRange: Equatable {
    /// <p>The IPv4 CIDR range. You can specify either a CIDR range or a source security group, but
    ///          not both. To specify a single IPv4 address, use the /32 prefix length.</p>
    public let cidrIp: String?

    public init (
        cidrIp: String? = nil
    )
    {
        self.cidrIp = cidrIp
    }
}

extension AwsEc2SecurityGroupIpv6Range: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cidrIpv6 = "CidrIpv6"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrIpv6 = cidrIpv6 {
            try encodeContainer.encode(cidrIpv6, forKey: .cidrIpv6)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrIpv6Decoded = try containerValues.decodeIfPresent(String.self, forKey: .cidrIpv6)
        cidrIpv6 = cidrIpv6Decoded
    }
}

extension AwsEc2SecurityGroupIpv6Range: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2SecurityGroupIpv6Range(cidrIpv6: \(String(describing: cidrIpv6)))"}
}

/// <p>A range of IPv6 addresses.</p>
public struct AwsEc2SecurityGroupIpv6Range: Equatable {
    /// <p>The IPv6 CIDR range. You can specify either a CIDR range or a source security group, but
    ///          not both. To specify a single IPv6 address, use the /128 prefix length.</p>
    public let cidrIpv6: String?

    public init (
        cidrIpv6: String? = nil
    )
    {
        self.cidrIpv6 = cidrIpv6
    }
}

extension AwsEc2SecurityGroupPrefixListId: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case prefixListId = "PrefixListId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let prefixListId = prefixListId {
            try encodeContainer.encode(prefixListId, forKey: .prefixListId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixListIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefixListId)
        prefixListId = prefixListIdDecoded
    }
}

extension AwsEc2SecurityGroupPrefixListId: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2SecurityGroupPrefixListId(prefixListId: \(String(describing: prefixListId)))"}
}

/// <p>A prefix list ID.</p>
public struct AwsEc2SecurityGroupPrefixListId: Equatable {
    /// <p>The ID of the prefix.</p>
    public let prefixListId: String?

    public init (
        prefixListId: String? = nil
    )
    {
        self.prefixListId = prefixListId
    }
}

extension AwsEc2SecurityGroupUserIdGroupPair: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
        case groupName = "GroupName"
        case peeringStatus = "PeeringStatus"
        case userId = "UserId"
        case vpcId = "VpcId"
        case vpcPeeringConnectionId = "VpcPeeringConnectionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let peeringStatus = peeringStatus {
            try encodeContainer.encode(peeringStatus, forKey: .peeringStatus)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
        if let vpcPeeringConnectionId = vpcPeeringConnectionId {
            try encodeContainer.encode(vpcPeeringConnectionId, forKey: .vpcPeeringConnectionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let peeringStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .peeringStatus)
        peeringStatus = peeringStatusDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let vpcPeeringConnectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcPeeringConnectionId)
        vpcPeeringConnectionId = vpcPeeringConnectionIdDecoded
    }
}

extension AwsEc2SecurityGroupUserIdGroupPair: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2SecurityGroupUserIdGroupPair(groupId: \(String(describing: groupId)), groupName: \(String(describing: groupName)), peeringStatus: \(String(describing: peeringStatus)), userId: \(String(describing: userId)), vpcId: \(String(describing: vpcId)), vpcPeeringConnectionId: \(String(describing: vpcPeeringConnectionId)))"}
}

/// <p>A relationship between a security group and a user.</p>
public struct AwsEc2SecurityGroupUserIdGroupPair: Equatable {
    /// <p>The ID of the security group.</p>
    public let groupId: String?
    /// <p>The name of the security group.</p>
    public let groupName: String?
    /// <p>The status of a VPC peering connection, if applicable.</p>
    public let peeringStatus: String?
    /// <p>The ID of an AWS account.</p>
    ///          <p>For a referenced security group in another VPC, the account ID of the referenced
    ///          security group is returned in the response. If the referenced security group is deleted,
    ///          this value is not returned.</p>
    ///          <p>[EC2-Classic] Required when adding or removing rules that reference a security group in
    ///          another AWS. </p>
    public let userId: String?
    /// <p>The ID of the VPC for the referenced security group, if applicable.</p>
    public let vpcId: String?
    /// <p>The ID of the VPC peering connection, if applicable.</p>
    public let vpcPeeringConnectionId: String?

    public init (
        groupId: String? = nil,
        groupName: String? = nil,
        peeringStatus: String? = nil,
        userId: String? = nil,
        vpcId: String? = nil,
        vpcPeeringConnectionId: String? = nil
    )
    {
        self.groupId = groupId
        self.groupName = groupName
        self.peeringStatus = peeringStatus
        self.userId = userId
        self.vpcId = vpcId
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }
}

extension AwsEc2SubnetDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignIpv6AddressOnCreation = "AssignIpv6AddressOnCreation"
        case availabilityZone = "AvailabilityZone"
        case availabilityZoneId = "AvailabilityZoneId"
        case availableIpAddressCount = "AvailableIpAddressCount"
        case cidrBlock = "CidrBlock"
        case defaultForAz = "DefaultForAz"
        case ipv6CidrBlockAssociationSet = "Ipv6CidrBlockAssociationSet"
        case mapPublicIpOnLaunch = "MapPublicIpOnLaunch"
        case ownerId = "OwnerId"
        case state = "State"
        case subnetArn = "SubnetArn"
        case subnetId = "SubnetId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if assignIpv6AddressOnCreation != false {
            try encodeContainer.encode(assignIpv6AddressOnCreation, forKey: .assignIpv6AddressOnCreation)
        }
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let availabilityZoneId = availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if availableIpAddressCount != 0 {
            try encodeContainer.encode(availableIpAddressCount, forKey: .availableIpAddressCount)
        }
        if let cidrBlock = cidrBlock {
            try encodeContainer.encode(cidrBlock, forKey: .cidrBlock)
        }
        if defaultForAz != false {
            try encodeContainer.encode(defaultForAz, forKey: .defaultForAz)
        }
        if let ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet {
            var ipv6CidrBlockAssociationSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipv6CidrBlockAssociationSet)
            for ipv6cidrblockassociationlist0 in ipv6CidrBlockAssociationSet {
                try ipv6CidrBlockAssociationSetContainer.encode(ipv6cidrblockassociationlist0)
            }
        }
        if mapPublicIpOnLaunch != false {
            try encodeContainer.encode(mapPublicIpOnLaunch, forKey: .mapPublicIpOnLaunch)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let subnetArn = subnetArn {
            try encodeContainer.encode(subnetArn, forKey: .subnetArn)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignIpv6AddressOnCreationDecoded = try containerValues.decode(Bool.self, forKey: .assignIpv6AddressOnCreation)
        assignIpv6AddressOnCreation = assignIpv6AddressOnCreationDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let availableIpAddressCountDecoded = try containerValues.decode(Int.self, forKey: .availableIpAddressCount)
        availableIpAddressCount = availableIpAddressCountDecoded
        let cidrBlockDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cidrBlock)
        cidrBlock = cidrBlockDecoded
        let defaultForAzDecoded = try containerValues.decode(Bool.self, forKey: .defaultForAz)
        defaultForAz = defaultForAzDecoded
        let mapPublicIpOnLaunchDecoded = try containerValues.decode(Bool.self, forKey: .mapPublicIpOnLaunch)
        mapPublicIpOnLaunch = mapPublicIpOnLaunchDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        let subnetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetArn)
        subnetArn = subnetArnDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let ipv6CidrBlockAssociationSetContainer = try containerValues.decodeIfPresent([Ipv6CidrBlockAssociation?].self, forKey: .ipv6CidrBlockAssociationSet)
        var ipv6CidrBlockAssociationSetDecoded0:[Ipv6CidrBlockAssociation]? = nil
        if let ipv6CidrBlockAssociationSetContainer = ipv6CidrBlockAssociationSetContainer {
            ipv6CidrBlockAssociationSetDecoded0 = [Ipv6CidrBlockAssociation]()
            for structure0 in ipv6CidrBlockAssociationSetContainer {
                if let structure0 = structure0 {
                    ipv6CidrBlockAssociationSetDecoded0?.append(structure0)
                }
            }
        }
        ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSetDecoded0
    }
}

extension AwsEc2SubnetDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2SubnetDetails(assignIpv6AddressOnCreation: \(String(describing: assignIpv6AddressOnCreation)), availabilityZone: \(String(describing: availabilityZone)), availabilityZoneId: \(String(describing: availabilityZoneId)), availableIpAddressCount: \(String(describing: availableIpAddressCount)), cidrBlock: \(String(describing: cidrBlock)), defaultForAz: \(String(describing: defaultForAz)), ipv6CidrBlockAssociationSet: \(String(describing: ipv6CidrBlockAssociationSet)), mapPublicIpOnLaunch: \(String(describing: mapPublicIpOnLaunch)), ownerId: \(String(describing: ownerId)), state: \(String(describing: state)), subnetArn: \(String(describing: subnetArn)), subnetId: \(String(describing: subnetId)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Contains information about a subnet in EC2.</p>
public struct AwsEc2SubnetDetails: Equatable {
    /// <p>Whether to assign an IPV6 address to a network interface that is created in this subnet.</p>
    public let assignIpv6AddressOnCreation: Bool
    /// <p>The Availability Zone for the subnet.</p>
    public let availabilityZone: String?
    /// <p>The identifier of the Availability Zone for the subnet.</p>
    public let availabilityZoneId: String?
    /// <p>The number of available IPV4 addresses in the subnet. Does not include addresses for stopped instances.</p>
    public let availableIpAddressCount: Int
    /// <p>The IPV4 CIDR block that is assigned to the subnet.</p>
    public let cidrBlock: String?
    /// <p>Whether this subnet is the default subnet for the Availability Zone.</p>
    public let defaultForAz: Bool
    /// <p>The IPV6 CIDR blocks that are associated with the subnet.</p>
    public let ipv6CidrBlockAssociationSet: [Ipv6CidrBlockAssociation]?
    /// <p>Whether instances in this subnet receive a public IP address.</p>
    public let mapPublicIpOnLaunch: Bool
    /// <p>The identifier of the AWS account that owns the subnet.</p>
    public let ownerId: String?
    /// <p>The current state of the subnet.</p>
    public let state: String?
    /// <p>The ARN of the subnet.</p>
    public let subnetArn: String?
    /// <p>The identifier of the subnet.</p>
    public let subnetId: String?
    /// <p>The identifier of the VPC that contains the subnet.</p>
    public let vpcId: String?

    public init (
        assignIpv6AddressOnCreation: Bool = false,
        availabilityZone: String? = nil,
        availabilityZoneId: String? = nil,
        availableIpAddressCount: Int = 0,
        cidrBlock: String? = nil,
        defaultForAz: Bool = false,
        ipv6CidrBlockAssociationSet: [Ipv6CidrBlockAssociation]? = nil,
        mapPublicIpOnLaunch: Bool = false,
        ownerId: String? = nil,
        state: String? = nil,
        subnetArn: String? = nil,
        subnetId: String? = nil,
        vpcId: String? = nil
    )
    {
        self.assignIpv6AddressOnCreation = assignIpv6AddressOnCreation
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.availableIpAddressCount = availableIpAddressCount
        self.cidrBlock = cidrBlock
        self.defaultForAz = defaultForAz
        self.ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet
        self.mapPublicIpOnLaunch = mapPublicIpOnLaunch
        self.ownerId = ownerId
        self.state = state
        self.subnetArn = subnetArn
        self.subnetId = subnetId
        self.vpcId = vpcId
    }
}

extension AwsEc2VolumeAttachment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachTime = "AttachTime"
        case deleteOnTermination = "DeleteOnTermination"
        case instanceId = "InstanceId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachTime = attachTime {
            try encodeContainer.encode(attachTime, forKey: .attachTime)
        }
        if deleteOnTermination != false {
            try encodeContainer.encode(deleteOnTermination, forKey: .deleteOnTermination)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachTime)
        attachTime = attachTimeDecoded
        let deleteOnTerminationDecoded = try containerValues.decode(Bool.self, forKey: .deleteOnTermination)
        deleteOnTermination = deleteOnTerminationDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AwsEc2VolumeAttachment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2VolumeAttachment(attachTime: \(String(describing: attachTime)), deleteOnTermination: \(String(describing: deleteOnTermination)), instanceId: \(String(describing: instanceId)), status: \(String(describing: status)))"}
}

/// <p>An attachment to an AWS EC2 volume.</p>
public struct AwsEc2VolumeAttachment: Equatable {
    /// <p>The datetime when the attachment initiated.</p>
    public let attachTime: String?
    /// <p>Whether the EBS volume is deleted when the EC2 instance is terminated.</p>
    public let deleteOnTermination: Bool
    /// <p>The identifier of the EC2 instance.</p>
    public let instanceId: String?
    /// <p>The attachment state of the volume.</p>
    public let status: String?

    public init (
        attachTime: String? = nil,
        deleteOnTermination: Bool = false,
        instanceId: String? = nil,
        status: String? = nil
    )
    {
        self.attachTime = attachTime
        self.deleteOnTermination = deleteOnTermination
        self.instanceId = instanceId
        self.status = status
    }
}

extension AwsEc2VolumeDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachments = "Attachments"
        case createTime = "CreateTime"
        case encrypted = "Encrypted"
        case kmsKeyId = "KmsKeyId"
        case size = "Size"
        case snapshotId = "SnapshotId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachments = attachments {
            var attachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachments)
            for awsec2volumeattachmentlist0 in attachments {
                try attachmentsContainer.encode(awsec2volumeattachmentlist0)
            }
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if encrypted != false {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let snapshotId = snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let encryptedDecoded = try containerValues.decode(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let sizeDecoded = try containerValues.decode(Int.self, forKey: .size)
        size = sizeDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let attachmentsContainer = try containerValues.decodeIfPresent([AwsEc2VolumeAttachment?].self, forKey: .attachments)
        var attachmentsDecoded0:[AwsEc2VolumeAttachment]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [AwsEc2VolumeAttachment]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
    }
}

extension AwsEc2VolumeDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2VolumeDetails(attachments: \(String(describing: attachments)), createTime: \(String(describing: createTime)), encrypted: \(String(describing: encrypted)), kmsKeyId: \(String(describing: kmsKeyId)), size: \(String(describing: size)), snapshotId: \(String(describing: snapshotId)), status: \(String(describing: status)))"}
}

/// <p>Details about an EC2 volume.</p>
public struct AwsEc2VolumeDetails: Equatable {
    /// <p>The volume attachments.</p>
    public let attachments: [AwsEc2VolumeAttachment]?
    /// <p>Indicates when the volume was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let createTime: String?
    /// <p>Whether the volume is encrypted.</p>
    public let encrypted: Bool
    /// <p>The ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) that was
    ///          used to protect the volume encryption key for the volume.</p>
    public let kmsKeyId: String?
    /// <p>The size of the volume, in GiBs.</p>
    public let size: Int
    /// <p>The snapshot from which the volume was created.</p>
    public let snapshotId: String?
    /// <p>The volume state.</p>
    public let status: String?

    public init (
        attachments: [AwsEc2VolumeAttachment]? = nil,
        createTime: String? = nil,
        encrypted: Bool = false,
        kmsKeyId: String? = nil,
        size: Int = 0,
        snapshotId: String? = nil,
        status: String? = nil
    )
    {
        self.attachments = attachments
        self.createTime = createTime
        self.encrypted = encrypted
        self.kmsKeyId = kmsKeyId
        self.size = size
        self.snapshotId = snapshotId
        self.status = status
    }
}

extension AwsEc2VpcDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cidrBlockAssociationSet = "CidrBlockAssociationSet"
        case dhcpOptionsId = "DhcpOptionsId"
        case ipv6CidrBlockAssociationSet = "Ipv6CidrBlockAssociationSet"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrBlockAssociationSet = cidrBlockAssociationSet {
            var cidrBlockAssociationSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrBlockAssociationSet)
            for cidrblockassociationlist0 in cidrBlockAssociationSet {
                try cidrBlockAssociationSetContainer.encode(cidrblockassociationlist0)
            }
        }
        if let dhcpOptionsId = dhcpOptionsId {
            try encodeContainer.encode(dhcpOptionsId, forKey: .dhcpOptionsId)
        }
        if let ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet {
            var ipv6CidrBlockAssociationSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipv6CidrBlockAssociationSet)
            for ipv6cidrblockassociationlist0 in ipv6CidrBlockAssociationSet {
                try ipv6CidrBlockAssociationSetContainer.encode(ipv6cidrblockassociationlist0)
            }
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrBlockAssociationSetContainer = try containerValues.decodeIfPresent([CidrBlockAssociation?].self, forKey: .cidrBlockAssociationSet)
        var cidrBlockAssociationSetDecoded0:[CidrBlockAssociation]? = nil
        if let cidrBlockAssociationSetContainer = cidrBlockAssociationSetContainer {
            cidrBlockAssociationSetDecoded0 = [CidrBlockAssociation]()
            for structure0 in cidrBlockAssociationSetContainer {
                if let structure0 = structure0 {
                    cidrBlockAssociationSetDecoded0?.append(structure0)
                }
            }
        }
        cidrBlockAssociationSet = cidrBlockAssociationSetDecoded0
        let ipv6CidrBlockAssociationSetContainer = try containerValues.decodeIfPresent([Ipv6CidrBlockAssociation?].self, forKey: .ipv6CidrBlockAssociationSet)
        var ipv6CidrBlockAssociationSetDecoded0:[Ipv6CidrBlockAssociation]? = nil
        if let ipv6CidrBlockAssociationSetContainer = ipv6CidrBlockAssociationSetContainer {
            ipv6CidrBlockAssociationSetDecoded0 = [Ipv6CidrBlockAssociation]()
            for structure0 in ipv6CidrBlockAssociationSetContainer {
                if let structure0 = structure0 {
                    ipv6CidrBlockAssociationSetDecoded0?.append(structure0)
                }
            }
        }
        ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSetDecoded0
        let dhcpOptionsIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dhcpOptionsId)
        dhcpOptionsId = dhcpOptionsIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
    }
}

extension AwsEc2VpcDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2VpcDetails(cidrBlockAssociationSet: \(String(describing: cidrBlockAssociationSet)), dhcpOptionsId: \(String(describing: dhcpOptionsId)), ipv6CidrBlockAssociationSet: \(String(describing: ipv6CidrBlockAssociationSet)), state: \(String(describing: state)))"}
}

/// <p>Details about an EC2 VPC.</p>
public struct AwsEc2VpcDetails: Equatable {
    /// <p>Information about the IPv4 CIDR blocks associated with the VPC.</p>
    public let cidrBlockAssociationSet: [CidrBlockAssociation]?
    /// <p>The identifier of the set of Dynamic Host Configuration Protocol (DHCP) options that are
    ///          associated with the VPC. If the default options are associated with the VPC, then this is
    ///          default.</p>
    public let dhcpOptionsId: String?
    /// <p>Information about the IPv6 CIDR blocks associated with the VPC.</p>
    public let ipv6CidrBlockAssociationSet: [Ipv6CidrBlockAssociation]?
    /// <p>The current state of the VPC.</p>
    public let state: String?

    public init (
        cidrBlockAssociationSet: [CidrBlockAssociation]? = nil,
        dhcpOptionsId: String? = nil,
        ipv6CidrBlockAssociationSet: [Ipv6CidrBlockAssociation]? = nil,
        state: String? = nil
    )
    {
        self.cidrBlockAssociationSet = cidrBlockAssociationSet
        self.dhcpOptionsId = dhcpOptionsId
        self.ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet
        self.state = state
    }
}

extension AwsElasticBeanstalkEnvironmentDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case cname = "Cname"
        case dateCreated = "DateCreated"
        case dateUpdated = "DateUpdated"
        case description = "Description"
        case endpointUrl = "EndpointUrl"
        case environmentArn = "EnvironmentArn"
        case environmentId = "EnvironmentId"
        case environmentLinks = "EnvironmentLinks"
        case environmentName = "EnvironmentName"
        case optionSettings = "OptionSettings"
        case platformArn = "PlatformArn"
        case solutionStackName = "SolutionStackName"
        case status = "Status"
        case tier = "Tier"
        case versionLabel = "VersionLabel"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let cname = cname {
            try encodeContainer.encode(cname, forKey: .cname)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateUpdated = dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endpointUrl = endpointUrl {
            try encodeContainer.encode(endpointUrl, forKey: .endpointUrl)
        }
        if let environmentArn = environmentArn {
            try encodeContainer.encode(environmentArn, forKey: .environmentArn)
        }
        if let environmentId = environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let environmentLinks = environmentLinks {
            var environmentLinksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environmentLinks)
            for awselasticbeanstalkenvironmentenvironmentlinks0 in environmentLinks {
                try environmentLinksContainer.encode(awselasticbeanstalkenvironmentenvironmentlinks0)
            }
        }
        if let environmentName = environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let optionSettings = optionSettings {
            var optionSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .optionSettings)
            for awselasticbeanstalkenvironmentoptionsettings0 in optionSettings {
                try optionSettingsContainer.encode(awselasticbeanstalkenvironmentoptionsettings0)
            }
        }
        if let platformArn = platformArn {
            try encodeContainer.encode(platformArn, forKey: .platformArn)
        }
        if let solutionStackName = solutionStackName {
            try encodeContainer.encode(solutionStackName, forKey: .solutionStackName)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tier = tier {
            try encodeContainer.encode(tier, forKey: .tier)
        }
        if let versionLabel = versionLabel {
            try encodeContainer.encode(versionLabel, forKey: .versionLabel)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let cnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cname)
        cname = cnameDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let endpointUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointUrl)
        endpointUrl = endpointUrlDecoded
        let environmentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentArn)
        environmentArn = environmentArnDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let environmentLinksContainer = try containerValues.decodeIfPresent([AwsElasticBeanstalkEnvironmentEnvironmentLink?].self, forKey: .environmentLinks)
        var environmentLinksDecoded0:[AwsElasticBeanstalkEnvironmentEnvironmentLink]? = nil
        if let environmentLinksContainer = environmentLinksContainer {
            environmentLinksDecoded0 = [AwsElasticBeanstalkEnvironmentEnvironmentLink]()
            for structure0 in environmentLinksContainer {
                if let structure0 = structure0 {
                    environmentLinksDecoded0?.append(structure0)
                }
            }
        }
        environmentLinks = environmentLinksDecoded0
        let environmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let optionSettingsContainer = try containerValues.decodeIfPresent([AwsElasticBeanstalkEnvironmentOptionSetting?].self, forKey: .optionSettings)
        var optionSettingsDecoded0:[AwsElasticBeanstalkEnvironmentOptionSetting]? = nil
        if let optionSettingsContainer = optionSettingsContainer {
            optionSettingsDecoded0 = [AwsElasticBeanstalkEnvironmentOptionSetting]()
            for structure0 in optionSettingsContainer {
                if let structure0 = structure0 {
                    optionSettingsDecoded0?.append(structure0)
                }
            }
        }
        optionSettings = optionSettingsDecoded0
        let platformArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformArn)
        platformArn = platformArnDecoded
        let solutionStackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionStackName)
        solutionStackName = solutionStackNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let tierDecoded = try containerValues.decodeIfPresent(AwsElasticBeanstalkEnvironmentTier.self, forKey: .tier)
        tier = tierDecoded
        let versionLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionLabel)
        versionLabel = versionLabelDecoded
    }
}

extension AwsElasticBeanstalkEnvironmentDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElasticBeanstalkEnvironmentDetails(applicationName: \(String(describing: applicationName)), cname: \(String(describing: cname)), dateCreated: \(String(describing: dateCreated)), dateUpdated: \(String(describing: dateUpdated)), description: \(String(describing: description)), endpointUrl: \(String(describing: endpointUrl)), environmentArn: \(String(describing: environmentArn)), environmentId: \(String(describing: environmentId)), environmentLinks: \(String(describing: environmentLinks)), environmentName: \(String(describing: environmentName)), optionSettings: \(String(describing: optionSettings)), platformArn: \(String(describing: platformArn)), solutionStackName: \(String(describing: solutionStackName)), status: \(String(describing: status)), tier: \(String(describing: tier)), versionLabel: \(String(describing: versionLabel)))"}
}

/// <p>Contains details about an Elastic Beanstalk environment.</p>
public struct AwsElasticBeanstalkEnvironmentDetails: Equatable {
    /// <p>The name of the application that is associated with the environment.</p>
    public let applicationName: String?
    /// <p>The URL to the CNAME for this environment.</p>
    public let cname: String?
    /// <p>The creation date for this environment.</p>
    public let dateCreated: String?
    /// <p>The date when this environment was last modified.</p>
    public let dateUpdated: String?
    /// <p>A description of the environment.</p>
    public let description: String?
    /// <p>For load-balanced, autoscaling environments, the URL to the load balancer. For single-instance environments, the IP address of the instance.</p>
    public let endpointUrl: String?
    /// <p>The ARN of the environment.</p>
    public let environmentArn: String?
    /// <p>The identifier of the environment.</p>
    public let environmentId: String?
    /// <p>Links to other environments in the same group.</p>
    public let environmentLinks: [AwsElasticBeanstalkEnvironmentEnvironmentLink]?
    /// <p>The name of the environment.</p>
    public let environmentName: String?
    /// <p>The configuration setting for the environment.</p>
    public let optionSettings: [AwsElasticBeanstalkEnvironmentOptionSetting]?
    /// <p>The ARN of the platform version for the environment.</p>
    public let platformArn: String?
    /// <p>The name of the solution stack that is deployed with the environment.</p>
    public let solutionStackName: String?
    /// <p>The current operational status of the environment.</p>
    public let status: String?
    /// <p>The tier of the environment.</p>
    public let tier: AwsElasticBeanstalkEnvironmentTier?
    /// <p>The application version of the environment.</p>
    public let versionLabel: String?

    public init (
        applicationName: String? = nil,
        cname: String? = nil,
        dateCreated: String? = nil,
        dateUpdated: String? = nil,
        description: String? = nil,
        endpointUrl: String? = nil,
        environmentArn: String? = nil,
        environmentId: String? = nil,
        environmentLinks: [AwsElasticBeanstalkEnvironmentEnvironmentLink]? = nil,
        environmentName: String? = nil,
        optionSettings: [AwsElasticBeanstalkEnvironmentOptionSetting]? = nil,
        platformArn: String? = nil,
        solutionStackName: String? = nil,
        status: String? = nil,
        tier: AwsElasticBeanstalkEnvironmentTier? = nil,
        versionLabel: String? = nil
    )
    {
        self.applicationName = applicationName
        self.cname = cname
        self.dateCreated = dateCreated
        self.dateUpdated = dateUpdated
        self.description = description
        self.endpointUrl = endpointUrl
        self.environmentArn = environmentArn
        self.environmentId = environmentId
        self.environmentLinks = environmentLinks
        self.environmentName = environmentName
        self.optionSettings = optionSettings
        self.platformArn = platformArn
        self.solutionStackName = solutionStackName
        self.status = status
        self.tier = tier
        self.versionLabel = versionLabel
    }
}

extension AwsElasticBeanstalkEnvironmentEnvironmentLink: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case environmentName = "EnvironmentName"
        case linkName = "LinkName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentName = environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let linkName = linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkName)
        linkName = linkNameDecoded
    }
}

extension AwsElasticBeanstalkEnvironmentEnvironmentLink: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElasticBeanstalkEnvironmentEnvironmentLink(environmentName: \(String(describing: environmentName)), linkName: \(String(describing: linkName)))"}
}

/// <p>Contains information about a link to another environment that is in the same group.</p>
public struct AwsElasticBeanstalkEnvironmentEnvironmentLink: Equatable {
    /// <p>The name of the linked environment.</p>
    public let environmentName: String?
    /// <p>The name of the environment link.</p>
    public let linkName: String?

    public init (
        environmentName: String? = nil,
        linkName: String? = nil
    )
    {
        self.environmentName = environmentName
        self.linkName = linkName
    }
}

extension AwsElasticBeanstalkEnvironmentOptionSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case namespace = "Namespace"
        case optionName = "OptionName"
        case resourceName = "ResourceName"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let optionName = optionName {
            try encodeContainer.encode(optionName, forKey: .optionName)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let optionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optionName)
        optionName = optionNameDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AwsElasticBeanstalkEnvironmentOptionSetting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElasticBeanstalkEnvironmentOptionSetting(namespace: \(String(describing: namespace)), optionName: \(String(describing: optionName)), resourceName: \(String(describing: resourceName)), value: \(String(describing: value)))"}
}

/// <p>A configuration option setting for the environment.</p>
public struct AwsElasticBeanstalkEnvironmentOptionSetting: Equatable {
    /// <p>The type of resource that the configuration option is associated with.</p>
    public let namespace: String?
    /// <p>The name of the option.</p>
    public let optionName: String?
    /// <p>The name of the resource.</p>
    public let resourceName: String?
    /// <p>The value of the configuration setting.</p>
    public let value: String?

    public init (
        namespace: String? = nil,
        optionName: String? = nil,
        resourceName: String? = nil,
        value: String? = nil
    )
    {
        self.namespace = namespace
        self.optionName = optionName
        self.resourceName = resourceName
        self.value = value
    }
}

extension AwsElasticBeanstalkEnvironmentTier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case type = "Type"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension AwsElasticBeanstalkEnvironmentTier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElasticBeanstalkEnvironmentTier(name: \(String(describing: name)), type: \(String(describing: type)), version: \(String(describing: version)))"}
}

/// <p>Contains information about the tier of the environment.</p>
public struct AwsElasticBeanstalkEnvironmentTier: Equatable {
    /// <p>The name of the environment tier.</p>
    public let name: String?
    /// <p>The type of environment tier.</p>
    public let type: String?
    /// <p>The version of the environment tier.</p>
    public let version: String?

    public init (
        name: String? = nil,
        type: String? = nil,
        version: String? = nil
    )
    {
        self.name = name
        self.type = type
        self.version = version
    }
}

extension AwsElasticsearchDomainDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessPolicies = "AccessPolicies"
        case domainEndpointOptions = "DomainEndpointOptions"
        case domainId = "DomainId"
        case domainName = "DomainName"
        case elasticsearchVersion = "ElasticsearchVersion"
        case encryptionAtRestOptions = "EncryptionAtRestOptions"
        case endpoint = "Endpoint"
        case endpoints = "Endpoints"
        case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
        case vPCOptions = "VPCOptions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPolicies = accessPolicies {
            try encodeContainer.encode(accessPolicies, forKey: .accessPolicies)
        }
        if let domainEndpointOptions = domainEndpointOptions {
            try encodeContainer.encode(domainEndpointOptions, forKey: .domainEndpointOptions)
        }
        if let domainId = domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let elasticsearchVersion = elasticsearchVersion {
            try encodeContainer.encode(elasticsearchVersion, forKey: .elasticsearchVersion)
        }
        if let encryptionAtRestOptions = encryptionAtRestOptions {
            try encodeContainer.encode(encryptionAtRestOptions, forKey: .encryptionAtRestOptions)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .endpoints)
            for (dictKey0, fieldmap0) in endpoints {
                try endpointsContainer.encode(fieldmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions {
            try encodeContainer.encode(nodeToNodeEncryptionOptions, forKey: .nodeToNodeEncryptionOptions)
        }
        if let vPCOptions = vPCOptions {
            try encodeContainer.encode(vPCOptions, forKey: .vPCOptions)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPoliciesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessPolicies)
        accessPolicies = accessPoliciesDecoded
        let domainEndpointOptionsDecoded = try containerValues.decodeIfPresent(AwsElasticsearchDomainDomainEndpointOptions.self, forKey: .domainEndpointOptions)
        domainEndpointOptions = domainEndpointOptionsDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .endpoints)
        var endpointsDecoded0: [String:String]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [String:String]()
            for (key0, nonemptystring0) in endpointsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    endpointsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        endpoints = endpointsDecoded0
        let elasticsearchVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .elasticsearchVersion)
        elasticsearchVersion = elasticsearchVersionDecoded
        let encryptionAtRestOptionsDecoded = try containerValues.decodeIfPresent(AwsElasticsearchDomainEncryptionAtRestOptions.self, forKey: .encryptionAtRestOptions)
        encryptionAtRestOptions = encryptionAtRestOptionsDecoded
        let nodeToNodeEncryptionOptionsDecoded = try containerValues.decodeIfPresent(AwsElasticsearchDomainNodeToNodeEncryptionOptions.self, forKey: .nodeToNodeEncryptionOptions)
        nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptionsDecoded
        let vPCOptionsDecoded = try containerValues.decodeIfPresent(AwsElasticsearchDomainVPCOptions.self, forKey: .vPCOptions)
        vPCOptions = vPCOptionsDecoded
    }
}

extension AwsElasticsearchDomainDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElasticsearchDomainDetails(accessPolicies: \(String(describing: accessPolicies)), domainEndpointOptions: \(String(describing: domainEndpointOptions)), domainId: \(String(describing: domainId)), domainName: \(String(describing: domainName)), elasticsearchVersion: \(String(describing: elasticsearchVersion)), encryptionAtRestOptions: \(String(describing: encryptionAtRestOptions)), endpoint: \(String(describing: endpoint)), endpoints: \(String(describing: endpoints)), nodeToNodeEncryptionOptions: \(String(describing: nodeToNodeEncryptionOptions)), vPCOptions: \(String(describing: vPCOptions)))"}
}

/// <p>Information about an Elasticsearch domain.</p>
public struct AwsElasticsearchDomainDetails: Equatable {
    /// <p>IAM policy document specifying the access policies for the new Amazon ES domain.</p>
    public let accessPolicies: String?
    /// <p>Additional options for the domain endpoint.</p>
    public let domainEndpointOptions: AwsElasticsearchDomainDomainEndpointOptions?
    /// <p>Unique identifier for an Amazon ES domain.</p>
    public let domainId: String?
    /// <p>Name of an Amazon ES domain.</p>
    ///          <p>Domain names are unique across all domains owned by the same account within an AWS
    ///          Region.</p>
    ///          <p>Domain names must start with a lowercase letter and must be between 3 and 28
    ///          characters.</p>
    ///          <p>Valid characters are a-z (lowercase only), 0-9, and – (hyphen). </p>
    public let domainName: String?
    /// <p>Elasticsearch version.</p>
    public let elasticsearchVersion: String?
    /// <p>Details about the configuration for encryption at rest.</p>
    public let encryptionAtRestOptions: AwsElasticsearchDomainEncryptionAtRestOptions?
    /// <p>Domain-specific endpoint used to submit index, search, and data upload requests to an
    ///          Amazon ES domain.</p>
    ///          <p>The endpoint is a service URL. </p>
    public let endpoint: String?
    /// <p>The key-value pair that exists if the Amazon ES domain uses VPC endpoints.</p>
    public let endpoints: [String:String]?
    /// <p>Details about the configuration for node-to-node encryption.</p>
    public let nodeToNodeEncryptionOptions: AwsElasticsearchDomainNodeToNodeEncryptionOptions?
    /// <p>Information that Amazon ES derives based on <code>VPCOptions</code> for the
    ///          domain.</p>
    public let vPCOptions: AwsElasticsearchDomainVPCOptions?

    public init (
        accessPolicies: String? = nil,
        domainEndpointOptions: AwsElasticsearchDomainDomainEndpointOptions? = nil,
        domainId: String? = nil,
        domainName: String? = nil,
        elasticsearchVersion: String? = nil,
        encryptionAtRestOptions: AwsElasticsearchDomainEncryptionAtRestOptions? = nil,
        endpoint: String? = nil,
        endpoints: [String:String]? = nil,
        nodeToNodeEncryptionOptions: AwsElasticsearchDomainNodeToNodeEncryptionOptions? = nil,
        vPCOptions: AwsElasticsearchDomainVPCOptions? = nil
    )
    {
        self.accessPolicies = accessPolicies
        self.domainEndpointOptions = domainEndpointOptions
        self.domainId = domainId
        self.domainName = domainName
        self.elasticsearchVersion = elasticsearchVersion
        self.encryptionAtRestOptions = encryptionAtRestOptions
        self.endpoint = endpoint
        self.endpoints = endpoints
        self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
        self.vPCOptions = vPCOptions
    }
}

extension AwsElasticsearchDomainDomainEndpointOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enforceHTTPS = "EnforceHTTPS"
        case tLSSecurityPolicy = "TLSSecurityPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enforceHTTPS != false {
            try encodeContainer.encode(enforceHTTPS, forKey: .enforceHTTPS)
        }
        if let tLSSecurityPolicy = tLSSecurityPolicy {
            try encodeContainer.encode(tLSSecurityPolicy, forKey: .tLSSecurityPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enforceHTTPSDecoded = try containerValues.decode(Bool.self, forKey: .enforceHTTPS)
        enforceHTTPS = enforceHTTPSDecoded
        let tLSSecurityPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tLSSecurityPolicy)
        tLSSecurityPolicy = tLSSecurityPolicyDecoded
    }
}

extension AwsElasticsearchDomainDomainEndpointOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElasticsearchDomainDomainEndpointOptions(enforceHTTPS: \(String(describing: enforceHTTPS)), tLSSecurityPolicy: \(String(describing: tLSSecurityPolicy)))"}
}

/// <p>Additional options for the domain endpoint, such as whether to require HTTPS for all
///          traffic.</p>
public struct AwsElasticsearchDomainDomainEndpointOptions: Equatable {
    /// <p>Whether to require that all traffic to the domain arrive over HTTPS.</p>
    public let enforceHTTPS: Bool
    /// <p>The TLS security policy to apply to the HTTPS endpoint of the Elasticsearch
    ///          domain.</p>
    ///          <p>Valid values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Policy-Min-TLS-1-0-2019-07</code>, which supports TLSv1.0 and higher</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Policy-Min-TLS-1-2-2019-07</code>, which only supports TLSv1.2</p>
    ///             </li>
    ///          </ul>
    public let tLSSecurityPolicy: String?

    public init (
        enforceHTTPS: Bool = false,
        tLSSecurityPolicy: String? = nil
    )
    {
        self.enforceHTTPS = enforceHTTPS
        self.tLSSecurityPolicy = tLSSecurityPolicy
    }
}

extension AwsElasticsearchDomainEncryptionAtRestOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case kmsKeyId = "KmsKeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension AwsElasticsearchDomainEncryptionAtRestOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElasticsearchDomainEncryptionAtRestOptions(enabled: \(String(describing: enabled)), kmsKeyId: \(String(describing: kmsKeyId)))"}
}

/// <p>Details about the configuration for encryption at rest.</p>
public struct AwsElasticsearchDomainEncryptionAtRestOptions: Equatable {
    /// <p>Whether encryption at rest is enabled.</p>
    public let enabled: Bool
    /// <p>The KMS key ID. Takes the form 1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a.</p>
    public let kmsKeyId: String?

    public init (
        enabled: Bool = false,
        kmsKeyId: String? = nil
    )
    {
        self.enabled = enabled
        self.kmsKeyId = kmsKeyId
    }
}

extension AwsElasticsearchDomainNodeToNodeEncryptionOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AwsElasticsearchDomainNodeToNodeEncryptionOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElasticsearchDomainNodeToNodeEncryptionOptions(enabled: \(String(describing: enabled)))"}
}

/// <p>Details about the configuration for node-to-node encryption.</p>
public struct AwsElasticsearchDomainNodeToNodeEncryptionOptions: Equatable {
    /// <p>Whether node-to-node encryption is enabled.</p>
    public let enabled: Bool

    public init (
        enabled: Bool = false
    )
    {
        self.enabled = enabled
    }
}

extension AwsElasticsearchDomainVPCOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vPCId = "VPCId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for nonemptystringlist0 in availabilityZones {
                try availabilityZonesContainer.encode(nonemptystringlist0)
            }
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for nonemptystringlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(nonemptystringlist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for nonemptystringlist0 in subnetIds {
                try subnetIdsContainer.encode(nonemptystringlist0)
            }
        }
        if let vPCId = vPCId {
            try encodeContainer.encode(vPCId, forKey: .vPCId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZonesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let vPCIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vPCId)
        vPCId = vPCIdDecoded
    }
}

extension AwsElasticsearchDomainVPCOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElasticsearchDomainVPCOptions(availabilityZones: \(String(describing: availabilityZones)), securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)), vPCId: \(String(describing: vPCId)))"}
}

/// <p>Information that Amazon ES derives based on <code>VPCOptions</code> for the
///          domain.</p>
public struct AwsElasticsearchDomainVPCOptions: Equatable {
    /// <p>The list of Availability Zones associated with the VPC subnets.</p>
    public let availabilityZones: [String]?
    /// <p>The list of security group IDs associated with the VPC endpoints for the domain.</p>
    public let securityGroupIds: [String]?
    /// <p>A list of subnet IDs associated with the VPC endpoints for the domain.</p>
    public let subnetIds: [String]?
    /// <p>ID for the VPC.</p>
    public let vPCId: String?

    public init (
        availabilityZones: [String]? = nil,
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil,
        vPCId: String? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vPCId = vPCId
    }
}

extension AwsElbAppCookieStickinessPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cookieName = "CookieName"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cookieName = cookieName {
            try encodeContainer.encode(cookieName, forKey: .cookieName)
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cookieNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cookieName)
        cookieName = cookieNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension AwsElbAppCookieStickinessPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElbAppCookieStickinessPolicy(cookieName: \(String(describing: cookieName)), policyName: \(String(describing: policyName)))"}
}

/// <p>Contains information about a stickiness policy that was created using
///             <code>CreateAppCookieStickinessPolicy</code>.</p>
public struct AwsElbAppCookieStickinessPolicy: Equatable {
    /// <p>The name of the application cookie used for stickiness.</p>
    public let cookieName: String?
    /// <p>The mnemonic name for the policy being created. The name must be unique within the set
    ///          of policies for the load balancer.</p>
    public let policyName: String?

    public init (
        cookieName: String? = nil,
        policyName: String? = nil
    )
    {
        self.cookieName = cookieName
        self.policyName = policyName
    }
}

extension AwsElbLbCookieStickinessPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cookieExpirationPeriod = "CookieExpirationPeriod"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cookieExpirationPeriod != 0 {
            try encodeContainer.encode(cookieExpirationPeriod, forKey: .cookieExpirationPeriod)
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cookieExpirationPeriodDecoded = try containerValues.decode(Int.self, forKey: .cookieExpirationPeriod)
        cookieExpirationPeriod = cookieExpirationPeriodDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension AwsElbLbCookieStickinessPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElbLbCookieStickinessPolicy(cookieExpirationPeriod: \(String(describing: cookieExpirationPeriod)), policyName: \(String(describing: policyName)))"}
}

/// <p>Contains information about a stickiness policy that was created using
///             <code>CreateLBCookieStickinessPolicy</code>.</p>
public struct AwsElbLbCookieStickinessPolicy: Equatable {
    /// <p>The amount of time, in seconds, after which the cookie is considered stale. If an
    ///          expiration period is not specified, the stickiness session lasts for the duration of the
    ///          browser session.</p>
    public let cookieExpirationPeriod: Int
    /// <p>The name of the policy. The name must be unique within the set of policies for the load
    ///          balancer.</p>
    public let policyName: String?

    public init (
        cookieExpirationPeriod: Int = 0,
        policyName: String? = nil
    )
    {
        self.cookieExpirationPeriod = cookieExpirationPeriod
        self.policyName = policyName
    }
}

extension AwsElbLoadBalancerAccessLog: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emitInterval = "EmitInterval"
        case enabled = "Enabled"
        case s3BucketName = "S3BucketName"
        case s3BucketPrefix = "S3BucketPrefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if emitInterval != 0 {
            try encodeContainer.encode(emitInterval, forKey: .emitInterval)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3BucketPrefix = s3BucketPrefix {
            try encodeContainer.encode(s3BucketPrefix, forKey: .s3BucketPrefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emitIntervalDecoded = try containerValues.decode(Int.self, forKey: .emitInterval)
        emitInterval = emitIntervalDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3BucketPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketPrefix)
        s3BucketPrefix = s3BucketPrefixDecoded
    }
}

extension AwsElbLoadBalancerAccessLog: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElbLoadBalancerAccessLog(emitInterval: \(String(describing: emitInterval)), enabled: \(String(describing: enabled)), s3BucketName: \(String(describing: s3BucketName)), s3BucketPrefix: \(String(describing: s3BucketPrefix)))"}
}

/// <p>Contains information about the access log configuration for the load balancer.</p>
public struct AwsElbLoadBalancerAccessLog: Equatable {
    /// <p>The interval in minutes for publishing the access logs.</p>
    ///          <p>You can publish access logs either every 5 minutes or every 60 minutes.</p>
    public let emitInterval: Int
    /// <p>Indicates whether access logs are enabled for the load balancer.</p>
    public let enabled: Bool
    /// <p>The name of the S3 bucket where the access logs are stored.</p>
    public let s3BucketName: String?
    /// <p>The logical hierarchy that was created for the S3 bucket.</p>
    ///          <p>If a prefix is not provided, the log is placed at the root level of the bucket.</p>
    public let s3BucketPrefix: String?

    public init (
        emitInterval: Int = 0,
        enabled: Bool = false,
        s3BucketName: String? = nil,
        s3BucketPrefix: String? = nil
    )
    {
        self.emitInterval = emitInterval
        self.enabled = enabled
        self.s3BucketName = s3BucketName
        self.s3BucketPrefix = s3BucketPrefix
    }
}

extension AwsElbLoadBalancerAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessLog = "AccessLog"
        case connectionDraining = "ConnectionDraining"
        case connectionSettings = "ConnectionSettings"
        case crossZoneLoadBalancing = "CrossZoneLoadBalancing"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLog = accessLog {
            try encodeContainer.encode(accessLog, forKey: .accessLog)
        }
        if let connectionDraining = connectionDraining {
            try encodeContainer.encode(connectionDraining, forKey: .connectionDraining)
        }
        if let connectionSettings = connectionSettings {
            try encodeContainer.encode(connectionSettings, forKey: .connectionSettings)
        }
        if let crossZoneLoadBalancing = crossZoneLoadBalancing {
            try encodeContainer.encode(crossZoneLoadBalancing, forKey: .crossZoneLoadBalancing)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogDecoded = try containerValues.decodeIfPresent(AwsElbLoadBalancerAccessLog.self, forKey: .accessLog)
        accessLog = accessLogDecoded
        let connectionDrainingDecoded = try containerValues.decodeIfPresent(AwsElbLoadBalancerConnectionDraining.self, forKey: .connectionDraining)
        connectionDraining = connectionDrainingDecoded
        let connectionSettingsDecoded = try containerValues.decodeIfPresent(AwsElbLoadBalancerConnectionSettings.self, forKey: .connectionSettings)
        connectionSettings = connectionSettingsDecoded
        let crossZoneLoadBalancingDecoded = try containerValues.decodeIfPresent(AwsElbLoadBalancerCrossZoneLoadBalancing.self, forKey: .crossZoneLoadBalancing)
        crossZoneLoadBalancing = crossZoneLoadBalancingDecoded
    }
}

extension AwsElbLoadBalancerAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElbLoadBalancerAttributes(accessLog: \(String(describing: accessLog)), connectionDraining: \(String(describing: connectionDraining)), connectionSettings: \(String(describing: connectionSettings)), crossZoneLoadBalancing: \(String(describing: crossZoneLoadBalancing)))"}
}

/// <p>Contains attributes for the load balancer.</p>
public struct AwsElbLoadBalancerAttributes: Equatable {
    /// <p>Information about the access log configuration for the load balancer.</p>
    ///          <p>If the access log is enabled, the load balancer captures detailed information about all
    ///          requests. It delivers the information to a specified S3 bucket.</p>
    public let accessLog: AwsElbLoadBalancerAccessLog?
    /// <p>Information about the connection draining configuration for the load balancer.</p>
    ///          <p>If connection draining is enabled, the load balancer allows existing requests to
    ///          complete before it shifts traffic away from a deregistered or unhealthy instance.</p>
    public let connectionDraining: AwsElbLoadBalancerConnectionDraining?
    /// <p>Connection settings for the load balancer.</p>
    ///          <p>If an idle timeout is configured, the load balancer allows connections to remain idle
    ///          for the specified duration. When a connection is idle, no data is sent over the
    ///          connection.</p>
    public let connectionSettings: AwsElbLoadBalancerConnectionSettings?
    /// <p>Cross-zone load balancing settings for the load balancer.</p>
    ///          <p>If cross-zone load balancing is enabled, the load balancer routes the request traffic
    ///          evenly across all instances regardless of the Availability Zones.</p>
    public let crossZoneLoadBalancing: AwsElbLoadBalancerCrossZoneLoadBalancing?

    public init (
        accessLog: AwsElbLoadBalancerAccessLog? = nil,
        connectionDraining: AwsElbLoadBalancerConnectionDraining? = nil,
        connectionSettings: AwsElbLoadBalancerConnectionSettings? = nil,
        crossZoneLoadBalancing: AwsElbLoadBalancerCrossZoneLoadBalancing? = nil
    )
    {
        self.accessLog = accessLog
        self.connectionDraining = connectionDraining
        self.connectionSettings = connectionSettings
        self.crossZoneLoadBalancing = crossZoneLoadBalancing
    }
}

extension AwsElbLoadBalancerBackendServerDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instancePort = "InstancePort"
        case policyNames = "PolicyNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if instancePort != 0 {
            try encodeContainer.encode(instancePort, forKey: .instancePort)
        }
        if let policyNames = policyNames {
            var policyNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyNames)
            for stringlist0 in policyNames {
                try policyNamesContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancePortDecoded = try containerValues.decode(Int.self, forKey: .instancePort)
        instancePort = instancePortDecoded
        let policyNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .policyNames)
        var policyNamesDecoded0:[String]? = nil
        if let policyNamesContainer = policyNamesContainer {
            policyNamesDecoded0 = [String]()
            for string0 in policyNamesContainer {
                if let string0 = string0 {
                    policyNamesDecoded0?.append(string0)
                }
            }
        }
        policyNames = policyNamesDecoded0
    }
}

extension AwsElbLoadBalancerBackendServerDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElbLoadBalancerBackendServerDescription(instancePort: \(String(describing: instancePort)), policyNames: \(String(describing: policyNames)))"}
}

/// <p>Provides information about the configuration of an EC2 instance for the load
///          balancer.</p>
public struct AwsElbLoadBalancerBackendServerDescription: Equatable {
    /// <p>The port on which the EC2 instance is listening.</p>
    public let instancePort: Int
    /// <p>The names of the policies that are enabled for the EC2 instance.</p>
    public let policyNames: [String]?

    public init (
        instancePort: Int = 0,
        policyNames: [String]? = nil
    )
    {
        self.instancePort = instancePort
        self.policyNames = policyNames
    }
}

extension AwsElbLoadBalancerConnectionDraining: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case timeout = "Timeout"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if timeout != 0 {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let timeoutDecoded = try containerValues.decode(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
    }
}

extension AwsElbLoadBalancerConnectionDraining: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElbLoadBalancerConnectionDraining(enabled: \(String(describing: enabled)), timeout: \(String(describing: timeout)))"}
}

/// <p>Contains information about the connection draining configuration for the load
///          balancer.</p>
public struct AwsElbLoadBalancerConnectionDraining: Equatable {
    /// <p>Indicates whether connection draining is enabled for the load balancer.</p>
    public let enabled: Bool
    /// <p>The maximum time, in seconds, to keep the existing connections open before deregistering
    ///          the instances.</p>
    public let timeout: Int

    public init (
        enabled: Bool = false,
        timeout: Int = 0
    )
    {
        self.enabled = enabled
        self.timeout = timeout
    }
}

extension AwsElbLoadBalancerConnectionSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case idleTimeout = "IdleTimeout"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if idleTimeout != 0 {
            try encodeContainer.encode(idleTimeout, forKey: .idleTimeout)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idleTimeoutDecoded = try containerValues.decode(Int.self, forKey: .idleTimeout)
        idleTimeout = idleTimeoutDecoded
    }
}

extension AwsElbLoadBalancerConnectionSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElbLoadBalancerConnectionSettings(idleTimeout: \(String(describing: idleTimeout)))"}
}

/// <p>Contains connection settings for the load balancer.</p>
public struct AwsElbLoadBalancerConnectionSettings: Equatable {
    /// <p>The time, in seconds, that the connection can be idle (no data is sent over the
    ///          connection) before it is closed by the load balancer.</p>
    public let idleTimeout: Int

    public init (
        idleTimeout: Int = 0
    )
    {
        self.idleTimeout = idleTimeout
    }
}

extension AwsElbLoadBalancerCrossZoneLoadBalancing: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AwsElbLoadBalancerCrossZoneLoadBalancing: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElbLoadBalancerCrossZoneLoadBalancing(enabled: \(String(describing: enabled)))"}
}

/// <p>Contains cross-zone load balancing settings for the load balancer.</p>
public struct AwsElbLoadBalancerCrossZoneLoadBalancing: Equatable {
    /// <p>Indicates whether cross-zone load balancing is enabled for the load balancer.</p>
    public let enabled: Bool

    public init (
        enabled: Bool = false
    )
    {
        self.enabled = enabled
    }
}

extension AwsElbLoadBalancerDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
        case backendServerDescriptions = "BackendServerDescriptions"
        case canonicalHostedZoneName = "CanonicalHostedZoneName"
        case canonicalHostedZoneNameID = "CanonicalHostedZoneNameID"
        case createdTime = "CreatedTime"
        case dnsName = "DnsName"
        case healthCheck = "HealthCheck"
        case instances = "Instances"
        case listenerDescriptions = "ListenerDescriptions"
        case loadBalancerAttributes = "LoadBalancerAttributes"
        case loadBalancerName = "LoadBalancerName"
        case policies = "Policies"
        case scheme = "Scheme"
        case securityGroups = "SecurityGroups"
        case sourceSecurityGroup = "SourceSecurityGroup"
        case subnets = "Subnets"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for stringlist0 in availabilityZones {
                try availabilityZonesContainer.encode(stringlist0)
            }
        }
        if let backendServerDescriptions = backendServerDescriptions {
            var backendServerDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .backendServerDescriptions)
            for awselbloadbalancerbackendserverdescriptions0 in backendServerDescriptions {
                try backendServerDescriptionsContainer.encode(awselbloadbalancerbackendserverdescriptions0)
            }
        }
        if let canonicalHostedZoneName = canonicalHostedZoneName {
            try encodeContainer.encode(canonicalHostedZoneName, forKey: .canonicalHostedZoneName)
        }
        if let canonicalHostedZoneNameID = canonicalHostedZoneNameID {
            try encodeContainer.encode(canonicalHostedZoneNameID, forKey: .canonicalHostedZoneNameID)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let dnsName = dnsName {
            try encodeContainer.encode(dnsName, forKey: .dnsName)
        }
        if let healthCheck = healthCheck {
            try encodeContainer.encode(healthCheck, forKey: .healthCheck)
        }
        if let instances = instances {
            var instancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instances)
            for awselbloadbalancerinstances0 in instances {
                try instancesContainer.encode(awselbloadbalancerinstances0)
            }
        }
        if let listenerDescriptions = listenerDescriptions {
            var listenerDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listenerDescriptions)
            for awselbloadbalancerlistenerdescriptions0 in listenerDescriptions {
                try listenerDescriptionsContainer.encode(awselbloadbalancerlistenerdescriptions0)
            }
        }
        if let loadBalancerAttributes = loadBalancerAttributes {
            try encodeContainer.encode(loadBalancerAttributes, forKey: .loadBalancerAttributes)
        }
        if let loadBalancerName = loadBalancerName {
            try encodeContainer.encode(loadBalancerName, forKey: .loadBalancerName)
        }
        if let policies = policies {
            try encodeContainer.encode(policies, forKey: .policies)
        }
        if let scheme = scheme {
            try encodeContainer.encode(scheme, forKey: .scheme)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for stringlist0 in securityGroups {
                try securityGroupsContainer.encode(stringlist0)
            }
        }
        if let sourceSecurityGroup = sourceSecurityGroup {
            try encodeContainer.encode(sourceSecurityGroup, forKey: .sourceSecurityGroup)
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for stringlist0 in subnets {
                try subnetsContainer.encode(stringlist0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZonesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let backendServerDescriptionsContainer = try containerValues.decodeIfPresent([AwsElbLoadBalancerBackendServerDescription?].self, forKey: .backendServerDescriptions)
        var backendServerDescriptionsDecoded0:[AwsElbLoadBalancerBackendServerDescription]? = nil
        if let backendServerDescriptionsContainer = backendServerDescriptionsContainer {
            backendServerDescriptionsDecoded0 = [AwsElbLoadBalancerBackendServerDescription]()
            for structure0 in backendServerDescriptionsContainer {
                if let structure0 = structure0 {
                    backendServerDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        backendServerDescriptions = backendServerDescriptionsDecoded0
        let canonicalHostedZoneNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .canonicalHostedZoneName)
        canonicalHostedZoneName = canonicalHostedZoneNameDecoded
        let canonicalHostedZoneNameIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .canonicalHostedZoneNameID)
        canonicalHostedZoneNameID = canonicalHostedZoneNameIDDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let dnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dnsName)
        dnsName = dnsNameDecoded
        let healthCheckDecoded = try containerValues.decodeIfPresent(AwsElbLoadBalancerHealthCheck.self, forKey: .healthCheck)
        healthCheck = healthCheckDecoded
        let instancesContainer = try containerValues.decodeIfPresent([AwsElbLoadBalancerInstance?].self, forKey: .instances)
        var instancesDecoded0:[AwsElbLoadBalancerInstance]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [AwsElbLoadBalancerInstance]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
        let listenerDescriptionsContainer = try containerValues.decodeIfPresent([AwsElbLoadBalancerListenerDescription?].self, forKey: .listenerDescriptions)
        var listenerDescriptionsDecoded0:[AwsElbLoadBalancerListenerDescription]? = nil
        if let listenerDescriptionsContainer = listenerDescriptionsContainer {
            listenerDescriptionsDecoded0 = [AwsElbLoadBalancerListenerDescription]()
            for structure0 in listenerDescriptionsContainer {
                if let structure0 = structure0 {
                    listenerDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        listenerDescriptions = listenerDescriptionsDecoded0
        let loadBalancerAttributesDecoded = try containerValues.decodeIfPresent(AwsElbLoadBalancerAttributes.self, forKey: .loadBalancerAttributes)
        loadBalancerAttributes = loadBalancerAttributesDecoded
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let policiesDecoded = try containerValues.decodeIfPresent(AwsElbLoadBalancerPolicies.self, forKey: .policies)
        policies = policiesDecoded
        let schemeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheme)
        scheme = schemeDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let sourceSecurityGroupDecoded = try containerValues.decodeIfPresent(AwsElbLoadBalancerSourceSecurityGroup.self, forKey: .sourceSecurityGroup)
        sourceSecurityGroup = sourceSecurityGroupDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnets)
        var subnetsDecoded0:[String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension AwsElbLoadBalancerDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElbLoadBalancerDetails(availabilityZones: \(String(describing: availabilityZones)), backendServerDescriptions: \(String(describing: backendServerDescriptions)), canonicalHostedZoneName: \(String(describing: canonicalHostedZoneName)), canonicalHostedZoneNameID: \(String(describing: canonicalHostedZoneNameID)), createdTime: \(String(describing: createdTime)), dnsName: \(String(describing: dnsName)), healthCheck: \(String(describing: healthCheck)), instances: \(String(describing: instances)), listenerDescriptions: \(String(describing: listenerDescriptions)), loadBalancerAttributes: \(String(describing: loadBalancerAttributes)), loadBalancerName: \(String(describing: loadBalancerName)), policies: \(String(describing: policies)), scheme: \(String(describing: scheme)), securityGroups: \(String(describing: securityGroups)), sourceSecurityGroup: \(String(describing: sourceSecurityGroup)), subnets: \(String(describing: subnets)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Contains details about a Classic Load Balancer.</p>
public struct AwsElbLoadBalancerDetails: Equatable {
    /// <p>The list of Availability Zones for the load balancer.</p>
    public let availabilityZones: [String]?
    /// <p>Information about the configuration of the EC2 instances.</p>
    public let backendServerDescriptions: [AwsElbLoadBalancerBackendServerDescription]?
    /// <p>The name of the Amazon Route 53 hosted zone for the load balancer.</p>
    public let canonicalHostedZoneName: String?
    /// <p>The ID of the Amazon Route 53 hosted zone for the load balancer.</p>
    public let canonicalHostedZoneNameID: String?
    /// <p>Indicates when the load balancer was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let createdTime: String?
    /// <p>The DNS name of the load balancer.</p>
    public let dnsName: String?
    /// <p>Information about the health checks that are conducted on the load balancer.</p>
    public let healthCheck: AwsElbLoadBalancerHealthCheck?
    /// <p>List of EC2 instances for the load balancer.</p>
    public let instances: [AwsElbLoadBalancerInstance]?
    /// <p>The policies that are enabled for the load balancer listeners.</p>
    public let listenerDescriptions: [AwsElbLoadBalancerListenerDescription]?
    /// <p>The attributes for a load balancer.</p>
    public let loadBalancerAttributes: AwsElbLoadBalancerAttributes?
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?
    /// <p>The policies for a load balancer.</p>
    public let policies: AwsElbLoadBalancerPolicies?
    /// <p>The type of load balancer. Only provided if the load balancer is in a VPC.</p>
    ///          <p>If <code>Scheme</code> is <code>internet-facing</code>, the load balancer has a public
    ///          DNS name that resolves to a public IP address.</p>
    ///          <p>If <code>Scheme</code> is <code>internal</code>, the load balancer has a public DNS name
    ///          that resolves to a private IP address.</p>
    public let scheme: String?
    /// <p>The security groups for the load balancer. Only provided if the load balancer is in a
    ///          VPC.</p>
    public let securityGroups: [String]?
    /// <p>Information about the security group for the load balancer. This is the security group
    ///          that is used for inbound rules.</p>
    public let sourceSecurityGroup: AwsElbLoadBalancerSourceSecurityGroup?
    /// <p>The list of subnet identifiers for the load balancer.</p>
    public let subnets: [String]?
    /// <p>The identifier of the VPC for the load balancer.</p>
    public let vpcId: String?

    public init (
        availabilityZones: [String]? = nil,
        backendServerDescriptions: [AwsElbLoadBalancerBackendServerDescription]? = nil,
        canonicalHostedZoneName: String? = nil,
        canonicalHostedZoneNameID: String? = nil,
        createdTime: String? = nil,
        dnsName: String? = nil,
        healthCheck: AwsElbLoadBalancerHealthCheck? = nil,
        instances: [AwsElbLoadBalancerInstance]? = nil,
        listenerDescriptions: [AwsElbLoadBalancerListenerDescription]? = nil,
        loadBalancerAttributes: AwsElbLoadBalancerAttributes? = nil,
        loadBalancerName: String? = nil,
        policies: AwsElbLoadBalancerPolicies? = nil,
        scheme: String? = nil,
        securityGroups: [String]? = nil,
        sourceSecurityGroup: AwsElbLoadBalancerSourceSecurityGroup? = nil,
        subnets: [String]? = nil,
        vpcId: String? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.backendServerDescriptions = backendServerDescriptions
        self.canonicalHostedZoneName = canonicalHostedZoneName
        self.canonicalHostedZoneNameID = canonicalHostedZoneNameID
        self.createdTime = createdTime
        self.dnsName = dnsName
        self.healthCheck = healthCheck
        self.instances = instances
        self.listenerDescriptions = listenerDescriptions
        self.loadBalancerAttributes = loadBalancerAttributes
        self.loadBalancerName = loadBalancerName
        self.policies = policies
        self.scheme = scheme
        self.securityGroups = securityGroups
        self.sourceSecurityGroup = sourceSecurityGroup
        self.subnets = subnets
        self.vpcId = vpcId
    }
}

extension AwsElbLoadBalancerHealthCheck: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case healthyThreshold = "HealthyThreshold"
        case interval = "Interval"
        case target = "Target"
        case timeout = "Timeout"
        case unhealthyThreshold = "UnhealthyThreshold"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if healthyThreshold != 0 {
            try encodeContainer.encode(healthyThreshold, forKey: .healthyThreshold)
        }
        if interval != 0 {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if timeout != 0 {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if unhealthyThreshold != 0 {
            try encodeContainer.encode(unhealthyThreshold, forKey: .unhealthyThreshold)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let healthyThresholdDecoded = try containerValues.decode(Int.self, forKey: .healthyThreshold)
        healthyThreshold = healthyThresholdDecoded
        let intervalDecoded = try containerValues.decode(Int.self, forKey: .interval)
        interval = intervalDecoded
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
        let timeoutDecoded = try containerValues.decode(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let unhealthyThresholdDecoded = try containerValues.decode(Int.self, forKey: .unhealthyThreshold)
        unhealthyThreshold = unhealthyThresholdDecoded
    }
}

extension AwsElbLoadBalancerHealthCheck: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElbLoadBalancerHealthCheck(healthyThreshold: \(String(describing: healthyThreshold)), interval: \(String(describing: interval)), target: \(String(describing: target)), timeout: \(String(describing: timeout)), unhealthyThreshold: \(String(describing: unhealthyThreshold)))"}
}

/// <p>Contains information about the health checks that are conducted on the load
///          balancer.</p>
public struct AwsElbLoadBalancerHealthCheck: Equatable {
    /// <p>The number of consecutive health check successes required before the instance is moved
    ///          to the Healthy state.</p>
    public let healthyThreshold: Int
    /// <p>The approximate interval, in seconds, between health checks of an individual
    ///          instance.</p>
    public let interval: Int
    /// <p>The instance that is being checked. The target specifies the protocol and port. The
    ///          available protocols are TCP, SSL, HTTP, and HTTPS. The range of valid ports is 1 through
    ///          65535.</p>
    ///          <p>For the HTTP and HTTPS protocols, the target also specifies the ping path.</p>
    ///          <p>For the TCP protocol, the target is specified as <code>TCP:
    ///                <i><port></i>
    ///             </code>.</p>
    ///          <p>For the SSL protocol, the target is specified as
    ///                <code>SSL.<i><port></i>
    ///             </code>.</p>
    ///          <p>For the HTTP and HTTPS protocols, the target is specified as
    ///                <code>
    ///                <i><protocol></i>:<i><port></i>/<i><path
    ///                to ping></i>
    ///             </code>.</p>
    public let target: String?
    /// <p>The amount of time, in seconds, during which no response means a failed health
    ///          check.</p>
    public let timeout: Int
    /// <p>The number of consecutive health check failures that must occur before the instance is
    ///          moved to the Unhealthy state.</p>
    public let unhealthyThreshold: Int

    public init (
        healthyThreshold: Int = 0,
        interval: Int = 0,
        target: String? = nil,
        timeout: Int = 0,
        unhealthyThreshold: Int = 0
    )
    {
        self.healthyThreshold = healthyThreshold
        self.interval = interval
        self.target = target
        self.timeout = timeout
        self.unhealthyThreshold = unhealthyThreshold
    }
}

extension AwsElbLoadBalancerInstance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension AwsElbLoadBalancerInstance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElbLoadBalancerInstance(instanceId: \(String(describing: instanceId)))"}
}

/// <p>Provides information about an EC2 instance for a load balancer.</p>
public struct AwsElbLoadBalancerInstance: Equatable {
    /// <p>The instance identifier.</p>
    public let instanceId: String?

    public init (
        instanceId: String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

extension AwsElbLoadBalancerListener: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instancePort = "InstancePort"
        case instanceProtocol = "InstanceProtocol"
        case loadBalancerPort = "LoadBalancerPort"
        case `protocol` = "Protocol"
        case sslCertificateId = "SslCertificateId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if instancePort != 0 {
            try encodeContainer.encode(instancePort, forKey: .instancePort)
        }
        if let instanceProtocol = instanceProtocol {
            try encodeContainer.encode(instanceProtocol, forKey: .instanceProtocol)
        }
        if loadBalancerPort != 0 {
            try encodeContainer.encode(loadBalancerPort, forKey: .loadBalancerPort)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
        if let sslCertificateId = sslCertificateId {
            try encodeContainer.encode(sslCertificateId, forKey: .sslCertificateId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancePortDecoded = try containerValues.decode(Int.self, forKey: .instancePort)
        instancePort = instancePortDecoded
        let instanceProtocolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceProtocol)
        instanceProtocol = instanceProtocolDecoded
        let loadBalancerPortDecoded = try containerValues.decode(Int.self, forKey: .loadBalancerPort)
        loadBalancerPort = loadBalancerPortDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let sslCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sslCertificateId)
        sslCertificateId = sslCertificateIdDecoded
    }
}

extension AwsElbLoadBalancerListener: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElbLoadBalancerListener(instancePort: \(String(describing: instancePort)), instanceProtocol: \(String(describing: instanceProtocol)), loadBalancerPort: \(String(describing: loadBalancerPort)), protocol: \(String(describing: `protocol`)), sslCertificateId: \(String(describing: sslCertificateId)))"}
}

/// <p>Information about a load balancer listener.</p>
public struct AwsElbLoadBalancerListener: Equatable {
    /// <p>The load balancer transport protocol to use for routing.</p>
    ///          <p>Valid values: <code>HTTP</code> | <code>HTTPS</code> | <code>TCP</code> |
    ///             <code>SSL</code>
    ///          </p>
    public let `protocol`: String?
    /// <p>The port on which the instance is listening.</p>
    public let instancePort: Int
    /// <p>The protocol to use to route traffic to instances.</p>
    ///          <p>Valid values: <code>HTTP</code> | <code>HTTPS</code> | <code>TCP</code> |
    ///             <code>SSL</code>
    ///          </p>
    public let instanceProtocol: String?
    /// <p>The port on which the load balancer is listening.</p>
    ///          <p>On EC2-VPC, you can specify any port from the range 1-65535.</p>
    ///          <p>On EC2-Classic, you can specify any port from the following list: 25, 80, 443, 465, 587,
    ///          1024-65535.</p>
    public let loadBalancerPort: Int
    /// <p>The ARN of the server certificate.</p>
    public let sslCertificateId: String?

    public init (
        `protocol`: String? = nil,
        instancePort: Int = 0,
        instanceProtocol: String? = nil,
        loadBalancerPort: Int = 0,
        sslCertificateId: String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.instancePort = instancePort
        self.instanceProtocol = instanceProtocol
        self.loadBalancerPort = loadBalancerPort
        self.sslCertificateId = sslCertificateId
    }
}

extension AwsElbLoadBalancerListenerDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case listener = "Listener"
        case policyNames = "PolicyNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listener = listener {
            try encodeContainer.encode(listener, forKey: .listener)
        }
        if let policyNames = policyNames {
            var policyNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyNames)
            for stringlist0 in policyNames {
                try policyNamesContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(AwsElbLoadBalancerListener.self, forKey: .listener)
        listener = listenerDecoded
        let policyNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .policyNames)
        var policyNamesDecoded0:[String]? = nil
        if let policyNamesContainer = policyNamesContainer {
            policyNamesDecoded0 = [String]()
            for string0 in policyNamesContainer {
                if let string0 = string0 {
                    policyNamesDecoded0?.append(string0)
                }
            }
        }
        policyNames = policyNamesDecoded0
    }
}

extension AwsElbLoadBalancerListenerDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElbLoadBalancerListenerDescription(listener: \(String(describing: listener)), policyNames: \(String(describing: policyNames)))"}
}

/// <p>Lists the policies that are enabled for a load balancer listener.</p>
public struct AwsElbLoadBalancerListenerDescription: Equatable {
    /// <p>Information about the listener.</p>
    public let listener: AwsElbLoadBalancerListener?
    /// <p>The policies enabled for the listener.</p>
    public let policyNames: [String]?

    public init (
        listener: AwsElbLoadBalancerListener? = nil,
        policyNames: [String]? = nil
    )
    {
        self.listener = listener
        self.policyNames = policyNames
    }
}

extension AwsElbLoadBalancerPolicies: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appCookieStickinessPolicies = "AppCookieStickinessPolicies"
        case lbCookieStickinessPolicies = "LbCookieStickinessPolicies"
        case otherPolicies = "OtherPolicies"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appCookieStickinessPolicies = appCookieStickinessPolicies {
            var appCookieStickinessPoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appCookieStickinessPolicies)
            for awselbappcookiestickinesspolicies0 in appCookieStickinessPolicies {
                try appCookieStickinessPoliciesContainer.encode(awselbappcookiestickinesspolicies0)
            }
        }
        if let lbCookieStickinessPolicies = lbCookieStickinessPolicies {
            var lbCookieStickinessPoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lbCookieStickinessPolicies)
            for awselblbcookiestickinesspolicies0 in lbCookieStickinessPolicies {
                try lbCookieStickinessPoliciesContainer.encode(awselblbcookiestickinesspolicies0)
            }
        }
        if let otherPolicies = otherPolicies {
            var otherPoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .otherPolicies)
            for stringlist0 in otherPolicies {
                try otherPoliciesContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appCookieStickinessPoliciesContainer = try containerValues.decodeIfPresent([AwsElbAppCookieStickinessPolicy?].self, forKey: .appCookieStickinessPolicies)
        var appCookieStickinessPoliciesDecoded0:[AwsElbAppCookieStickinessPolicy]? = nil
        if let appCookieStickinessPoliciesContainer = appCookieStickinessPoliciesContainer {
            appCookieStickinessPoliciesDecoded0 = [AwsElbAppCookieStickinessPolicy]()
            for structure0 in appCookieStickinessPoliciesContainer {
                if let structure0 = structure0 {
                    appCookieStickinessPoliciesDecoded0?.append(structure0)
                }
            }
        }
        appCookieStickinessPolicies = appCookieStickinessPoliciesDecoded0
        let lbCookieStickinessPoliciesContainer = try containerValues.decodeIfPresent([AwsElbLbCookieStickinessPolicy?].self, forKey: .lbCookieStickinessPolicies)
        var lbCookieStickinessPoliciesDecoded0:[AwsElbLbCookieStickinessPolicy]? = nil
        if let lbCookieStickinessPoliciesContainer = lbCookieStickinessPoliciesContainer {
            lbCookieStickinessPoliciesDecoded0 = [AwsElbLbCookieStickinessPolicy]()
            for structure0 in lbCookieStickinessPoliciesContainer {
                if let structure0 = structure0 {
                    lbCookieStickinessPoliciesDecoded0?.append(structure0)
                }
            }
        }
        lbCookieStickinessPolicies = lbCookieStickinessPoliciesDecoded0
        let otherPoliciesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .otherPolicies)
        var otherPoliciesDecoded0:[String]? = nil
        if let otherPoliciesContainer = otherPoliciesContainer {
            otherPoliciesDecoded0 = [String]()
            for string0 in otherPoliciesContainer {
                if let string0 = string0 {
                    otherPoliciesDecoded0?.append(string0)
                }
            }
        }
        otherPolicies = otherPoliciesDecoded0
    }
}

extension AwsElbLoadBalancerPolicies: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElbLoadBalancerPolicies(appCookieStickinessPolicies: \(String(describing: appCookieStickinessPolicies)), lbCookieStickinessPolicies: \(String(describing: lbCookieStickinessPolicies)), otherPolicies: \(String(describing: otherPolicies)))"}
}

/// <p>Contains information about the policies for a load balancer.</p>
public struct AwsElbLoadBalancerPolicies: Equatable {
    /// <p>The stickiness policies that are created using
    ///             <code>CreateAppCookieStickinessPolicy</code>.</p>
    public let appCookieStickinessPolicies: [AwsElbAppCookieStickinessPolicy]?
    /// <p>The stickiness policies that are created using
    ///             <code>CreateLBCookieStickinessPolicy</code>.</p>
    public let lbCookieStickinessPolicies: [AwsElbLbCookieStickinessPolicy]?
    /// <p>The policies other than the stickiness policies.</p>
    public let otherPolicies: [String]?

    public init (
        appCookieStickinessPolicies: [AwsElbAppCookieStickinessPolicy]? = nil,
        lbCookieStickinessPolicies: [AwsElbLbCookieStickinessPolicy]? = nil,
        otherPolicies: [String]? = nil
    )
    {
        self.appCookieStickinessPolicies = appCookieStickinessPolicies
        self.lbCookieStickinessPolicies = lbCookieStickinessPolicies
        self.otherPolicies = otherPolicies
    }
}

extension AwsElbLoadBalancerSourceSecurityGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupName = "GroupName"
        case ownerAlias = "OwnerAlias"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let ownerAlias = ownerAlias {
            try encodeContainer.encode(ownerAlias, forKey: .ownerAlias)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let ownerAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAlias)
        ownerAlias = ownerAliasDecoded
    }
}

extension AwsElbLoadBalancerSourceSecurityGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElbLoadBalancerSourceSecurityGroup(groupName: \(String(describing: groupName)), ownerAlias: \(String(describing: ownerAlias)))"}
}

/// <p>Contains information about the security group for the load balancer.</p>
public struct AwsElbLoadBalancerSourceSecurityGroup: Equatable {
    /// <p>The name of the security group.</p>
    public let groupName: String?
    /// <p>The owner of the security group.</p>
    public let ownerAlias: String?

    public init (
        groupName: String? = nil,
        ownerAlias: String? = nil
    )
    {
        self.groupName = groupName
        self.ownerAlias = ownerAlias
    }
}

extension AwsElbv2LoadBalancerDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
        case canonicalHostedZoneId = "CanonicalHostedZoneId"
        case createdTime = "CreatedTime"
        case dNSName = "DNSName"
        case ipAddressType = "IpAddressType"
        case scheme = "Scheme"
        case securityGroups = "SecurityGroups"
        case state = "State"
        case type = "Type"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzones0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzones0)
            }
        }
        if let canonicalHostedZoneId = canonicalHostedZoneId {
            try encodeContainer.encode(canonicalHostedZoneId, forKey: .canonicalHostedZoneId)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let dNSName = dNSName {
            try encodeContainer.encode(dNSName, forKey: .dNSName)
        }
        if let ipAddressType = ipAddressType {
            try encodeContainer.encode(ipAddressType, forKey: .ipAddressType)
        }
        if let scheme = scheme {
            try encodeContainer.encode(scheme, forKey: .scheme)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroups0 in securityGroups {
                try securityGroupsContainer.encode(securitygroups0)
            }
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZonesContainer = try containerValues.decodeIfPresent([AvailabilityZone?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[AvailabilityZone]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [AvailabilityZone]()
            for structure0 in availabilityZonesContainer {
                if let structure0 = structure0 {
                    availabilityZonesDecoded0?.append(structure0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let canonicalHostedZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .canonicalHostedZoneId)
        canonicalHostedZoneId = canonicalHostedZoneIdDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let dNSNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dNSName)
        dNSName = dNSNameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let schemeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheme)
        scheme = schemeDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LoadBalancerState.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension AwsElbv2LoadBalancerDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsElbv2LoadBalancerDetails(availabilityZones: \(String(describing: availabilityZones)), canonicalHostedZoneId: \(String(describing: canonicalHostedZoneId)), createdTime: \(String(describing: createdTime)), dNSName: \(String(describing: dNSName)), ipAddressType: \(String(describing: ipAddressType)), scheme: \(String(describing: scheme)), securityGroups: \(String(describing: securityGroups)), state: \(String(describing: state)), type: \(String(describing: type)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Information about a load balancer.</p>
public struct AwsElbv2LoadBalancerDetails: Equatable {
    /// <p>The Availability Zones for the load balancer.</p>
    public let availabilityZones: [AvailabilityZone]?
    /// <p>The ID of the Amazon Route 53 hosted zone associated with the load balancer.</p>
    public let canonicalHostedZoneId: String?
    /// <p>Indicates when the load balancer was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let createdTime: String?
    /// <p>The public DNS name of the load balancer.</p>
    public let dNSName: String?
    /// <p>The type of IP addresses used by the subnets for your load balancer. The possible values
    ///          are <code>ipv4</code> (for IPv4 addresses) and <code>dualstack</code> (for IPv4 and IPv6
    ///          addresses).</p>
    public let ipAddressType: String?
    /// <p>The nodes of an Internet-facing load balancer have public IP addresses.</p>
    public let scheme: String?
    /// <p>The IDs of the security groups for the load balancer.</p>
    public let securityGroups: [String]?
    /// <p>The state of the load balancer.</p>
    public let state: LoadBalancerState?
    /// <p>The type of load balancer.</p>
    public let type: String?
    /// <p>The ID of the VPC for the load balancer.</p>
    public let vpcId: String?

    public init (
        availabilityZones: [AvailabilityZone]? = nil,
        canonicalHostedZoneId: String? = nil,
        createdTime: String? = nil,
        dNSName: String? = nil,
        ipAddressType: String? = nil,
        scheme: String? = nil,
        securityGroups: [String]? = nil,
        state: LoadBalancerState? = nil,
        type: String? = nil,
        vpcId: String? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.canonicalHostedZoneId = canonicalHostedZoneId
        self.createdTime = createdTime
        self.dNSName = dNSName
        self.ipAddressType = ipAddressType
        self.scheme = scheme
        self.securityGroups = securityGroups
        self.state = state
        self.type = type
        self.vpcId = vpcId
    }
}

extension AwsIamAccessKeyDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessKeyId = "AccessKeyId"
        case accountId = "AccountId"
        case createdAt = "CreatedAt"
        case principalId = "PrincipalId"
        case principalName = "PrincipalName"
        case principalType = "PrincipalType"
        case sessionContext = "SessionContext"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalName = principalName {
            try encodeContainer.encode(principalName, forKey: .principalName)
        }
        if let principalType = principalType {
            try encodeContainer.encode(principalType, forKey: .principalType)
        }
        if let sessionContext = sessionContext {
            try encodeContainer.encode(sessionContext, forKey: .sessionContext)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AwsIamAccessKeyStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let principalNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalName)
        principalName = principalNameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let sessionContextDecoded = try containerValues.decodeIfPresent(AwsIamAccessKeySessionContext.self, forKey: .sessionContext)
        sessionContext = sessionContextDecoded
    }
}

extension AwsIamAccessKeyDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsIamAccessKeyDetails(accessKeyId: \(String(describing: accessKeyId)), accountId: \(String(describing: accountId)), createdAt: \(String(describing: createdAt)), principalId: \(String(describing: principalId)), principalName: \(String(describing: principalName)), principalType: \(String(describing: principalType)), sessionContext: \(String(describing: sessionContext)), status: \(String(describing: status)), userName: \(String(describing: userName)))"}
}

/// <p>IAM access key details related to a finding.</p>
public struct AwsIamAccessKeyDetails: Equatable {
    /// <p>The identifier of the access key.</p>
    public let accessKeyId: String?
    /// <p>The AWS account ID of the account for the key.</p>
    public let accountId: String?
    /// <p>Indicates when the IAM access key was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let createdAt: String?
    /// <p>The ID of the principal associated with an access key.</p>
    public let principalId: String?
    /// <p>The name of the principal.</p>
    public let principalName: String?
    /// <p>The type of principal associated with an access key.</p>
    public let principalType: String?
    /// <p>Information about the session that the key was used for.</p>
    public let sessionContext: AwsIamAccessKeySessionContext?
    /// <p>The status of the IAM access key related to a finding.</p>
    public let status: AwsIamAccessKeyStatus?
    /// <p>The user associated with the IAM access key related to a finding.</p>
    ///          <p>The <code>UserName</code> parameter has been replaced with the
    ///             <code>PrincipalName</code> parameter because access keys can also be assigned to
    ///          principals that are not IAM users.</p>
    @available(*, deprecated, message: "This field is deprecated, use PrincipalName instead.")
    public let userName: String?

    public init (
        accessKeyId: String? = nil,
        accountId: String? = nil,
        createdAt: String? = nil,
        principalId: String? = nil,
        principalName: String? = nil,
        principalType: String? = nil,
        sessionContext: AwsIamAccessKeySessionContext? = nil,
        status: AwsIamAccessKeyStatus? = nil,
        userName: String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.accountId = accountId
        self.createdAt = createdAt
        self.principalId = principalId
        self.principalName = principalName
        self.principalType = principalType
        self.sessionContext = sessionContext
        self.status = status
        self.userName = userName
    }
}

extension AwsIamAccessKeySessionContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case sessionIssuer = "SessionIssuer"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let sessionIssuer = sessionIssuer {
            try encodeContainer.encode(sessionIssuer, forKey: .sessionIssuer)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesDecoded = try containerValues.decodeIfPresent(AwsIamAccessKeySessionContextAttributes.self, forKey: .attributes)
        attributes = attributesDecoded
        let sessionIssuerDecoded = try containerValues.decodeIfPresent(AwsIamAccessKeySessionContextSessionIssuer.self, forKey: .sessionIssuer)
        sessionIssuer = sessionIssuerDecoded
    }
}

extension AwsIamAccessKeySessionContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsIamAccessKeySessionContext(attributes: \(String(describing: attributes)), sessionIssuer: \(String(describing: sessionIssuer)))"}
}

/// <p>Provides information about the session that the key was used for.</p>
public struct AwsIamAccessKeySessionContext: Equatable {
    /// <p>Attributes of the session that the key was used for.</p>
    public let attributes: AwsIamAccessKeySessionContextAttributes?
    /// <p>Information about the entity that created the session.</p>
    public let sessionIssuer: AwsIamAccessKeySessionContextSessionIssuer?

    public init (
        attributes: AwsIamAccessKeySessionContextAttributes? = nil,
        sessionIssuer: AwsIamAccessKeySessionContextSessionIssuer? = nil
    )
    {
        self.attributes = attributes
        self.sessionIssuer = sessionIssuer
    }
}

extension AwsIamAccessKeySessionContextAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case mfaAuthenticated = "MfaAuthenticated"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if mfaAuthenticated != false {
            try encodeContainer.encode(mfaAuthenticated, forKey: .mfaAuthenticated)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mfaAuthenticatedDecoded = try containerValues.decode(Bool.self, forKey: .mfaAuthenticated)
        mfaAuthenticated = mfaAuthenticatedDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension AwsIamAccessKeySessionContextAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsIamAccessKeySessionContextAttributes(creationDate: \(String(describing: creationDate)), mfaAuthenticated: \(String(describing: mfaAuthenticated)))"}
}

/// <p>Attributes of the session that the key was used for.</p>
public struct AwsIamAccessKeySessionContextAttributes: Equatable {
    /// <p>Indicates when the session was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let creationDate: String?
    /// <p>Indicates whether the session used multi-factor authentication (MFA).</p>
    public let mfaAuthenticated: Bool

    public init (
        creationDate: String? = nil,
        mfaAuthenticated: Bool = false
    )
    {
        self.creationDate = creationDate
        self.mfaAuthenticated = mfaAuthenticated
    }
}

extension AwsIamAccessKeySessionContextSessionIssuer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case arn = "Arn"
        case principalId = "PrincipalId"
        case type = "Type"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension AwsIamAccessKeySessionContextSessionIssuer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsIamAccessKeySessionContextSessionIssuer(accountId: \(String(describing: accountId)), arn: \(String(describing: arn)), principalId: \(String(describing: principalId)), type: \(String(describing: type)), userName: \(String(describing: userName)))"}
}

/// <p>Information about the entity that created the session.</p>
public struct AwsIamAccessKeySessionContextSessionIssuer: Equatable {
    /// <p>The identifier of the AWS account that created the session.</p>
    public let accountId: String?
    /// <p>The ARN of the session.</p>
    public let arn: String?
    /// <p>The principal ID of the principal (user, role, or group) that created the
    ///          session.</p>
    public let principalId: String?
    /// <p>The type of principal (user, role, or group) that created the session.</p>
    public let type: String?
    /// <p>The name of the principal that created the session.</p>
    public let userName: String?

    public init (
        accountId: String? = nil,
        arn: String? = nil,
        principalId: String? = nil,
        type: String? = nil,
        userName: String? = nil
    )
    {
        self.accountId = accountId
        self.arn = arn
        self.principalId = principalId
        self.type = type
        self.userName = userName
    }
}

public enum AwsIamAccessKeyStatus {
    case active
    case inactive
    case sdkUnknown(String)
}

extension AwsIamAccessKeyStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AwsIamAccessKeyStatus] {
        return [
            .active,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "Active"
        case .inactive: return "Inactive"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AwsIamAccessKeyStatus(rawValue: rawValue) ?? AwsIamAccessKeyStatus.sdkUnknown(rawValue)
    }
}

extension AwsIamAttachedManagedPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyArn = "PolicyArn"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension AwsIamAttachedManagedPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsIamAttachedManagedPolicy(policyArn: \(String(describing: policyArn)), policyName: \(String(describing: policyName)))"}
}

/// <p>A managed policy that is attached to an IAM principal.</p>
public struct AwsIamAttachedManagedPolicy: Equatable {
    /// <p>The ARN of the policy.</p>
    public let policyArn: String?
    /// <p>The name of the policy.</p>
    public let policyName: String?

    public init (
        policyArn: String? = nil,
        policyName: String? = nil
    )
    {
        self.policyArn = policyArn
        self.policyName = policyName
    }
}

extension AwsIamGroupDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case createDate = "CreateDate"
        case groupId = "GroupId"
        case groupName = "GroupName"
        case groupPolicyList = "GroupPolicyList"
        case path = "Path"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachedManagedPolicies = attachedManagedPolicies {
            var attachedManagedPoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachedManagedPolicies)
            for awsiamattachedmanagedpolicylist0 in attachedManagedPolicies {
                try attachedManagedPoliciesContainer.encode(awsiamattachedmanagedpolicylist0)
            }
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate, forKey: .createDate)
        }
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let groupPolicyList = groupPolicyList {
            var groupPolicyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupPolicyList)
            for awsiamgrouppolicylist0 in groupPolicyList {
                try groupPolicyListContainer.encode(awsiamgrouppolicylist0)
            }
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedManagedPoliciesContainer = try containerValues.decodeIfPresent([AwsIamAttachedManagedPolicy?].self, forKey: .attachedManagedPolicies)
        var attachedManagedPoliciesDecoded0:[AwsIamAttachedManagedPolicy]? = nil
        if let attachedManagedPoliciesContainer = attachedManagedPoliciesContainer {
            attachedManagedPoliciesDecoded0 = [AwsIamAttachedManagedPolicy]()
            for structure0 in attachedManagedPoliciesContainer {
                if let structure0 = structure0 {
                    attachedManagedPoliciesDecoded0?.append(structure0)
                }
            }
        }
        attachedManagedPolicies = attachedManagedPoliciesDecoded0
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        createDate = createDateDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupPolicyListContainer = try containerValues.decodeIfPresent([AwsIamGroupPolicy?].self, forKey: .groupPolicyList)
        var groupPolicyListDecoded0:[AwsIamGroupPolicy]? = nil
        if let groupPolicyListContainer = groupPolicyListContainer {
            groupPolicyListDecoded0 = [AwsIamGroupPolicy]()
            for structure0 in groupPolicyListContainer {
                if let structure0 = structure0 {
                    groupPolicyListDecoded0?.append(structure0)
                }
            }
        }
        groupPolicyList = groupPolicyListDecoded0
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
    }
}

extension AwsIamGroupDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsIamGroupDetails(attachedManagedPolicies: \(String(describing: attachedManagedPolicies)), createDate: \(String(describing: createDate)), groupId: \(String(describing: groupId)), groupName: \(String(describing: groupName)), groupPolicyList: \(String(describing: groupPolicyList)), path: \(String(describing: path)))"}
}

/// <p>Contains details about an IAM group.</p>
public struct AwsIamGroupDetails: Equatable {
    /// <p>A list of the managed policies that are attached to the IAM group.</p>
    public let attachedManagedPolicies: [AwsIamAttachedManagedPolicy]?
    /// <p>Indicates when the IAM group was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let createDate: String?
    /// <p>The identifier of the IAM group.</p>
    public let groupId: String?
    /// <p>The name of the IAM group.</p>
    public let groupName: String?
    /// <p>The list of inline policies that are embedded in the group.</p>
    public let groupPolicyList: [AwsIamGroupPolicy]?
    /// <p>The path to the group.</p>
    public let path: String?

    public init (
        attachedManagedPolicies: [AwsIamAttachedManagedPolicy]? = nil,
        createDate: String? = nil,
        groupId: String? = nil,
        groupName: String? = nil,
        groupPolicyList: [AwsIamGroupPolicy]? = nil,
        path: String? = nil
    )
    {
        self.attachedManagedPolicies = attachedManagedPolicies
        self.createDate = createDate
        self.groupId = groupId
        self.groupName = groupName
        self.groupPolicyList = groupPolicyList
        self.path = path
    }
}

extension AwsIamGroupPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension AwsIamGroupPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsIamGroupPolicy(policyName: \(String(describing: policyName)))"}
}

/// <p>A managed policy that is attached to the IAM group.</p>
public struct AwsIamGroupPolicy: Equatable {
    /// <p>The name of the policy.</p>
    public let policyName: String?

    public init (
        policyName: String? = nil
    )
    {
        self.policyName = policyName
    }
}

extension AwsIamInstanceProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case instanceProfileId = "InstanceProfileId"
        case instanceProfileName = "InstanceProfileName"
        case path = "Path"
        case roles = "Roles"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate, forKey: .createDate)
        }
        if let instanceProfileId = instanceProfileId {
            try encodeContainer.encode(instanceProfileId, forKey: .instanceProfileId)
        }
        if let instanceProfileName = instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for awsiaminstanceprofileroles0 in roles {
                try rolesContainer.encode(awsiaminstanceprofileroles0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        createDate = createDateDecoded
        let instanceProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceProfileId)
        instanceProfileId = instanceProfileIdDecoded
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let rolesContainer = try containerValues.decodeIfPresent([AwsIamInstanceProfileRole?].self, forKey: .roles)
        var rolesDecoded0:[AwsIamInstanceProfileRole]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [AwsIamInstanceProfileRole]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
    }
}

extension AwsIamInstanceProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsIamInstanceProfile(arn: \(String(describing: arn)), createDate: \(String(describing: createDate)), instanceProfileId: \(String(describing: instanceProfileId)), instanceProfileName: \(String(describing: instanceProfileName)), path: \(String(describing: path)), roles: \(String(describing: roles)))"}
}

/// <p>Information about an instance profile.</p>
public struct AwsIamInstanceProfile: Equatable {
    /// <p>The ARN of the instance profile.</p>
    public let arn: String?
    /// <p>Indicates when the instance profile was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let createDate: String?
    /// <p>The identifier of the instance profile.</p>
    public let instanceProfileId: String?
    /// <p>The name of the instance profile.</p>
    public let instanceProfileName: String?
    /// <p>The path to the instance profile.</p>
    public let path: String?
    /// <p>The roles associated with the instance profile.</p>
    public let roles: [AwsIamInstanceProfileRole]?

    public init (
        arn: String? = nil,
        createDate: String? = nil,
        instanceProfileId: String? = nil,
        instanceProfileName: String? = nil,
        path: String? = nil,
        roles: [AwsIamInstanceProfileRole]? = nil
    )
    {
        self.arn = arn
        self.createDate = createDate
        self.instanceProfileId = instanceProfileId
        self.instanceProfileName = instanceProfileName
        self.path = path
        self.roles = roles
    }
}

extension AwsIamInstanceProfileRole: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
        case createDate = "CreateDate"
        case path = "Path"
        case roleId = "RoleId"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assumeRolePolicyDocument = assumeRolePolicyDocument {
            try encodeContainer.encode(assumeRolePolicyDocument, forKey: .assumeRolePolicyDocument)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate, forKey: .createDate)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let roleId = roleId {
            try encodeContainer.encode(roleId, forKey: .roleId)
        }
        if let roleName = roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let assumeRolePolicyDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assumeRolePolicyDocument)
        assumeRolePolicyDocument = assumeRolePolicyDocumentDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        createDate = createDateDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let roleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleId)
        roleId = roleIdDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleName)
        roleName = roleNameDecoded
    }
}

extension AwsIamInstanceProfileRole: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsIamInstanceProfileRole(arn: \(String(describing: arn)), assumeRolePolicyDocument: \(String(describing: assumeRolePolicyDocument)), createDate: \(String(describing: createDate)), path: \(String(describing: path)), roleId: \(String(describing: roleId)), roleName: \(String(describing: roleName)))"}
}

/// <p>Information about a role associated with an instance profile.</p>
public struct AwsIamInstanceProfileRole: Equatable {
    /// <p>The ARN of the role.</p>
    public let arn: String?
    /// <p>The policy that grants an entity permission to assume the role.</p>
    public let assumeRolePolicyDocument: String?
    /// <p>Indicates when the role was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let createDate: String?
    /// <p>The path to the role.</p>
    public let path: String?
    /// <p>The identifier of the role.</p>
    public let roleId: String?
    /// <p>The name of the role.</p>
    public let roleName: String?

    public init (
        arn: String? = nil,
        assumeRolePolicyDocument: String? = nil,
        createDate: String? = nil,
        path: String? = nil,
        roleId: String? = nil,
        roleName: String? = nil
    )
    {
        self.arn = arn
        self.assumeRolePolicyDocument = assumeRolePolicyDocument
        self.createDate = createDate
        self.path = path
        self.roleId = roleId
        self.roleName = roleName
    }
}

extension AwsIamPermissionsBoundary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case permissionsBoundaryArn = "PermissionsBoundaryArn"
        case permissionsBoundaryType = "PermissionsBoundaryType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionsBoundaryArn = permissionsBoundaryArn {
            try encodeContainer.encode(permissionsBoundaryArn, forKey: .permissionsBoundaryArn)
        }
        if let permissionsBoundaryType = permissionsBoundaryType {
            try encodeContainer.encode(permissionsBoundaryType, forKey: .permissionsBoundaryType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsBoundaryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionsBoundaryArn)
        permissionsBoundaryArn = permissionsBoundaryArnDecoded
        let permissionsBoundaryTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionsBoundaryType)
        permissionsBoundaryType = permissionsBoundaryTypeDecoded
    }
}

extension AwsIamPermissionsBoundary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsIamPermissionsBoundary(permissionsBoundaryArn: \(String(describing: permissionsBoundaryArn)), permissionsBoundaryType: \(String(describing: permissionsBoundaryType)))"}
}

/// <p>Information about the policy used to set the permissions boundary for an IAM
///          principal.</p>
public struct AwsIamPermissionsBoundary: Equatable {
    /// <p>The ARN of the policy used to set the permissions boundary.</p>
    public let permissionsBoundaryArn: String?
    /// <p>The usage type for the permissions boundary.</p>
    public let permissionsBoundaryType: String?

    public init (
        permissionsBoundaryArn: String? = nil,
        permissionsBoundaryType: String? = nil
    )
    {
        self.permissionsBoundaryArn = permissionsBoundaryArn
        self.permissionsBoundaryType = permissionsBoundaryType
    }
}

extension AwsIamPolicyDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachmentCount = "AttachmentCount"
        case createDate = "CreateDate"
        case defaultVersionId = "DefaultVersionId"
        case description = "Description"
        case isAttachable = "IsAttachable"
        case path = "Path"
        case permissionsBoundaryUsageCount = "PermissionsBoundaryUsageCount"
        case policyId = "PolicyId"
        case policyName = "PolicyName"
        case policyVersionList = "PolicyVersionList"
        case updateDate = "UpdateDate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if attachmentCount != 0 {
            try encodeContainer.encode(attachmentCount, forKey: .attachmentCount)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate, forKey: .createDate)
        }
        if let defaultVersionId = defaultVersionId {
            try encodeContainer.encode(defaultVersionId, forKey: .defaultVersionId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if isAttachable != false {
            try encodeContainer.encode(isAttachable, forKey: .isAttachable)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if permissionsBoundaryUsageCount != 0 {
            try encodeContainer.encode(permissionsBoundaryUsageCount, forKey: .permissionsBoundaryUsageCount)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let policyVersionList = policyVersionList {
            var policyVersionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyVersionList)
            for awsiampolicyversionlist0 in policyVersionList {
                try policyVersionListContainer.encode(awsiampolicyversionlist0)
            }
        }
        if let updateDate = updateDate {
            try encodeContainer.encode(updateDate, forKey: .updateDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentCountDecoded = try containerValues.decode(Int.self, forKey: .attachmentCount)
        attachmentCount = attachmentCountDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        createDate = createDateDecoded
        let defaultVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultVersionId)
        defaultVersionId = defaultVersionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let isAttachableDecoded = try containerValues.decode(Bool.self, forKey: .isAttachable)
        isAttachable = isAttachableDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let permissionsBoundaryUsageCountDecoded = try containerValues.decode(Int.self, forKey: .permissionsBoundaryUsageCount)
        permissionsBoundaryUsageCount = permissionsBoundaryUsageCountDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyVersionListContainer = try containerValues.decodeIfPresent([AwsIamPolicyVersion?].self, forKey: .policyVersionList)
        var policyVersionListDecoded0:[AwsIamPolicyVersion]? = nil
        if let policyVersionListContainer = policyVersionListContainer {
            policyVersionListDecoded0 = [AwsIamPolicyVersion]()
            for structure0 in policyVersionListContainer {
                if let structure0 = structure0 {
                    policyVersionListDecoded0?.append(structure0)
                }
            }
        }
        policyVersionList = policyVersionListDecoded0
        let updateDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateDate)
        updateDate = updateDateDecoded
    }
}

extension AwsIamPolicyDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsIamPolicyDetails(attachmentCount: \(String(describing: attachmentCount)), createDate: \(String(describing: createDate)), defaultVersionId: \(String(describing: defaultVersionId)), description: \(String(describing: description)), isAttachable: \(String(describing: isAttachable)), path: \(String(describing: path)), permissionsBoundaryUsageCount: \(String(describing: permissionsBoundaryUsageCount)), policyId: \(String(describing: policyId)), policyName: \(String(describing: policyName)), policyVersionList: \(String(describing: policyVersionList)), updateDate: \(String(describing: updateDate)))"}
}

/// <p>Represents an IAM permissions policy.</p>
public struct AwsIamPolicyDetails: Equatable {
    /// <p>The number of users, groups, and roles that the policy is attached to.</p>
    public let attachmentCount: Int
    /// <p>When the policy was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let createDate: String?
    /// <p>The identifier of the default version of the policy.</p>
    public let defaultVersionId: String?
    /// <p>A description of the policy.</p>
    public let description: String?
    /// <p>Whether the policy can be attached to a user, group, or role.</p>
    public let isAttachable: Bool
    /// <p>The path to the policy.</p>
    public let path: String?
    /// <p>The number of users and roles that use the policy to set the permissions
    ///          boundary.</p>
    public let permissionsBoundaryUsageCount: Int
    /// <p>The unique identifier of the policy.</p>
    public let policyId: String?
    /// <p>The name of the policy.</p>
    public let policyName: String?
    /// <p>List of versions of the policy.</p>
    public let policyVersionList: [AwsIamPolicyVersion]?
    /// <p>When the policy was most recently updated.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let updateDate: String?

    public init (
        attachmentCount: Int = 0,
        createDate: String? = nil,
        defaultVersionId: String? = nil,
        description: String? = nil,
        isAttachable: Bool = false,
        path: String? = nil,
        permissionsBoundaryUsageCount: Int = 0,
        policyId: String? = nil,
        policyName: String? = nil,
        policyVersionList: [AwsIamPolicyVersion]? = nil,
        updateDate: String? = nil
    )
    {
        self.attachmentCount = attachmentCount
        self.createDate = createDate
        self.defaultVersionId = defaultVersionId
        self.description = description
        self.isAttachable = isAttachable
        self.path = path
        self.permissionsBoundaryUsageCount = permissionsBoundaryUsageCount
        self.policyId = policyId
        self.policyName = policyName
        self.policyVersionList = policyVersionList
        self.updateDate = updateDate
    }
}

extension AwsIamPolicyVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createDate = "CreateDate"
        case isDefaultVersion = "IsDefaultVersion"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createDate = createDate {
            try encodeContainer.encode(createDate, forKey: .createDate)
        }
        if isDefaultVersion != false {
            try encodeContainer.encode(isDefaultVersion, forKey: .isDefaultVersion)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let isDefaultVersionDecoded = try containerValues.decode(Bool.self, forKey: .isDefaultVersion)
        isDefaultVersion = isDefaultVersionDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension AwsIamPolicyVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsIamPolicyVersion(createDate: \(String(describing: createDate)), isDefaultVersion: \(String(describing: isDefaultVersion)), versionId: \(String(describing: versionId)))"}
}

/// <p>A version of an IAM policy.</p>
public struct AwsIamPolicyVersion: Equatable {
    /// <p>Indicates when the version was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let createDate: String?
    /// <p>Whether the version is the default version.</p>
    public let isDefaultVersion: Bool
    /// <p>The identifier of the policy version.</p>
    public let versionId: String?

    public init (
        createDate: String? = nil,
        isDefaultVersion: Bool = false,
        versionId: String? = nil
    )
    {
        self.createDate = createDate
        self.isDefaultVersion = isDefaultVersion
        self.versionId = versionId
    }
}

extension AwsIamRoleDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case createDate = "CreateDate"
        case instanceProfileList = "InstanceProfileList"
        case maxSessionDuration = "MaxSessionDuration"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case roleId = "RoleId"
        case roleName = "RoleName"
        case rolePolicyList = "RolePolicyList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assumeRolePolicyDocument = assumeRolePolicyDocument {
            try encodeContainer.encode(assumeRolePolicyDocument, forKey: .assumeRolePolicyDocument)
        }
        if let attachedManagedPolicies = attachedManagedPolicies {
            var attachedManagedPoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachedManagedPolicies)
            for awsiamattachedmanagedpolicylist0 in attachedManagedPolicies {
                try attachedManagedPoliciesContainer.encode(awsiamattachedmanagedpolicylist0)
            }
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate, forKey: .createDate)
        }
        if let instanceProfileList = instanceProfileList {
            var instanceProfileListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceProfileList)
            for awsiaminstanceprofilelist0 in instanceProfileList {
                try instanceProfileListContainer.encode(awsiaminstanceprofilelist0)
            }
        }
        if maxSessionDuration != 0 {
            try encodeContainer.encode(maxSessionDuration, forKey: .maxSessionDuration)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let permissionsBoundary = permissionsBoundary {
            try encodeContainer.encode(permissionsBoundary, forKey: .permissionsBoundary)
        }
        if let roleId = roleId {
            try encodeContainer.encode(roleId, forKey: .roleId)
        }
        if let roleName = roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let rolePolicyList = rolePolicyList {
            var rolePolicyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rolePolicyList)
            for awsiamrolepolicylist0 in rolePolicyList {
                try rolePolicyListContainer.encode(awsiamrolepolicylist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assumeRolePolicyDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assumeRolePolicyDocument)
        assumeRolePolicyDocument = assumeRolePolicyDocumentDecoded
        let attachedManagedPoliciesContainer = try containerValues.decodeIfPresent([AwsIamAttachedManagedPolicy?].self, forKey: .attachedManagedPolicies)
        var attachedManagedPoliciesDecoded0:[AwsIamAttachedManagedPolicy]? = nil
        if let attachedManagedPoliciesContainer = attachedManagedPoliciesContainer {
            attachedManagedPoliciesDecoded0 = [AwsIamAttachedManagedPolicy]()
            for structure0 in attachedManagedPoliciesContainer {
                if let structure0 = structure0 {
                    attachedManagedPoliciesDecoded0?.append(structure0)
                }
            }
        }
        attachedManagedPolicies = attachedManagedPoliciesDecoded0
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        createDate = createDateDecoded
        let instanceProfileListContainer = try containerValues.decodeIfPresent([AwsIamInstanceProfile?].self, forKey: .instanceProfileList)
        var instanceProfileListDecoded0:[AwsIamInstanceProfile]? = nil
        if let instanceProfileListContainer = instanceProfileListContainer {
            instanceProfileListDecoded0 = [AwsIamInstanceProfile]()
            for structure0 in instanceProfileListContainer {
                if let structure0 = structure0 {
                    instanceProfileListDecoded0?.append(structure0)
                }
            }
        }
        instanceProfileList = instanceProfileListDecoded0
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(AwsIamPermissionsBoundary.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
        let roleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleId)
        roleId = roleIdDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let rolePolicyListContainer = try containerValues.decodeIfPresent([AwsIamRolePolicy?].self, forKey: .rolePolicyList)
        var rolePolicyListDecoded0:[AwsIamRolePolicy]? = nil
        if let rolePolicyListContainer = rolePolicyListContainer {
            rolePolicyListDecoded0 = [AwsIamRolePolicy]()
            for structure0 in rolePolicyListContainer {
                if let structure0 = structure0 {
                    rolePolicyListDecoded0?.append(structure0)
                }
            }
        }
        rolePolicyList = rolePolicyListDecoded0
        let maxSessionDurationDecoded = try containerValues.decode(Int.self, forKey: .maxSessionDuration)
        maxSessionDuration = maxSessionDurationDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
    }
}

extension AwsIamRoleDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsIamRoleDetails(assumeRolePolicyDocument: \(String(describing: assumeRolePolicyDocument)), attachedManagedPolicies: \(String(describing: attachedManagedPolicies)), createDate: \(String(describing: createDate)), instanceProfileList: \(String(describing: instanceProfileList)), maxSessionDuration: \(String(describing: maxSessionDuration)), path: \(String(describing: path)), permissionsBoundary: \(String(describing: permissionsBoundary)), roleId: \(String(describing: roleId)), roleName: \(String(describing: roleName)), rolePolicyList: \(String(describing: rolePolicyList)))"}
}

/// <p>Contains information about an IAM role, including all of the role's policies.</p>
public struct AwsIamRoleDetails: Equatable {
    /// <p>The trust policy that grants permission to assume the role.</p>
    public let assumeRolePolicyDocument: String?
    /// <p>The list of the managed policies that are attached to the role.</p>
    public let attachedManagedPolicies: [AwsIamAttachedManagedPolicy]?
    /// <p>Indicates when the role was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let createDate: String?
    /// <p>The list of instance profiles that contain this role.</p>
    public let instanceProfileList: [AwsIamInstanceProfile]?
    /// <p>The maximum session duration (in seconds) that you want to set for the specified role.</p>
    public let maxSessionDuration: Int
    /// <p>The path to the role.</p>
    public let path: String?
    /// <p>Information about the policy used to set the permissions boundary for an IAM
    ///          principal.</p>
    public let permissionsBoundary: AwsIamPermissionsBoundary?
    /// <p>The stable and unique string identifying the role.</p>
    public let roleId: String?
    /// <p>The friendly name that identifies the role.</p>
    public let roleName: String?
    /// <p>The list of inline policies that are embedded in the role.</p>
    public let rolePolicyList: [AwsIamRolePolicy]?

    public init (
        assumeRolePolicyDocument: String? = nil,
        attachedManagedPolicies: [AwsIamAttachedManagedPolicy]? = nil,
        createDate: String? = nil,
        instanceProfileList: [AwsIamInstanceProfile]? = nil,
        maxSessionDuration: Int = 0,
        path: String? = nil,
        permissionsBoundary: AwsIamPermissionsBoundary? = nil,
        roleId: String? = nil,
        roleName: String? = nil,
        rolePolicyList: [AwsIamRolePolicy]? = nil
    )
    {
        self.assumeRolePolicyDocument = assumeRolePolicyDocument
        self.attachedManagedPolicies = attachedManagedPolicies
        self.createDate = createDate
        self.instanceProfileList = instanceProfileList
        self.maxSessionDuration = maxSessionDuration
        self.path = path
        self.permissionsBoundary = permissionsBoundary
        self.roleId = roleId
        self.roleName = roleName
        self.rolePolicyList = rolePolicyList
    }
}

extension AwsIamRolePolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension AwsIamRolePolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsIamRolePolicy(policyName: \(String(describing: policyName)))"}
}

/// <p>An inline policy that is embedded in the role.</p>
public struct AwsIamRolePolicy: Equatable {
    /// <p>The name of the policy.</p>
    public let policyName: String?

    public init (
        policyName: String? = nil
    )
    {
        self.policyName = policyName
    }
}

extension AwsIamUserDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case createDate = "CreateDate"
        case groupList = "GroupList"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case userId = "UserId"
        case userName = "UserName"
        case userPolicyList = "UserPolicyList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachedManagedPolicies = attachedManagedPolicies {
            var attachedManagedPoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachedManagedPolicies)
            for awsiamattachedmanagedpolicylist0 in attachedManagedPolicies {
                try attachedManagedPoliciesContainer.encode(awsiamattachedmanagedpolicylist0)
            }
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate, forKey: .createDate)
        }
        if let groupList = groupList {
            var groupListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupList)
            for stringlist0 in groupList {
                try groupListContainer.encode(stringlist0)
            }
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let permissionsBoundary = permissionsBoundary {
            try encodeContainer.encode(permissionsBoundary, forKey: .permissionsBoundary)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userPolicyList = userPolicyList {
            var userPolicyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userPolicyList)
            for awsiamuserpolicylist0 in userPolicyList {
                try userPolicyListContainer.encode(awsiamuserpolicylist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedManagedPoliciesContainer = try containerValues.decodeIfPresent([AwsIamAttachedManagedPolicy?].self, forKey: .attachedManagedPolicies)
        var attachedManagedPoliciesDecoded0:[AwsIamAttachedManagedPolicy]? = nil
        if let attachedManagedPoliciesContainer = attachedManagedPoliciesContainer {
            attachedManagedPoliciesDecoded0 = [AwsIamAttachedManagedPolicy]()
            for structure0 in attachedManagedPoliciesContainer {
                if let structure0 = structure0 {
                    attachedManagedPoliciesDecoded0?.append(structure0)
                }
            }
        }
        attachedManagedPolicies = attachedManagedPoliciesDecoded0
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        createDate = createDateDecoded
        let groupListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .groupList)
        var groupListDecoded0:[String]? = nil
        if let groupListContainer = groupListContainer {
            groupListDecoded0 = [String]()
            for string0 in groupListContainer {
                if let string0 = string0 {
                    groupListDecoded0?.append(string0)
                }
            }
        }
        groupList = groupListDecoded0
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(AwsIamPermissionsBoundary.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let userPolicyListContainer = try containerValues.decodeIfPresent([AwsIamUserPolicy?].self, forKey: .userPolicyList)
        var userPolicyListDecoded0:[AwsIamUserPolicy]? = nil
        if let userPolicyListContainer = userPolicyListContainer {
            userPolicyListDecoded0 = [AwsIamUserPolicy]()
            for structure0 in userPolicyListContainer {
                if let structure0 = structure0 {
                    userPolicyListDecoded0?.append(structure0)
                }
            }
        }
        userPolicyList = userPolicyListDecoded0
    }
}

extension AwsIamUserDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsIamUserDetails(attachedManagedPolicies: \(String(describing: attachedManagedPolicies)), createDate: \(String(describing: createDate)), groupList: \(String(describing: groupList)), path: \(String(describing: path)), permissionsBoundary: \(String(describing: permissionsBoundary)), userId: \(String(describing: userId)), userName: \(String(describing: userName)), userPolicyList: \(String(describing: userPolicyList)))"}
}

/// <p>Information about an IAM user.</p>
public struct AwsIamUserDetails: Equatable {
    /// <p>A list of the managed policies that are attached to the user.</p>
    public let attachedManagedPolicies: [AwsIamAttachedManagedPolicy]?
    /// <p>Indicates when the user was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let createDate: String?
    /// <p>A list of IAM groups that the user belongs to.</p>
    public let groupList: [String]?
    /// <p>The path to the user.</p>
    public let path: String?
    /// <p>The permissions boundary for the user.</p>
    public let permissionsBoundary: AwsIamPermissionsBoundary?
    /// <p>The unique identifier for the user.</p>
    public let userId: String?
    /// <p>The name of the user.</p>
    public let userName: String?
    /// <p>The list of inline policies that are embedded in the user.</p>
    public let userPolicyList: [AwsIamUserPolicy]?

    public init (
        attachedManagedPolicies: [AwsIamAttachedManagedPolicy]? = nil,
        createDate: String? = nil,
        groupList: [String]? = nil,
        path: String? = nil,
        permissionsBoundary: AwsIamPermissionsBoundary? = nil,
        userId: String? = nil,
        userName: String? = nil,
        userPolicyList: [AwsIamUserPolicy]? = nil
    )
    {
        self.attachedManagedPolicies = attachedManagedPolicies
        self.createDate = createDate
        self.groupList = groupList
        self.path = path
        self.permissionsBoundary = permissionsBoundary
        self.userId = userId
        self.userName = userName
        self.userPolicyList = userPolicyList
    }
}

extension AwsIamUserPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension AwsIamUserPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsIamUserPolicy(policyName: \(String(describing: policyName)))"}
}

/// <p>Information about an inline policy that is embedded in the user.</p>
public struct AwsIamUserPolicy: Equatable {
    /// <p>The name of the policy.</p>
    public let policyName: String?

    public init (
        policyName: String? = nil
    )
    {
        self.policyName = policyName
    }
}

extension AwsKmsKeyDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aWSAccountId = "AWSAccountId"
        case creationDate = "CreationDate"
        case description = "Description"
        case keyId = "KeyId"
        case keyManager = "KeyManager"
        case keyState = "KeyState"
        case origin = "Origin"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aWSAccountId = aWSAccountId {
            try encodeContainer.encode(aWSAccountId, forKey: .aWSAccountId)
        }
        if creationDate != 0.0 {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let keyManager = keyManager {
            try encodeContainer.encode(keyManager, forKey: .keyManager)
        }
        if let keyState = keyState {
            try encodeContainer.encode(keyState, forKey: .keyState)
        }
        if let origin = origin {
            try encodeContainer.encode(origin, forKey: .origin)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aWSAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aWSAccountId)
        aWSAccountId = aWSAccountIdDecoded
        let creationDateDecoded = try containerValues.decode(Double.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let keyManagerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyManager)
        keyManager = keyManagerDecoded
        let keyStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyState)
        keyState = keyStateDecoded
        let originDecoded = try containerValues.decodeIfPresent(String.self, forKey: .origin)
        origin = originDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AwsKmsKeyDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsKmsKeyDetails(aWSAccountId: \(String(describing: aWSAccountId)), creationDate: \(String(describing: creationDate)), description: \(String(describing: description)), keyId: \(String(describing: keyId)), keyManager: \(String(describing: keyManager)), keyState: \(String(describing: keyState)), origin: \(String(describing: origin)))"}
}

/// <p>Contains metadata about a customer master key (CMK).</p>
public struct AwsKmsKeyDetails: Equatable {
    /// <p>The twelve-digit account ID of the AWS account that owns the CMK.</p>
    public let aWSAccountId: String?
    /// <p>Indicates when the CMK was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let creationDate: Double
    /// <p>A description of the key.</p>
    public let description: String?
    /// <p>The globally unique identifier for the CMK.</p>
    public let keyId: String?
    /// <p>The manager of the CMK. CMKs in your AWS account are either customer managed or AWS managed.</p>
    public let keyManager: String?
    /// <p>The state of the CMK.</p>
    public let keyState: String?
    /// <p>The source of the CMK's key material.</p>
    ///          <p>When this value is <code>AWS_KMS</code>, AWS KMS created the key material.</p>
    ///          <p>When this value is <code>EXTERNAL</code>, the key material was imported from your
    ///          existing key management infrastructure or the CMK lacks key material.</p>
    ///          <p>When this value is <code>AWS_CLOUDHSM</code>, the key material was created in the AWS
    ///          CloudHSM cluster associated with a custom key store.</p>
    public let origin: String?

    public init (
        aWSAccountId: String? = nil,
        creationDate: Double = 0.0,
        description: String? = nil,
        keyId: String? = nil,
        keyManager: String? = nil,
        keyState: String? = nil,
        origin: String? = nil
    )
    {
        self.aWSAccountId = aWSAccountId
        self.creationDate = creationDate
        self.description = description
        self.keyId = keyId
        self.keyManager = keyManager
        self.keyState = keyState
        self.origin = origin
    }
}

extension AwsLambdaFunctionCode: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
        case s3ObjectVersion = "S3ObjectVersion"
        case zipFile = "ZipFile"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
        if let s3ObjectVersion = s3ObjectVersion {
            try encodeContainer.encode(s3ObjectVersion, forKey: .s3ObjectVersion)
        }
        if let zipFile = zipFile {
            try encodeContainer.encode(zipFile, forKey: .zipFile)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let s3ObjectVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3ObjectVersion)
        s3ObjectVersion = s3ObjectVersionDecoded
        let zipFileDecoded = try containerValues.decodeIfPresent(String.self, forKey: .zipFile)
        zipFile = zipFileDecoded
    }
}

extension AwsLambdaFunctionCode: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsLambdaFunctionCode(s3Bucket: \(String(describing: s3Bucket)), s3Key: \(String(describing: s3Key)), s3ObjectVersion: \(String(describing: s3ObjectVersion)), zipFile: \(String(describing: zipFile)))"}
}

/// <p>The code for the Lambda function. You can specify either an object in Amazon S3, or upload a deployment package directly.</p>
public struct AwsLambdaFunctionCode: Equatable {
    /// <p>An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.</p>
    public let s3Bucket: String?
    /// <p>The Amazon S3 key of the deployment package.</p>
    public let s3Key: String?
    /// <p>For versioned objects, the version of the deployment package object to use.</p>
    public let s3ObjectVersion: String?
    /// <p>The base64-encoded contents of the deployment package. AWS SDK and AWS CLI clients handle the encoding for you.</p>
    public let zipFile: String?

    public init (
        s3Bucket: String? = nil,
        s3Key: String? = nil,
        s3ObjectVersion: String? = nil,
        zipFile: String? = nil
    )
    {
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
        self.s3ObjectVersion = s3ObjectVersion
        self.zipFile = zipFile
    }
}

extension AwsLambdaFunctionDeadLetterConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetArn = targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
    }
}

extension AwsLambdaFunctionDeadLetterConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsLambdaFunctionDeadLetterConfig(targetArn: \(String(describing: targetArn)))"}
}

/// <p>The dead-letter queue for failed asynchronous invocations.</p>
public struct AwsLambdaFunctionDeadLetterConfig: Equatable {
    /// <p>The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.</p>
    public let targetArn: String?

    public init (
        targetArn: String? = nil
    )
    {
        self.targetArn = targetArn
    }
}

extension AwsLambdaFunctionDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case codeSha256 = "CodeSha256"
        case deadLetterConfig = "DeadLetterConfig"
        case environment = "Environment"
        case functionName = "FunctionName"
        case handler = "Handler"
        case kmsKeyArn = "KmsKeyArn"
        case lastModified = "LastModified"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let codeSha256 = codeSha256 {
            try encodeContainer.encode(codeSha256, forKey: .codeSha256)
        }
        if let deadLetterConfig = deadLetterConfig {
            try encodeContainer.encode(deadLetterConfig, forKey: .deadLetterConfig)
        }
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let functionName = functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let handler = handler {
            try encodeContainer.encode(handler, forKey: .handler)
        }
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified, forKey: .lastModified)
        }
        if let layers = layers {
            var layersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layers)
            for awslambdafunctionlayerlist0 in layers {
                try layersContainer.encode(awslambdafunctionlayerlist0)
            }
        }
        if let masterArn = masterArn {
            try encodeContainer.encode(masterArn, forKey: .masterArn)
        }
        if memorySize != 0 {
            try encodeContainer.encode(memorySize, forKey: .memorySize)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let runtime = runtime {
            try encodeContainer.encode(runtime, forKey: .runtime)
        }
        if timeout != 0 {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let tracingConfig = tracingConfig {
            try encodeContainer.encode(tracingConfig, forKey: .tracingConfig)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(AwsLambdaFunctionCode.self, forKey: .code)
        code = codeDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(AwsLambdaFunctionDeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(AwsLambdaFunctionEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let functionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .handler)
        handler = handlerDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let layersContainer = try containerValues.decodeIfPresent([AwsLambdaFunctionLayer?].self, forKey: .layers)
        var layersDecoded0:[AwsLambdaFunctionLayer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [AwsLambdaFunctionLayer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let masterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let memorySizeDecoded = try containerValues.decode(Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .runtime)
        runtime = runtimeDecoded
        let timeoutDecoded = try containerValues.decode(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(AwsLambdaFunctionTracingConfig.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(AwsLambdaFunctionVpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension AwsLambdaFunctionDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsLambdaFunctionDetails(code: \(String(describing: code)), codeSha256: \(String(describing: codeSha256)), deadLetterConfig: \(String(describing: deadLetterConfig)), environment: \(String(describing: environment)), functionName: \(String(describing: functionName)), handler: \(String(describing: handler)), kmsKeyArn: \(String(describing: kmsKeyArn)), lastModified: \(String(describing: lastModified)), layers: \(String(describing: layers)), masterArn: \(String(describing: masterArn)), memorySize: \(String(describing: memorySize)), revisionId: \(String(describing: revisionId)), role: \(String(describing: role)), runtime: \(String(describing: runtime)), timeout: \(String(describing: timeout)), tracingConfig: \(String(describing: tracingConfig)), version: \(String(describing: version)), vpcConfig: \(String(describing: vpcConfig)))"}
}

/// <p>Details about a function's configuration.</p>
public struct AwsLambdaFunctionDetails: Equatable {
    /// <p>An <code>AwsLambdaFunctionCode</code> object.</p>
    public let code: AwsLambdaFunctionCode?
    /// <p>The SHA256 hash of the function's deployment package.</p>
    public let codeSha256: String?
    /// <p>The function's dead letter queue.</p>
    public let deadLetterConfig: AwsLambdaFunctionDeadLetterConfig?
    /// <p>The function's environment variables.</p>
    public let environment: AwsLambdaFunctionEnvironment?
    /// <p>The name of the function.</p>
    public let functionName: String?
    /// <p>The function that Lambda calls to begin executing your function.</p>
    public let handler: String?
    /// <p>The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've configured a customer managed CMK.</p>
    public let kmsKeyArn: String?
    /// <p>Indicates when the function was last updated.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let lastModified: String?
    /// <p>The function's layers.</p>
    public let layers: [AwsLambdaFunctionLayer]?
    /// <p>For Lambda@Edge functions, the ARN of the master function.</p>
    public let masterArn: String?
    /// <p>The memory that's allocated to the function.</p>
    public let memorySize: Int
    /// <p>The latest updated revision of the function or alias.</p>
    public let revisionId: String?
    /// <p>The function's execution role.</p>
    public let role: String?
    /// <p>The runtime environment for the Lambda function.</p>
    public let runtime: String?
    /// <p>The amount of time that Lambda allows a function to run before stopping it.</p>
    public let timeout: Int
    /// <p>The function's AWS X-Ray tracing configuration.</p>
    public let tracingConfig: AwsLambdaFunctionTracingConfig?
    /// <p>The version of the Lambda function.</p>
    public let version: String?
    /// <p>The function's networking configuration.</p>
    public let vpcConfig: AwsLambdaFunctionVpcConfig?

    public init (
        code: AwsLambdaFunctionCode? = nil,
        codeSha256: String? = nil,
        deadLetterConfig: AwsLambdaFunctionDeadLetterConfig? = nil,
        environment: AwsLambdaFunctionEnvironment? = nil,
        functionName: String? = nil,
        handler: String? = nil,
        kmsKeyArn: String? = nil,
        lastModified: String? = nil,
        layers: [AwsLambdaFunctionLayer]? = nil,
        masterArn: String? = nil,
        memorySize: Int = 0,
        revisionId: String? = nil,
        role: String? = nil,
        runtime: String? = nil,
        timeout: Int = 0,
        tracingConfig: AwsLambdaFunctionTracingConfig? = nil,
        version: String? = nil,
        vpcConfig: AwsLambdaFunctionVpcConfig? = nil
    )
    {
        self.code = code
        self.codeSha256 = codeSha256
        self.deadLetterConfig = deadLetterConfig
        self.environment = environment
        self.functionName = functionName
        self.handler = handler
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

extension AwsLambdaFunctionEnvironment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case error = "Error"
        case variables = "Variables"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .variables)
            for (dictKey0, fieldmap0) in variables {
                try variablesContainer.encode(fieldmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .variables)
        var variablesDecoded0: [String:String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [String:String]()
            for (key0, nonemptystring0) in variablesContainer {
                if let nonemptystring0 = nonemptystring0 {
                    variablesDecoded0?[key0] = nonemptystring0
                }
            }
        }
        variables = variablesDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(AwsLambdaFunctionEnvironmentError.self, forKey: .error)
        error = errorDecoded
    }
}

extension AwsLambdaFunctionEnvironment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsLambdaFunctionEnvironment(error: \(String(describing: error)), variables: \(String(describing: variables)))"}
}

/// <p>A function's environment variable settings.</p>
public struct AwsLambdaFunctionEnvironment: Equatable {
    /// <p>An <code>AwsLambdaFunctionEnvironmentError</code> object.</p>
    public let error: AwsLambdaFunctionEnvironmentError?
    /// <p>Environment variable key-value pairs.</p>
    public let variables: [String:String]?

    public init (
        error: AwsLambdaFunctionEnvironmentError? = nil,
        variables: [String:String]? = nil
    )
    {
        self.error = error
        self.variables = variables
    }
}

extension AwsLambdaFunctionEnvironmentError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AwsLambdaFunctionEnvironmentError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsLambdaFunctionEnvironmentError(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

/// <p>Error messages for environment variables that couldn't be applied.</p>
public struct AwsLambdaFunctionEnvironmentError: Equatable {
    /// <p>The error code.</p>
    public let errorCode: String?
    /// <p>The error message.</p>
    public let message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

extension AwsLambdaFunctionLayer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case codeSize = "CodeSize"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if codeSize != 0 {
            try encodeContainer.encode(codeSize, forKey: .codeSize)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let codeSizeDecoded = try containerValues.decode(Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
    }
}

extension AwsLambdaFunctionLayer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsLambdaFunctionLayer(arn: \(String(describing: arn)), codeSize: \(String(describing: codeSize)))"}
}

/// <p>An AWS Lambda layer.</p>
public struct AwsLambdaFunctionLayer: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the function layer.</p>
    public let arn: String?
    /// <p>The size of the layer archive in bytes.</p>
    public let codeSize: Int

    public init (
        arn: String? = nil,
        codeSize: Int = 0
    )
    {
        self.arn = arn
        self.codeSize = codeSize
    }
}

extension AwsLambdaFunctionTracingConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mode = "Mode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = mode {
            try encodeContainer.encode(mode, forKey: .mode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension AwsLambdaFunctionTracingConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsLambdaFunctionTracingConfig(mode: \(String(describing: mode)))"}
}

/// <p>The function's AWS X-Ray tracing configuration.</p>
public struct AwsLambdaFunctionTracingConfig: Equatable {
    /// <p>The tracing mode.</p>
    public let mode: String?

    public init (
        mode: String? = nil
    )
    {
        self.mode = mode
    }
}

extension AwsLambdaFunctionVpcConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for nonemptystringlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(nonemptystringlist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for nonemptystringlist0 in subnetIds {
                try subnetIdsContainer.encode(nonemptystringlist0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension AwsLambdaFunctionVpcConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsLambdaFunctionVpcConfig(securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>The VPC security groups and subnets that are attached to a Lambda function. For more information, see VPC Settings.</p>
public struct AwsLambdaFunctionVpcConfig: Equatable {
    /// <p>A list of VPC security groups IDs.</p>
    public let securityGroupIds: [String]?
    /// <p>A list of VPC subnet IDs.</p>
    public let subnetIds: [String]?
    /// <p>The ID of the VPC.</p>
    public let vpcId: String?

    public init (
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil,
        vpcId: String? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

extension AwsLambdaLayerVersionDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case compatibleRuntimes = "CompatibleRuntimes"
        case createdDate = "CreatedDate"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleRuntimes = compatibleRuntimes {
            var compatibleRuntimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleRuntimes)
            for nonemptystringlist0 in compatibleRuntimes {
                try compatibleRuntimesContainer.encode(nonemptystringlist0)
            }
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[String]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [String]()
            for string0 in compatibleRuntimesContainer {
                if let string0 = string0 {
                    compatibleRuntimesDecoded0?.append(string0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let createdDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension AwsLambdaLayerVersionDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsLambdaLayerVersionDetails(compatibleRuntimes: \(String(describing: compatibleRuntimes)), createdDate: \(String(describing: createdDate)), version: \(String(describing: version)))"}
}

/// <p>Details about a Lambda layer version.</p>
public struct AwsLambdaLayerVersionDetails: Equatable {
    /// <p>The layer's compatible runtimes. Maximum number of five items.</p>
    ///          <p>Valid values: <code>nodejs10.x</code> | <code>nodejs12.x</code> | <code>java8</code> |
    ///             <code>java11</code> | <code>python2.7</code> | <code>python3.6</code> |
    ///             <code>python3.7</code> | <code>python3.8</code> | <code>dotnetcore1.0</code> |
    ///             <code>dotnetcore2.1</code> | <code>go1.x</code> | <code>ruby2.5</code> |
    ///             <code>provided</code>
    ///          </p>
    public let compatibleRuntimes: [String]?
    /// <p>Indicates when the version was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let createdDate: String?
    /// <p>The version number.</p>
    public let version: Int

    public init (
        compatibleRuntimes: [String]? = nil,
        createdDate: String? = nil,
        version: Int = 0
    )
    {
        self.compatibleRuntimes = compatibleRuntimes
        self.createdDate = createdDate
        self.version = version
    }
}

extension AwsRdsDbClusterAssociatedRole: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn = "RoleArn"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AwsRdsDbClusterAssociatedRole: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRdsDbClusterAssociatedRole(roleArn: \(String(describing: roleArn)), status: \(String(describing: status)))"}
}

/// <p>An IAM role that is associated with the Amazon RDS DB cluster.</p>
public struct AwsRdsDbClusterAssociatedRole: Equatable {
    /// <p>The ARN of the IAM role.</p>
    public let roleArn: String?
    /// <p>The status of the association between the IAM role and the DB cluster.</p>
    public let status: String?

    public init (
        roleArn: String? = nil,
        status: String? = nil
    )
    {
        self.roleArn = roleArn
        self.status = status
    }
}

extension AwsRdsDbClusterDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activityStreamStatus = "ActivityStreamStatus"
        case allocatedStorage = "AllocatedStorage"
        case associatedRoles = "AssociatedRoles"
        case availabilityZones = "AvailabilityZones"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case clusterCreateTime = "ClusterCreateTime"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case crossAccountClone = "CrossAccountClone"
        case customEndpoints = "CustomEndpoints"
        case databaseName = "DatabaseName"
        case dbClusterIdentifier = "DbClusterIdentifier"
        case dbClusterMembers = "DbClusterMembers"
        case dbClusterOptionGroupMemberships = "DbClusterOptionGroupMemberships"
        case dbClusterParameterGroup = "DbClusterParameterGroup"
        case dbClusterResourceId = "DbClusterResourceId"
        case dbSubnetGroup = "DbSubnetGroup"
        case deletionProtection = "DeletionProtection"
        case domainMemberships = "DomainMemberships"
        case enabledCloudWatchLogsExports = "EnabledCloudWatchLogsExports"
        case endpoint = "Endpoint"
        case engine = "Engine"
        case engineMode = "EngineMode"
        case engineVersion = "EngineVersion"
        case hostedZoneId = "HostedZoneId"
        case httpEndpointEnabled = "HttpEndpointEnabled"
        case iamDatabaseAuthenticationEnabled = "IamDatabaseAuthenticationEnabled"
        case kmsKeyId = "KmsKeyId"
        case masterUsername = "MasterUsername"
        case multiAz = "MultiAz"
        case port = "Port"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case readReplicaIdentifiers = "ReadReplicaIdentifiers"
        case readerEndpoint = "ReaderEndpoint"
        case status = "Status"
        case storageEncrypted = "StorageEncrypted"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activityStreamStatus = activityStreamStatus {
            try encodeContainer.encode(activityStreamStatus, forKey: .activityStreamStatus)
        }
        if allocatedStorage != 0 {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if let associatedRoles = associatedRoles {
            var associatedRolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedRoles)
            for awsrdsdbclusterassociatedroles0 in associatedRoles {
                try associatedRolesContainer.encode(awsrdsdbclusterassociatedroles0)
            }
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for stringlist0 in availabilityZones {
                try availabilityZonesContainer.encode(stringlist0)
            }
        }
        if backupRetentionPeriod != 0 {
            try encodeContainer.encode(backupRetentionPeriod, forKey: .backupRetentionPeriod)
        }
        if let clusterCreateTime = clusterCreateTime {
            try encodeContainer.encode(clusterCreateTime, forKey: .clusterCreateTime)
        }
        if copyTagsToSnapshot != false {
            try encodeContainer.encode(copyTagsToSnapshot, forKey: .copyTagsToSnapshot)
        }
        if crossAccountClone != false {
            try encodeContainer.encode(crossAccountClone, forKey: .crossAccountClone)
        }
        if let customEndpoints = customEndpoints {
            var customEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customEndpoints)
            for stringlist0 in customEndpoints {
                try customEndpointsContainer.encode(stringlist0)
            }
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dbClusterIdentifier = dbClusterIdentifier {
            try encodeContainer.encode(dbClusterIdentifier, forKey: .dbClusterIdentifier)
        }
        if let dbClusterMembers = dbClusterMembers {
            var dbClusterMembersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dbClusterMembers)
            for awsrdsdbclustermembers0 in dbClusterMembers {
                try dbClusterMembersContainer.encode(awsrdsdbclustermembers0)
            }
        }
        if let dbClusterOptionGroupMemberships = dbClusterOptionGroupMemberships {
            var dbClusterOptionGroupMembershipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dbClusterOptionGroupMemberships)
            for awsrdsdbclusteroptiongroupmemberships0 in dbClusterOptionGroupMemberships {
                try dbClusterOptionGroupMembershipsContainer.encode(awsrdsdbclusteroptiongroupmemberships0)
            }
        }
        if let dbClusterParameterGroup = dbClusterParameterGroup {
            try encodeContainer.encode(dbClusterParameterGroup, forKey: .dbClusterParameterGroup)
        }
        if let dbClusterResourceId = dbClusterResourceId {
            try encodeContainer.encode(dbClusterResourceId, forKey: .dbClusterResourceId)
        }
        if let dbSubnetGroup = dbSubnetGroup {
            try encodeContainer.encode(dbSubnetGroup, forKey: .dbSubnetGroup)
        }
        if deletionProtection != false {
            try encodeContainer.encode(deletionProtection, forKey: .deletionProtection)
        }
        if let domainMemberships = domainMemberships {
            var domainMembershipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainMemberships)
            for awsrdsdbdomainmemberships0 in domainMemberships {
                try domainMembershipsContainer.encode(awsrdsdbdomainmemberships0)
            }
        }
        if let enabledCloudWatchLogsExports = enabledCloudWatchLogsExports {
            var enabledCloudWatchLogsExportsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .enabledCloudWatchLogsExports)
            for stringlist0 in enabledCloudWatchLogsExports {
                try enabledCloudWatchLogsExportsContainer.encode(stringlist0)
            }
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let engine = engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let engineMode = engineMode {
            try encodeContainer.encode(engineMode, forKey: .engineMode)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let hostedZoneId = hostedZoneId {
            try encodeContainer.encode(hostedZoneId, forKey: .hostedZoneId)
        }
        if httpEndpointEnabled != false {
            try encodeContainer.encode(httpEndpointEnabled, forKey: .httpEndpointEnabled)
        }
        if iamDatabaseAuthenticationEnabled != false {
            try encodeContainer.encode(iamDatabaseAuthenticationEnabled, forKey: .iamDatabaseAuthenticationEnabled)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let masterUsername = masterUsername {
            try encodeContainer.encode(masterUsername, forKey: .masterUsername)
        }
        if multiAz != false {
            try encodeContainer.encode(multiAz, forKey: .multiAz)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try encodeContainer.encode(preferredBackupWindow, forKey: .preferredBackupWindow)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let readReplicaIdentifiers = readReplicaIdentifiers {
            var readReplicaIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .readReplicaIdentifiers)
            for stringlist0 in readReplicaIdentifiers {
                try readReplicaIdentifiersContainer.encode(stringlist0)
            }
        }
        if let readerEndpoint = readerEndpoint {
            try encodeContainer.encode(readerEndpoint, forKey: .readerEndpoint)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if storageEncrypted != false {
            try encodeContainer.encode(storageEncrypted, forKey: .storageEncrypted)
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroups)
            for awsrdsdbinstancevpcsecuritygroups0 in vpcSecurityGroups {
                try vpcSecurityGroupsContainer.encode(awsrdsdbinstancevpcsecuritygroups0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allocatedStorageDecoded = try containerValues.decode(Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let backupRetentionPeriodDecoded = try containerValues.decode(Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let readerEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .readerEndpoint)
        readerEndpoint = readerEndpointDecoded
        let customEndpointsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .customEndpoints)
        var customEndpointsDecoded0:[String]? = nil
        if let customEndpointsContainer = customEndpointsContainer {
            customEndpointsDecoded0 = [String]()
            for string0 in customEndpointsContainer {
                if let string0 = string0 {
                    customEndpointsDecoded0?.append(string0)
                }
            }
        }
        customEndpoints = customEndpointsDecoded0
        let multiAzDecoded = try containerValues.decode(Bool.self, forKey: .multiAz)
        multiAz = multiAzDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let readReplicaIdentifiersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .readReplicaIdentifiers)
        var readReplicaIdentifiersDecoded0:[String]? = nil
        if let readReplicaIdentifiersContainer = readReplicaIdentifiersContainer {
            readReplicaIdentifiersDecoded0 = [String]()
            for string0 in readReplicaIdentifiersContainer {
                if let string0 = string0 {
                    readReplicaIdentifiersDecoded0?.append(string0)
                }
            }
        }
        readReplicaIdentifiers = readReplicaIdentifiersDecoded0
        let vpcSecurityGroupsContainer = try containerValues.decodeIfPresent([AwsRdsDbInstanceVpcSecurityGroup?].self, forKey: .vpcSecurityGroups)
        var vpcSecurityGroupsDecoded0:[AwsRdsDbInstanceVpcSecurityGroup]? = nil
        if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
            vpcSecurityGroupsDecoded0 = [AwsRdsDbInstanceVpcSecurityGroup]()
            for structure0 in vpcSecurityGroupsContainer {
                if let structure0 = structure0 {
                    vpcSecurityGroupsDecoded0?.append(structure0)
                }
            }
        }
        vpcSecurityGroups = vpcSecurityGroupsDecoded0
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
        let storageEncryptedDecoded = try containerValues.decode(Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dbClusterResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbClusterResourceId)
        dbClusterResourceId = dbClusterResourceIdDecoded
        let associatedRolesContainer = try containerValues.decodeIfPresent([AwsRdsDbClusterAssociatedRole?].self, forKey: .associatedRoles)
        var associatedRolesDecoded0:[AwsRdsDbClusterAssociatedRole]? = nil
        if let associatedRolesContainer = associatedRolesContainer {
            associatedRolesDecoded0 = [AwsRdsDbClusterAssociatedRole]()
            for structure0 in associatedRolesContainer {
                if let structure0 = structure0 {
                    associatedRolesDecoded0?.append(structure0)
                }
            }
        }
        associatedRoles = associatedRolesDecoded0
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterCreateTime)
        clusterCreateTime = clusterCreateTimeDecoded
        let enabledCloudWatchLogsExportsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .enabledCloudWatchLogsExports)
        var enabledCloudWatchLogsExportsDecoded0:[String]? = nil
        if let enabledCloudWatchLogsExportsContainer = enabledCloudWatchLogsExportsContainer {
            enabledCloudWatchLogsExportsDecoded0 = [String]()
            for string0 in enabledCloudWatchLogsExportsContainer {
                if let string0 = string0 {
                    enabledCloudWatchLogsExportsDecoded0?.append(string0)
                }
            }
        }
        enabledCloudWatchLogsExports = enabledCloudWatchLogsExportsDecoded0
        let engineModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineMode)
        engineMode = engineModeDecoded
        let deletionProtectionDecoded = try containerValues.decode(Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let httpEndpointEnabledDecoded = try containerValues.decode(Bool.self, forKey: .httpEndpointEnabled)
        httpEndpointEnabled = httpEndpointEnabledDecoded
        let activityStreamStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activityStreamStatus)
        activityStreamStatus = activityStreamStatusDecoded
        let copyTagsToSnapshotDecoded = try containerValues.decode(Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let crossAccountCloneDecoded = try containerValues.decode(Bool.self, forKey: .crossAccountClone)
        crossAccountClone = crossAccountCloneDecoded
        let domainMembershipsContainer = try containerValues.decodeIfPresent([AwsRdsDbDomainMembership?].self, forKey: .domainMemberships)
        var domainMembershipsDecoded0:[AwsRdsDbDomainMembership]? = nil
        if let domainMembershipsContainer = domainMembershipsContainer {
            domainMembershipsDecoded0 = [AwsRdsDbDomainMembership]()
            for structure0 in domainMembershipsContainer {
                if let structure0 = structure0 {
                    domainMembershipsDecoded0?.append(structure0)
                }
            }
        }
        domainMemberships = domainMembershipsDecoded0
        let dbClusterParameterGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbClusterParameterGroup)
        dbClusterParameterGroup = dbClusterParameterGroupDecoded
        let dbSubnetGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbSubnetGroup)
        dbSubnetGroup = dbSubnetGroupDecoded
        let dbClusterOptionGroupMembershipsContainer = try containerValues.decodeIfPresent([AwsRdsDbClusterOptionGroupMembership?].self, forKey: .dbClusterOptionGroupMemberships)
        var dbClusterOptionGroupMembershipsDecoded0:[AwsRdsDbClusterOptionGroupMembership]? = nil
        if let dbClusterOptionGroupMembershipsContainer = dbClusterOptionGroupMembershipsContainer {
            dbClusterOptionGroupMembershipsDecoded0 = [AwsRdsDbClusterOptionGroupMembership]()
            for structure0 in dbClusterOptionGroupMembershipsContainer {
                if let structure0 = structure0 {
                    dbClusterOptionGroupMembershipsDecoded0?.append(structure0)
                }
            }
        }
        dbClusterOptionGroupMemberships = dbClusterOptionGroupMembershipsDecoded0
        let dbClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbClusterIdentifier)
        dbClusterIdentifier = dbClusterIdentifierDecoded
        let dbClusterMembersContainer = try containerValues.decodeIfPresent([AwsRdsDbClusterMember?].self, forKey: .dbClusterMembers)
        var dbClusterMembersDecoded0:[AwsRdsDbClusterMember]? = nil
        if let dbClusterMembersContainer = dbClusterMembersContainer {
            dbClusterMembersDecoded0 = [AwsRdsDbClusterMember]()
            for structure0 in dbClusterMembersContainer {
                if let structure0 = structure0 {
                    dbClusterMembersDecoded0?.append(structure0)
                }
            }
        }
        dbClusterMembers = dbClusterMembersDecoded0
        let iamDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Bool.self, forKey: .iamDatabaseAuthenticationEnabled)
        iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabledDecoded
    }
}

extension AwsRdsDbClusterDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRdsDbClusterDetails(activityStreamStatus: \(String(describing: activityStreamStatus)), allocatedStorage: \(String(describing: allocatedStorage)), associatedRoles: \(String(describing: associatedRoles)), availabilityZones: \(String(describing: availabilityZones)), backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), clusterCreateTime: \(String(describing: clusterCreateTime)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), crossAccountClone: \(String(describing: crossAccountClone)), customEndpoints: \(String(describing: customEndpoints)), databaseName: \(String(describing: databaseName)), dbClusterIdentifier: \(String(describing: dbClusterIdentifier)), dbClusterMembers: \(String(describing: dbClusterMembers)), dbClusterOptionGroupMemberships: \(String(describing: dbClusterOptionGroupMemberships)), dbClusterParameterGroup: \(String(describing: dbClusterParameterGroup)), dbClusterResourceId: \(String(describing: dbClusterResourceId)), dbSubnetGroup: \(String(describing: dbSubnetGroup)), deletionProtection: \(String(describing: deletionProtection)), domainMemberships: \(String(describing: domainMemberships)), enabledCloudWatchLogsExports: \(String(describing: enabledCloudWatchLogsExports)), endpoint: \(String(describing: endpoint)), engine: \(String(describing: engine)), engineMode: \(String(describing: engineMode)), engineVersion: \(String(describing: engineVersion)), hostedZoneId: \(String(describing: hostedZoneId)), httpEndpointEnabled: \(String(describing: httpEndpointEnabled)), iamDatabaseAuthenticationEnabled: \(String(describing: iamDatabaseAuthenticationEnabled)), kmsKeyId: \(String(describing: kmsKeyId)), masterUsername: \(String(describing: masterUsername)), multiAz: \(String(describing: multiAz)), port: \(String(describing: port)), preferredBackupWindow: \(String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), readReplicaIdentifiers: \(String(describing: readReplicaIdentifiers)), readerEndpoint: \(String(describing: readerEndpoint)), status: \(String(describing: status)), storageEncrypted: \(String(describing: storageEncrypted)), vpcSecurityGroups: \(String(describing: vpcSecurityGroups)))"}
}

/// <p>Information about an Amazon RDS DB cluster.</p>
public struct AwsRdsDbClusterDetails: Equatable {
    /// <p>The status of the database activity stream.</p>
    public let activityStreamStatus: String?
    /// <p>For all database engines except Aurora, specifies the allocated storage size in
    ///          gibibytes (GiB).</p>
    public let allocatedStorage: Int
    /// <p>A list of the IAM roles that are associated with the DB cluster.</p>
    public let associatedRoles: [AwsRdsDbClusterAssociatedRole]?
    /// <p>A list of Availability Zones (AZs) where instances in the DB cluster can be
    ///          created.</p>
    public let availabilityZones: [String]?
    /// <p>The number of days for which automated backups are retained.</p>
    public let backupRetentionPeriod: Int
    /// <p>Indicates when the DB cluster was created, in Universal Coordinated Time (UTC).</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let clusterCreateTime: String?
    /// <p>Whether tags are copied from the DB cluster to snapshots of the DB cluster.</p>
    public let copyTagsToSnapshot: Bool
    /// <p>Whether the DB cluster is a clone of a DB cluster owned by a different AWS
    ///          account.</p>
    public let crossAccountClone: Bool
    /// <p>A list of custom endpoints for the DB cluster.</p>
    public let customEndpoints: [String]?
    /// <p>The name of the database.</p>
    public let databaseName: String?
    /// <p>The DB cluster identifier that the user assigned to the cluster. This identifier is the
    ///          unique key that identifies a DB cluster.</p>
    public let dbClusterIdentifier: String?
    /// <p>The list of instances that make up the DB cluster.</p>
    public let dbClusterMembers: [AwsRdsDbClusterMember]?
    /// <p>The list of option group memberships for this DB cluster.</p>
    public let dbClusterOptionGroupMemberships: [AwsRdsDbClusterOptionGroupMembership]?
    /// <p>The name of the DB cluster parameter group for the DB cluster.</p>
    public let dbClusterParameterGroup: String?
    /// <p>The identifier of the DB cluster. The identifier must be unique within each AWS Region
    ///          and is immutable.</p>
    public let dbClusterResourceId: String?
    /// <p>The subnet group that is associated with the DB cluster, including the name,
    ///          description, and subnets in the subnet group.</p>
    public let dbSubnetGroup: String?
    /// <p>Whether the DB cluster has deletion protection enabled.</p>
    public let deletionProtection: Bool
    /// <p>The Active Directory domain membership records that are associated with the DB
    ///          cluster.</p>
    public let domainMemberships: [AwsRdsDbDomainMembership]?
    /// <p>A list of log types that this DB cluster is configured to export to CloudWatch
    ///          Logs.</p>
    public let enabledCloudWatchLogsExports: [String]?
    /// <p>The connection endpoint for the primary instance of the DB cluster.</p>
    public let endpoint: String?
    /// <p>The name of the database engine to use for this DB cluster.</p>
    public let engine: String?
    /// <p>The database engine mode of the DB cluster.</p>
    public let engineMode: String?
    /// <p>The version number of the database engine to use.</p>
    public let engineVersion: String?
    /// <p>Specifies the identifier that Amazon Route 53 assigns when you create a hosted
    ///          zone.</p>
    public let hostedZoneId: String?
    /// <p>Whether the HTTP endpoint for an Aurora Serverless DB cluster is enabled.</p>
    public let httpEndpointEnabled: Bool
    /// <p>Whether the mapping of IAM accounts to database accounts is enabled.</p>
    public let iamDatabaseAuthenticationEnabled: Bool
    /// <p>The ARN of the AWS KMS master key that is used to encrypt the database instances in the
    ///          DB cluster.</p>
    public let kmsKeyId: String?
    /// <p>The name of the master user for the DB cluster.</p>
    public let masterUsername: String?
    /// <p>Whether the DB cluster has instances in multiple Availability Zones.</p>
    public let multiAz: Bool
    /// <p>The port number on which the DB instances in the DB cluster accept connections.</p>
    public let port: Int
    /// <p>The range of time each day when automated backups are created, if automated backups are
    ///          enabled.</p>
    ///          <p>Uses the format <code>HH:MM-HH:MM</code>. For example, <code>04:52-05:22</code>.</p>
    public let preferredBackupWindow: String?
    /// <p>The weekly time range during which system maintenance can occur, in Universal
    ///          Coordinated Time (UTC).</p>
    ///          <p>Uses the format <code><day>:HH:MM-<day>:HH:MM</code>.</p>
    ///          <p>For the day values, use
    ///             <code>mon</code>|<code>tue</code>|<code>wed</code>|<code>thu</code>|<code>fri</code>|<code>sat</code>|<code>sun</code>.</p>
    ///          <p>For example, <code>sun:09:32-sun:10:02</code>.</p>
    public let preferredMaintenanceWindow: String?
    /// <p>The identifiers of the read replicas that are associated with this DB cluster.</p>
    public let readReplicaIdentifiers: [String]?
    /// <p>The reader endpoint for the DB cluster.</p>
    public let readerEndpoint: String?
    /// <p>The current status of this DB cluster.</p>
    public let status: String?
    /// <p>Whether the DB cluster is encrypted.</p>
    public let storageEncrypted: Bool
    /// <p>A list of VPC security groups that the DB cluster belongs to.</p>
    public let vpcSecurityGroups: [AwsRdsDbInstanceVpcSecurityGroup]?

    public init (
        activityStreamStatus: String? = nil,
        allocatedStorage: Int = 0,
        associatedRoles: [AwsRdsDbClusterAssociatedRole]? = nil,
        availabilityZones: [String]? = nil,
        backupRetentionPeriod: Int = 0,
        clusterCreateTime: String? = nil,
        copyTagsToSnapshot: Bool = false,
        crossAccountClone: Bool = false,
        customEndpoints: [String]? = nil,
        databaseName: String? = nil,
        dbClusterIdentifier: String? = nil,
        dbClusterMembers: [AwsRdsDbClusterMember]? = nil,
        dbClusterOptionGroupMemberships: [AwsRdsDbClusterOptionGroupMembership]? = nil,
        dbClusterParameterGroup: String? = nil,
        dbClusterResourceId: String? = nil,
        dbSubnetGroup: String? = nil,
        deletionProtection: Bool = false,
        domainMemberships: [AwsRdsDbDomainMembership]? = nil,
        enabledCloudWatchLogsExports: [String]? = nil,
        endpoint: String? = nil,
        engine: String? = nil,
        engineMode: String? = nil,
        engineVersion: String? = nil,
        hostedZoneId: String? = nil,
        httpEndpointEnabled: Bool = false,
        iamDatabaseAuthenticationEnabled: Bool = false,
        kmsKeyId: String? = nil,
        masterUsername: String? = nil,
        multiAz: Bool = false,
        port: Int = 0,
        preferredBackupWindow: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        readReplicaIdentifiers: [String]? = nil,
        readerEndpoint: String? = nil,
        status: String? = nil,
        storageEncrypted: Bool = false,
        vpcSecurityGroups: [AwsRdsDbInstanceVpcSecurityGroup]? = nil
    )
    {
        self.activityStreamStatus = activityStreamStatus
        self.allocatedStorage = allocatedStorage
        self.associatedRoles = associatedRoles
        self.availabilityZones = availabilityZones
        self.backupRetentionPeriod = backupRetentionPeriod
        self.clusterCreateTime = clusterCreateTime
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.crossAccountClone = crossAccountClone
        self.customEndpoints = customEndpoints
        self.databaseName = databaseName
        self.dbClusterIdentifier = dbClusterIdentifier
        self.dbClusterMembers = dbClusterMembers
        self.dbClusterOptionGroupMemberships = dbClusterOptionGroupMemberships
        self.dbClusterParameterGroup = dbClusterParameterGroup
        self.dbClusterResourceId = dbClusterResourceId
        self.dbSubnetGroup = dbSubnetGroup
        self.deletionProtection = deletionProtection
        self.domainMemberships = domainMemberships
        self.enabledCloudWatchLogsExports = enabledCloudWatchLogsExports
        self.endpoint = endpoint
        self.engine = engine
        self.engineMode = engineMode
        self.engineVersion = engineVersion
        self.hostedZoneId = hostedZoneId
        self.httpEndpointEnabled = httpEndpointEnabled
        self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
        self.kmsKeyId = kmsKeyId
        self.masterUsername = masterUsername
        self.multiAz = multiAz
        self.port = port
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.readReplicaIdentifiers = readReplicaIdentifiers
        self.readerEndpoint = readerEndpoint
        self.status = status
        self.storageEncrypted = storageEncrypted
        self.vpcSecurityGroups = vpcSecurityGroups
    }
}

extension AwsRdsDbClusterMember: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dbClusterParameterGroupStatus = "DbClusterParameterGroupStatus"
        case dbInstanceIdentifier = "DbInstanceIdentifier"
        case isClusterWriter = "IsClusterWriter"
        case promotionTier = "PromotionTier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dbClusterParameterGroupStatus = dbClusterParameterGroupStatus {
            try encodeContainer.encode(dbClusterParameterGroupStatus, forKey: .dbClusterParameterGroupStatus)
        }
        if let dbInstanceIdentifier = dbInstanceIdentifier {
            try encodeContainer.encode(dbInstanceIdentifier, forKey: .dbInstanceIdentifier)
        }
        if isClusterWriter != false {
            try encodeContainer.encode(isClusterWriter, forKey: .isClusterWriter)
        }
        if promotionTier != 0 {
            try encodeContainer.encode(promotionTier, forKey: .promotionTier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isClusterWriterDecoded = try containerValues.decode(Bool.self, forKey: .isClusterWriter)
        isClusterWriter = isClusterWriterDecoded
        let promotionTierDecoded = try containerValues.decode(Int.self, forKey: .promotionTier)
        promotionTier = promotionTierDecoded
        let dbInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbInstanceIdentifier)
        dbInstanceIdentifier = dbInstanceIdentifierDecoded
        let dbClusterParameterGroupStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbClusterParameterGroupStatus)
        dbClusterParameterGroupStatus = dbClusterParameterGroupStatusDecoded
    }
}

extension AwsRdsDbClusterMember: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRdsDbClusterMember(dbClusterParameterGroupStatus: \(String(describing: dbClusterParameterGroupStatus)), dbInstanceIdentifier: \(String(describing: dbInstanceIdentifier)), isClusterWriter: \(String(describing: isClusterWriter)), promotionTier: \(String(describing: promotionTier)))"}
}

/// <p>Information about an instance in the DB cluster.</p>
public struct AwsRdsDbClusterMember: Equatable {
    /// <p>The status of the DB cluster parameter group for this member of the DB cluster.</p>
    public let dbClusterParameterGroupStatus: String?
    /// <p>The instance identifier for this member of the DB cluster.</p>
    public let dbInstanceIdentifier: String?
    /// <p>Whether the cluster member is the primary instance for the DB cluster.</p>
    public let isClusterWriter: Bool
    /// <p>Specifies the order in which an Aurora replica is promoted to the primary instance when
    ///          the existing primary instance fails.</p>
    public let promotionTier: Int

    public init (
        dbClusterParameterGroupStatus: String? = nil,
        dbInstanceIdentifier: String? = nil,
        isClusterWriter: Bool = false,
        promotionTier: Int = 0
    )
    {
        self.dbClusterParameterGroupStatus = dbClusterParameterGroupStatus
        self.dbInstanceIdentifier = dbInstanceIdentifier
        self.isClusterWriter = isClusterWriter
        self.promotionTier = promotionTier
    }
}

extension AwsRdsDbClusterOptionGroupMembership: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dbClusterOptionGroupName = "DbClusterOptionGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dbClusterOptionGroupName = dbClusterOptionGroupName {
            try encodeContainer.encode(dbClusterOptionGroupName, forKey: .dbClusterOptionGroupName)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbClusterOptionGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbClusterOptionGroupName)
        dbClusterOptionGroupName = dbClusterOptionGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AwsRdsDbClusterOptionGroupMembership: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRdsDbClusterOptionGroupMembership(dbClusterOptionGroupName: \(String(describing: dbClusterOptionGroupName)), status: \(String(describing: status)))"}
}

/// <p>Information about an option group membership for a DB cluster.</p>
public struct AwsRdsDbClusterOptionGroupMembership: Equatable {
    /// <p>The name of the DB cluster option group.</p>
    public let dbClusterOptionGroupName: String?
    /// <p>The status of the DB cluster option group.</p>
    public let status: String?

    public init (
        dbClusterOptionGroupName: String? = nil,
        status: String? = nil
    )
    {
        self.dbClusterOptionGroupName = dbClusterOptionGroupName
        self.status = status
    }
}

extension AwsRdsDbClusterSnapshotDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case availabilityZones = "AvailabilityZones"
        case clusterCreateTime = "ClusterCreateTime"
        case dbClusterIdentifier = "DbClusterIdentifier"
        case dbClusterSnapshotIdentifier = "DbClusterSnapshotIdentifier"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case iamDatabaseAuthenticationEnabled = "IamDatabaseAuthenticationEnabled"
        case kmsKeyId = "KmsKeyId"
        case licenseModel = "LicenseModel"
        case masterUsername = "MasterUsername"
        case percentProgress = "PercentProgress"
        case port = "Port"
        case snapshotCreateTime = "SnapshotCreateTime"
        case snapshotType = "SnapshotType"
        case status = "Status"
        case storageEncrypted = "StorageEncrypted"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allocatedStorage != 0 {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for stringlist0 in availabilityZones {
                try availabilityZonesContainer.encode(stringlist0)
            }
        }
        if let clusterCreateTime = clusterCreateTime {
            try encodeContainer.encode(clusterCreateTime, forKey: .clusterCreateTime)
        }
        if let dbClusterIdentifier = dbClusterIdentifier {
            try encodeContainer.encode(dbClusterIdentifier, forKey: .dbClusterIdentifier)
        }
        if let dbClusterSnapshotIdentifier = dbClusterSnapshotIdentifier {
            try encodeContainer.encode(dbClusterSnapshotIdentifier, forKey: .dbClusterSnapshotIdentifier)
        }
        if let engine = engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if iamDatabaseAuthenticationEnabled != false {
            try encodeContainer.encode(iamDatabaseAuthenticationEnabled, forKey: .iamDatabaseAuthenticationEnabled)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let licenseModel = licenseModel {
            try encodeContainer.encode(licenseModel, forKey: .licenseModel)
        }
        if let masterUsername = masterUsername {
            try encodeContainer.encode(masterUsername, forKey: .masterUsername)
        }
        if percentProgress != 0 {
            try encodeContainer.encode(percentProgress, forKey: .percentProgress)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let snapshotCreateTime = snapshotCreateTime {
            try encodeContainer.encode(snapshotCreateTime, forKey: .snapshotCreateTime)
        }
        if let snapshotType = snapshotType {
            try encodeContainer.encode(snapshotType, forKey: .snapshotType)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if storageEncrypted != false {
            try encodeContainer.encode(storageEncrypted, forKey: .storageEncrypted)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZonesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let snapshotCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotCreateTime)
        snapshotCreateTime = snapshotCreateTimeDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let allocatedStorageDecoded = try containerValues.decode(Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterCreateTime)
        clusterCreateTime = clusterCreateTimeDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let snapshotTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotType)
        snapshotType = snapshotTypeDecoded
        let percentProgressDecoded = try containerValues.decode(Int.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let storageEncryptedDecoded = try containerValues.decode(Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dbClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbClusterIdentifier)
        dbClusterIdentifier = dbClusterIdentifierDecoded
        let dbClusterSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbClusterSnapshotIdentifier)
        dbClusterSnapshotIdentifier = dbClusterSnapshotIdentifierDecoded
        let iamDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Bool.self, forKey: .iamDatabaseAuthenticationEnabled)
        iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabledDecoded
    }
}

extension AwsRdsDbClusterSnapshotDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRdsDbClusterSnapshotDetails(allocatedStorage: \(String(describing: allocatedStorage)), availabilityZones: \(String(describing: availabilityZones)), clusterCreateTime: \(String(describing: clusterCreateTime)), dbClusterIdentifier: \(String(describing: dbClusterIdentifier)), dbClusterSnapshotIdentifier: \(String(describing: dbClusterSnapshotIdentifier)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), iamDatabaseAuthenticationEnabled: \(String(describing: iamDatabaseAuthenticationEnabled)), kmsKeyId: \(String(describing: kmsKeyId)), licenseModel: \(String(describing: licenseModel)), masterUsername: \(String(describing: masterUsername)), percentProgress: \(String(describing: percentProgress)), port: \(String(describing: port)), snapshotCreateTime: \(String(describing: snapshotCreateTime)), snapshotType: \(String(describing: snapshotType)), status: \(String(describing: status)), storageEncrypted: \(String(describing: storageEncrypted)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Information about an Amazon RDS DB cluster snapshot.</p>
public struct AwsRdsDbClusterSnapshotDetails: Equatable {
    /// <p>Specifies the allocated storage size in gibibytes (GiB).</p>
    public let allocatedStorage: Int
    /// <p>A list of Availability Zones where instances in the DB cluster can be created.</p>
    public let availabilityZones: [String]?
    /// <p>Indicates when the DB cluster was created, in Universal Coordinated Time (UTC).</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let clusterCreateTime: String?
    /// <p>The DB cluster identifier.</p>
    public let dbClusterIdentifier: String?
    /// <p>The identifier of the DB cluster snapshot.</p>
    public let dbClusterSnapshotIdentifier: String?
    /// <p>The name of the database engine that you want to use for this DB instance.</p>
    public let engine: String?
    /// <p>The version of the database engine to use.</p>
    public let engineVersion: String?
    /// <p>Whether mapping of IAM accounts to database accounts is enabled.</p>
    public let iamDatabaseAuthenticationEnabled: Bool
    /// <p>The ARN of the AWS KMS master key that is used to encrypt the database instances in the
    ///          DB cluster.</p>
    public let kmsKeyId: String?
    /// <p>The license model information for this DB cluster snapshot.</p>
    public let licenseModel: String?
    /// <p>The name of the master user for the DB cluster.</p>
    public let masterUsername: String?
    /// <p>Specifies the percentage of the estimated data that has been transferred.</p>
    public let percentProgress: Int
    /// <p>The port number on which the DB instances in the DB cluster accept connections.</p>
    public let port: Int
    /// <p>Indicates when the snapshot was taken.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let snapshotCreateTime: String?
    /// <p>The type of DB cluster snapshot.</p>
    public let snapshotType: String?
    /// <p>The status of this DB cluster snapshot.</p>
    public let status: String?
    /// <p>Whether the DB cluster is encrypted.</p>
    public let storageEncrypted: Bool
    /// <p>The VPC ID that is associated with the DB cluster snapshot.</p>
    public let vpcId: String?

    public init (
        allocatedStorage: Int = 0,
        availabilityZones: [String]? = nil,
        clusterCreateTime: String? = nil,
        dbClusterIdentifier: String? = nil,
        dbClusterSnapshotIdentifier: String? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        iamDatabaseAuthenticationEnabled: Bool = false,
        kmsKeyId: String? = nil,
        licenseModel: String? = nil,
        masterUsername: String? = nil,
        percentProgress: Int = 0,
        port: Int = 0,
        snapshotCreateTime: String? = nil,
        snapshotType: String? = nil,
        status: String? = nil,
        storageEncrypted: Bool = false,
        vpcId: String? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.availabilityZones = availabilityZones
        self.clusterCreateTime = clusterCreateTime
        self.dbClusterIdentifier = dbClusterIdentifier
        self.dbClusterSnapshotIdentifier = dbClusterSnapshotIdentifier
        self.engine = engine
        self.engineVersion = engineVersion
        self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
        self.kmsKeyId = kmsKeyId
        self.licenseModel = licenseModel
        self.masterUsername = masterUsername
        self.percentProgress = percentProgress
        self.port = port
        self.snapshotCreateTime = snapshotCreateTime
        self.snapshotType = snapshotType
        self.status = status
        self.storageEncrypted = storageEncrypted
        self.vpcId = vpcId
    }
}

extension AwsRdsDbDomainMembership: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domain = "Domain"
        case fqdn = "Fqdn"
        case iamRoleName = "IamRoleName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let fqdn = fqdn {
            try encodeContainer.encode(fqdn, forKey: .fqdn)
        }
        if let iamRoleName = iamRoleName {
            try encodeContainer.encode(iamRoleName, forKey: .iamRoleName)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let fqdnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fqdn)
        fqdn = fqdnDecoded
        let iamRoleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleName)
        iamRoleName = iamRoleNameDecoded
    }
}

extension AwsRdsDbDomainMembership: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRdsDbDomainMembership(domain: \(String(describing: domain)), fqdn: \(String(describing: fqdn)), iamRoleName: \(String(describing: iamRoleName)), status: \(String(describing: status)))"}
}

/// <p>Information about an Active Directory domain membership record associated with the DB
///          instance.</p>
public struct AwsRdsDbDomainMembership: Equatable {
    /// <p>The identifier of the Active Directory domain.</p>
    public let domain: String?
    /// <p>The fully qualified domain name of the Active Directory domain.</p>
    public let fqdn: String?
    /// <p>The name of the IAM role to use when making API calls to the Directory Service.</p>
    public let iamRoleName: String?
    /// <p>The status of the Active Directory Domain membership for the DB instance.</p>
    public let status: String?

    public init (
        domain: String? = nil,
        fqdn: String? = nil,
        iamRoleName: String? = nil,
        status: String? = nil
    )
    {
        self.domain = domain
        self.fqdn = fqdn
        self.iamRoleName = iamRoleName
        self.status = status
    }
}

extension AwsRdsDbInstanceAssociatedRole: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case featureName = "FeatureName"
        case roleArn = "RoleArn"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featureName = featureName {
            try encodeContainer.encode(featureName, forKey: .featureName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let featureNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .featureName)
        featureName = featureNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AwsRdsDbInstanceAssociatedRole: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRdsDbInstanceAssociatedRole(featureName: \(String(describing: featureName)), roleArn: \(String(describing: roleArn)), status: \(String(describing: status)))"}
}

/// <p>An AWS Identity and Access Management (IAM) role associated with the DB instance.</p>
public struct AwsRdsDbInstanceAssociatedRole: Equatable {
    /// <p>The name of the feature associated with the IAM)role.</p>
    public let featureName: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role that is associated with the DB
    ///          instance.</p>
    public let roleArn: String?
    /// <p>Describes the state of the association between the IAM role and the DB instance. The
    ///             <code>Status</code> property returns one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code> - The IAM role ARN is associated with the DB instance and can
    ///                be used to access other AWS services on your behalf.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PENDING</code> - The IAM role ARN is being associated with the DB
    ///                instance.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INVALID</code> - The IAM role ARN is associated with the DB instance. But
    ///                the DB instance is unable to assume the IAM role in order to access other AWS
    ///                services on your behalf. </p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        featureName: String? = nil,
        roleArn: String? = nil,
        status: String? = nil
    )
    {
        self.featureName = featureName
        self.roleArn = roleArn
        self.status = status
    }
}

extension AwsRdsDbInstanceDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case associatedRoles = "AssociatedRoles"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case cACertificateIdentifier = "CACertificateIdentifier"
        case characterSetName = "CharacterSetName"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBInstanceClass = "DBInstanceClass"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBName = "DBName"
        case dbInstancePort = "DbInstancePort"
        case dbInstanceStatus = "DbInstanceStatus"
        case dbParameterGroups = "DbParameterGroups"
        case dbSecurityGroups = "DbSecurityGroups"
        case dbSubnetGroup = "DbSubnetGroup"
        case dbiResourceId = "DbiResourceId"
        case deletionProtection = "DeletionProtection"
        case domainMemberships = "DomainMemberships"
        case enabledCloudWatchLogsExports = "EnabledCloudWatchLogsExports"
        case endpoint = "Endpoint"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case enhancedMonitoringResourceArn = "EnhancedMonitoringResourceArn"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case instanceCreateTime = "InstanceCreateTime"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case latestRestorableTime = "LatestRestorableTime"
        case licenseModel = "LicenseModel"
        case listenerEndpoint = "ListenerEndpoint"
        case masterUsername = "MasterUsername"
        case maxAllocatedStorage = "MaxAllocatedStorage"
        case monitoringInterval = "MonitoringInterval"
        case monitoringRoleArn = "MonitoringRoleArn"
        case multiAz = "MultiAz"
        case optionGroupMemberships = "OptionGroupMemberships"
        case pendingModifiedValues = "PendingModifiedValues"
        case performanceInsightsEnabled = "PerformanceInsightsEnabled"
        case performanceInsightsKmsKeyId = "PerformanceInsightsKmsKeyId"
        case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case processorFeatures = "ProcessorFeatures"
        case promotionTier = "PromotionTier"
        case publiclyAccessible = "PubliclyAccessible"
        case readReplicaDBClusterIdentifiers = "ReadReplicaDBClusterIdentifiers"
        case readReplicaDBInstanceIdentifiers = "ReadReplicaDBInstanceIdentifiers"
        case readReplicaSourceDBInstanceIdentifier = "ReadReplicaSourceDBInstanceIdentifier"
        case secondaryAvailabilityZone = "SecondaryAvailabilityZone"
        case statusInfos = "StatusInfos"
        case storageEncrypted = "StorageEncrypted"
        case storageType = "StorageType"
        case tdeCredentialArn = "TdeCredentialArn"
        case timezone = "Timezone"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allocatedStorage != 0 {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if let associatedRoles = associatedRoles {
            var associatedRolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedRoles)
            for awsrdsdbinstanceassociatedroles0 in associatedRoles {
                try associatedRolesContainer.encode(awsrdsdbinstanceassociatedroles0)
            }
        }
        if autoMinorVersionUpgrade != false {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if backupRetentionPeriod != 0 {
            try encodeContainer.encode(backupRetentionPeriod, forKey: .backupRetentionPeriod)
        }
        if let cACertificateIdentifier = cACertificateIdentifier {
            try encodeContainer.encode(cACertificateIdentifier, forKey: .cACertificateIdentifier)
        }
        if let characterSetName = characterSetName {
            try encodeContainer.encode(characterSetName, forKey: .characterSetName)
        }
        if copyTagsToSnapshot != false {
            try encodeContainer.encode(copyTagsToSnapshot, forKey: .copyTagsToSnapshot)
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try encodeContainer.encode(dBClusterIdentifier, forKey: .dBClusterIdentifier)
        }
        if let dBInstanceClass = dBInstanceClass {
            try encodeContainer.encode(dBInstanceClass, forKey: .dBInstanceClass)
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try encodeContainer.encode(dBInstanceIdentifier, forKey: .dBInstanceIdentifier)
        }
        if let dBName = dBName {
            try encodeContainer.encode(dBName, forKey: .dBName)
        }
        if dbInstancePort != 0 {
            try encodeContainer.encode(dbInstancePort, forKey: .dbInstancePort)
        }
        if let dbInstanceStatus = dbInstanceStatus {
            try encodeContainer.encode(dbInstanceStatus, forKey: .dbInstanceStatus)
        }
        if let dbParameterGroups = dbParameterGroups {
            var dbParameterGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dbParameterGroups)
            for awsrdsdbparametergroups0 in dbParameterGroups {
                try dbParameterGroupsContainer.encode(awsrdsdbparametergroups0)
            }
        }
        if let dbSecurityGroups = dbSecurityGroups {
            var dbSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dbSecurityGroups)
            for stringlist0 in dbSecurityGroups {
                try dbSecurityGroupsContainer.encode(stringlist0)
            }
        }
        if let dbSubnetGroup = dbSubnetGroup {
            try encodeContainer.encode(dbSubnetGroup, forKey: .dbSubnetGroup)
        }
        if let dbiResourceId = dbiResourceId {
            try encodeContainer.encode(dbiResourceId, forKey: .dbiResourceId)
        }
        if deletionProtection != false {
            try encodeContainer.encode(deletionProtection, forKey: .deletionProtection)
        }
        if let domainMemberships = domainMemberships {
            var domainMembershipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainMemberships)
            for awsrdsdbdomainmemberships0 in domainMemberships {
                try domainMembershipsContainer.encode(awsrdsdbdomainmemberships0)
            }
        }
        if let enabledCloudWatchLogsExports = enabledCloudWatchLogsExports {
            var enabledCloudWatchLogsExportsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .enabledCloudWatchLogsExports)
            for stringlist0 in enabledCloudWatchLogsExports {
                try enabledCloudWatchLogsExportsContainer.encode(stringlist0)
            }
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let engine = engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let enhancedMonitoringResourceArn = enhancedMonitoringResourceArn {
            try encodeContainer.encode(enhancedMonitoringResourceArn, forKey: .enhancedMonitoringResourceArn)
        }
        if iAMDatabaseAuthenticationEnabled != false {
            try encodeContainer.encode(iAMDatabaseAuthenticationEnabled, forKey: .iAMDatabaseAuthenticationEnabled)
        }
        if let instanceCreateTime = instanceCreateTime {
            try encodeContainer.encode(instanceCreateTime, forKey: .instanceCreateTime)
        }
        if iops != 0 {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let latestRestorableTime = latestRestorableTime {
            try encodeContainer.encode(latestRestorableTime, forKey: .latestRestorableTime)
        }
        if let licenseModel = licenseModel {
            try encodeContainer.encode(licenseModel, forKey: .licenseModel)
        }
        if let listenerEndpoint = listenerEndpoint {
            try encodeContainer.encode(listenerEndpoint, forKey: .listenerEndpoint)
        }
        if let masterUsername = masterUsername {
            try encodeContainer.encode(masterUsername, forKey: .masterUsername)
        }
        if maxAllocatedStorage != 0 {
            try encodeContainer.encode(maxAllocatedStorage, forKey: .maxAllocatedStorage)
        }
        if monitoringInterval != 0 {
            try encodeContainer.encode(monitoringInterval, forKey: .monitoringInterval)
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try encodeContainer.encode(monitoringRoleArn, forKey: .monitoringRoleArn)
        }
        if multiAz != false {
            try encodeContainer.encode(multiAz, forKey: .multiAz)
        }
        if let optionGroupMemberships = optionGroupMemberships {
            var optionGroupMembershipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .optionGroupMemberships)
            for awsrdsdboptiongroupmemberships0 in optionGroupMemberships {
                try optionGroupMembershipsContainer.encode(awsrdsdboptiongroupmemberships0)
            }
        }
        if let pendingModifiedValues = pendingModifiedValues {
            try encodeContainer.encode(pendingModifiedValues, forKey: .pendingModifiedValues)
        }
        if performanceInsightsEnabled != false {
            try encodeContainer.encode(performanceInsightsEnabled, forKey: .performanceInsightsEnabled)
        }
        if let performanceInsightsKmsKeyId = performanceInsightsKmsKeyId {
            try encodeContainer.encode(performanceInsightsKmsKeyId, forKey: .performanceInsightsKmsKeyId)
        }
        if performanceInsightsRetentionPeriod != 0 {
            try encodeContainer.encode(performanceInsightsRetentionPeriod, forKey: .performanceInsightsRetentionPeriod)
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try encodeContainer.encode(preferredBackupWindow, forKey: .preferredBackupWindow)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processorFeatures)
            for awsrdsdbprocessorfeatures0 in processorFeatures {
                try processorFeaturesContainer.encode(awsrdsdbprocessorfeatures0)
            }
        }
        if promotionTier != 0 {
            try encodeContainer.encode(promotionTier, forKey: .promotionTier)
        }
        if publiclyAccessible != false {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiers {
            var readReplicaDBClusterIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .readReplicaDBClusterIdentifiers)
            for stringlist0 in readReplicaDBClusterIdentifiers {
                try readReplicaDBClusterIdentifiersContainer.encode(stringlist0)
            }
        }
        if let readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiers {
            var readReplicaDBInstanceIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .readReplicaDBInstanceIdentifiers)
            for stringlist0 in readReplicaDBInstanceIdentifiers {
                try readReplicaDBInstanceIdentifiersContainer.encode(stringlist0)
            }
        }
        if let readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifier {
            try encodeContainer.encode(readReplicaSourceDBInstanceIdentifier, forKey: .readReplicaSourceDBInstanceIdentifier)
        }
        if let secondaryAvailabilityZone = secondaryAvailabilityZone {
            try encodeContainer.encode(secondaryAvailabilityZone, forKey: .secondaryAvailabilityZone)
        }
        if let statusInfos = statusInfos {
            var statusInfosContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statusInfos)
            for awsrdsdbstatusinfos0 in statusInfos {
                try statusInfosContainer.encode(awsrdsdbstatusinfos0)
            }
        }
        if storageEncrypted != false {
            try encodeContainer.encode(storageEncrypted, forKey: .storageEncrypted)
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType, forKey: .storageType)
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try encodeContainer.encode(tdeCredentialArn, forKey: .tdeCredentialArn)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroups)
            for awsrdsdbinstancevpcsecuritygroups0 in vpcSecurityGroups {
                try vpcSecurityGroupsContainer.encode(awsrdsdbinstancevpcsecuritygroups0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedRolesContainer = try containerValues.decodeIfPresent([AwsRdsDbInstanceAssociatedRole?].self, forKey: .associatedRoles)
        var associatedRolesDecoded0:[AwsRdsDbInstanceAssociatedRole]? = nil
        if let associatedRolesContainer = associatedRolesContainer {
            associatedRolesDecoded0 = [AwsRdsDbInstanceAssociatedRole]()
            for structure0 in associatedRolesContainer {
                if let structure0 = structure0 {
                    associatedRolesDecoded0?.append(structure0)
                }
            }
        }
        associatedRoles = associatedRolesDecoded0
        let cACertificateIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cACertificateIdentifier)
        cACertificateIdentifier = cACertificateIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let dbInstancePortDecoded = try containerValues.decode(Int.self, forKey: .dbInstancePort)
        dbInstancePort = dbInstancePortDecoded
        let dbiResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbiResourceId)
        dbiResourceId = dbiResourceIdDecoded
        let dBNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBName)
        dBName = dBNameDecoded
        let deletionProtectionDecoded = try containerValues.decode(Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(AwsRdsDbInstanceEndpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        let instanceCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceCreateTime)
        instanceCreateTime = instanceCreateTimeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let publiclyAccessibleDecoded = try containerValues.decode(Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let storageEncryptedDecoded = try containerValues.decode(Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let tdeCredentialArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tdeCredentialArn)
        tdeCredentialArn = tdeCredentialArnDecoded
        let vpcSecurityGroupsContainer = try containerValues.decodeIfPresent([AwsRdsDbInstanceVpcSecurityGroup?].self, forKey: .vpcSecurityGroups)
        var vpcSecurityGroupsDecoded0:[AwsRdsDbInstanceVpcSecurityGroup]? = nil
        if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
            vpcSecurityGroupsDecoded0 = [AwsRdsDbInstanceVpcSecurityGroup]()
            for structure0 in vpcSecurityGroupsContainer {
                if let structure0 = structure0 {
                    vpcSecurityGroupsDecoded0?.append(structure0)
                }
            }
        }
        vpcSecurityGroups = vpcSecurityGroupsDecoded0
        let multiAzDecoded = try containerValues.decode(Bool.self, forKey: .multiAz)
        multiAz = multiAzDecoded
        let enhancedMonitoringResourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .enhancedMonitoringResourceArn)
        enhancedMonitoringResourceArn = enhancedMonitoringResourceArnDecoded
        let dbInstanceStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbInstanceStatus)
        dbInstanceStatus = dbInstanceStatusDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let allocatedStorageDecoded = try containerValues.decode(Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let backupRetentionPeriodDecoded = try containerValues.decode(Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let dbSecurityGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dbSecurityGroups)
        var dbSecurityGroupsDecoded0:[String]? = nil
        if let dbSecurityGroupsContainer = dbSecurityGroupsContainer {
            dbSecurityGroupsDecoded0 = [String]()
            for string0 in dbSecurityGroupsContainer {
                if let string0 = string0 {
                    dbSecurityGroupsDecoded0?.append(string0)
                }
            }
        }
        dbSecurityGroups = dbSecurityGroupsDecoded0
        let dbParameterGroupsContainer = try containerValues.decodeIfPresent([AwsRdsDbParameterGroup?].self, forKey: .dbParameterGroups)
        var dbParameterGroupsDecoded0:[AwsRdsDbParameterGroup]? = nil
        if let dbParameterGroupsContainer = dbParameterGroupsContainer {
            dbParameterGroupsDecoded0 = [AwsRdsDbParameterGroup]()
            for structure0 in dbParameterGroupsContainer {
                if let structure0 = structure0 {
                    dbParameterGroupsDecoded0?.append(structure0)
                }
            }
        }
        dbParameterGroups = dbParameterGroupsDecoded0
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let dbSubnetGroupDecoded = try containerValues.decodeIfPresent(AwsRdsDbSubnetGroup.self, forKey: .dbSubnetGroup)
        dbSubnetGroup = dbSubnetGroupDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(AwsRdsDbPendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
        let latestRestorableTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestRestorableTime)
        latestRestorableTime = latestRestorableTimeDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decode(Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let readReplicaSourceDBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .readReplicaSourceDBInstanceIdentifier)
        readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifierDecoded
        let readReplicaDBInstanceIdentifiersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .readReplicaDBInstanceIdentifiers)
        var readReplicaDBInstanceIdentifiersDecoded0:[String]? = nil
        if let readReplicaDBInstanceIdentifiersContainer = readReplicaDBInstanceIdentifiersContainer {
            readReplicaDBInstanceIdentifiersDecoded0 = [String]()
            for string0 in readReplicaDBInstanceIdentifiersContainer {
                if let string0 = string0 {
                    readReplicaDBInstanceIdentifiersDecoded0?.append(string0)
                }
            }
        }
        readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiersDecoded0
        let readReplicaDBClusterIdentifiersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .readReplicaDBClusterIdentifiers)
        var readReplicaDBClusterIdentifiersDecoded0:[String]? = nil
        if let readReplicaDBClusterIdentifiersContainer = readReplicaDBClusterIdentifiersContainer {
            readReplicaDBClusterIdentifiersDecoded0 = [String]()
            for string0 in readReplicaDBClusterIdentifiersContainer {
                if let string0 = string0 {
                    readReplicaDBClusterIdentifiersDecoded0?.append(string0)
                }
            }
        }
        readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiersDecoded0
        let licenseModelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let iopsDecoded = try containerValues.decode(Int.self, forKey: .iops)
        iops = iopsDecoded
        let optionGroupMembershipsContainer = try containerValues.decodeIfPresent([AwsRdsDbOptionGroupMembership?].self, forKey: .optionGroupMemberships)
        var optionGroupMembershipsDecoded0:[AwsRdsDbOptionGroupMembership]? = nil
        if let optionGroupMembershipsContainer = optionGroupMembershipsContainer {
            optionGroupMembershipsDecoded0 = [AwsRdsDbOptionGroupMembership]()
            for structure0 in optionGroupMembershipsContainer {
                if let structure0 = structure0 {
                    optionGroupMembershipsDecoded0?.append(structure0)
                }
            }
        }
        optionGroupMemberships = optionGroupMembershipsDecoded0
        let characterSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let secondaryAvailabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secondaryAvailabilityZone)
        secondaryAvailabilityZone = secondaryAvailabilityZoneDecoded
        let statusInfosContainer = try containerValues.decodeIfPresent([AwsRdsDbStatusInfo?].self, forKey: .statusInfos)
        var statusInfosDecoded0:[AwsRdsDbStatusInfo]? = nil
        if let statusInfosContainer = statusInfosContainer {
            statusInfosDecoded0 = [AwsRdsDbStatusInfo]()
            for structure0 in statusInfosContainer {
                if let structure0 = structure0 {
                    statusInfosDecoded0?.append(structure0)
                }
            }
        }
        statusInfos = statusInfosDecoded0
        let storageTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let domainMembershipsContainer = try containerValues.decodeIfPresent([AwsRdsDbDomainMembership?].self, forKey: .domainMemberships)
        var domainMembershipsDecoded0:[AwsRdsDbDomainMembership]? = nil
        if let domainMembershipsContainer = domainMembershipsContainer {
            domainMembershipsDecoded0 = [AwsRdsDbDomainMembership]()
            for structure0 in domainMembershipsContainer {
                if let structure0 = structure0 {
                    domainMembershipsDecoded0?.append(structure0)
                }
            }
        }
        domainMemberships = domainMembershipsDecoded0
        let copyTagsToSnapshotDecoded = try containerValues.decode(Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let monitoringIntervalDecoded = try containerValues.decode(Int.self, forKey: .monitoringInterval)
        monitoringInterval = monitoringIntervalDecoded
        let monitoringRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .monitoringRoleArn)
        monitoringRoleArn = monitoringRoleArnDecoded
        let promotionTierDecoded = try containerValues.decode(Int.self, forKey: .promotionTier)
        promotionTier = promotionTierDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let performanceInsightsEnabledDecoded = try containerValues.decode(Bool.self, forKey: .performanceInsightsEnabled)
        performanceInsightsEnabled = performanceInsightsEnabledDecoded
        let performanceInsightsKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .performanceInsightsKmsKeyId)
        performanceInsightsKmsKeyId = performanceInsightsKmsKeyIdDecoded
        let performanceInsightsRetentionPeriodDecoded = try containerValues.decode(Int.self, forKey: .performanceInsightsRetentionPeriod)
        performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriodDecoded
        let enabledCloudWatchLogsExportsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .enabledCloudWatchLogsExports)
        var enabledCloudWatchLogsExportsDecoded0:[String]? = nil
        if let enabledCloudWatchLogsExportsContainer = enabledCloudWatchLogsExportsContainer {
            enabledCloudWatchLogsExportsDecoded0 = [String]()
            for string0 in enabledCloudWatchLogsExportsContainer {
                if let string0 = string0 {
                    enabledCloudWatchLogsExportsDecoded0?.append(string0)
                }
            }
        }
        enabledCloudWatchLogsExports = enabledCloudWatchLogsExportsDecoded0
        let processorFeaturesContainer = try containerValues.decodeIfPresent([AwsRdsDbProcessorFeature?].self, forKey: .processorFeatures)
        var processorFeaturesDecoded0:[AwsRdsDbProcessorFeature]? = nil
        if let processorFeaturesContainer = processorFeaturesContainer {
            processorFeaturesDecoded0 = [AwsRdsDbProcessorFeature]()
            for structure0 in processorFeaturesContainer {
                if let structure0 = structure0 {
                    processorFeaturesDecoded0?.append(structure0)
                }
            }
        }
        processorFeatures = processorFeaturesDecoded0
        let listenerEndpointDecoded = try containerValues.decodeIfPresent(AwsRdsDbInstanceEndpoint.self, forKey: .listenerEndpoint)
        listenerEndpoint = listenerEndpointDecoded
        let maxAllocatedStorageDecoded = try containerValues.decode(Int.self, forKey: .maxAllocatedStorage)
        maxAllocatedStorage = maxAllocatedStorageDecoded
    }
}

extension AwsRdsDbInstanceDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRdsDbInstanceDetails(allocatedStorage: \(String(describing: allocatedStorage)), associatedRoles: \(String(describing: associatedRoles)), autoMinorVersionUpgrade: \(String(describing: autoMinorVersionUpgrade)), availabilityZone: \(String(describing: availabilityZone)), backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), cACertificateIdentifier: \(String(describing: cACertificateIdentifier)), characterSetName: \(String(describing: characterSetName)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBInstanceClass: \(String(describing: dBInstanceClass)), dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), dBName: \(String(describing: dBName)), dbInstancePort: \(String(describing: dbInstancePort)), dbInstanceStatus: \(String(describing: dbInstanceStatus)), dbParameterGroups: \(String(describing: dbParameterGroups)), dbSecurityGroups: \(String(describing: dbSecurityGroups)), dbSubnetGroup: \(String(describing: dbSubnetGroup)), dbiResourceId: \(String(describing: dbiResourceId)), deletionProtection: \(String(describing: deletionProtection)), domainMemberships: \(String(describing: domainMemberships)), enabledCloudWatchLogsExports: \(String(describing: enabledCloudWatchLogsExports)), endpoint: \(String(describing: endpoint)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), enhancedMonitoringResourceArn: \(String(describing: enhancedMonitoringResourceArn)), iAMDatabaseAuthenticationEnabled: \(String(describing: iAMDatabaseAuthenticationEnabled)), instanceCreateTime: \(String(describing: instanceCreateTime)), iops: \(String(describing: iops)), kmsKeyId: \(String(describing: kmsKeyId)), latestRestorableTime: \(String(describing: latestRestorableTime)), licenseModel: \(String(describing: licenseModel)), listenerEndpoint: \(String(describing: listenerEndpoint)), masterUsername: \(String(describing: masterUsername)), maxAllocatedStorage: \(String(describing: maxAllocatedStorage)), monitoringInterval: \(String(describing: monitoringInterval)), monitoringRoleArn: \(String(describing: monitoringRoleArn)), multiAz: \(String(describing: multiAz)), optionGroupMemberships: \(String(describing: optionGroupMemberships)), pendingModifiedValues: \(String(describing: pendingModifiedValues)), performanceInsightsEnabled: \(String(describing: performanceInsightsEnabled)), performanceInsightsKmsKeyId: \(String(describing: performanceInsightsKmsKeyId)), performanceInsightsRetentionPeriod: \(String(describing: performanceInsightsRetentionPeriod)), preferredBackupWindow: \(String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), processorFeatures: \(String(describing: processorFeatures)), promotionTier: \(String(describing: promotionTier)), publiclyAccessible: \(String(describing: publiclyAccessible)), readReplicaDBClusterIdentifiers: \(String(describing: readReplicaDBClusterIdentifiers)), readReplicaDBInstanceIdentifiers: \(String(describing: readReplicaDBInstanceIdentifiers)), readReplicaSourceDBInstanceIdentifier: \(String(describing: readReplicaSourceDBInstanceIdentifier)), secondaryAvailabilityZone: \(String(describing: secondaryAvailabilityZone)), statusInfos: \(String(describing: statusInfos)), storageEncrypted: \(String(describing: storageEncrypted)), storageType: \(String(describing: storageType)), tdeCredentialArn: \(String(describing: tdeCredentialArn)), timezone: \(String(describing: timezone)), vpcSecurityGroups: \(String(describing: vpcSecurityGroups)))"}
}

/// <p>Contains the details of an Amazon RDS DB instance.</p>
public struct AwsRdsDbInstanceDetails: Equatable {
    /// <p>The amount of storage (in gigabytes) to initially allocate for the DB instance.</p>
    public let allocatedStorage: Int
    /// <p>The AWS Identity and Access Management (IAM) roles associated with the DB
    ///          instance.</p>
    public let associatedRoles: [AwsRdsDbInstanceAssociatedRole]?
    /// <p>Indicates whether minor version patches are applied automatically.</p>
    public let autoMinorVersionUpgrade: Bool
    /// <p>The Availability Zone where the DB instance will be created.</p>
    public let availabilityZone: String?
    /// <p>The number of days for which to retain automated backups.</p>
    public let backupRetentionPeriod: Int
    /// <p>The identifier of the CA certificate for this DB instance.</p>
    public let cACertificateIdentifier: String?
    /// <p>The name of the character set that this DB instance is associated with.</p>
    public let characterSetName: String?
    /// <p>Whether to copy resource tags to snapshots of the DB instance.</p>
    public let copyTagsToSnapshot: Bool
    /// <p>If the DB instance is a member of a DB cluster, contains the name of the DB cluster that
    ///          the DB instance is a member of.</p>
    public let dBClusterIdentifier: String?
    /// <p>Contains the name of the compute and memory capacity class of the DB instance.</p>
    public let dBInstanceClass: String?
    /// <p>Contains a user-supplied database identifier. This identifier is the unique key that
    ///          identifies a DB instance.</p>
    public let dBInstanceIdentifier: String?
    /// <p>The meaning of this parameter differs according to the database engine you use.</p>
    ///          <p>
    ///             <b>MySQL, MariaDB, SQL Server, PostgreSQL</b>
    ///          </p>
    ///          <p>Contains the name of the initial database of this instance that was provided at create
    ///          time, if one was specified when the DB instance was created. This same name is returned for
    ///          the life of the DB instance.</p>
    ///          <p>
    ///             <b>Oracle</b>
    ///          </p>
    ///          <p>Contains the Oracle System ID (SID) of the created DB instance. Not shown when the
    ///          returned parameters do not apply to an Oracle DB instance. </p>
    public let dBName: String?
    /// <p>Specifies the port that the DB instance listens on. If the DB instance is part of a DB
    ///          cluster, this can be a different port than the DB cluster port.</p>
    public let dbInstancePort: Int
    /// <p>The current status of the DB instance.</p>
    public let dbInstanceStatus: String?
    /// <p>A list of the DB parameter groups to assign to the DB instance.</p>
    public let dbParameterGroups: [AwsRdsDbParameterGroup]?
    /// <p>A list of the DB security groups to assign to the DB instance.</p>
    public let dbSecurityGroups: [String]?
    /// <p>Information about the subnet group that is associated with the DB instance.</p>
    public let dbSubnetGroup: AwsRdsDbSubnetGroup?
    /// <p>The AWS Region-unique, immutable identifier for the DB instance. This identifier is
    ///          found in AWS CloudTrail log entries whenever the AWS KMS key for the DB instance is
    ///          accessed. </p>
    public let dbiResourceId: String?
    /// <p>Indicates whether the DB instance has deletion protection enabled.</p>
    ///          <p>When deletion protection is enabled, the database cannot be deleted.</p>
    public let deletionProtection: Bool
    /// <p>The Active Directory domain membership records associated with the DB instance.</p>
    public let domainMemberships: [AwsRdsDbDomainMembership]?
    /// <p>A list of log types that this DB instance is configured to export to CloudWatch
    ///          Logs.</p>
    public let enabledCloudWatchLogsExports: [String]?
    /// <p>Specifies the connection endpoint.</p>
    public let endpoint: AwsRdsDbInstanceEndpoint?
    /// <p>Provides the name of the database engine to use for this DB instance.</p>
    public let engine: String?
    /// <p>Indicates the database engine version.</p>
    public let engineVersion: String?
    /// <p>The ARN of the CloudWatch Logs log stream that receives the enhanced monitoring metrics
    ///          data for the DB instance.</p>
    public let enhancedMonitoringResourceArn: String?
    /// <p>True if mapping of AWS Identity and Access Management (IAM) accounts to database
    ///          accounts is enabled, and otherwise false.</p>
    ///          <p>IAM database authentication can be enabled for the following database engines.</p>
    ///          <ul>
    ///             <li>
    ///                <p>For MySQL 5.6, minor version 5.6.34 or higher</p>
    ///             </li>
    ///             <li>
    ///                <p>For MySQL 5.7, minor version 5.7.16 or higher</p>
    ///             </li>
    ///             <li>
    ///                <p>Aurora 5.6 or higher</p>
    ///             </li>
    ///          </ul>
    public let iAMDatabaseAuthenticationEnabled: Bool
    /// <p>Indicates when the DB instance was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let instanceCreateTime: String?
    /// <p>Specifies the provisioned IOPS (I/O operations per second) for this DB instance.</p>
    public let iops: Int
    /// <p>If <code>StorageEncrypted</code> is true, the AWS KMS key identifier for the encrypted
    ///          DB instance.</p>
    public let kmsKeyId: String?
    /// <p>Specifies the latest time to which a database can be restored with point-in-time
    ///          restore.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let latestRestorableTime: String?
    /// <p>License model information for this DB instance.</p>
    public let licenseModel: String?
    /// <p>Specifies the connection endpoint.</p>
    public let listenerEndpoint: AwsRdsDbInstanceEndpoint?
    /// <p>The master user name of the DB instance.</p>
    public let masterUsername: String?
    /// <p>The upper limit to which Amazon RDS can automatically scale the storage of the DB
    ///          instance.</p>
    public let maxAllocatedStorage: Int
    /// <p>The interval, in seconds, between points when enhanced monitoring metrics are collected
    ///          for the DB instance.</p>
    public let monitoringInterval: Int
    /// <p>The ARN for the IAM role that permits Amazon RDS to send enhanced monitoring metrics to
    ///          CloudWatch Logs.</p>
    public let monitoringRoleArn: String?
    /// <p>Whether the DB instance is a multiple Availability Zone deployment.</p>
    public let multiAz: Bool
    /// <p>The list of option group memberships for this DB instance.</p>
    public let optionGroupMemberships: [AwsRdsDbOptionGroupMembership]?
    /// <p>Changes to the DB instance that are currently pending.</p>
    public let pendingModifiedValues: AwsRdsDbPendingModifiedValues?
    /// <p>Indicates whether Performance Insights is enabled for the DB instance.</p>
    public let performanceInsightsEnabled: Bool
    /// <p>The identifier of the AWS KMS key used to encrypt the Performance Insights data.</p>
    public let performanceInsightsKmsKeyId: String?
    /// <p>The number of days to retain Performance Insights data.</p>
    public let performanceInsightsRetentionPeriod: Int
    /// <p>The range of time each day when automated backups are created, if automated backups are
    ///          enabled.</p>
    ///          <p>Uses the format <code>HH:MM-HH:MM</code>. For example, <code>04:52-05:22</code>.</p>
    public let preferredBackupWindow: String?
    /// <p>The weekly time range during which system maintenance can occur, in Universal
    ///          Coordinated Time (UTC).</p>
    ///          <p>Uses the format <code><day>:HH:MM-<day>:HH:MM</code>.</p>
    ///          <p>For the day values, use
    ///             <code>mon</code>|<code>tue</code>|<code>wed</code>|<code>thu</code>|<code>fri</code>|<code>sat</code>|<code>sun</code>.</p>
    ///          <p>For example, <code>sun:09:32-sun:10:02</code>.</p>
    public let preferredMaintenanceWindow: String?
    /// <p>The number of CPU cores and the number of threads per core for the DB instance class of
    ///          the DB instance.</p>
    public let processorFeatures: [AwsRdsDbProcessorFeature]?
    /// <p>The order in which to promote an Aurora replica to the primary instance after a failure
    ///          of the existing primary instance.</p>
    public let promotionTier: Int
    /// <p>Specifies the accessibility options for the DB instance.</p>
    ///          <p>A value of true specifies an Internet-facing instance with a publicly resolvable DNS
    ///          name, which resolves to a public IP address.</p>
    ///          <p>A value of false specifies an internal instance with a DNS name that resolves to a
    ///          private IP address. </p>
    public let publiclyAccessible: Bool
    /// <p>List of identifiers of Aurora DB clusters to which the RDS DB instance is replicated as
    ///          a read replica.</p>
    public let readReplicaDBClusterIdentifiers: [String]?
    /// <p>List of identifiers of the read replicas associated with this DB instance.</p>
    public let readReplicaDBInstanceIdentifiers: [String]?
    /// <p>If this DB instance is a read replica, contains the identifier of the source DB
    ///          instance.</p>
    public let readReplicaSourceDBInstanceIdentifier: String?
    /// <p>For a DB instance with multi-Availability Zone support, the name of the secondary
    ///          Availability Zone.</p>
    public let secondaryAvailabilityZone: String?
    /// <p>The status of a read replica. If the instance isn't a read replica, this is
    ///          empty.</p>
    public let statusInfos: [AwsRdsDbStatusInfo]?
    /// <p>Specifies whether the DB instance is encrypted.</p>
    public let storageEncrypted: Bool
    /// <p>The storage type for the DB instance.</p>
    public let storageType: String?
    /// <p>The ARN from the key store with which the instance is associated for TDE
    ///          encryption.</p>
    public let tdeCredentialArn: String?
    /// <p>The time zone of the DB instance.</p>
    public let timezone: String?
    /// <p>A list of VPC security groups that the DB instance belongs to.</p>
    public let vpcSecurityGroups: [AwsRdsDbInstanceVpcSecurityGroup]?

    public init (
        allocatedStorage: Int = 0,
        associatedRoles: [AwsRdsDbInstanceAssociatedRole]? = nil,
        autoMinorVersionUpgrade: Bool = false,
        availabilityZone: String? = nil,
        backupRetentionPeriod: Int = 0,
        cACertificateIdentifier: String? = nil,
        characterSetName: String? = nil,
        copyTagsToSnapshot: Bool = false,
        dBClusterIdentifier: String? = nil,
        dBInstanceClass: String? = nil,
        dBInstanceIdentifier: String? = nil,
        dBName: String? = nil,
        dbInstancePort: Int = 0,
        dbInstanceStatus: String? = nil,
        dbParameterGroups: [AwsRdsDbParameterGroup]? = nil,
        dbSecurityGroups: [String]? = nil,
        dbSubnetGroup: AwsRdsDbSubnetGroup? = nil,
        dbiResourceId: String? = nil,
        deletionProtection: Bool = false,
        domainMemberships: [AwsRdsDbDomainMembership]? = nil,
        enabledCloudWatchLogsExports: [String]? = nil,
        endpoint: AwsRdsDbInstanceEndpoint? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        enhancedMonitoringResourceArn: String? = nil,
        iAMDatabaseAuthenticationEnabled: Bool = false,
        instanceCreateTime: String? = nil,
        iops: Int = 0,
        kmsKeyId: String? = nil,
        latestRestorableTime: String? = nil,
        licenseModel: String? = nil,
        listenerEndpoint: AwsRdsDbInstanceEndpoint? = nil,
        masterUsername: String? = nil,
        maxAllocatedStorage: Int = 0,
        monitoringInterval: Int = 0,
        monitoringRoleArn: String? = nil,
        multiAz: Bool = false,
        optionGroupMemberships: [AwsRdsDbOptionGroupMembership]? = nil,
        pendingModifiedValues: AwsRdsDbPendingModifiedValues? = nil,
        performanceInsightsEnabled: Bool = false,
        performanceInsightsKmsKeyId: String? = nil,
        performanceInsightsRetentionPeriod: Int = 0,
        preferredBackupWindow: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        processorFeatures: [AwsRdsDbProcessorFeature]? = nil,
        promotionTier: Int = 0,
        publiclyAccessible: Bool = false,
        readReplicaDBClusterIdentifiers: [String]? = nil,
        readReplicaDBInstanceIdentifiers: [String]? = nil,
        readReplicaSourceDBInstanceIdentifier: String? = nil,
        secondaryAvailabilityZone: String? = nil,
        statusInfos: [AwsRdsDbStatusInfo]? = nil,
        storageEncrypted: Bool = false,
        storageType: String? = nil,
        tdeCredentialArn: String? = nil,
        timezone: String? = nil,
        vpcSecurityGroups: [AwsRdsDbInstanceVpcSecurityGroup]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.associatedRoles = associatedRoles
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.backupRetentionPeriod = backupRetentionPeriod
        self.cACertificateIdentifier = cACertificateIdentifier
        self.characterSetName = characterSetName
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBName = dBName
        self.dbInstancePort = dbInstancePort
        self.dbInstanceStatus = dbInstanceStatus
        self.dbParameterGroups = dbParameterGroups
        self.dbSecurityGroups = dbSecurityGroups
        self.dbSubnetGroup = dbSubnetGroup
        self.dbiResourceId = dbiResourceId
        self.deletionProtection = deletionProtection
        self.domainMemberships = domainMemberships
        self.enabledCloudWatchLogsExports = enabledCloudWatchLogsExports
        self.endpoint = endpoint
        self.engine = engine
        self.engineVersion = engineVersion
        self.enhancedMonitoringResourceArn = enhancedMonitoringResourceArn
        self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
        self.instanceCreateTime = instanceCreateTime
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.latestRestorableTime = latestRestorableTime
        self.licenseModel = licenseModel
        self.listenerEndpoint = listenerEndpoint
        self.masterUsername = masterUsername
        self.maxAllocatedStorage = maxAllocatedStorage
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.multiAz = multiAz
        self.optionGroupMemberships = optionGroupMemberships
        self.pendingModifiedValues = pendingModifiedValues
        self.performanceInsightsEnabled = performanceInsightsEnabled
        self.performanceInsightsKmsKeyId = performanceInsightsKmsKeyId
        self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.processorFeatures = processorFeatures
        self.promotionTier = promotionTier
        self.publiclyAccessible = publiclyAccessible
        self.readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiers
        self.readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiers
        self.readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifier
        self.secondaryAvailabilityZone = secondaryAvailabilityZone
        self.statusInfos = statusInfos
        self.storageEncrypted = storageEncrypted
        self.storageType = storageType
        self.tdeCredentialArn = tdeCredentialArn
        self.timezone = timezone
        self.vpcSecurityGroups = vpcSecurityGroups
    }
}

extension AwsRdsDbInstanceEndpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case hostedZoneId = "HostedZoneId"
        case port = "Port"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let hostedZoneId = hostedZoneId {
            try encodeContainer.encode(hostedZoneId, forKey: .hostedZoneId)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
    }
}

extension AwsRdsDbInstanceEndpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRdsDbInstanceEndpoint(address: \(String(describing: address)), hostedZoneId: \(String(describing: hostedZoneId)), port: \(String(describing: port)))"}
}

/// <p>Specifies the connection endpoint.</p>
public struct AwsRdsDbInstanceEndpoint: Equatable {
    /// <p>Specifies the DNS address of the DB instance.</p>
    public let address: String?
    /// <p>Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.</p>
    public let hostedZoneId: String?
    /// <p>Specifies the port that the database engine is listening on.</p>
    public let port: Int

    public init (
        address: String? = nil,
        hostedZoneId: String? = nil,
        port: Int = 0
    )
    {
        self.address = address
        self.hostedZoneId = hostedZoneId
        self.port = port
    }
}

extension AwsRdsDbInstanceVpcSecurityGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
        case vpcSecurityGroupId = "VpcSecurityGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let vpcSecurityGroupId = vpcSecurityGroupId {
            try encodeContainer.encode(vpcSecurityGroupId, forKey: .vpcSecurityGroupId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcSecurityGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcSecurityGroupId)
        vpcSecurityGroupId = vpcSecurityGroupIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AwsRdsDbInstanceVpcSecurityGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRdsDbInstanceVpcSecurityGroup(status: \(String(describing: status)), vpcSecurityGroupId: \(String(describing: vpcSecurityGroupId)))"}
}

/// <p>A VPC security groups that the DB instance belongs to.</p>
public struct AwsRdsDbInstanceVpcSecurityGroup: Equatable {
    /// <p>The status of the VPC security group.</p>
    public let status: String?
    /// <p>The name of the VPC security group.</p>
    public let vpcSecurityGroupId: String?

    public init (
        status: String? = nil,
        vpcSecurityGroupId: String? = nil
    )
    {
        self.status = status
        self.vpcSecurityGroupId = vpcSecurityGroupId
    }
}

extension AwsRdsDbOptionGroupMembership: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case optionGroupName = "OptionGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let optionGroupName = optionGroupName {
            try encodeContainer.encode(optionGroupName, forKey: .optionGroupName)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AwsRdsDbOptionGroupMembership: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRdsDbOptionGroupMembership(optionGroupName: \(String(describing: optionGroupName)), status: \(String(describing: status)))"}
}

/// <p>An option group membership.</p>
public struct AwsRdsDbOptionGroupMembership: Equatable {
    /// <p>The name of the option group.</p>
    public let optionGroupName: String?
    /// <p>The status of the option group membership.</p>
    public let status: String?

    public init (
        optionGroupName: String? = nil,
        status: String? = nil
    )
    {
        self.optionGroupName = optionGroupName
        self.status = status
    }
}

extension AwsRdsDbParameterGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dbParameterGroupName = "DbParameterGroupName"
        case parameterApplyStatus = "ParameterApplyStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dbParameterGroupName = dbParameterGroupName {
            try encodeContainer.encode(dbParameterGroupName, forKey: .dbParameterGroupName)
        }
        if let parameterApplyStatus = parameterApplyStatus {
            try encodeContainer.encode(parameterApplyStatus, forKey: .parameterApplyStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbParameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbParameterGroupName)
        dbParameterGroupName = dbParameterGroupNameDecoded
        let parameterApplyStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterApplyStatus)
        parameterApplyStatus = parameterApplyStatusDecoded
    }
}

extension AwsRdsDbParameterGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRdsDbParameterGroup(dbParameterGroupName: \(String(describing: dbParameterGroupName)), parameterApplyStatus: \(String(describing: parameterApplyStatus)))"}
}

/// <p>Provides information about a parameter group for a DB instance.</p>
public struct AwsRdsDbParameterGroup: Equatable {
    /// <p>The name of the parameter group.</p>
    public let dbParameterGroupName: String?
    /// <p>The status of parameter updates.</p>
    public let parameterApplyStatus: String?

    public init (
        dbParameterGroupName: String? = nil,
        parameterApplyStatus: String? = nil
    )
    {
        self.dbParameterGroupName = dbParameterGroupName
        self.parameterApplyStatus = parameterApplyStatus
    }
}

extension AwsRdsDbPendingModifiedValues: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case caCertificateIdentifier = "CaCertificateIdentifier"
        case dbInstanceClass = "DbInstanceClass"
        case dbInstanceIdentifier = "DbInstanceIdentifier"
        case dbSubnetGroupName = "DbSubnetGroupName"
        case engineVersion = "EngineVersion"
        case iops = "Iops"
        case licenseModel = "LicenseModel"
        case masterUserPassword = "MasterUserPassword"
        case multiAZ = "MultiAZ"
        case pendingCloudWatchLogsExports = "PendingCloudWatchLogsExports"
        case port = "Port"
        case processorFeatures = "ProcessorFeatures"
        case storageType = "StorageType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allocatedStorage != 0 {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if backupRetentionPeriod != 0 {
            try encodeContainer.encode(backupRetentionPeriod, forKey: .backupRetentionPeriod)
        }
        if let caCertificateIdentifier = caCertificateIdentifier {
            try encodeContainer.encode(caCertificateIdentifier, forKey: .caCertificateIdentifier)
        }
        if let dbInstanceClass = dbInstanceClass {
            try encodeContainer.encode(dbInstanceClass, forKey: .dbInstanceClass)
        }
        if let dbInstanceIdentifier = dbInstanceIdentifier {
            try encodeContainer.encode(dbInstanceIdentifier, forKey: .dbInstanceIdentifier)
        }
        if let dbSubnetGroupName = dbSubnetGroupName {
            try encodeContainer.encode(dbSubnetGroupName, forKey: .dbSubnetGroupName)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if iops != 0 {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let licenseModel = licenseModel {
            try encodeContainer.encode(licenseModel, forKey: .licenseModel)
        }
        if let masterUserPassword = masterUserPassword {
            try encodeContainer.encode(masterUserPassword, forKey: .masterUserPassword)
        }
        if multiAZ != false {
            try encodeContainer.encode(multiAZ, forKey: .multiAZ)
        }
        if let pendingCloudWatchLogsExports = pendingCloudWatchLogsExports {
            try encodeContainer.encode(pendingCloudWatchLogsExports, forKey: .pendingCloudWatchLogsExports)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processorFeatures)
            for awsrdsdbprocessorfeatures0 in processorFeatures {
                try processorFeaturesContainer.encode(awsrdsdbprocessorfeatures0)
            }
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType, forKey: .storageType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbInstanceClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbInstanceClass)
        dbInstanceClass = dbInstanceClassDecoded
        let allocatedStorageDecoded = try containerValues.decode(Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let backupRetentionPeriodDecoded = try containerValues.decode(Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let multiAZDecoded = try containerValues.decode(Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let iopsDecoded = try containerValues.decode(Int.self, forKey: .iops)
        iops = iopsDecoded
        let dbInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbInstanceIdentifier)
        dbInstanceIdentifier = dbInstanceIdentifierDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let caCertificateIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .caCertificateIdentifier)
        caCertificateIdentifier = caCertificateIdentifierDecoded
        let dbSubnetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbSubnetGroupName)
        dbSubnetGroupName = dbSubnetGroupNameDecoded
        let pendingCloudWatchLogsExportsDecoded = try containerValues.decodeIfPresent(AwsRdsPendingCloudWatchLogsExports.self, forKey: .pendingCloudWatchLogsExports)
        pendingCloudWatchLogsExports = pendingCloudWatchLogsExportsDecoded
        let processorFeaturesContainer = try containerValues.decodeIfPresent([AwsRdsDbProcessorFeature?].self, forKey: .processorFeatures)
        var processorFeaturesDecoded0:[AwsRdsDbProcessorFeature]? = nil
        if let processorFeaturesContainer = processorFeaturesContainer {
            processorFeaturesDecoded0 = [AwsRdsDbProcessorFeature]()
            for structure0 in processorFeaturesContainer {
                if let structure0 = structure0 {
                    processorFeaturesDecoded0?.append(structure0)
                }
            }
        }
        processorFeatures = processorFeaturesDecoded0
    }
}

extension AwsRdsDbPendingModifiedValues: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRdsDbPendingModifiedValues(allocatedStorage: \(String(describing: allocatedStorage)), backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), caCertificateIdentifier: \(String(describing: caCertificateIdentifier)), dbInstanceClass: \(String(describing: dbInstanceClass)), dbInstanceIdentifier: \(String(describing: dbInstanceIdentifier)), dbSubnetGroupName: \(String(describing: dbSubnetGroupName)), engineVersion: \(String(describing: engineVersion)), iops: \(String(describing: iops)), licenseModel: \(String(describing: licenseModel)), masterUserPassword: \(String(describing: masterUserPassword)), multiAZ: \(String(describing: multiAZ)), pendingCloudWatchLogsExports: \(String(describing: pendingCloudWatchLogsExports)), port: \(String(describing: port)), processorFeatures: \(String(describing: processorFeatures)), storageType: \(String(describing: storageType)))"}
}

/// <p>Changes to a DB instance that are currently pending.</p>
public struct AwsRdsDbPendingModifiedValues: Equatable {
    /// <p>The new value of the allocated storage for the DB instance.</p>
    public let allocatedStorage: Int
    /// <p>The new backup retention period for the DB instance.</p>
    public let backupRetentionPeriod: Int
    /// <p>The new CA certificate identifier for the DB instance.</p>
    public let caCertificateIdentifier: String?
    /// <p>The new DB instance class for the DB instance.</p>
    public let dbInstanceClass: String?
    /// <p>The new DB instance identifier for the DB instance.</p>
    public let dbInstanceIdentifier: String?
    /// <p>The name of the new subnet group for the DB instance.</p>
    public let dbSubnetGroupName: String?
    /// <p>The new engine version for the DB instance.</p>
    public let engineVersion: String?
    /// <p>The new provisioned IOPS value for the DB instance.</p>
    public let iops: Int
    /// <p>The new license model value for the DB instance.</p>
    public let licenseModel: String?
    /// <p>The new master user password for the DB instance.</p>
    public let masterUserPassword: String?
    /// <p>Indicates that a single Availability Zone DB instance is changing to a multiple Availability Zone deployment.</p>
    public let multiAZ: Bool
    /// <p>A list of log types that are being enabled or disabled.</p>
    public let pendingCloudWatchLogsExports: AwsRdsPendingCloudWatchLogsExports?
    /// <p>The new port for the DB instance.</p>
    public let port: Int
    /// <p>Processor features that are being updated.</p>
    public let processorFeatures: [AwsRdsDbProcessorFeature]?
    /// <p>The new storage type for the DB instance.</p>
    public let storageType: String?

    public init (
        allocatedStorage: Int = 0,
        backupRetentionPeriod: Int = 0,
        caCertificateIdentifier: String? = nil,
        dbInstanceClass: String? = nil,
        dbInstanceIdentifier: String? = nil,
        dbSubnetGroupName: String? = nil,
        engineVersion: String? = nil,
        iops: Int = 0,
        licenseModel: String? = nil,
        masterUserPassword: String? = nil,
        multiAZ: Bool = false,
        pendingCloudWatchLogsExports: AwsRdsPendingCloudWatchLogsExports? = nil,
        port: Int = 0,
        processorFeatures: [AwsRdsDbProcessorFeature]? = nil,
        storageType: String? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.backupRetentionPeriod = backupRetentionPeriod
        self.caCertificateIdentifier = caCertificateIdentifier
        self.dbInstanceClass = dbInstanceClass
        self.dbInstanceIdentifier = dbInstanceIdentifier
        self.dbSubnetGroupName = dbSubnetGroupName
        self.engineVersion = engineVersion
        self.iops = iops
        self.licenseModel = licenseModel
        self.masterUserPassword = masterUserPassword
        self.multiAZ = multiAZ
        self.pendingCloudWatchLogsExports = pendingCloudWatchLogsExports
        self.port = port
        self.processorFeatures = processorFeatures
        self.storageType = storageType
    }
}

extension AwsRdsDbProcessorFeature: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AwsRdsDbProcessorFeature: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRdsDbProcessorFeature(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>A processor feature.</p>
public struct AwsRdsDbProcessorFeature: Equatable {
    /// <p>The name of the processor feature.</p>
    public let name: String?
    /// <p>The value of the processor feature.</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

extension AwsRdsDbSnapshotDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case availabilityZone = "AvailabilityZone"
        case dbInstanceIdentifier = "DbInstanceIdentifier"
        case dbSnapshotIdentifier = "DbSnapshotIdentifier"
        case dbiResourceId = "DbiResourceId"
        case encrypted = "Encrypted"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case iamDatabaseAuthenticationEnabled = "IamDatabaseAuthenticationEnabled"
        case instanceCreateTime = "InstanceCreateTime"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case licenseModel = "LicenseModel"
        case masterUsername = "MasterUsername"
        case optionGroupName = "OptionGroupName"
        case percentProgress = "PercentProgress"
        case port = "Port"
        case processorFeatures = "ProcessorFeatures"
        case snapshotCreateTime = "SnapshotCreateTime"
        case snapshotType = "SnapshotType"
        case sourceDbSnapshotIdentifier = "SourceDbSnapshotIdentifier"
        case sourceRegion = "SourceRegion"
        case status = "Status"
        case storageType = "StorageType"
        case tdeCredentialArn = "TdeCredentialArn"
        case timezone = "Timezone"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allocatedStorage != 0 {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let dbInstanceIdentifier = dbInstanceIdentifier {
            try encodeContainer.encode(dbInstanceIdentifier, forKey: .dbInstanceIdentifier)
        }
        if let dbSnapshotIdentifier = dbSnapshotIdentifier {
            try encodeContainer.encode(dbSnapshotIdentifier, forKey: .dbSnapshotIdentifier)
        }
        if let dbiResourceId = dbiResourceId {
            try encodeContainer.encode(dbiResourceId, forKey: .dbiResourceId)
        }
        if encrypted != false {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let engine = engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if iamDatabaseAuthenticationEnabled != false {
            try encodeContainer.encode(iamDatabaseAuthenticationEnabled, forKey: .iamDatabaseAuthenticationEnabled)
        }
        if let instanceCreateTime = instanceCreateTime {
            try encodeContainer.encode(instanceCreateTime, forKey: .instanceCreateTime)
        }
        if iops != 0 {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let licenseModel = licenseModel {
            try encodeContainer.encode(licenseModel, forKey: .licenseModel)
        }
        if let masterUsername = masterUsername {
            try encodeContainer.encode(masterUsername, forKey: .masterUsername)
        }
        if let optionGroupName = optionGroupName {
            try encodeContainer.encode(optionGroupName, forKey: .optionGroupName)
        }
        if percentProgress != 0 {
            try encodeContainer.encode(percentProgress, forKey: .percentProgress)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processorFeatures)
            for awsrdsdbprocessorfeatures0 in processorFeatures {
                try processorFeaturesContainer.encode(awsrdsdbprocessorfeatures0)
            }
        }
        if let snapshotCreateTime = snapshotCreateTime {
            try encodeContainer.encode(snapshotCreateTime, forKey: .snapshotCreateTime)
        }
        if let snapshotType = snapshotType {
            try encodeContainer.encode(snapshotType, forKey: .snapshotType)
        }
        if let sourceDbSnapshotIdentifier = sourceDbSnapshotIdentifier {
            try encodeContainer.encode(sourceDbSnapshotIdentifier, forKey: .sourceDbSnapshotIdentifier)
        }
        if let sourceRegion = sourceRegion {
            try encodeContainer.encode(sourceRegion, forKey: .sourceRegion)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType, forKey: .storageType)
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try encodeContainer.encode(tdeCredentialArn, forKey: .tdeCredentialArn)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbSnapshotIdentifier)
        dbSnapshotIdentifier = dbSnapshotIdentifierDecoded
        let dbInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbInstanceIdentifier)
        dbInstanceIdentifier = dbInstanceIdentifierDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotCreateTime)
        snapshotCreateTime = snapshotCreateTimeDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let allocatedStorageDecoded = try containerValues.decode(Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let instanceCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceCreateTime)
        instanceCreateTime = instanceCreateTimeDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let snapshotTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotType)
        snapshotType = snapshotTypeDecoded
        let iopsDecoded = try containerValues.decode(Int.self, forKey: .iops)
        iops = iopsDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let percentProgressDecoded = try containerValues.decode(Int.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        let sourceDbSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceDbSnapshotIdentifier)
        sourceDbSnapshotIdentifier = sourceDbSnapshotIdentifierDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let tdeCredentialArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tdeCredentialArn)
        tdeCredentialArn = tdeCredentialArnDecoded
        let encryptedDecoded = try containerValues.decode(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let iamDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Bool.self, forKey: .iamDatabaseAuthenticationEnabled)
        iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabledDecoded
        let processorFeaturesContainer = try containerValues.decodeIfPresent([AwsRdsDbProcessorFeature?].self, forKey: .processorFeatures)
        var processorFeaturesDecoded0:[AwsRdsDbProcessorFeature]? = nil
        if let processorFeaturesContainer = processorFeaturesContainer {
            processorFeaturesDecoded0 = [AwsRdsDbProcessorFeature]()
            for structure0 in processorFeaturesContainer {
                if let structure0 = structure0 {
                    processorFeaturesDecoded0?.append(structure0)
                }
            }
        }
        processorFeatures = processorFeaturesDecoded0
        let dbiResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbiResourceId)
        dbiResourceId = dbiResourceIdDecoded
    }
}

extension AwsRdsDbSnapshotDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRdsDbSnapshotDetails(allocatedStorage: \(String(describing: allocatedStorage)), availabilityZone: \(String(describing: availabilityZone)), dbInstanceIdentifier: \(String(describing: dbInstanceIdentifier)), dbSnapshotIdentifier: \(String(describing: dbSnapshotIdentifier)), dbiResourceId: \(String(describing: dbiResourceId)), encrypted: \(String(describing: encrypted)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), iamDatabaseAuthenticationEnabled: \(String(describing: iamDatabaseAuthenticationEnabled)), instanceCreateTime: \(String(describing: instanceCreateTime)), iops: \(String(describing: iops)), kmsKeyId: \(String(describing: kmsKeyId)), licenseModel: \(String(describing: licenseModel)), masterUsername: \(String(describing: masterUsername)), optionGroupName: \(String(describing: optionGroupName)), percentProgress: \(String(describing: percentProgress)), port: \(String(describing: port)), processorFeatures: \(String(describing: processorFeatures)), snapshotCreateTime: \(String(describing: snapshotCreateTime)), snapshotType: \(String(describing: snapshotType)), sourceDbSnapshotIdentifier: \(String(describing: sourceDbSnapshotIdentifier)), sourceRegion: \(String(describing: sourceRegion)), status: \(String(describing: status)), storageType: \(String(describing: storageType)), tdeCredentialArn: \(String(describing: tdeCredentialArn)), timezone: \(String(describing: timezone)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Provides details about an Amazon RDS DB cluster snapshot.</p>
public struct AwsRdsDbSnapshotDetails: Equatable {
    /// <p>The amount of storage (in gigabytes) to be initially allocated for the database instance.</p>
    public let allocatedStorage: Int
    /// <p>Specifies the name of the Availability Zone in which the DB instance was located at the time of the DB snapshot.</p>
    public let availabilityZone: String?
    /// <p>A name for the DB instance.</p>
    public let dbInstanceIdentifier: String?
    /// <p>The name or ARN of the DB snapshot that is used to restore the DB instance.</p>
    public let dbSnapshotIdentifier: String?
    /// <p>The identifier for the source DB instance.</p>
    public let dbiResourceId: String?
    /// <p>Whether the DB snapshot is encrypted.</p>
    public let encrypted: Bool
    /// <p>The name of the database engine to use for this DB instance.</p>
    public let engine: String?
    /// <p>The version of the database engine.</p>
    public let engineVersion: String?
    /// <p>Whether mapping of IAM accounts to database accounts is enabled.</p>
    public let iamDatabaseAuthenticationEnabled: Bool
    /// <p>Specifies the time in Coordinated Universal Time (UTC) when the DB instance, from which the snapshot was taken, was created.</p>
    public let instanceCreateTime: String?
    /// <p>The provisioned IOPS (I/O operations per second) value of the DB instance at the time of the snapshot.</p>
    public let iops: Int
    /// <p>If <code>Encrypted</code> is <code>true</code>, the AWS KMS key identifier for the encrypted DB snapshot.</p>
    public let kmsKeyId: String?
    /// <p>License model information for the restored DB instance.</p>
    public let licenseModel: String?
    /// <p>The master user name for the DB snapshot.</p>
    public let masterUsername: String?
    /// <p>The option group name for the DB snapshot.</p>
    public let optionGroupName: String?
    /// <p>The percentage of the estimated data that has been transferred.</p>
    public let percentProgress: Int
    /// <p>The port that the database engine was listening on at the time of the snapshot.</p>
    public let port: Int
    /// <p>The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.</p>
    public let processorFeatures: [AwsRdsDbProcessorFeature]?
    /// <p>When the snapshot was taken in Coordinated Universal Time (UTC).</p>
    public let snapshotCreateTime: String?
    /// <p>The type of the DB snapshot.</p>
    public let snapshotType: String?
    /// <p>The DB snapshot ARN that the DB snapshot was copied from.</p>
    public let sourceDbSnapshotIdentifier: String?
    /// <p>The AWS Region that the DB snapshot was created in or copied from.</p>
    public let sourceRegion: String?
    /// <p>The status of this DB snapshot.</p>
    public let status: String?
    /// <p>The storage type associated with the DB snapshot.</p>
    public let storageType: String?
    /// <p>The ARN from the key store with which to associate the instance for TDE encryption.</p>
    public let tdeCredentialArn: String?
    /// <p>The time zone of the DB snapshot.</p>
    public let timezone: String?
    /// <p>The VPC ID associated with the DB snapshot.</p>
    public let vpcId: String?

    public init (
        allocatedStorage: Int = 0,
        availabilityZone: String? = nil,
        dbInstanceIdentifier: String? = nil,
        dbSnapshotIdentifier: String? = nil,
        dbiResourceId: String? = nil,
        encrypted: Bool = false,
        engine: String? = nil,
        engineVersion: String? = nil,
        iamDatabaseAuthenticationEnabled: Bool = false,
        instanceCreateTime: String? = nil,
        iops: Int = 0,
        kmsKeyId: String? = nil,
        licenseModel: String? = nil,
        masterUsername: String? = nil,
        optionGroupName: String? = nil,
        percentProgress: Int = 0,
        port: Int = 0,
        processorFeatures: [AwsRdsDbProcessorFeature]? = nil,
        snapshotCreateTime: String? = nil,
        snapshotType: String? = nil,
        sourceDbSnapshotIdentifier: String? = nil,
        sourceRegion: String? = nil,
        status: String? = nil,
        storageType: String? = nil,
        tdeCredentialArn: String? = nil,
        timezone: String? = nil,
        vpcId: String? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.availabilityZone = availabilityZone
        self.dbInstanceIdentifier = dbInstanceIdentifier
        self.dbSnapshotIdentifier = dbSnapshotIdentifier
        self.dbiResourceId = dbiResourceId
        self.encrypted = encrypted
        self.engine = engine
        self.engineVersion = engineVersion
        self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
        self.instanceCreateTime = instanceCreateTime
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.licenseModel = licenseModel
        self.masterUsername = masterUsername
        self.optionGroupName = optionGroupName
        self.percentProgress = percentProgress
        self.port = port
        self.processorFeatures = processorFeatures
        self.snapshotCreateTime = snapshotCreateTime
        self.snapshotType = snapshotType
        self.sourceDbSnapshotIdentifier = sourceDbSnapshotIdentifier
        self.sourceRegion = sourceRegion
        self.status = status
        self.storageType = storageType
        self.tdeCredentialArn = tdeCredentialArn
        self.timezone = timezone
        self.vpcId = vpcId
    }
}

extension AwsRdsDbStatusInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case normal = "Normal"
        case status = "Status"
        case statusType = "StatusType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if normal != false {
            try encodeContainer.encode(normal, forKey: .normal)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let statusType = statusType {
            try encodeContainer.encode(statusType, forKey: .statusType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusType)
        statusType = statusTypeDecoded
        let normalDecoded = try containerValues.decode(Bool.self, forKey: .normal)
        normal = normalDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AwsRdsDbStatusInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRdsDbStatusInfo(message: \(String(describing: message)), normal: \(String(describing: normal)), status: \(String(describing: status)), statusType: \(String(describing: statusType)))"}
}

/// <p>Information about the status of a read replica.</p>
public struct AwsRdsDbStatusInfo: Equatable {
    /// <p>If the read replica is currently in an error state, provides the error details.</p>
    public let message: String?
    /// <p>Whether the read replica instance is operating normally.</p>
    public let normal: Bool
    /// <p>The status of the read replica instance.</p>
    public let status: String?
    /// <p>The type of status. For a read replica, the status type is read replication.</p>
    public let statusType: String?

    public init (
        message: String? = nil,
        normal: Bool = false,
        status: String? = nil,
        statusType: String? = nil
    )
    {
        self.message = message
        self.normal = normal
        self.status = status
        self.statusType = statusType
    }
}

extension AwsRdsDbSubnetGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dbSubnetGroupArn = "DbSubnetGroupArn"
        case dbSubnetGroupDescription = "DbSubnetGroupDescription"
        case dbSubnetGroupName = "DbSubnetGroupName"
        case subnetGroupStatus = "SubnetGroupStatus"
        case subnets = "Subnets"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dbSubnetGroupArn = dbSubnetGroupArn {
            try encodeContainer.encode(dbSubnetGroupArn, forKey: .dbSubnetGroupArn)
        }
        if let dbSubnetGroupDescription = dbSubnetGroupDescription {
            try encodeContainer.encode(dbSubnetGroupDescription, forKey: .dbSubnetGroupDescription)
        }
        if let dbSubnetGroupName = dbSubnetGroupName {
            try encodeContainer.encode(dbSubnetGroupName, forKey: .dbSubnetGroupName)
        }
        if let subnetGroupStatus = subnetGroupStatus {
            try encodeContainer.encode(subnetGroupStatus, forKey: .subnetGroupStatus)
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for awsrdsdbsubnetgroupsubnets0 in subnets {
                try subnetsContainer.encode(awsrdsdbsubnetgroupsubnets0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbSubnetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbSubnetGroupName)
        dbSubnetGroupName = dbSubnetGroupNameDecoded
        let dbSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbSubnetGroupDescription)
        dbSubnetGroupDescription = dbSubnetGroupDescriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetGroupStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetGroupStatus)
        subnetGroupStatus = subnetGroupStatusDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([AwsRdsDbSubnetGroupSubnet?].self, forKey: .subnets)
        var subnetsDecoded0:[AwsRdsDbSubnetGroupSubnet]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [AwsRdsDbSubnetGroupSubnet]()
            for structure0 in subnetsContainer {
                if let structure0 = structure0 {
                    subnetsDecoded0?.append(structure0)
                }
            }
        }
        subnets = subnetsDecoded0
        let dbSubnetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbSubnetGroupArn)
        dbSubnetGroupArn = dbSubnetGroupArnDecoded
    }
}

extension AwsRdsDbSubnetGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRdsDbSubnetGroup(dbSubnetGroupArn: \(String(describing: dbSubnetGroupArn)), dbSubnetGroupDescription: \(String(describing: dbSubnetGroupDescription)), dbSubnetGroupName: \(String(describing: dbSubnetGroupName)), subnetGroupStatus: \(String(describing: subnetGroupStatus)), subnets: \(String(describing: subnets)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Information about the subnet group for the database instance.</p>
public struct AwsRdsDbSubnetGroup: Equatable {
    /// <p>The ARN of the subnet group.</p>
    public let dbSubnetGroupArn: String?
    /// <p>The description of the subnet group.</p>
    public let dbSubnetGroupDescription: String?
    /// <p>The name of the subnet group.</p>
    public let dbSubnetGroupName: String?
    /// <p>The status of the subnet group.</p>
    public let subnetGroupStatus: String?
    /// <p>A list of subnets in the subnet group.</p>
    public let subnets: [AwsRdsDbSubnetGroupSubnet]?
    /// <p>The VPC ID of the subnet group.</p>
    public let vpcId: String?

    public init (
        dbSubnetGroupArn: String? = nil,
        dbSubnetGroupDescription: String? = nil,
        dbSubnetGroupName: String? = nil,
        subnetGroupStatus: String? = nil,
        subnets: [AwsRdsDbSubnetGroupSubnet]? = nil,
        vpcId: String? = nil
    )
    {
        self.dbSubnetGroupArn = dbSubnetGroupArn
        self.dbSubnetGroupDescription = dbSubnetGroupDescription
        self.dbSubnetGroupName = dbSubnetGroupName
        self.subnetGroupStatus = subnetGroupStatus
        self.subnets = subnets
        self.vpcId = vpcId
    }
}

extension AwsRdsDbSubnetGroupSubnet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetIdentifier = "SubnetIdentifier"
        case subnetStatus = "SubnetStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetAvailabilityZone = subnetAvailabilityZone {
            try encodeContainer.encode(subnetAvailabilityZone, forKey: .subnetAvailabilityZone)
        }
        if let subnetIdentifier = subnetIdentifier {
            try encodeContainer.encode(subnetIdentifier, forKey: .subnetIdentifier)
        }
        if let subnetStatus = subnetStatus {
            try encodeContainer.encode(subnetStatus, forKey: .subnetStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetIdentifier)
        subnetIdentifier = subnetIdentifierDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(AwsRdsDbSubnetGroupSubnetAvailabilityZone.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
        let subnetStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetStatus)
        subnetStatus = subnetStatusDecoded
    }
}

extension AwsRdsDbSubnetGroupSubnet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRdsDbSubnetGroupSubnet(subnetAvailabilityZone: \(String(describing: subnetAvailabilityZone)), subnetIdentifier: \(String(describing: subnetIdentifier)), subnetStatus: \(String(describing: subnetStatus)))"}
}

/// <p>Information about a subnet in a subnet group.</p>
public struct AwsRdsDbSubnetGroupSubnet: Equatable {
    /// <p>Information about the Availability Zone for a subnet in the subnet group.</p>
    public let subnetAvailabilityZone: AwsRdsDbSubnetGroupSubnetAvailabilityZone?
    /// <p>The identifier of a subnet in the subnet group.</p>
    public let subnetIdentifier: String?
    /// <p>The status of a subnet in the subnet group.</p>
    public let subnetStatus: String?

    public init (
        subnetAvailabilityZone: AwsRdsDbSubnetGroupSubnetAvailabilityZone? = nil,
        subnetIdentifier: String? = nil,
        subnetStatus: String? = nil
    )
    {
        self.subnetAvailabilityZone = subnetAvailabilityZone
        self.subnetIdentifier = subnetIdentifier
        self.subnetStatus = subnetStatus
    }
}

extension AwsRdsDbSubnetGroupSubnetAvailabilityZone: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AwsRdsDbSubnetGroupSubnetAvailabilityZone: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRdsDbSubnetGroupSubnetAvailabilityZone(name: \(String(describing: name)))"}
}

/// <p>An Availability Zone for a subnet in a subnet group.</p>
public struct AwsRdsDbSubnetGroupSubnetAvailabilityZone: Equatable {
    /// <p>The name of the Availability Zone for a subnet in the subnet group.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension AwsRdsPendingCloudWatchLogsExports: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logTypesToDisable = "LogTypesToDisable"
        case logTypesToEnable = "LogTypesToEnable"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logTypesToDisable = logTypesToDisable {
            var logTypesToDisableContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logTypesToDisable)
            for stringlist0 in logTypesToDisable {
                try logTypesToDisableContainer.encode(stringlist0)
            }
        }
        if let logTypesToEnable = logTypesToEnable {
            var logTypesToEnableContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logTypesToEnable)
            for stringlist0 in logTypesToEnable {
                try logTypesToEnableContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logTypesToEnableContainer = try containerValues.decodeIfPresent([String?].self, forKey: .logTypesToEnable)
        var logTypesToEnableDecoded0:[String]? = nil
        if let logTypesToEnableContainer = logTypesToEnableContainer {
            logTypesToEnableDecoded0 = [String]()
            for string0 in logTypesToEnableContainer {
                if let string0 = string0 {
                    logTypesToEnableDecoded0?.append(string0)
                }
            }
        }
        logTypesToEnable = logTypesToEnableDecoded0
        let logTypesToDisableContainer = try containerValues.decodeIfPresent([String?].self, forKey: .logTypesToDisable)
        var logTypesToDisableDecoded0:[String]? = nil
        if let logTypesToDisableContainer = logTypesToDisableContainer {
            logTypesToDisableDecoded0 = [String]()
            for string0 in logTypesToDisableContainer {
                if let string0 = string0 {
                    logTypesToDisableDecoded0?.append(string0)
                }
            }
        }
        logTypesToDisable = logTypesToDisableDecoded0
    }
}

extension AwsRdsPendingCloudWatchLogsExports: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRdsPendingCloudWatchLogsExports(logTypesToDisable: \(String(describing: logTypesToDisable)), logTypesToEnable: \(String(describing: logTypesToEnable)))"}
}

/// <p>Identifies the log types to enable and disable.</p>
public struct AwsRdsPendingCloudWatchLogsExports: Equatable {
    /// <p>A list of log types that are being disabled.</p>
    public let logTypesToDisable: [String]?
    /// <p>A list of log types that are being enabled.</p>
    public let logTypesToEnable: [String]?

    public init (
        logTypesToDisable: [String]? = nil,
        logTypesToEnable: [String]? = nil
    )
    {
        self.logTypesToDisable = logTypesToDisable
        self.logTypesToEnable = logTypesToEnable
    }
}

extension AwsRedshiftClusterClusterNode: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nodeRole = "NodeRole"
        case privateIpAddress = "PrivateIpAddress"
        case publicIpAddress = "PublicIpAddress"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nodeRole = nodeRole {
            try encodeContainer.encode(nodeRole, forKey: .nodeRole)
        }
        if let privateIpAddress = privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
        if let publicIpAddress = publicIpAddress {
            try encodeContainer.encode(publicIpAddress, forKey: .publicIpAddress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeRole)
        nodeRole = nodeRoleDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let publicIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicIpAddress)
        publicIpAddress = publicIpAddressDecoded
    }
}

extension AwsRedshiftClusterClusterNode: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRedshiftClusterClusterNode(nodeRole: \(String(describing: nodeRole)), privateIpAddress: \(String(describing: privateIpAddress)), publicIpAddress: \(String(describing: publicIpAddress)))"}
}

/// <p>A node in an Amazon Redshift cluster.</p>
public struct AwsRedshiftClusterClusterNode: Equatable {
    /// <p>The role of the node. A node might be a leader node or a compute node.</p>
    public let nodeRole: String?
    /// <p>The private IP address of the node.</p>
    public let privateIpAddress: String?
    /// <p>The public IP address of the node.</p>
    public let publicIpAddress: String?

    public init (
        nodeRole: String? = nil,
        privateIpAddress: String? = nil,
        publicIpAddress: String? = nil
    )
    {
        self.nodeRole = nodeRole
        self.privateIpAddress = privateIpAddress
        self.publicIpAddress = publicIpAddress
    }
}

extension AwsRedshiftClusterClusterParameterGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterParameterStatusList = "ClusterParameterStatusList"
        case parameterApplyStatus = "ParameterApplyStatus"
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterParameterStatusList = clusterParameterStatusList {
            var clusterParameterStatusListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clusterParameterStatusList)
            for awsredshiftclusterclusterparameterstatuslist0 in clusterParameterStatusList {
                try clusterParameterStatusListContainer.encode(awsredshiftclusterclusterparameterstatuslist0)
            }
        }
        if let parameterApplyStatus = parameterApplyStatus {
            try encodeContainer.encode(parameterApplyStatus, forKey: .parameterApplyStatus)
        }
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterParameterStatusListContainer = try containerValues.decodeIfPresent([AwsRedshiftClusterClusterParameterStatus?].self, forKey: .clusterParameterStatusList)
        var clusterParameterStatusListDecoded0:[AwsRedshiftClusterClusterParameterStatus]? = nil
        if let clusterParameterStatusListContainer = clusterParameterStatusListContainer {
            clusterParameterStatusListDecoded0 = [AwsRedshiftClusterClusterParameterStatus]()
            for structure0 in clusterParameterStatusListContainer {
                if let structure0 = structure0 {
                    clusterParameterStatusListDecoded0?.append(structure0)
                }
            }
        }
        clusterParameterStatusList = clusterParameterStatusListDecoded0
        let parameterApplyStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterApplyStatus)
        parameterApplyStatus = parameterApplyStatusDecoded
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
    }
}

extension AwsRedshiftClusterClusterParameterGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRedshiftClusterClusterParameterGroup(clusterParameterStatusList: \(String(describing: clusterParameterStatusList)), parameterApplyStatus: \(String(describing: parameterApplyStatus)), parameterGroupName: \(String(describing: parameterGroupName)))"}
}

/// <p>A cluster parameter group that is associated with an Amazon Redshift cluster.</p>
public struct AwsRedshiftClusterClusterParameterGroup: Equatable {
    /// <p>The list of parameter statuses.</p>
    public let clusterParameterStatusList: [AwsRedshiftClusterClusterParameterStatus]?
    /// <p>The status of updates to the parameters.</p>
    public let parameterApplyStatus: String?
    /// <p>The name of the parameter group.</p>
    public let parameterGroupName: String?

    public init (
        clusterParameterStatusList: [AwsRedshiftClusterClusterParameterStatus]? = nil,
        parameterApplyStatus: String? = nil,
        parameterGroupName: String? = nil
    )
    {
        self.clusterParameterStatusList = clusterParameterStatusList
        self.parameterApplyStatus = parameterApplyStatus
        self.parameterGroupName = parameterGroupName
    }
}

extension AwsRedshiftClusterClusterParameterStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameterApplyErrorDescription = "ParameterApplyErrorDescription"
        case parameterApplyStatus = "ParameterApplyStatus"
        case parameterName = "ParameterName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterApplyErrorDescription = parameterApplyErrorDescription {
            try encodeContainer.encode(parameterApplyErrorDescription, forKey: .parameterApplyErrorDescription)
        }
        if let parameterApplyStatus = parameterApplyStatus {
            try encodeContainer.encode(parameterApplyStatus, forKey: .parameterApplyStatus)
        }
        if let parameterName = parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterApplyStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterApplyStatus)
        parameterApplyStatus = parameterApplyStatusDecoded
        let parameterApplyErrorDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterApplyErrorDescription)
        parameterApplyErrorDescription = parameterApplyErrorDescriptionDecoded
    }
}

extension AwsRedshiftClusterClusterParameterStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRedshiftClusterClusterParameterStatus(parameterApplyErrorDescription: \(String(describing: parameterApplyErrorDescription)), parameterApplyStatus: \(String(describing: parameterApplyStatus)), parameterName: \(String(describing: parameterName)))"}
}

/// <p>The status of a parameter in a cluster parameter group for an Amazon Redshift
///          cluster.</p>
public struct AwsRedshiftClusterClusterParameterStatus: Equatable {
    /// <p>The error that prevented the parameter from being applied to the database.</p>
    public let parameterApplyErrorDescription: String?
    /// <p>The status of the parameter. Indicates whether the parameter is in sync with the
    ///          database, waiting for a cluster reboot, or encountered an error when it was applied.</p>
    ///          <p>Valid values: <code>in-sync</code> | <code>pending-reboot</code> | <code>applying</code>
    ///          | <code>invalid-parameter</code> | <code>apply-deferred</code> | <code>apply-error</code> |
    ///             <code>unknown-error</code>
    ///          </p>
    public let parameterApplyStatus: String?
    /// <p>The name of the parameter.</p>
    public let parameterName: String?

    public init (
        parameterApplyErrorDescription: String? = nil,
        parameterApplyStatus: String? = nil,
        parameterName: String? = nil
    )
    {
        self.parameterApplyErrorDescription = parameterApplyErrorDescription
        self.parameterApplyStatus = parameterApplyStatus
        self.parameterName = parameterName
    }
}

extension AwsRedshiftClusterClusterSecurityGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterSecurityGroupName = "ClusterSecurityGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterSecurityGroupName = clusterSecurityGroupName {
            try encodeContainer.encode(clusterSecurityGroupName, forKey: .clusterSecurityGroupName)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterSecurityGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterSecurityGroupName)
        clusterSecurityGroupName = clusterSecurityGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AwsRedshiftClusterClusterSecurityGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRedshiftClusterClusterSecurityGroup(clusterSecurityGroupName: \(String(describing: clusterSecurityGroupName)), status: \(String(describing: status)))"}
}

/// <p>A security group that is associated with the cluster.</p>
public struct AwsRedshiftClusterClusterSecurityGroup: Equatable {
    /// <p>The name of the cluster security group.</p>
    public let clusterSecurityGroupName: String?
    /// <p>The status of the cluster security group.</p>
    public let status: String?

    public init (
        clusterSecurityGroupName: String? = nil,
        status: String? = nil
    )
    {
        self.clusterSecurityGroupName = clusterSecurityGroupName
        self.status = status
    }
}

extension AwsRedshiftClusterClusterSnapshotCopyStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationRegion = "DestinationRegion"
        case manualSnapshotRetentionPeriod = "ManualSnapshotRetentionPeriod"
        case retentionPeriod = "RetentionPeriod"
        case snapshotCopyGrantName = "SnapshotCopyGrantName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationRegion = destinationRegion {
            try encodeContainer.encode(destinationRegion, forKey: .destinationRegion)
        }
        if manualSnapshotRetentionPeriod != 0 {
            try encodeContainer.encode(manualSnapshotRetentionPeriod, forKey: .manualSnapshotRetentionPeriod)
        }
        if retentionPeriod != 0 {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let snapshotCopyGrantName = snapshotCopyGrantName {
            try encodeContainer.encode(snapshotCopyGrantName, forKey: .snapshotCopyGrantName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationRegion)
        destinationRegion = destinationRegionDecoded
        let manualSnapshotRetentionPeriodDecoded = try containerValues.decode(Int.self, forKey: .manualSnapshotRetentionPeriod)
        manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriodDecoded
        let retentionPeriodDecoded = try containerValues.decode(Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let snapshotCopyGrantNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotCopyGrantName)
        snapshotCopyGrantName = snapshotCopyGrantNameDecoded
    }
}

extension AwsRedshiftClusterClusterSnapshotCopyStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRedshiftClusterClusterSnapshotCopyStatus(destinationRegion: \(String(describing: destinationRegion)), manualSnapshotRetentionPeriod: \(String(describing: manualSnapshotRetentionPeriod)), retentionPeriod: \(String(describing: retentionPeriod)), snapshotCopyGrantName: \(String(describing: snapshotCopyGrantName)))"}
}

/// <p>Information about a cross-Region snapshot copy.</p>
public struct AwsRedshiftClusterClusterSnapshotCopyStatus: Equatable {
    /// <p>The destination Region that snapshots are automatically copied to when cross-Region
    ///          snapshot copy is enabled.</p>
    public let destinationRegion: String?
    /// <p>The number of days that manual snapshots are retained in the destination region after
    ///          they are copied from a source region.</p>
    ///          <p>If the value is -1, then the manual snapshot is retained indefinitely.</p>
    ///          <p>Valid values: Either -1 or an integer between 1 and 3,653</p>
    public let manualSnapshotRetentionPeriod: Int
    /// <p>The number of days to retain automated snapshots in the destination Region after they
    ///          are copied from a source Region.</p>
    public let retentionPeriod: Int
    /// <p>The name of the snapshot copy grant.</p>
    public let snapshotCopyGrantName: String?

    public init (
        destinationRegion: String? = nil,
        manualSnapshotRetentionPeriod: Int = 0,
        retentionPeriod: Int = 0,
        snapshotCopyGrantName: String? = nil
    )
    {
        self.destinationRegion = destinationRegion
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.retentionPeriod = retentionPeriod
        self.snapshotCopyGrantName = snapshotCopyGrantName
    }
}

extension AwsRedshiftClusterDeferredMaintenanceWindow: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deferMaintenanceEndTime = "DeferMaintenanceEndTime"
        case deferMaintenanceIdentifier = "DeferMaintenanceIdentifier"
        case deferMaintenanceStartTime = "DeferMaintenanceStartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deferMaintenanceEndTime = deferMaintenanceEndTime {
            try encodeContainer.encode(deferMaintenanceEndTime, forKey: .deferMaintenanceEndTime)
        }
        if let deferMaintenanceIdentifier = deferMaintenanceIdentifier {
            try encodeContainer.encode(deferMaintenanceIdentifier, forKey: .deferMaintenanceIdentifier)
        }
        if let deferMaintenanceStartTime = deferMaintenanceStartTime {
            try encodeContainer.encode(deferMaintenanceStartTime, forKey: .deferMaintenanceStartTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deferMaintenanceEndTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deferMaintenanceEndTime)
        deferMaintenanceEndTime = deferMaintenanceEndTimeDecoded
        let deferMaintenanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deferMaintenanceIdentifier)
        deferMaintenanceIdentifier = deferMaintenanceIdentifierDecoded
        let deferMaintenanceStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deferMaintenanceStartTime)
        deferMaintenanceStartTime = deferMaintenanceStartTimeDecoded
    }
}

extension AwsRedshiftClusterDeferredMaintenanceWindow: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRedshiftClusterDeferredMaintenanceWindow(deferMaintenanceEndTime: \(String(describing: deferMaintenanceEndTime)), deferMaintenanceIdentifier: \(String(describing: deferMaintenanceIdentifier)), deferMaintenanceStartTime: \(String(describing: deferMaintenanceStartTime)))"}
}

/// <p>A time windows during which maintenance was deferred for an Amazon Redshift
///          cluster.</p>
public struct AwsRedshiftClusterDeferredMaintenanceWindow: Equatable {
    /// <p>The end of the time window for which maintenance was deferred.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let deferMaintenanceEndTime: String?
    /// <p>The identifier of the maintenance window.</p>
    public let deferMaintenanceIdentifier: String?
    /// <p>The start of the time window for which maintenance was deferred.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let deferMaintenanceStartTime: String?

    public init (
        deferMaintenanceEndTime: String? = nil,
        deferMaintenanceIdentifier: String? = nil,
        deferMaintenanceStartTime: String? = nil
    )
    {
        self.deferMaintenanceEndTime = deferMaintenanceEndTime
        self.deferMaintenanceIdentifier = deferMaintenanceIdentifier
        self.deferMaintenanceStartTime = deferMaintenanceStartTime
    }
}

extension AwsRedshiftClusterDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowVersionUpgrade = "AllowVersionUpgrade"
        case automatedSnapshotRetentionPeriod = "AutomatedSnapshotRetentionPeriod"
        case availabilityZone = "AvailabilityZone"
        case clusterAvailabilityStatus = "ClusterAvailabilityStatus"
        case clusterCreateTime = "ClusterCreateTime"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterNodes = "ClusterNodes"
        case clusterParameterGroups = "ClusterParameterGroups"
        case clusterPublicKey = "ClusterPublicKey"
        case clusterRevisionNumber = "ClusterRevisionNumber"
        case clusterSecurityGroups = "ClusterSecurityGroups"
        case clusterSnapshotCopyStatus = "ClusterSnapshotCopyStatus"
        case clusterStatus = "ClusterStatus"
        case clusterSubnetGroupName = "ClusterSubnetGroupName"
        case clusterVersion = "ClusterVersion"
        case dBName = "DBName"
        case deferredMaintenanceWindows = "DeferredMaintenanceWindows"
        case elasticIpStatus = "ElasticIpStatus"
        case elasticResizeNumberOfNodeOptions = "ElasticResizeNumberOfNodeOptions"
        case encrypted = "Encrypted"
        case endpoint = "Endpoint"
        case enhancedVpcRouting = "EnhancedVpcRouting"
        case expectedNextSnapshotScheduleTime = "ExpectedNextSnapshotScheduleTime"
        case expectedNextSnapshotScheduleTimeStatus = "ExpectedNextSnapshotScheduleTimeStatus"
        case hsmStatus = "HsmStatus"
        case iamRoles = "IamRoles"
        case kmsKeyId = "KmsKeyId"
        case maintenanceTrackName = "MaintenanceTrackName"
        case manualSnapshotRetentionPeriod = "ManualSnapshotRetentionPeriod"
        case masterUsername = "MasterUsername"
        case nextMaintenanceWindowStartTime = "NextMaintenanceWindowStartTime"
        case nodeType = "NodeType"
        case numberOfNodes = "NumberOfNodes"
        case pendingActions = "PendingActions"
        case pendingModifiedValues = "PendingModifiedValues"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case publiclyAccessible = "PubliclyAccessible"
        case resizeInfo = "ResizeInfo"
        case restoreStatus = "RestoreStatus"
        case snapshotScheduleIdentifier = "SnapshotScheduleIdentifier"
        case snapshotScheduleState = "SnapshotScheduleState"
        case vpcId = "VpcId"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowVersionUpgrade != false {
            try encodeContainer.encode(allowVersionUpgrade, forKey: .allowVersionUpgrade)
        }
        if automatedSnapshotRetentionPeriod != 0 {
            try encodeContainer.encode(automatedSnapshotRetentionPeriod, forKey: .automatedSnapshotRetentionPeriod)
        }
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let clusterAvailabilityStatus = clusterAvailabilityStatus {
            try encodeContainer.encode(clusterAvailabilityStatus, forKey: .clusterAvailabilityStatus)
        }
        if let clusterCreateTime = clusterCreateTime {
            try encodeContainer.encode(clusterCreateTime, forKey: .clusterCreateTime)
        }
        if let clusterIdentifier = clusterIdentifier {
            try encodeContainer.encode(clusterIdentifier, forKey: .clusterIdentifier)
        }
        if let clusterNodes = clusterNodes {
            var clusterNodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clusterNodes)
            for awsredshiftclusterclusternodes0 in clusterNodes {
                try clusterNodesContainer.encode(awsredshiftclusterclusternodes0)
            }
        }
        if let clusterParameterGroups = clusterParameterGroups {
            var clusterParameterGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clusterParameterGroups)
            for awsredshiftclusterclusterparametergroups0 in clusterParameterGroups {
                try clusterParameterGroupsContainer.encode(awsredshiftclusterclusterparametergroups0)
            }
        }
        if let clusterPublicKey = clusterPublicKey {
            try encodeContainer.encode(clusterPublicKey, forKey: .clusterPublicKey)
        }
        if let clusterRevisionNumber = clusterRevisionNumber {
            try encodeContainer.encode(clusterRevisionNumber, forKey: .clusterRevisionNumber)
        }
        if let clusterSecurityGroups = clusterSecurityGroups {
            var clusterSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clusterSecurityGroups)
            for awsredshiftclusterclustersecuritygroups0 in clusterSecurityGroups {
                try clusterSecurityGroupsContainer.encode(awsredshiftclusterclustersecuritygroups0)
            }
        }
        if let clusterSnapshotCopyStatus = clusterSnapshotCopyStatus {
            try encodeContainer.encode(clusterSnapshotCopyStatus, forKey: .clusterSnapshotCopyStatus)
        }
        if let clusterStatus = clusterStatus {
            try encodeContainer.encode(clusterStatus, forKey: .clusterStatus)
        }
        if let clusterSubnetGroupName = clusterSubnetGroupName {
            try encodeContainer.encode(clusterSubnetGroupName, forKey: .clusterSubnetGroupName)
        }
        if let clusterVersion = clusterVersion {
            try encodeContainer.encode(clusterVersion, forKey: .clusterVersion)
        }
        if let dBName = dBName {
            try encodeContainer.encode(dBName, forKey: .dBName)
        }
        if let deferredMaintenanceWindows = deferredMaintenanceWindows {
            var deferredMaintenanceWindowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deferredMaintenanceWindows)
            for awsredshiftclusterdeferredmaintenancewindows0 in deferredMaintenanceWindows {
                try deferredMaintenanceWindowsContainer.encode(awsredshiftclusterdeferredmaintenancewindows0)
            }
        }
        if let elasticIpStatus = elasticIpStatus {
            try encodeContainer.encode(elasticIpStatus, forKey: .elasticIpStatus)
        }
        if let elasticResizeNumberOfNodeOptions = elasticResizeNumberOfNodeOptions {
            try encodeContainer.encode(elasticResizeNumberOfNodeOptions, forKey: .elasticResizeNumberOfNodeOptions)
        }
        if encrypted != false {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if enhancedVpcRouting != false {
            try encodeContainer.encode(enhancedVpcRouting, forKey: .enhancedVpcRouting)
        }
        if let expectedNextSnapshotScheduleTime = expectedNextSnapshotScheduleTime {
            try encodeContainer.encode(expectedNextSnapshotScheduleTime, forKey: .expectedNextSnapshotScheduleTime)
        }
        if let expectedNextSnapshotScheduleTimeStatus = expectedNextSnapshotScheduleTimeStatus {
            try encodeContainer.encode(expectedNextSnapshotScheduleTimeStatus, forKey: .expectedNextSnapshotScheduleTimeStatus)
        }
        if let hsmStatus = hsmStatus {
            try encodeContainer.encode(hsmStatus, forKey: .hsmStatus)
        }
        if let iamRoles = iamRoles {
            var iamRolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .iamRoles)
            for awsredshiftclusteriamroles0 in iamRoles {
                try iamRolesContainer.encode(awsredshiftclusteriamroles0)
            }
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try encodeContainer.encode(maintenanceTrackName, forKey: .maintenanceTrackName)
        }
        if manualSnapshotRetentionPeriod != 0 {
            try encodeContainer.encode(manualSnapshotRetentionPeriod, forKey: .manualSnapshotRetentionPeriod)
        }
        if let masterUsername = masterUsername {
            try encodeContainer.encode(masterUsername, forKey: .masterUsername)
        }
        if let nextMaintenanceWindowStartTime = nextMaintenanceWindowStartTime {
            try encodeContainer.encode(nextMaintenanceWindowStartTime, forKey: .nextMaintenanceWindowStartTime)
        }
        if let nodeType = nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if numberOfNodes != 0 {
            try encodeContainer.encode(numberOfNodes, forKey: .numberOfNodes)
        }
        if let pendingActions = pendingActions {
            var pendingActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pendingActions)
            for stringlist0 in pendingActions {
                try pendingActionsContainer.encode(stringlist0)
            }
        }
        if let pendingModifiedValues = pendingModifiedValues {
            try encodeContainer.encode(pendingModifiedValues, forKey: .pendingModifiedValues)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if publiclyAccessible != false {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let resizeInfo = resizeInfo {
            try encodeContainer.encode(resizeInfo, forKey: .resizeInfo)
        }
        if let restoreStatus = restoreStatus {
            try encodeContainer.encode(restoreStatus, forKey: .restoreStatus)
        }
        if let snapshotScheduleIdentifier = snapshotScheduleIdentifier {
            try encodeContainer.encode(snapshotScheduleIdentifier, forKey: .snapshotScheduleIdentifier)
        }
        if let snapshotScheduleState = snapshotScheduleState {
            try encodeContainer.encode(snapshotScheduleState, forKey: .snapshotScheduleState)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroups)
            for awsredshiftclustervpcsecuritygroups0 in vpcSecurityGroups {
                try vpcSecurityGroupsContainer.encode(awsredshiftclustervpcsecuritygroups0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowVersionUpgradeDecoded = try containerValues.decode(Bool.self, forKey: .allowVersionUpgrade)
        allowVersionUpgrade = allowVersionUpgradeDecoded
        let automatedSnapshotRetentionPeriodDecoded = try containerValues.decode(Int.self, forKey: .automatedSnapshotRetentionPeriod)
        automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriodDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let clusterAvailabilityStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterAvailabilityStatus)
        clusterAvailabilityStatus = clusterAvailabilityStatusDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterCreateTime)
        clusterCreateTime = clusterCreateTimeDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let clusterNodesContainer = try containerValues.decodeIfPresent([AwsRedshiftClusterClusterNode?].self, forKey: .clusterNodes)
        var clusterNodesDecoded0:[AwsRedshiftClusterClusterNode]? = nil
        if let clusterNodesContainer = clusterNodesContainer {
            clusterNodesDecoded0 = [AwsRedshiftClusterClusterNode]()
            for structure0 in clusterNodesContainer {
                if let structure0 = structure0 {
                    clusterNodesDecoded0?.append(structure0)
                }
            }
        }
        clusterNodes = clusterNodesDecoded0
        let clusterParameterGroupsContainer = try containerValues.decodeIfPresent([AwsRedshiftClusterClusterParameterGroup?].self, forKey: .clusterParameterGroups)
        var clusterParameterGroupsDecoded0:[AwsRedshiftClusterClusterParameterGroup]? = nil
        if let clusterParameterGroupsContainer = clusterParameterGroupsContainer {
            clusterParameterGroupsDecoded0 = [AwsRedshiftClusterClusterParameterGroup]()
            for structure0 in clusterParameterGroupsContainer {
                if let structure0 = structure0 {
                    clusterParameterGroupsDecoded0?.append(structure0)
                }
            }
        }
        clusterParameterGroups = clusterParameterGroupsDecoded0
        let clusterPublicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterPublicKey)
        clusterPublicKey = clusterPublicKeyDecoded
        let clusterRevisionNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterRevisionNumber)
        clusterRevisionNumber = clusterRevisionNumberDecoded
        let clusterSecurityGroupsContainer = try containerValues.decodeIfPresent([AwsRedshiftClusterClusterSecurityGroup?].self, forKey: .clusterSecurityGroups)
        var clusterSecurityGroupsDecoded0:[AwsRedshiftClusterClusterSecurityGroup]? = nil
        if let clusterSecurityGroupsContainer = clusterSecurityGroupsContainer {
            clusterSecurityGroupsDecoded0 = [AwsRedshiftClusterClusterSecurityGroup]()
            for structure0 in clusterSecurityGroupsContainer {
                if let structure0 = structure0 {
                    clusterSecurityGroupsDecoded0?.append(structure0)
                }
            }
        }
        clusterSecurityGroups = clusterSecurityGroupsDecoded0
        let clusterSnapshotCopyStatusDecoded = try containerValues.decodeIfPresent(AwsRedshiftClusterClusterSnapshotCopyStatus.self, forKey: .clusterSnapshotCopyStatus)
        clusterSnapshotCopyStatus = clusterSnapshotCopyStatusDecoded
        let clusterStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterStatus)
        clusterStatus = clusterStatusDecoded
        let clusterSubnetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterSubnetGroupName)
        clusterSubnetGroupName = clusterSubnetGroupNameDecoded
        let clusterVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterVersion)
        clusterVersion = clusterVersionDecoded
        let dBNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBName)
        dBName = dBNameDecoded
        let deferredMaintenanceWindowsContainer = try containerValues.decodeIfPresent([AwsRedshiftClusterDeferredMaintenanceWindow?].self, forKey: .deferredMaintenanceWindows)
        var deferredMaintenanceWindowsDecoded0:[AwsRedshiftClusterDeferredMaintenanceWindow]? = nil
        if let deferredMaintenanceWindowsContainer = deferredMaintenanceWindowsContainer {
            deferredMaintenanceWindowsDecoded0 = [AwsRedshiftClusterDeferredMaintenanceWindow]()
            for structure0 in deferredMaintenanceWindowsContainer {
                if let structure0 = structure0 {
                    deferredMaintenanceWindowsDecoded0?.append(structure0)
                }
            }
        }
        deferredMaintenanceWindows = deferredMaintenanceWindowsDecoded0
        let elasticIpStatusDecoded = try containerValues.decodeIfPresent(AwsRedshiftClusterElasticIpStatus.self, forKey: .elasticIpStatus)
        elasticIpStatus = elasticIpStatusDecoded
        let elasticResizeNumberOfNodeOptionsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .elasticResizeNumberOfNodeOptions)
        elasticResizeNumberOfNodeOptions = elasticResizeNumberOfNodeOptionsDecoded
        let encryptedDecoded = try containerValues.decode(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(AwsRedshiftClusterEndpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let enhancedVpcRoutingDecoded = try containerValues.decode(Bool.self, forKey: .enhancedVpcRouting)
        enhancedVpcRouting = enhancedVpcRoutingDecoded
        let expectedNextSnapshotScheduleTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expectedNextSnapshotScheduleTime)
        expectedNextSnapshotScheduleTime = expectedNextSnapshotScheduleTimeDecoded
        let expectedNextSnapshotScheduleTimeStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expectedNextSnapshotScheduleTimeStatus)
        expectedNextSnapshotScheduleTimeStatus = expectedNextSnapshotScheduleTimeStatusDecoded
        let hsmStatusDecoded = try containerValues.decodeIfPresent(AwsRedshiftClusterHsmStatus.self, forKey: .hsmStatus)
        hsmStatus = hsmStatusDecoded
        let iamRolesContainer = try containerValues.decodeIfPresent([AwsRedshiftClusterIamRole?].self, forKey: .iamRoles)
        var iamRolesDecoded0:[AwsRedshiftClusterIamRole]? = nil
        if let iamRolesContainer = iamRolesContainer {
            iamRolesDecoded0 = [AwsRedshiftClusterIamRole]()
            for structure0 in iamRolesContainer {
                if let structure0 = structure0 {
                    iamRolesDecoded0?.append(structure0)
                }
            }
        }
        iamRoles = iamRolesDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let maintenanceTrackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maintenanceTrackName)
        maintenanceTrackName = maintenanceTrackNameDecoded
        let manualSnapshotRetentionPeriodDecoded = try containerValues.decode(Int.self, forKey: .manualSnapshotRetentionPeriod)
        manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriodDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let nextMaintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMaintenanceWindowStartTime)
        nextMaintenanceWindowStartTime = nextMaintenanceWindowStartTimeDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let numberOfNodesDecoded = try containerValues.decode(Int.self, forKey: .numberOfNodes)
        numberOfNodes = numberOfNodesDecoded
        let pendingActionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .pendingActions)
        var pendingActionsDecoded0:[String]? = nil
        if let pendingActionsContainer = pendingActionsContainer {
            pendingActionsDecoded0 = [String]()
            for string0 in pendingActionsContainer {
                if let string0 = string0 {
                    pendingActionsDecoded0?.append(string0)
                }
            }
        }
        pendingActions = pendingActionsDecoded0
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(AwsRedshiftClusterPendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let publiclyAccessibleDecoded = try containerValues.decode(Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let resizeInfoDecoded = try containerValues.decodeIfPresent(AwsRedshiftClusterResizeInfo.self, forKey: .resizeInfo)
        resizeInfo = resizeInfoDecoded
        let restoreStatusDecoded = try containerValues.decodeIfPresent(AwsRedshiftClusterRestoreStatus.self, forKey: .restoreStatus)
        restoreStatus = restoreStatusDecoded
        let snapshotScheduleIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotScheduleIdentifier)
        snapshotScheduleIdentifier = snapshotScheduleIdentifierDecoded
        let snapshotScheduleStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotScheduleState)
        snapshotScheduleState = snapshotScheduleStateDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let vpcSecurityGroupsContainer = try containerValues.decodeIfPresent([AwsRedshiftClusterVpcSecurityGroup?].self, forKey: .vpcSecurityGroups)
        var vpcSecurityGroupsDecoded0:[AwsRedshiftClusterVpcSecurityGroup]? = nil
        if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
            vpcSecurityGroupsDecoded0 = [AwsRedshiftClusterVpcSecurityGroup]()
            for structure0 in vpcSecurityGroupsContainer {
                if let structure0 = structure0 {
                    vpcSecurityGroupsDecoded0?.append(structure0)
                }
            }
        }
        vpcSecurityGroups = vpcSecurityGroupsDecoded0
    }
}

extension AwsRedshiftClusterDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRedshiftClusterDetails(allowVersionUpgrade: \(String(describing: allowVersionUpgrade)), automatedSnapshotRetentionPeriod: \(String(describing: automatedSnapshotRetentionPeriod)), availabilityZone: \(String(describing: availabilityZone)), clusterAvailabilityStatus: \(String(describing: clusterAvailabilityStatus)), clusterCreateTime: \(String(describing: clusterCreateTime)), clusterIdentifier: \(String(describing: clusterIdentifier)), clusterNodes: \(String(describing: clusterNodes)), clusterParameterGroups: \(String(describing: clusterParameterGroups)), clusterPublicKey: \(String(describing: clusterPublicKey)), clusterRevisionNumber: \(String(describing: clusterRevisionNumber)), clusterSecurityGroups: \(String(describing: clusterSecurityGroups)), clusterSnapshotCopyStatus: \(String(describing: clusterSnapshotCopyStatus)), clusterStatus: \(String(describing: clusterStatus)), clusterSubnetGroupName: \(String(describing: clusterSubnetGroupName)), clusterVersion: \(String(describing: clusterVersion)), dBName: \(String(describing: dBName)), deferredMaintenanceWindows: \(String(describing: deferredMaintenanceWindows)), elasticIpStatus: \(String(describing: elasticIpStatus)), elasticResizeNumberOfNodeOptions: \(String(describing: elasticResizeNumberOfNodeOptions)), encrypted: \(String(describing: encrypted)), endpoint: \(String(describing: endpoint)), enhancedVpcRouting: \(String(describing: enhancedVpcRouting)), expectedNextSnapshotScheduleTime: \(String(describing: expectedNextSnapshotScheduleTime)), expectedNextSnapshotScheduleTimeStatus: \(String(describing: expectedNextSnapshotScheduleTimeStatus)), hsmStatus: \(String(describing: hsmStatus)), iamRoles: \(String(describing: iamRoles)), kmsKeyId: \(String(describing: kmsKeyId)), maintenanceTrackName: \(String(describing: maintenanceTrackName)), manualSnapshotRetentionPeriod: \(String(describing: manualSnapshotRetentionPeriod)), masterUsername: \(String(describing: masterUsername)), nextMaintenanceWindowStartTime: \(String(describing: nextMaintenanceWindowStartTime)), nodeType: \(String(describing: nodeType)), numberOfNodes: \(String(describing: numberOfNodes)), pendingActions: \(String(describing: pendingActions)), pendingModifiedValues: \(String(describing: pendingModifiedValues)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), publiclyAccessible: \(String(describing: publiclyAccessible)), resizeInfo: \(String(describing: resizeInfo)), restoreStatus: \(String(describing: restoreStatus)), snapshotScheduleIdentifier: \(String(describing: snapshotScheduleIdentifier)), snapshotScheduleState: \(String(describing: snapshotScheduleState)), vpcId: \(String(describing: vpcId)), vpcSecurityGroups: \(String(describing: vpcSecurityGroups)))"}
}

/// <p>Details about an Amazon Redshift cluster.</p>
public struct AwsRedshiftClusterDetails: Equatable {
    /// <p>Indicates whether major version upgrades are applied automatically to the cluster during
    ///          the maintenance window.</p>
    public let allowVersionUpgrade: Bool
    /// <p>The number of days that automatic cluster snapshots are retained.</p>
    public let automatedSnapshotRetentionPeriod: Int
    /// <p>The name of the Availability Zone in which the cluster is located.</p>
    public let availabilityZone: String?
    /// <p>The availability status of the cluster for queries. Possible values are the
    ///          following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Available</code> - The cluster is available for queries.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Unavailable</code> - The cluster is not available for queries.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Maintenance</code> - The cluster is intermittently available for queries due
    ///                to maintenance activities.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Modifying</code> -The cluster is intermittently available for queries due to
    ///                changes that modify the cluster.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Failed</code> - The cluster failed and is not available for queries.</p>
    ///             </li>
    ///          </ul>
    public let clusterAvailabilityStatus: String?
    /// <p>Indicates when the cluster was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let clusterCreateTime: String?
    /// <p>The unique identifier of the cluster.</p>
    public let clusterIdentifier: String?
    /// <p>The nodes in the cluster.</p>
    public let clusterNodes: [AwsRedshiftClusterClusterNode]?
    /// <p>The list of cluster parameter groups that are associated with this cluster.</p>
    public let clusterParameterGroups: [AwsRedshiftClusterClusterParameterGroup]?
    /// <p>The public key for the cluster.</p>
    public let clusterPublicKey: String?
    /// <p>The specific revision number of the database in the cluster.</p>
    public let clusterRevisionNumber: String?
    /// <p>A list of cluster security groups that are associated with the cluster.</p>
    public let clusterSecurityGroups: [AwsRedshiftClusterClusterSecurityGroup]?
    /// <p>Information about the destination Region and retention period for the cross-Region
    ///          snapshot copy.</p>
    public let clusterSnapshotCopyStatus: AwsRedshiftClusterClusterSnapshotCopyStatus?
    /// <p>The current status of the cluster.</p>
    ///          <p>Valid values: <code>available</code> | <code>available, prep-for-resize</code> |
    ///             <code>available, resize-cleanup</code> |<code> cancelling-resize</code> |
    ///             <code>creating</code> | <code>deleting</code> | <code>final-snapshot</code> |
    ///             <code>hardware-failure</code> | <code>incompatible-hsm</code> |<code>
    ///             incompatible-network</code> | <code>incompatible-parameters</code> |
    ///             <code>incompatible-restore</code> | <code>modifying</code> | <code>paused</code> |
    ///             <code>rebooting</code> | <code>renaming</code> | <code>resizing</code> |
    ///             <code>rotating-keys</code> | <code>storage-full</code> |
    ///          <code>updating-hsm</code>
    ///          </p>
    public let clusterStatus: String?
    /// <p>The name of the subnet group that is associated with the cluster. This parameter is
    ///          valid only when the cluster is in a VPC.</p>
    public let clusterSubnetGroupName: String?
    /// <p>The version ID of the Amazon Redshift engine that runs on the cluster.</p>
    public let clusterVersion: String?
    /// <p>The name of the initial database that was created when the cluster was created.</p>
    ///          <p>The same name is returned for the life of the cluster.</p>
    ///          <p>If an initial database is not specified, a database named <code>devdev</code> is created
    ///          by default.</p>
    public let dBName: String?
    /// <p>List of time windows during which maintenance was deferred.</p>
    public let deferredMaintenanceWindows: [AwsRedshiftClusterDeferredMaintenanceWindow]?
    /// <p>Information about the status of the Elastic IP (EIP) address.</p>
    public let elasticIpStatus: AwsRedshiftClusterElasticIpStatus?
    /// <p>The number of nodes that you can use the elastic resize method to resize the cluster
    ///          to.</p>
    public let elasticResizeNumberOfNodeOptions: String?
    /// <p>Indicates whether the data in the cluster is encrypted at rest.</p>
    public let encrypted: Bool
    /// <p>The connection endpoint.</p>
    public let endpoint: AwsRedshiftClusterEndpoint?
    /// <p>Indicates whether to create the cluster with enhanced VPC routing enabled.</p>
    public let enhancedVpcRouting: Bool
    /// <p>Indicates when the next snapshot is expected to be taken. The cluster must have a valid
    ///          snapshot schedule and have backups enabled.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let expectedNextSnapshotScheduleTime: String?
    /// <p>The status of the next expected snapshot.</p>
    ///          <p>Valid values: <code>OnTrack</code> | <code>Pending</code>
    ///          </p>
    public let expectedNextSnapshotScheduleTimeStatus: String?
    /// <p>Information about whether the Amazon Redshift cluster finished applying any changes to
    ///          hardware security module (HSM) settings that were specified in a modify cluster
    ///          command.</p>
    public let hsmStatus: AwsRedshiftClusterHsmStatus?
    /// <p>A list of IAM roles that the cluster can use to access other AWS services.</p>
    public let iamRoles: [AwsRedshiftClusterIamRole]?
    /// <p>The identifier of the AWS KMS encryption key that is used to encrypt data in the
    ///          cluster.</p>
    public let kmsKeyId: String?
    /// <p>The name of the maintenance track for the cluster.</p>
    public let maintenanceTrackName: String?
    /// <p>The default number of days to retain a manual snapshot.</p>
    ///          <p>If the value is -1, the snapshot is retained indefinitely.</p>
    ///          <p>This setting doesn't change the retention period of existing snapshots.</p>
    ///          <p>Valid values: Either -1 or an integer between 1 and 3,653</p>
    public let manualSnapshotRetentionPeriod: Int
    /// <p>The master user name for the cluster. This name is used to connect to the database that
    ///          is specified in as the value of <code>DBName</code>.</p>
    public let masterUsername: String?
    /// <p>Indicates the start of the next maintenance window.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let nextMaintenanceWindowStartTime: String?
    /// <p>The node type for the nodes in the cluster.</p>
    public let nodeType: String?
    /// <p>The number of compute nodes in the cluster.</p>
    public let numberOfNodes: Int
    /// <p>A list of cluster operations that are waiting to start.</p>
    public let pendingActions: [String]?
    /// <p>A list of changes to the cluster that are currently pending.</p>
    public let pendingModifiedValues: AwsRedshiftClusterPendingModifiedValues?
    /// <p>The weekly time range, in Universal Coordinated Time (UTC), during which system
    ///          maintenance can occur.</p>
    ///          <p>Format:
    ///             <code>
    ///                <i><day></i>:HH:MM-<i><day></i>:HH:MM</code>
    ///          </p>
    ///          <p>For the day values, use <code>mon</code> | <code>tue</code> | <code>wed</code> |
    ///             <code>thu</code> | <code>fri</code> | <code>sat</code> | <code>sun</code>
    ///          </p>
    ///          <p>For example, <code>sun:09:32-sun:10:02</code>
    ///          </p>
    public let preferredMaintenanceWindow: String?
    /// <p>Whether the cluster can be accessed from a public network.</p>
    public let publiclyAccessible: Bool
    /// <p>Information about the resize operation for the cluster.</p>
    public let resizeInfo: AwsRedshiftClusterResizeInfo?
    /// <p>Information about the status of a cluster restore action. Only applies to a cluster that
    ///          was created by restoring a snapshot.</p>
    public let restoreStatus: AwsRedshiftClusterRestoreStatus?
    /// <p>A unique identifier for the cluster snapshot schedule.</p>
    public let snapshotScheduleIdentifier: String?
    /// <p>The current state of the cluster snapshot schedule.</p>
    ///          <p>Valid values: <code>MODIFYING</code> | <code>ACTIVE</code> | <code>FAILED</code>
    ///          </p>
    public let snapshotScheduleState: String?
    /// <p>The identifier of the VPC that the cluster is in, if the cluster is in a VPC.</p>
    public let vpcId: String?
    /// <p>The list of VPC security groups that the cluster belongs to, if the cluster is in a
    ///          VPC.</p>
    public let vpcSecurityGroups: [AwsRedshiftClusterVpcSecurityGroup]?

    public init (
        allowVersionUpgrade: Bool = false,
        automatedSnapshotRetentionPeriod: Int = 0,
        availabilityZone: String? = nil,
        clusterAvailabilityStatus: String? = nil,
        clusterCreateTime: String? = nil,
        clusterIdentifier: String? = nil,
        clusterNodes: [AwsRedshiftClusterClusterNode]? = nil,
        clusterParameterGroups: [AwsRedshiftClusterClusterParameterGroup]? = nil,
        clusterPublicKey: String? = nil,
        clusterRevisionNumber: String? = nil,
        clusterSecurityGroups: [AwsRedshiftClusterClusterSecurityGroup]? = nil,
        clusterSnapshotCopyStatus: AwsRedshiftClusterClusterSnapshotCopyStatus? = nil,
        clusterStatus: String? = nil,
        clusterSubnetGroupName: String? = nil,
        clusterVersion: String? = nil,
        dBName: String? = nil,
        deferredMaintenanceWindows: [AwsRedshiftClusterDeferredMaintenanceWindow]? = nil,
        elasticIpStatus: AwsRedshiftClusterElasticIpStatus? = nil,
        elasticResizeNumberOfNodeOptions: String? = nil,
        encrypted: Bool = false,
        endpoint: AwsRedshiftClusterEndpoint? = nil,
        enhancedVpcRouting: Bool = false,
        expectedNextSnapshotScheduleTime: String? = nil,
        expectedNextSnapshotScheduleTimeStatus: String? = nil,
        hsmStatus: AwsRedshiftClusterHsmStatus? = nil,
        iamRoles: [AwsRedshiftClusterIamRole]? = nil,
        kmsKeyId: String? = nil,
        maintenanceTrackName: String? = nil,
        manualSnapshotRetentionPeriod: Int = 0,
        masterUsername: String? = nil,
        nextMaintenanceWindowStartTime: String? = nil,
        nodeType: String? = nil,
        numberOfNodes: Int = 0,
        pendingActions: [String]? = nil,
        pendingModifiedValues: AwsRedshiftClusterPendingModifiedValues? = nil,
        preferredMaintenanceWindow: String? = nil,
        publiclyAccessible: Bool = false,
        resizeInfo: AwsRedshiftClusterResizeInfo? = nil,
        restoreStatus: AwsRedshiftClusterRestoreStatus? = nil,
        snapshotScheduleIdentifier: String? = nil,
        snapshotScheduleState: String? = nil,
        vpcId: String? = nil,
        vpcSecurityGroups: [AwsRedshiftClusterVpcSecurityGroup]? = nil
    )
    {
        self.allowVersionUpgrade = allowVersionUpgrade
        self.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod
        self.availabilityZone = availabilityZone
        self.clusterAvailabilityStatus = clusterAvailabilityStatus
        self.clusterCreateTime = clusterCreateTime
        self.clusterIdentifier = clusterIdentifier
        self.clusterNodes = clusterNodes
        self.clusterParameterGroups = clusterParameterGroups
        self.clusterPublicKey = clusterPublicKey
        self.clusterRevisionNumber = clusterRevisionNumber
        self.clusterSecurityGroups = clusterSecurityGroups
        self.clusterSnapshotCopyStatus = clusterSnapshotCopyStatus
        self.clusterStatus = clusterStatus
        self.clusterSubnetGroupName = clusterSubnetGroupName
        self.clusterVersion = clusterVersion
        self.dBName = dBName
        self.deferredMaintenanceWindows = deferredMaintenanceWindows
        self.elasticIpStatus = elasticIpStatus
        self.elasticResizeNumberOfNodeOptions = elasticResizeNumberOfNodeOptions
        self.encrypted = encrypted
        self.endpoint = endpoint
        self.enhancedVpcRouting = enhancedVpcRouting
        self.expectedNextSnapshotScheduleTime = expectedNextSnapshotScheduleTime
        self.expectedNextSnapshotScheduleTimeStatus = expectedNextSnapshotScheduleTimeStatus
        self.hsmStatus = hsmStatus
        self.iamRoles = iamRoles
        self.kmsKeyId = kmsKeyId
        self.maintenanceTrackName = maintenanceTrackName
        self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
        self.masterUsername = masterUsername
        self.nextMaintenanceWindowStartTime = nextMaintenanceWindowStartTime
        self.nodeType = nodeType
        self.numberOfNodes = numberOfNodes
        self.pendingActions = pendingActions
        self.pendingModifiedValues = pendingModifiedValues
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.publiclyAccessible = publiclyAccessible
        self.resizeInfo = resizeInfo
        self.restoreStatus = restoreStatus
        self.snapshotScheduleIdentifier = snapshotScheduleIdentifier
        self.snapshotScheduleState = snapshotScheduleState
        self.vpcId = vpcId
        self.vpcSecurityGroups = vpcSecurityGroups
    }
}

extension AwsRedshiftClusterElasticIpStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case elasticIp = "ElasticIp"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticIp = elasticIp {
            try encodeContainer.encode(elasticIp, forKey: .elasticIp)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AwsRedshiftClusterElasticIpStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRedshiftClusterElasticIpStatus(elasticIp: \(String(describing: elasticIp)), status: \(String(describing: status)))"}
}

/// <p>The status of the elastic IP (EIP) address for an Amazon Redshift cluster.</p>
public struct AwsRedshiftClusterElasticIpStatus: Equatable {
    /// <p>The elastic IP address for the cluster.</p>
    public let elasticIp: String?
    /// <p>The status of the elastic IP address.</p>
    public let status: String?

    public init (
        elasticIp: String? = nil,
        status: String? = nil
    )
    {
        self.elasticIp = elasticIp
        self.status = status
    }
}

extension AwsRedshiftClusterEndpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case port = "Port"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
    }
}

extension AwsRedshiftClusterEndpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRedshiftClusterEndpoint(address: \(String(describing: address)), port: \(String(describing: port)))"}
}

/// <p>The connection endpoint for an Amazon Redshift cluster.</p>
public struct AwsRedshiftClusterEndpoint: Equatable {
    /// <p>The DNS address of the cluster.</p>
    public let address: String?
    /// <p>The port that the database engine listens on.</p>
    public let port: Int

    public init (
        address: String? = nil,
        port: Int = 0
    )
    {
        self.address = address
        self.port = port
    }
}

extension AwsRedshiftClusterHsmStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hsmClientCertificateIdentifier = "HsmClientCertificateIdentifier"
        case hsmConfigurationIdentifier = "HsmConfigurationIdentifier"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hsmClientCertificateIdentifier = hsmClientCertificateIdentifier {
            try encodeContainer.encode(hsmClientCertificateIdentifier, forKey: .hsmClientCertificateIdentifier)
        }
        if let hsmConfigurationIdentifier = hsmConfigurationIdentifier {
            try encodeContainer.encode(hsmConfigurationIdentifier, forKey: .hsmConfigurationIdentifier)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmClientCertificateIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmClientCertificateIdentifier)
        hsmClientCertificateIdentifier = hsmClientCertificateIdentifierDecoded
        let hsmConfigurationIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmConfigurationIdentifier)
        hsmConfigurationIdentifier = hsmConfigurationIdentifierDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AwsRedshiftClusterHsmStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRedshiftClusterHsmStatus(hsmClientCertificateIdentifier: \(String(describing: hsmClientCertificateIdentifier)), hsmConfigurationIdentifier: \(String(describing: hsmConfigurationIdentifier)), status: \(String(describing: status)))"}
}

/// <p>Information about whether an Amazon Redshift cluster finished applying any hardware
///          changes to security module (HSM) settings that were specified in a modify cluster
///          command.</p>
public struct AwsRedshiftClusterHsmStatus: Equatable {
    /// <p>The name of the HSM client certificate that the Amazon Redshift cluster uses to retrieve
    ///          the data encryption keys that are stored in an HSM.</p>
    public let hsmClientCertificateIdentifier: String?
    /// <p>The name of the HSM configuration that contains the information that the Amazon Redshift
    ///          cluster can use to retrieve and store keys in an HSM.</p>
    public let hsmConfigurationIdentifier: String?
    /// <p>Indicates whether the Amazon Redshift cluster has finished applying any HSM settings
    ///          changes specified in a modify cluster command.</p>
    ///          <p>Type: String</p>
    ///          <p>Valid values: <code>active</code> | <code>applying</code>
    ///          </p>
    public let status: String?

    public init (
        hsmClientCertificateIdentifier: String? = nil,
        hsmConfigurationIdentifier: String? = nil,
        status: String? = nil
    )
    {
        self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
        self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
        self.status = status
    }
}

extension AwsRedshiftClusterIamRole: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applyStatus = "ApplyStatus"
        case iamRoleArn = "IamRoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applyStatus = applyStatus {
            try encodeContainer.encode(applyStatus, forKey: .applyStatus)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applyStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applyStatus)
        applyStatus = applyStatusDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
    }
}

extension AwsRedshiftClusterIamRole: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRedshiftClusterIamRole(applyStatus: \(String(describing: applyStatus)), iamRoleArn: \(String(describing: iamRoleArn)))"}
}

/// <p>An IAM role that the cluster can use to access other AWS services.</p>
public struct AwsRedshiftClusterIamRole: Equatable {
    /// <p>The status of the IAM role's association with the cluster.</p>
    ///          <p>Valid values: <code>in-sync</code> | <code>adding</code> | <code>removing</code>
    ///          </p>
    public let applyStatus: String?
    /// <p>The ARN of the IAM role.</p>
    public let iamRoleArn: String?

    public init (
        applyStatus: String? = nil,
        iamRoleArn: String? = nil
    )
    {
        self.applyStatus = applyStatus
        self.iamRoleArn = iamRoleArn
    }
}

extension AwsRedshiftClusterPendingModifiedValues: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case automatedSnapshotRetentionPeriod = "AutomatedSnapshotRetentionPeriod"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterType = "ClusterType"
        case clusterVersion = "ClusterVersion"
        case encryptionType = "EncryptionType"
        case enhancedVpcRouting = "EnhancedVpcRouting"
        case maintenanceTrackName = "MaintenanceTrackName"
        case masterUserPassword = "MasterUserPassword"
        case nodeType = "NodeType"
        case numberOfNodes = "NumberOfNodes"
        case publiclyAccessible = "PubliclyAccessible"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if automatedSnapshotRetentionPeriod != 0 {
            try encodeContainer.encode(automatedSnapshotRetentionPeriod, forKey: .automatedSnapshotRetentionPeriod)
        }
        if let clusterIdentifier = clusterIdentifier {
            try encodeContainer.encode(clusterIdentifier, forKey: .clusterIdentifier)
        }
        if let clusterType = clusterType {
            try encodeContainer.encode(clusterType, forKey: .clusterType)
        }
        if let clusterVersion = clusterVersion {
            try encodeContainer.encode(clusterVersion, forKey: .clusterVersion)
        }
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType, forKey: .encryptionType)
        }
        if enhancedVpcRouting != false {
            try encodeContainer.encode(enhancedVpcRouting, forKey: .enhancedVpcRouting)
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try encodeContainer.encode(maintenanceTrackName, forKey: .maintenanceTrackName)
        }
        if let masterUserPassword = masterUserPassword {
            try encodeContainer.encode(masterUserPassword, forKey: .masterUserPassword)
        }
        if let nodeType = nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if numberOfNodes != 0 {
            try encodeContainer.encode(numberOfNodes, forKey: .numberOfNodes)
        }
        if publiclyAccessible != false {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automatedSnapshotRetentionPeriodDecoded = try containerValues.decode(Int.self, forKey: .automatedSnapshotRetentionPeriod)
        automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriodDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let clusterTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterType)
        clusterType = clusterTypeDecoded
        let clusterVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterVersion)
        clusterVersion = clusterVersionDecoded
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let enhancedVpcRoutingDecoded = try containerValues.decode(Bool.self, forKey: .enhancedVpcRouting)
        enhancedVpcRouting = enhancedVpcRoutingDecoded
        let maintenanceTrackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maintenanceTrackName)
        maintenanceTrackName = maintenanceTrackNameDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let numberOfNodesDecoded = try containerValues.decode(Int.self, forKey: .numberOfNodes)
        numberOfNodes = numberOfNodesDecoded
        let publiclyAccessibleDecoded = try containerValues.decode(Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
    }
}

extension AwsRedshiftClusterPendingModifiedValues: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRedshiftClusterPendingModifiedValues(automatedSnapshotRetentionPeriod: \(String(describing: automatedSnapshotRetentionPeriod)), clusterIdentifier: \(String(describing: clusterIdentifier)), clusterType: \(String(describing: clusterType)), clusterVersion: \(String(describing: clusterVersion)), encryptionType: \(String(describing: encryptionType)), enhancedVpcRouting: \(String(describing: enhancedVpcRouting)), maintenanceTrackName: \(String(describing: maintenanceTrackName)), masterUserPassword: \(String(describing: masterUserPassword)), nodeType: \(String(describing: nodeType)), numberOfNodes: \(String(describing: numberOfNodes)), publiclyAccessible: \(String(describing: publiclyAccessible)))"}
}

/// <p>Changes to the Amazon Redshift cluster that are currently pending.</p>
public struct AwsRedshiftClusterPendingModifiedValues: Equatable {
    /// <p>The pending or in-progress change to the automated snapshot retention period.</p>
    public let automatedSnapshotRetentionPeriod: Int
    /// <p>The pending or in-progress change to the identifier for the cluster.</p>
    public let clusterIdentifier: String?
    /// <p>The pending or in-progress change to the cluster type.</p>
    public let clusterType: String?
    /// <p>The pending or in-progress change to the service version.</p>
    public let clusterVersion: String?
    /// <p>The encryption type for a cluster.</p>
    public let encryptionType: String?
    /// <p>Indicates whether to create the cluster with enhanced VPC routing enabled.</p>
    public let enhancedVpcRouting: Bool
    /// <p>The name of the maintenance track that the cluster changes to during the next
    ///          maintenance window.</p>
    public let maintenanceTrackName: String?
    /// <p>The pending or in-progress change to the master user password for the cluster.</p>
    public let masterUserPassword: String?
    /// <p>The pending or in-progress change to the cluster's node type.</p>
    public let nodeType: String?
    /// <p>The pending or in-progress change to the number of nodes in the cluster.</p>
    public let numberOfNodes: Int
    /// <p>The pending or in-progress change to whether the cluster can be connected to from the
    ///          public network.</p>
    public let publiclyAccessible: Bool

    public init (
        automatedSnapshotRetentionPeriod: Int = 0,
        clusterIdentifier: String? = nil,
        clusterType: String? = nil,
        clusterVersion: String? = nil,
        encryptionType: String? = nil,
        enhancedVpcRouting: Bool = false,
        maintenanceTrackName: String? = nil,
        masterUserPassword: String? = nil,
        nodeType: String? = nil,
        numberOfNodes: Int = 0,
        publiclyAccessible: Bool = false
    )
    {
        self.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod
        self.clusterIdentifier = clusterIdentifier
        self.clusterType = clusterType
        self.clusterVersion = clusterVersion
        self.encryptionType = encryptionType
        self.enhancedVpcRouting = enhancedVpcRouting
        self.maintenanceTrackName = maintenanceTrackName
        self.masterUserPassword = masterUserPassword
        self.nodeType = nodeType
        self.numberOfNodes = numberOfNodes
        self.publiclyAccessible = publiclyAccessible
    }
}

extension AwsRedshiftClusterResizeInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowCancelResize = "AllowCancelResize"
        case resizeType = "ResizeType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowCancelResize != false {
            try encodeContainer.encode(allowCancelResize, forKey: .allowCancelResize)
        }
        if let resizeType = resizeType {
            try encodeContainer.encode(resizeType, forKey: .resizeType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowCancelResizeDecoded = try containerValues.decode(Bool.self, forKey: .allowCancelResize)
        allowCancelResize = allowCancelResizeDecoded
        let resizeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resizeType)
        resizeType = resizeTypeDecoded
    }
}

extension AwsRedshiftClusterResizeInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRedshiftClusterResizeInfo(allowCancelResize: \(String(describing: allowCancelResize)), resizeType: \(String(describing: resizeType)))"}
}

/// <p>Information about the resize operation for the cluster.</p>
public struct AwsRedshiftClusterResizeInfo: Equatable {
    /// <p>Indicates whether the resize operation can be canceled.</p>
    public let allowCancelResize: Bool
    /// <p>The type of resize operation.</p>
    ///          <p>Valid values: <code>ClassicResize</code>
    ///          </p>
    public let resizeType: String?

    public init (
        allowCancelResize: Bool = false,
        resizeType: String? = nil
    )
    {
        self.allowCancelResize = allowCancelResize
        self.resizeType = resizeType
    }
}

extension AwsRedshiftClusterRestoreStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentRestoreRateInMegaBytesPerSecond = "CurrentRestoreRateInMegaBytesPerSecond"
        case elapsedTimeInSeconds = "ElapsedTimeInSeconds"
        case estimatedTimeToCompletionInSeconds = "EstimatedTimeToCompletionInSeconds"
        case progressInMegaBytes = "ProgressInMegaBytes"
        case snapshotSizeInMegaBytes = "SnapshotSizeInMegaBytes"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if currentRestoreRateInMegaBytesPerSecond != 0.0 {
            try encodeContainer.encode(currentRestoreRateInMegaBytesPerSecond, forKey: .currentRestoreRateInMegaBytesPerSecond)
        }
        if elapsedTimeInSeconds != 0 {
            try encodeContainer.encode(elapsedTimeInSeconds, forKey: .elapsedTimeInSeconds)
        }
        if estimatedTimeToCompletionInSeconds != 0 {
            try encodeContainer.encode(estimatedTimeToCompletionInSeconds, forKey: .estimatedTimeToCompletionInSeconds)
        }
        if progressInMegaBytes != 0 {
            try encodeContainer.encode(progressInMegaBytes, forKey: .progressInMegaBytes)
        }
        if snapshotSizeInMegaBytes != 0 {
            try encodeContainer.encode(snapshotSizeInMegaBytes, forKey: .snapshotSizeInMegaBytes)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentRestoreRateInMegaBytesPerSecondDecoded = try containerValues.decode(Double.self, forKey: .currentRestoreRateInMegaBytesPerSecond)
        currentRestoreRateInMegaBytesPerSecond = currentRestoreRateInMegaBytesPerSecondDecoded
        let elapsedTimeInSecondsDecoded = try containerValues.decode(Int.self, forKey: .elapsedTimeInSeconds)
        elapsedTimeInSeconds = elapsedTimeInSecondsDecoded
        let estimatedTimeToCompletionInSecondsDecoded = try containerValues.decode(Int.self, forKey: .estimatedTimeToCompletionInSeconds)
        estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSecondsDecoded
        let progressInMegaBytesDecoded = try containerValues.decode(Int.self, forKey: .progressInMegaBytes)
        progressInMegaBytes = progressInMegaBytesDecoded
        let snapshotSizeInMegaBytesDecoded = try containerValues.decode(Int.self, forKey: .snapshotSizeInMegaBytes)
        snapshotSizeInMegaBytes = snapshotSizeInMegaBytesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AwsRedshiftClusterRestoreStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRedshiftClusterRestoreStatus(currentRestoreRateInMegaBytesPerSecond: \(String(describing: currentRestoreRateInMegaBytesPerSecond)), elapsedTimeInSeconds: \(String(describing: elapsedTimeInSeconds)), estimatedTimeToCompletionInSeconds: \(String(describing: estimatedTimeToCompletionInSeconds)), progressInMegaBytes: \(String(describing: progressInMegaBytes)), snapshotSizeInMegaBytes: \(String(describing: snapshotSizeInMegaBytes)), status: \(String(describing: status)))"}
}

/// <p>Information about the status of a cluster restore action. It only applies if the cluster
///          was created by restoring a snapshot.</p>
public struct AwsRedshiftClusterRestoreStatus: Equatable {
    /// <p>The number of megabytes per second being transferred from the backup storage. Returns
    ///          the average rate for a completed backup.</p>
    ///          <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
    public let currentRestoreRateInMegaBytesPerSecond: Double
    /// <p>The amount of time an in-progress restore has been running, or the amount of time it
    ///          took a completed restore to finish.</p>
    ///          <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
    public let elapsedTimeInSeconds: Int
    /// <p>The estimate of the time remaining before the restore is complete. Returns 0 for a
    ///          completed restore.</p>
    ///          <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
    public let estimatedTimeToCompletionInSeconds: Int
    /// <p>The number of megabytes that were transferred from snapshot storage.</p>
    ///          <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
    public let progressInMegaBytes: Int
    /// <p>The size of the set of snapshot data that was used to restore the cluster.</p>
    ///          <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
    public let snapshotSizeInMegaBytes: Int
    /// <p>The status of the restore action.</p>
    ///          <p>Valid values: <code>starting</code> | <code>restoring</code> | <code>completed</code> |
    ///             <code>failed</code>
    ///          </p>
    public let status: String?

    public init (
        currentRestoreRateInMegaBytesPerSecond: Double = 0.0,
        elapsedTimeInSeconds: Int = 0,
        estimatedTimeToCompletionInSeconds: Int = 0,
        progressInMegaBytes: Int = 0,
        snapshotSizeInMegaBytes: Int = 0,
        status: String? = nil
    )
    {
        self.currentRestoreRateInMegaBytesPerSecond = currentRestoreRateInMegaBytesPerSecond
        self.elapsedTimeInSeconds = elapsedTimeInSeconds
        self.estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSeconds
        self.progressInMegaBytes = progressInMegaBytes
        self.snapshotSizeInMegaBytes = snapshotSizeInMegaBytes
        self.status = status
    }
}

extension AwsRedshiftClusterVpcSecurityGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
        case vpcSecurityGroupId = "VpcSecurityGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let vpcSecurityGroupId = vpcSecurityGroupId {
            try encodeContainer.encode(vpcSecurityGroupId, forKey: .vpcSecurityGroupId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let vpcSecurityGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcSecurityGroupId)
        vpcSecurityGroupId = vpcSecurityGroupIdDecoded
    }
}

extension AwsRedshiftClusterVpcSecurityGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsRedshiftClusterVpcSecurityGroup(status: \(String(describing: status)), vpcSecurityGroupId: \(String(describing: vpcSecurityGroupId)))"}
}

/// <p>A VPC security group that the cluster belongs to, if the cluster is in a VPC.</p>
public struct AwsRedshiftClusterVpcSecurityGroup: Equatable {
    /// <p>The status of the VPC security group.</p>
    public let status: String?
    /// <p>The identifier of the VPC security group.</p>
    public let vpcSecurityGroupId: String?

    public init (
        status: String? = nil,
        vpcSecurityGroupId: String? = nil
    )
    {
        self.status = status
        self.vpcSecurityGroupId = vpcSecurityGroupId
    }
}

extension AwsS3AccountPublicAccessBlockDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blockPublicAcls = "BlockPublicAcls"
        case blockPublicPolicy = "BlockPublicPolicy"
        case ignorePublicAcls = "IgnorePublicAcls"
        case restrictPublicBuckets = "RestrictPublicBuckets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blockPublicAcls != false {
            try encodeContainer.encode(blockPublicAcls, forKey: .blockPublicAcls)
        }
        if blockPublicPolicy != false {
            try encodeContainer.encode(blockPublicPolicy, forKey: .blockPublicPolicy)
        }
        if ignorePublicAcls != false {
            try encodeContainer.encode(ignorePublicAcls, forKey: .ignorePublicAcls)
        }
        if restrictPublicBuckets != false {
            try encodeContainer.encode(restrictPublicBuckets, forKey: .restrictPublicBuckets)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockPublicAclsDecoded = try containerValues.decode(Bool.self, forKey: .blockPublicAcls)
        blockPublicAcls = blockPublicAclsDecoded
        let blockPublicPolicyDecoded = try containerValues.decode(Bool.self, forKey: .blockPublicPolicy)
        blockPublicPolicy = blockPublicPolicyDecoded
        let ignorePublicAclsDecoded = try containerValues.decode(Bool.self, forKey: .ignorePublicAcls)
        ignorePublicAcls = ignorePublicAclsDecoded
        let restrictPublicBucketsDecoded = try containerValues.decode(Bool.self, forKey: .restrictPublicBuckets)
        restrictPublicBuckets = restrictPublicBucketsDecoded
    }
}

extension AwsS3AccountPublicAccessBlockDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsS3AccountPublicAccessBlockDetails(blockPublicAcls: \(String(describing: blockPublicAcls)), blockPublicPolicy: \(String(describing: blockPublicPolicy)), ignorePublicAcls: \(String(describing: ignorePublicAcls)), restrictPublicBuckets: \(String(describing: restrictPublicBuckets)))"}
}

/// <p>provides information about the Amazon S3 Public Access Block configuration for accounts.</p>
public struct AwsS3AccountPublicAccessBlockDetails: Equatable {
    /// <p>Indicates whether to reject calls to update an S3 bucket if the calls include a public access control list (ACL).</p>
    public let blockPublicAcls: Bool
    /// <p>Indicates whether to reject calls to update the access policy for an S3 bucket or access point if the policy allows public access.</p>
    public let blockPublicPolicy: Bool
    /// <p>Indicates whether Amazon S3 ignores public ACLs that are associated with an S3 bucket.</p>
    public let ignorePublicAcls: Bool
    /// <p>Indicates whether to restrict access to an access point or S3 bucket that has a public policy to only AWS service principals and authorized users within the S3 bucket owner's account.</p>
    public let restrictPublicBuckets: Bool

    public init (
        blockPublicAcls: Bool = false,
        blockPublicPolicy: Bool = false,
        ignorePublicAcls: Bool = false,
        restrictPublicBuckets: Bool = false
    )
    {
        self.blockPublicAcls = blockPublicAcls
        self.blockPublicPolicy = blockPublicPolicy
        self.ignorePublicAcls = ignorePublicAcls
        self.restrictPublicBuckets = restrictPublicBuckets
    }
}

extension AwsS3BucketDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case ownerId = "OwnerId"
        case ownerName = "OwnerName"
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let ownerName = ownerName {
            try encodeContainer.encode(ownerName, forKey: .ownerName)
        }
        if let publicAccessBlockConfiguration = publicAccessBlockConfiguration {
            try encodeContainer.encode(publicAccessBlockConfiguration, forKey: .publicAccessBlockConfiguration)
        }
        if let serverSideEncryptionConfiguration = serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let ownerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerName)
        ownerName = ownerNameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(AwsS3BucketServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(AwsS3AccountPublicAccessBlockDetails.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
    }
}

extension AwsS3BucketDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsS3BucketDetails(createdAt: \(String(describing: createdAt)), ownerId: \(String(describing: ownerId)), ownerName: \(String(describing: ownerName)), publicAccessBlockConfiguration: \(String(describing: publicAccessBlockConfiguration)), serverSideEncryptionConfiguration: \(String(describing: serverSideEncryptionConfiguration)))"}
}

/// <p>The details of an Amazon S3 bucket.</p>
public struct AwsS3BucketDetails: Equatable {
    /// <p>Indicates when the S3 bucket was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let createdAt: String?
    /// <p>The canonical user ID of the owner of the S3 bucket.</p>
    public let ownerId: String?
    /// <p>The display name of the owner of the S3 bucket.</p>
    public let ownerName: String?
    /// <p>Provides information about the Amazon S3 Public Access Block configuration for the S3 bucket.</p>
    public let publicAccessBlockConfiguration: AwsS3AccountPublicAccessBlockDetails?
    /// <p>The encryption rules that are applied to the S3 bucket.</p>
    public let serverSideEncryptionConfiguration: AwsS3BucketServerSideEncryptionConfiguration?

    public init (
        createdAt: String? = nil,
        ownerId: String? = nil,
        ownerName: String? = nil,
        publicAccessBlockConfiguration: AwsS3AccountPublicAccessBlockDetails? = nil,
        serverSideEncryptionConfiguration: AwsS3BucketServerSideEncryptionConfiguration? = nil
    )
    {
        self.createdAt = createdAt
        self.ownerId = ownerId
        self.ownerName = ownerName
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
    }
}

extension AwsS3BucketServerSideEncryptionByDefault: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kMSMasterKeyID = "KMSMasterKeyID"
        case sSEAlgorithm = "SSEAlgorithm"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kMSMasterKeyID = kMSMasterKeyID {
            try encodeContainer.encode(kMSMasterKeyID, forKey: .kMSMasterKeyID)
        }
        if let sSEAlgorithm = sSEAlgorithm {
            try encodeContainer.encode(sSEAlgorithm, forKey: .sSEAlgorithm)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sSEAlgorithmDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sSEAlgorithm)
        sSEAlgorithm = sSEAlgorithmDecoded
        let kMSMasterKeyIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSMasterKeyID)
        kMSMasterKeyID = kMSMasterKeyIDDecoded
    }
}

extension AwsS3BucketServerSideEncryptionByDefault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsS3BucketServerSideEncryptionByDefault(kMSMasterKeyID: \(String(describing: kMSMasterKeyID)), sSEAlgorithm: \(String(describing: sSEAlgorithm)))"}
}

/// <p>Specifies the default server-side encryption to apply to new objects in the
///          bucket.</p>
public struct AwsS3BucketServerSideEncryptionByDefault: Equatable {
    /// <p>AWS KMS customer master key (CMK) ID to use for the default encryption.</p>
    public let kMSMasterKeyID: String?
    /// <p>Server-side encryption algorithm to use for the default encryption.</p>
    public let sSEAlgorithm: String?

    public init (
        kMSMasterKeyID: String? = nil,
        sSEAlgorithm: String? = nil
    )
    {
        self.kMSMasterKeyID = kMSMasterKeyID
        self.sSEAlgorithm = sSEAlgorithm
    }
}

extension AwsS3BucketServerSideEncryptionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rules = "Rules"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for awss3bucketserversideencryptionrules0 in rules {
                try rulesContainer.encode(awss3bucketserversideencryptionrules0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([AwsS3BucketServerSideEncryptionRule?].self, forKey: .rules)
        var rulesDecoded0:[AwsS3BucketServerSideEncryptionRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [AwsS3BucketServerSideEncryptionRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension AwsS3BucketServerSideEncryptionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsS3BucketServerSideEncryptionConfiguration(rules: \(String(describing: rules)))"}
}

/// <p>The encryption configuration for the S3 bucket.</p>
public struct AwsS3BucketServerSideEncryptionConfiguration: Equatable {
    /// <p>The encryption rules that are applied to the S3 bucket.</p>
    public let rules: [AwsS3BucketServerSideEncryptionRule]?

    public init (
        rules: [AwsS3BucketServerSideEncryptionRule]? = nil
    )
    {
        self.rules = rules
    }
}

extension AwsS3BucketServerSideEncryptionRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applyServerSideEncryptionByDefault = "ApplyServerSideEncryptionByDefault"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applyServerSideEncryptionByDefault = applyServerSideEncryptionByDefault {
            try encodeContainer.encode(applyServerSideEncryptionByDefault, forKey: .applyServerSideEncryptionByDefault)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applyServerSideEncryptionByDefaultDecoded = try containerValues.decodeIfPresent(AwsS3BucketServerSideEncryptionByDefault.self, forKey: .applyServerSideEncryptionByDefault)
        applyServerSideEncryptionByDefault = applyServerSideEncryptionByDefaultDecoded
    }
}

extension AwsS3BucketServerSideEncryptionRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsS3BucketServerSideEncryptionRule(applyServerSideEncryptionByDefault: \(String(describing: applyServerSideEncryptionByDefault)))"}
}

/// <p>An encryption rule to apply to the S3 bucket.</p>
public struct AwsS3BucketServerSideEncryptionRule: Equatable {
    /// <p>Specifies the default server-side encryption to apply to new objects in the bucket. If a
    ///             <code>PUT</code> object request doesn't specify any server-side encryption, this default
    ///          encryption is applied.</p>
    public let applyServerSideEncryptionByDefault: AwsS3BucketServerSideEncryptionByDefault?

    public init (
        applyServerSideEncryptionByDefault: AwsS3BucketServerSideEncryptionByDefault? = nil
    )
    {
        self.applyServerSideEncryptionByDefault = applyServerSideEncryptionByDefault
    }
}

extension AwsS3ObjectDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentType = "ContentType"
        case eTag = "ETag"
        case lastModified = "LastModified"
        case sSEKMSKeyId = "SSEKMSKeyId"
        case serverSideEncryption = "ServerSideEncryption"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let eTag = eTag {
            try encodeContainer.encode(eTag, forKey: .eTag)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified, forKey: .lastModified)
        }
        if let sSEKMSKeyId = sSEKMSKeyId {
            try encodeContainer.encode(sSEKMSKeyId, forKey: .sSEKMSKeyId)
        }
        if let serverSideEncryption = serverSideEncryption {
            try encodeContainer.encode(serverSideEncryption, forKey: .serverSideEncryption)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let eTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eTag)
        eTag = eTagDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let serverSideEncryptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverSideEncryption)
        serverSideEncryption = serverSideEncryptionDecoded
        let sSEKMSKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sSEKMSKeyId)
        sSEKMSKeyId = sSEKMSKeyIdDecoded
    }
}

extension AwsS3ObjectDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsS3ObjectDetails(contentType: \(String(describing: contentType)), eTag: \(String(describing: eTag)), lastModified: \(String(describing: lastModified)), sSEKMSKeyId: \(String(describing: sSEKMSKeyId)), serverSideEncryption: \(String(describing: serverSideEncryption)), versionId: \(String(describing: versionId)))"}
}

/// <p>Details about an Amazon S3 object.</p>
public struct AwsS3ObjectDetails: Equatable {
    /// <p>A standard MIME type describing the format of the object data.</p>
    public let contentType: String?
    /// <p>The opaque identifier assigned by a web server to a specific version of a resource found
    ///          at a URL.</p>
    public let eTag: String?
    /// <p>Indicates when the object was last modified.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let lastModified: String?
    /// <p>The identifier of the AWS Key Management Service (AWS KMS) symmetric customer managed
    ///          customer master key (CMK) that was used for the object.</p>
    public let sSEKMSKeyId: String?
    /// <p>If the object is stored using server-side encryption, the value of the server-side
    ///          encryption algorithm used when storing this object in Amazon S3.</p>
    public let serverSideEncryption: String?
    /// <p>The version of the object.</p>
    public let versionId: String?

    public init (
        contentType: String? = nil,
        eTag: String? = nil,
        lastModified: String? = nil,
        sSEKMSKeyId: String? = nil,
        serverSideEncryption: String? = nil,
        versionId: String? = nil
    )
    {
        self.contentType = contentType
        self.eTag = eTag
        self.lastModified = lastModified
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.versionId = versionId
    }
}

extension AwsSecretsManagerSecretDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deleted = "Deleted"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case rotationEnabled = "RotationEnabled"
        case rotationLambdaArn = "RotationLambdaArn"
        case rotationOccurredWithinFrequency = "RotationOccurredWithinFrequency"
        case rotationRules = "RotationRules"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deleted != false {
            try encodeContainer.encode(deleted, forKey: .deleted)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if rotationEnabled != false {
            try encodeContainer.encode(rotationEnabled, forKey: .rotationEnabled)
        }
        if let rotationLambdaArn = rotationLambdaArn {
            try encodeContainer.encode(rotationLambdaArn, forKey: .rotationLambdaArn)
        }
        if rotationOccurredWithinFrequency != false {
            try encodeContainer.encode(rotationOccurredWithinFrequency, forKey: .rotationOccurredWithinFrequency)
        }
        if let rotationRules = rotationRules {
            try encodeContainer.encode(rotationRules, forKey: .rotationRules)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationRulesDecoded = try containerValues.decodeIfPresent(AwsSecretsManagerSecretRotationRules.self, forKey: .rotationRules)
        rotationRules = rotationRulesDecoded
        let rotationOccurredWithinFrequencyDecoded = try containerValues.decode(Bool.self, forKey: .rotationOccurredWithinFrequency)
        rotationOccurredWithinFrequency = rotationOccurredWithinFrequencyDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let rotationEnabledDecoded = try containerValues.decode(Bool.self, forKey: .rotationEnabled)
        rotationEnabled = rotationEnabledDecoded
        let rotationLambdaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rotationLambdaArn)
        rotationLambdaArn = rotationLambdaArnDecoded
        let deletedDecoded = try containerValues.decode(Bool.self, forKey: .deleted)
        deleted = deletedDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AwsSecretsManagerSecretDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsSecretsManagerSecretDetails(deleted: \(String(describing: deleted)), description: \(String(describing: description)), kmsKeyId: \(String(describing: kmsKeyId)), name: \(String(describing: name)), rotationEnabled: \(String(describing: rotationEnabled)), rotationLambdaArn: \(String(describing: rotationLambdaArn)), rotationOccurredWithinFrequency: \(String(describing: rotationOccurredWithinFrequency)), rotationRules: \(String(describing: rotationRules)))"}
}

/// <p>Details about an AWS Secrets Manager secret.</p>
public struct AwsSecretsManagerSecretDetails: Equatable {
    /// <p>Whether the secret is deleted.</p>
    public let deleted: Bool
    /// <p>The user-provided description of the secret.</p>
    public let description: String?
    /// <p>The ARN, Key ID, or alias of the AWS KMS customer master key (CMK) used to encrypt the
    ///             <code>SecretString</code> or <code>SecretBinary</code> values for versions of this
    ///          secret.</p>
    public let kmsKeyId: String?
    /// <p>The name of the secret.</p>
    public let name: String?
    /// <p>Whether rotation is enabled.</p>
    public let rotationEnabled: Bool
    /// <p>The ARN of the Lambda function that rotates the secret.</p>
    public let rotationLambdaArn: String?
    /// <p>Whether the rotation occurred within the specified rotation frequency.</p>
    public let rotationOccurredWithinFrequency: Bool
    /// <p>Defines the rotation schedule for the secret.</p>
    public let rotationRules: AwsSecretsManagerSecretRotationRules?

    public init (
        deleted: Bool = false,
        description: String? = nil,
        kmsKeyId: String? = nil,
        name: String? = nil,
        rotationEnabled: Bool = false,
        rotationLambdaArn: String? = nil,
        rotationOccurredWithinFrequency: Bool = false,
        rotationRules: AwsSecretsManagerSecretRotationRules? = nil
    )
    {
        self.deleted = deleted
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.rotationEnabled = rotationEnabled
        self.rotationLambdaArn = rotationLambdaArn
        self.rotationOccurredWithinFrequency = rotationOccurredWithinFrequency
        self.rotationRules = rotationRules
    }
}

extension AwsSecretsManagerSecretRotationRules: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case automaticallyAfterDays = "AutomaticallyAfterDays"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if automaticallyAfterDays != 0 {
            try encodeContainer.encode(automaticallyAfterDays, forKey: .automaticallyAfterDays)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automaticallyAfterDaysDecoded = try containerValues.decode(Int.self, forKey: .automaticallyAfterDays)
        automaticallyAfterDays = automaticallyAfterDaysDecoded
    }
}

extension AwsSecretsManagerSecretRotationRules: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsSecretsManagerSecretRotationRules(automaticallyAfterDays: \(String(describing: automaticallyAfterDays)))"}
}

/// <p>Defines the rotation schedule for the secret.</p>
public struct AwsSecretsManagerSecretRotationRules: Equatable {
    /// <p>The number of days after the previous rotation to rotate the secret.</p>
    public let automaticallyAfterDays: Int

    public init (
        automaticallyAfterDays: Int = 0
    )
    {
        self.automaticallyAfterDays = automaticallyAfterDays
    }
}

extension AwsSecurityFinding: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case awsAccountId = "AwsAccountId"
        case compliance = "Compliance"
        case confidence = "Confidence"
        case createdAt = "CreatedAt"
        case criticality = "Criticality"
        case description = "Description"
        case findingProviderFields = "FindingProviderFields"
        case firstObservedAt = "FirstObservedAt"
        case generatorId = "GeneratorId"
        case id = "Id"
        case lastObservedAt = "LastObservedAt"
        case malware = "Malware"
        case network = "Network"
        case networkPath = "NetworkPath"
        case note = "Note"
        case patchSummary = "PatchSummary"
        case process = "Process"
        case productArn = "ProductArn"
        case productFields = "ProductFields"
        case recordState = "RecordState"
        case relatedFindings = "RelatedFindings"
        case remediation = "Remediation"
        case resources = "Resources"
        case schemaVersion = "SchemaVersion"
        case severity = "Severity"
        case sourceUrl = "SourceUrl"
        case threatIntelIndicators = "ThreatIntelIndicators"
        case title = "Title"
        case types = "Types"
        case updatedAt = "UpdatedAt"
        case userDefinedFields = "UserDefinedFields"
        case verificationState = "VerificationState"
        case vulnerabilities = "Vulnerabilities"
        case workflow = "Workflow"
        case workflowState = "WorkflowState"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let awsAccountId = awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let compliance = compliance {
            try encodeContainer.encode(compliance, forKey: .compliance)
        }
        if confidence != 0 {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if criticality != 0 {
            try encodeContainer.encode(criticality, forKey: .criticality)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let findingProviderFields = findingProviderFields {
            try encodeContainer.encode(findingProviderFields, forKey: .findingProviderFields)
        }
        if let firstObservedAt = firstObservedAt {
            try encodeContainer.encode(firstObservedAt, forKey: .firstObservedAt)
        }
        if let generatorId = generatorId {
            try encodeContainer.encode(generatorId, forKey: .generatorId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastObservedAt = lastObservedAt {
            try encodeContainer.encode(lastObservedAt, forKey: .lastObservedAt)
        }
        if let malware = malware {
            var malwareContainer = encodeContainer.nestedUnkeyedContainer(forKey: .malware)
            for malwarelist0 in malware {
                try malwareContainer.encode(malwarelist0)
            }
        }
        if let network = network {
            try encodeContainer.encode(network, forKey: .network)
        }
        if let networkPath = networkPath {
            var networkPathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkPath)
            for networkpathlist0 in networkPath {
                try networkPathContainer.encode(networkpathlist0)
            }
        }
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let patchSummary = patchSummary {
            try encodeContainer.encode(patchSummary, forKey: .patchSummary)
        }
        if let process = process {
            try encodeContainer.encode(process, forKey: .process)
        }
        if let productArn = productArn {
            try encodeContainer.encode(productArn, forKey: .productArn)
        }
        if let productFields = productFields {
            var productFieldsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .productFields)
            for (dictKey0, fieldmap0) in productFields {
                try productFieldsContainer.encode(fieldmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let recordState = recordState {
            try encodeContainer.encode(recordState.rawValue, forKey: .recordState)
        }
        if let relatedFindings = relatedFindings {
            var relatedFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedFindings)
            for relatedfindinglist0 in relatedFindings {
                try relatedFindingsContainer.encode(relatedfindinglist0)
            }
        }
        if let remediation = remediation {
            try encodeContainer.encode(remediation, forKey: .remediation)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resourcelist0 in resources {
                try resourcesContainer.encode(resourcelist0)
            }
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let sourceUrl = sourceUrl {
            try encodeContainer.encode(sourceUrl, forKey: .sourceUrl)
        }
        if let threatIntelIndicators = threatIntelIndicators {
            var threatIntelIndicatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatIntelIndicators)
            for threatintelindicatorlist0 in threatIntelIndicators {
                try threatIntelIndicatorsContainer.encode(threatintelindicatorlist0)
            }
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let types = types {
            var typesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .types)
            for typelist0 in types {
                try typesContainer.encode(typelist0)
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt, forKey: .updatedAt)
        }
        if let userDefinedFields = userDefinedFields {
            var userDefinedFieldsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .userDefinedFields)
            for (dictKey0, fieldmap0) in userDefinedFields {
                try userDefinedFieldsContainer.encode(fieldmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let verificationState = verificationState {
            try encodeContainer.encode(verificationState.rawValue, forKey: .verificationState)
        }
        if let vulnerabilities = vulnerabilities {
            var vulnerabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vulnerabilities)
            for vulnerabilitylist0 in vulnerabilities {
                try vulnerabilitiesContainer.encode(vulnerabilitylist0)
            }
        }
        if let workflow = workflow {
            try encodeContainer.encode(workflow, forKey: .workflow)
        }
        if let workflowState = workflowState {
            try encodeContainer.encode(workflowState.rawValue, forKey: .workflowState)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let productArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productArn)
        productArn = productArnDecoded
        let generatorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .generatorId)
        generatorId = generatorIdDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let typesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .types)
        var typesDecoded0:[String]? = nil
        if let typesContainer = typesContainer {
            typesDecoded0 = [String]()
            for string0 in typesContainer {
                if let string0 = string0 {
                    typesDecoded0?.append(string0)
                }
            }
        }
        types = typesDecoded0
        let firstObservedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firstObservedAt)
        firstObservedAt = firstObservedAtDecoded
        let lastObservedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastObservedAt)
        lastObservedAt = lastObservedAtDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Severity.self, forKey: .severity)
        severity = severityDecoded
        let confidenceDecoded = try containerValues.decode(Int.self, forKey: .confidence)
        confidence = confidenceDecoded
        let criticalityDecoded = try containerValues.decode(Int.self, forKey: .criticality)
        criticality = criticalityDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let remediationDecoded = try containerValues.decodeIfPresent(Remediation.self, forKey: .remediation)
        remediation = remediationDecoded
        let sourceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceUrl)
        sourceUrl = sourceUrlDecoded
        let productFieldsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .productFields)
        var productFieldsDecoded0: [String:String]? = nil
        if let productFieldsContainer = productFieldsContainer {
            productFieldsDecoded0 = [String:String]()
            for (key0, nonemptystring0) in productFieldsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    productFieldsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        productFields = productFieldsDecoded0
        let userDefinedFieldsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .userDefinedFields)
        var userDefinedFieldsDecoded0: [String:String]? = nil
        if let userDefinedFieldsContainer = userDefinedFieldsContainer {
            userDefinedFieldsDecoded0 = [String:String]()
            for (key0, nonemptystring0) in userDefinedFieldsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    userDefinedFieldsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        userDefinedFields = userDefinedFieldsDecoded0
        let malwareContainer = try containerValues.decodeIfPresent([Malware?].self, forKey: .malware)
        var malwareDecoded0:[Malware]? = nil
        if let malwareContainer = malwareContainer {
            malwareDecoded0 = [Malware]()
            for structure0 in malwareContainer {
                if let structure0 = structure0 {
                    malwareDecoded0?.append(structure0)
                }
            }
        }
        malware = malwareDecoded0
        let networkDecoded = try containerValues.decodeIfPresent(Network.self, forKey: .network)
        network = networkDecoded
        let networkPathContainer = try containerValues.decodeIfPresent([NetworkPathComponent?].self, forKey: .networkPath)
        var networkPathDecoded0:[NetworkPathComponent]? = nil
        if let networkPathContainer = networkPathContainer {
            networkPathDecoded0 = [NetworkPathComponent]()
            for structure0 in networkPathContainer {
                if let structure0 = structure0 {
                    networkPathDecoded0?.append(structure0)
                }
            }
        }
        networkPath = networkPathDecoded0
        let processDecoded = try containerValues.decodeIfPresent(ProcessDetails.self, forKey: .process)
        process = processDecoded
        let threatIntelIndicatorsContainer = try containerValues.decodeIfPresent([ThreatIntelIndicator?].self, forKey: .threatIntelIndicators)
        var threatIntelIndicatorsDecoded0:[ThreatIntelIndicator]? = nil
        if let threatIntelIndicatorsContainer = threatIntelIndicatorsContainer {
            threatIntelIndicatorsDecoded0 = [ThreatIntelIndicator]()
            for structure0 in threatIntelIndicatorsContainer {
                if let structure0 = structure0 {
                    threatIntelIndicatorsDecoded0?.append(structure0)
                }
            }
        }
        threatIntelIndicators = threatIntelIndicatorsDecoded0
        let resourcesContainer = try containerValues.decodeIfPresent([Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let complianceDecoded = try containerValues.decodeIfPresent(Compliance.self, forKey: .compliance)
        compliance = complianceDecoded
        let verificationStateDecoded = try containerValues.decodeIfPresent(VerificationState.self, forKey: .verificationState)
        verificationState = verificationStateDecoded
        let workflowStateDecoded = try containerValues.decodeIfPresent(WorkflowState.self, forKey: .workflowState)
        workflowState = workflowStateDecoded
        let workflowDecoded = try containerValues.decodeIfPresent(Workflow.self, forKey: .workflow)
        workflow = workflowDecoded
        let recordStateDecoded = try containerValues.decodeIfPresent(RecordState.self, forKey: .recordState)
        recordState = recordStateDecoded
        let relatedFindingsContainer = try containerValues.decodeIfPresent([RelatedFinding?].self, forKey: .relatedFindings)
        var relatedFindingsDecoded0:[RelatedFinding]? = nil
        if let relatedFindingsContainer = relatedFindingsContainer {
            relatedFindingsDecoded0 = [RelatedFinding]()
            for structure0 in relatedFindingsContainer {
                if let structure0 = structure0 {
                    relatedFindingsDecoded0?.append(structure0)
                }
            }
        }
        relatedFindings = relatedFindingsDecoded0
        let noteDecoded = try containerValues.decodeIfPresent(Note.self, forKey: .note)
        note = noteDecoded
        let vulnerabilitiesContainer = try containerValues.decodeIfPresent([Vulnerability?].self, forKey: .vulnerabilities)
        var vulnerabilitiesDecoded0:[Vulnerability]? = nil
        if let vulnerabilitiesContainer = vulnerabilitiesContainer {
            vulnerabilitiesDecoded0 = [Vulnerability]()
            for structure0 in vulnerabilitiesContainer {
                if let structure0 = structure0 {
                    vulnerabilitiesDecoded0?.append(structure0)
                }
            }
        }
        vulnerabilities = vulnerabilitiesDecoded0
        let patchSummaryDecoded = try containerValues.decodeIfPresent(PatchSummary.self, forKey: .patchSummary)
        patchSummary = patchSummaryDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
        let findingProviderFieldsDecoded = try containerValues.decodeIfPresent(FindingProviderFields.self, forKey: .findingProviderFields)
        findingProviderFields = findingProviderFieldsDecoded
    }
}

extension AwsSecurityFinding: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsSecurityFinding(action: \(String(describing: action)), awsAccountId: \(String(describing: awsAccountId)), compliance: \(String(describing: compliance)), confidence: \(String(describing: confidence)), createdAt: \(String(describing: createdAt)), criticality: \(String(describing: criticality)), description: \(String(describing: description)), findingProviderFields: \(String(describing: findingProviderFields)), firstObservedAt: \(String(describing: firstObservedAt)), generatorId: \(String(describing: generatorId)), id: \(String(describing: id)), lastObservedAt: \(String(describing: lastObservedAt)), malware: \(String(describing: malware)), network: \(String(describing: network)), networkPath: \(String(describing: networkPath)), note: \(String(describing: note)), patchSummary: \(String(describing: patchSummary)), process: \(String(describing: process)), productArn: \(String(describing: productArn)), productFields: \(String(describing: productFields)), recordState: \(String(describing: recordState)), relatedFindings: \(String(describing: relatedFindings)), remediation: \(String(describing: remediation)), resources: \(String(describing: resources)), schemaVersion: \(String(describing: schemaVersion)), severity: \(String(describing: severity)), sourceUrl: \(String(describing: sourceUrl)), threatIntelIndicators: \(String(describing: threatIntelIndicators)), title: \(String(describing: title)), types: \(String(describing: types)), updatedAt: \(String(describing: updatedAt)), userDefinedFields: \(String(describing: userDefinedFields)), verificationState: \(String(describing: verificationState)), vulnerabilities: \(String(describing: vulnerabilities)), workflow: \(String(describing: workflow)), workflowState: \(String(describing: workflowState)))"}
}

/// <p>Provides consistent format for the contents of the Security Hub-aggregated findings.
///             <code>AwsSecurityFinding</code> format enables you to share findings between AWS
///          security services and third-party solutions, and security standards checks.</p>
///          <note>
///             <p>A finding is a potential security issue generated either by AWS services (Amazon
///             GuardDuty, Amazon Inspector, and Amazon Macie) or by the integrated third-party
///             solutions and standards checks.</p>
///          </note>
public struct AwsSecurityFinding: Equatable {
    /// <p>Provides details about an action that affects or that was taken on a resource.</p>
    public let action: Action?
    /// <p>The AWS account ID that a finding is generated in.</p>
    public let awsAccountId: String?
    /// <p>This data type is exclusive to findings that are generated as the result of a check run
    ///          against a specific rule in a supported security standard, such as CIS AWS Foundations.
    ///          Contains security standard-related finding details.</p>
    public let compliance: Compliance?
    /// <p>A finding's confidence. Confidence is defined as the likelihood that a finding
    ///          accurately identifies the behavior or issue that it was intended to identify.</p>
    ///          <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent
    ///          confidence and 100 means 100 percent confidence.</p>
    public let confidence: Int
    /// <p>Indicates when the security-findings provider created the potential security issue that
    ///          a finding captured.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let createdAt: String?
    /// <p>The level of importance assigned to the resources associated with the finding.</p>
    ///          <p>A score of 0 means that the underlying resources have no criticality, and a score of 100
    ///          is reserved for the most critical resources.</p>
    public let criticality: Int
    /// <p>A finding's description.</p>
    ///          <note>
    ///             <p>In this release, <code>Description</code> is a required property.</p>
    ///          </note>
    public let description: String?
    /// <p>In a <code>BatchImportFindings</code> request, finding providers use <code>FindingProviderFields</code> to provide and update their own values for confidence, criticality, related findings, severity, and types.</p>
    public let findingProviderFields: FindingProviderFields?
    /// <p>Indicates when the security-findings provider first observed the potential security
    ///          issue that a finding captured.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let firstObservedAt: String?
    /// <p>The identifier for the solution-specific component (a discrete unit of logic) that
    ///          generated a finding. In various security-findings providers' solutions, this generator can
    ///          be called a rule, a check, a detector, a plugin, etc. </p>
    public let generatorId: String?
    /// <p>The security findings provider-specific identifier for a finding.</p>
    public let id: String?
    /// <p>Indicates when the security-findings provider most recently observed the potential
    ///          security issue that a finding captured.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let lastObservedAt: String?
    /// <p>A list of malware related to a finding.</p>
    public let malware: [Malware]?
    /// <p>The details of network-related information about a finding.</p>
    public let network: Network?
    /// <p>Provides information about a network path that is relevant to a finding. Each entry
    ///          under <code>NetworkPath</code> represents a component of that path.</p>
    public let networkPath: [NetworkPathComponent]?
    /// <p>A user-defined note added to a finding.</p>
    public let note: Note?
    /// <p>Provides an overview of the patch compliance status for an instance against a selected
    ///          compliance standard.</p>
    public let patchSummary: PatchSummary?
    /// <p>The details of process-related information about a finding.</p>
    public let process: ProcessDetails?
    /// <p>The ARN generated by Security Hub that uniquely identifies a product that generates findings.
    ///          This can be the ARN for a third-party product that is integrated with Security Hub, or the ARN for
    ///          a custom integration.</p>
    public let productArn: String?
    /// <p>A data type where security-findings providers can include additional solution-specific
    ///          details that aren't part of the defined <code>AwsSecurityFinding</code> format.</p>
    public let productFields: [String:String]?
    /// <p>The record state of a finding.</p>
    public let recordState: RecordState?
    /// <p>A list of related findings.</p>
    public let relatedFindings: [RelatedFinding]?
    /// <p>A data type that describes the remediation options for a finding.</p>
    public let remediation: Remediation?
    /// <p>A set of resource data types that describe the resources that the finding refers
    ///          to.</p>
    public let resources: [Resource]?
    /// <p>The schema version that a finding is formatted for.</p>
    public let schemaVersion: String?
    /// <p>A finding's severity.</p>
    public let severity: Severity?
    /// <p>A URL that links to a page about the current finding in the security-findings provider's
    ///          solution.</p>
    public let sourceUrl: String?
    /// <p>Threat intelligence details related to a finding.</p>
    public let threatIntelIndicators: [ThreatIntelIndicator]?
    /// <p>A finding's title.</p>
    ///          <note>
    ///             <p>In this release, <code>Title</code> is a required property.</p>
    ///          </note>
    public let title: String?
    /// <p>One or more finding types in the format of <code>namespace/category/classifier</code>
    ///          that classify a finding.</p>
    ///          <p>Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual
    ///          Behaviors | Sensitive Data Identifications</p>
    public let types: [String]?
    /// <p>Indicates when the security-findings provider last updated the finding record.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let updatedAt: String?
    /// <p>A list of name/value string pairs associated with the finding. These are custom,
    ///          user-defined fields added to a finding. </p>
    public let userDefinedFields: [String:String]?
    /// <p>Indicates the veracity of a finding. </p>
    public let verificationState: VerificationState?
    /// <p>Provides a list of vulnerabilities associated with the findings.</p>
    public let vulnerabilities: [Vulnerability]?
    /// <p>Provides information about the status of the investigation into a finding.</p>
    public let workflow: Workflow?
    /// <p>The workflow state of a finding. </p>
    @available(*, deprecated, message: "This field is deprecated, use Workflow.Status instead.")
    public let workflowState: WorkflowState?

    public init (
        action: Action? = nil,
        awsAccountId: String? = nil,
        compliance: Compliance? = nil,
        confidence: Int = 0,
        createdAt: String? = nil,
        criticality: Int = 0,
        description: String? = nil,
        findingProviderFields: FindingProviderFields? = nil,
        firstObservedAt: String? = nil,
        generatorId: String? = nil,
        id: String? = nil,
        lastObservedAt: String? = nil,
        malware: [Malware]? = nil,
        network: Network? = nil,
        networkPath: [NetworkPathComponent]? = nil,
        note: Note? = nil,
        patchSummary: PatchSummary? = nil,
        process: ProcessDetails? = nil,
        productArn: String? = nil,
        productFields: [String:String]? = nil,
        recordState: RecordState? = nil,
        relatedFindings: [RelatedFinding]? = nil,
        remediation: Remediation? = nil,
        resources: [Resource]? = nil,
        schemaVersion: String? = nil,
        severity: Severity? = nil,
        sourceUrl: String? = nil,
        threatIntelIndicators: [ThreatIntelIndicator]? = nil,
        title: String? = nil,
        types: [String]? = nil,
        updatedAt: String? = nil,
        userDefinedFields: [String:String]? = nil,
        verificationState: VerificationState? = nil,
        vulnerabilities: [Vulnerability]? = nil,
        workflow: Workflow? = nil,
        workflowState: WorkflowState? = nil
    )
    {
        self.action = action
        self.awsAccountId = awsAccountId
        self.compliance = compliance
        self.confidence = confidence
        self.createdAt = createdAt
        self.criticality = criticality
        self.description = description
        self.findingProviderFields = findingProviderFields
        self.firstObservedAt = firstObservedAt
        self.generatorId = generatorId
        self.id = id
        self.lastObservedAt = lastObservedAt
        self.malware = malware
        self.network = network
        self.networkPath = networkPath
        self.note = note
        self.patchSummary = patchSummary
        self.process = process
        self.productArn = productArn
        self.productFields = productFields
        self.recordState = recordState
        self.relatedFindings = relatedFindings
        self.remediation = remediation
        self.resources = resources
        self.schemaVersion = schemaVersion
        self.severity = severity
        self.sourceUrl = sourceUrl
        self.threatIntelIndicators = threatIntelIndicators
        self.title = title
        self.types = types
        self.updatedAt = updatedAt
        self.userDefinedFields = userDefinedFields
        self.verificationState = verificationState
        self.vulnerabilities = vulnerabilities
        self.workflow = workflow
        self.workflowState = workflowState
    }
}

extension AwsSecurityFindingFilters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsAccountId = "AwsAccountId"
        case companyName = "CompanyName"
        case complianceStatus = "ComplianceStatus"
        case confidence = "Confidence"
        case createdAt = "CreatedAt"
        case criticality = "Criticality"
        case description = "Description"
        case findingProviderFieldsConfidence = "FindingProviderFieldsConfidence"
        case findingProviderFieldsCriticality = "FindingProviderFieldsCriticality"
        case findingProviderFieldsRelatedFindingsId = "FindingProviderFieldsRelatedFindingsId"
        case findingProviderFieldsRelatedFindingsProductArn = "FindingProviderFieldsRelatedFindingsProductArn"
        case findingProviderFieldsSeverityLabel = "FindingProviderFieldsSeverityLabel"
        case findingProviderFieldsSeverityOriginal = "FindingProviderFieldsSeverityOriginal"
        case findingProviderFieldsTypes = "FindingProviderFieldsTypes"
        case firstObservedAt = "FirstObservedAt"
        case generatorId = "GeneratorId"
        case id = "Id"
        case keyword = "Keyword"
        case lastObservedAt = "LastObservedAt"
        case malwareName = "MalwareName"
        case malwarePath = "MalwarePath"
        case malwareState = "MalwareState"
        case malwareType = "MalwareType"
        case networkDestinationDomain = "NetworkDestinationDomain"
        case networkDestinationIpV4 = "NetworkDestinationIpV4"
        case networkDestinationIpV6 = "NetworkDestinationIpV6"
        case networkDestinationPort = "NetworkDestinationPort"
        case networkDirection = "NetworkDirection"
        case networkProtocol = "NetworkProtocol"
        case networkSourceDomain = "NetworkSourceDomain"
        case networkSourceIpV4 = "NetworkSourceIpV4"
        case networkSourceIpV6 = "NetworkSourceIpV6"
        case networkSourceMac = "NetworkSourceMac"
        case networkSourcePort = "NetworkSourcePort"
        case noteText = "NoteText"
        case noteUpdatedAt = "NoteUpdatedAt"
        case noteUpdatedBy = "NoteUpdatedBy"
        case processLaunchedAt = "ProcessLaunchedAt"
        case processName = "ProcessName"
        case processParentPid = "ProcessParentPid"
        case processPath = "ProcessPath"
        case processPid = "ProcessPid"
        case processTerminatedAt = "ProcessTerminatedAt"
        case productArn = "ProductArn"
        case productFields = "ProductFields"
        case productName = "ProductName"
        case recommendationText = "RecommendationText"
        case recordState = "RecordState"
        case relatedFindingsId = "RelatedFindingsId"
        case relatedFindingsProductArn = "RelatedFindingsProductArn"
        case resourceAwsEc2InstanceIamInstanceProfileArn = "ResourceAwsEc2InstanceIamInstanceProfileArn"
        case resourceAwsEc2InstanceImageId = "ResourceAwsEc2InstanceImageId"
        case resourceAwsEc2InstanceIpV4Addresses = "ResourceAwsEc2InstanceIpV4Addresses"
        case resourceAwsEc2InstanceIpV6Addresses = "ResourceAwsEc2InstanceIpV6Addresses"
        case resourceAwsEc2InstanceKeyName = "ResourceAwsEc2InstanceKeyName"
        case resourceAwsEc2InstanceLaunchedAt = "ResourceAwsEc2InstanceLaunchedAt"
        case resourceAwsEc2InstanceSubnetId = "ResourceAwsEc2InstanceSubnetId"
        case resourceAwsEc2InstanceType = "ResourceAwsEc2InstanceType"
        case resourceAwsEc2InstanceVpcId = "ResourceAwsEc2InstanceVpcId"
        case resourceAwsIamAccessKeyCreatedAt = "ResourceAwsIamAccessKeyCreatedAt"
        case resourceAwsIamAccessKeyStatus = "ResourceAwsIamAccessKeyStatus"
        case resourceAwsIamAccessKeyUserName = "ResourceAwsIamAccessKeyUserName"
        case resourceAwsS3BucketOwnerId = "ResourceAwsS3BucketOwnerId"
        case resourceAwsS3BucketOwnerName = "ResourceAwsS3BucketOwnerName"
        case resourceContainerImageId = "ResourceContainerImageId"
        case resourceContainerImageName = "ResourceContainerImageName"
        case resourceContainerLaunchedAt = "ResourceContainerLaunchedAt"
        case resourceContainerName = "ResourceContainerName"
        case resourceDetailsOther = "ResourceDetailsOther"
        case resourceId = "ResourceId"
        case resourcePartition = "ResourcePartition"
        case resourceRegion = "ResourceRegion"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case severityLabel = "SeverityLabel"
        case severityNormalized = "SeverityNormalized"
        case severityProduct = "SeverityProduct"
        case sourceUrl = "SourceUrl"
        case threatIntelIndicatorCategory = "ThreatIntelIndicatorCategory"
        case threatIntelIndicatorLastObservedAt = "ThreatIntelIndicatorLastObservedAt"
        case threatIntelIndicatorSource = "ThreatIntelIndicatorSource"
        case threatIntelIndicatorSourceUrl = "ThreatIntelIndicatorSourceUrl"
        case threatIntelIndicatorType = "ThreatIntelIndicatorType"
        case threatIntelIndicatorValue = "ThreatIntelIndicatorValue"
        case title = "Title"
        case type = "Type"
        case updatedAt = "UpdatedAt"
        case userDefinedFields = "UserDefinedFields"
        case verificationState = "VerificationState"
        case workflowState = "WorkflowState"
        case workflowStatus = "WorkflowStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = awsAccountId {
            var awsAccountIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsAccountId)
            for stringfilterlist0 in awsAccountId {
                try awsAccountIdContainer.encode(stringfilterlist0)
            }
        }
        if let companyName = companyName {
            var companyNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .companyName)
            for stringfilterlist0 in companyName {
                try companyNameContainer.encode(stringfilterlist0)
            }
        }
        if let complianceStatus = complianceStatus {
            var complianceStatusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .complianceStatus)
            for stringfilterlist0 in complianceStatus {
                try complianceStatusContainer.encode(stringfilterlist0)
            }
        }
        if let confidence = confidence {
            var confidenceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .confidence)
            for numberfilterlist0 in confidence {
                try confidenceContainer.encode(numberfilterlist0)
            }
        }
        if let createdAt = createdAt {
            var createdAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .createdAt)
            for datefilterlist0 in createdAt {
                try createdAtContainer.encode(datefilterlist0)
            }
        }
        if let criticality = criticality {
            var criticalityContainer = encodeContainer.nestedUnkeyedContainer(forKey: .criticality)
            for numberfilterlist0 in criticality {
                try criticalityContainer.encode(numberfilterlist0)
            }
        }
        if let description = description {
            var descriptionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .description)
            for stringfilterlist0 in description {
                try descriptionContainer.encode(stringfilterlist0)
            }
        }
        if let findingProviderFieldsConfidence = findingProviderFieldsConfidence {
            var findingProviderFieldsConfidenceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingProviderFieldsConfidence)
            for numberfilterlist0 in findingProviderFieldsConfidence {
                try findingProviderFieldsConfidenceContainer.encode(numberfilterlist0)
            }
        }
        if let findingProviderFieldsCriticality = findingProviderFieldsCriticality {
            var findingProviderFieldsCriticalityContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingProviderFieldsCriticality)
            for numberfilterlist0 in findingProviderFieldsCriticality {
                try findingProviderFieldsCriticalityContainer.encode(numberfilterlist0)
            }
        }
        if let findingProviderFieldsRelatedFindingsId = findingProviderFieldsRelatedFindingsId {
            var findingProviderFieldsRelatedFindingsIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingProviderFieldsRelatedFindingsId)
            for stringfilterlist0 in findingProviderFieldsRelatedFindingsId {
                try findingProviderFieldsRelatedFindingsIdContainer.encode(stringfilterlist0)
            }
        }
        if let findingProviderFieldsRelatedFindingsProductArn = findingProviderFieldsRelatedFindingsProductArn {
            var findingProviderFieldsRelatedFindingsProductArnContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingProviderFieldsRelatedFindingsProductArn)
            for stringfilterlist0 in findingProviderFieldsRelatedFindingsProductArn {
                try findingProviderFieldsRelatedFindingsProductArnContainer.encode(stringfilterlist0)
            }
        }
        if let findingProviderFieldsSeverityLabel = findingProviderFieldsSeverityLabel {
            var findingProviderFieldsSeverityLabelContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingProviderFieldsSeverityLabel)
            for stringfilterlist0 in findingProviderFieldsSeverityLabel {
                try findingProviderFieldsSeverityLabelContainer.encode(stringfilterlist0)
            }
        }
        if let findingProviderFieldsSeverityOriginal = findingProviderFieldsSeverityOriginal {
            var findingProviderFieldsSeverityOriginalContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingProviderFieldsSeverityOriginal)
            for stringfilterlist0 in findingProviderFieldsSeverityOriginal {
                try findingProviderFieldsSeverityOriginalContainer.encode(stringfilterlist0)
            }
        }
        if let findingProviderFieldsTypes = findingProviderFieldsTypes {
            var findingProviderFieldsTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingProviderFieldsTypes)
            for stringfilterlist0 in findingProviderFieldsTypes {
                try findingProviderFieldsTypesContainer.encode(stringfilterlist0)
            }
        }
        if let firstObservedAt = firstObservedAt {
            var firstObservedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .firstObservedAt)
            for datefilterlist0 in firstObservedAt {
                try firstObservedAtContainer.encode(datefilterlist0)
            }
        }
        if let generatorId = generatorId {
            var generatorIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .generatorId)
            for stringfilterlist0 in generatorId {
                try generatorIdContainer.encode(stringfilterlist0)
            }
        }
        if let id = id {
            var idContainer = encodeContainer.nestedUnkeyedContainer(forKey: .id)
            for stringfilterlist0 in id {
                try idContainer.encode(stringfilterlist0)
            }
        }
        if let keyword = keyword {
            var keywordContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keyword)
            for keywordfilterlist0 in keyword {
                try keywordContainer.encode(keywordfilterlist0)
            }
        }
        if let lastObservedAt = lastObservedAt {
            var lastObservedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lastObservedAt)
            for datefilterlist0 in lastObservedAt {
                try lastObservedAtContainer.encode(datefilterlist0)
            }
        }
        if let malwareName = malwareName {
            var malwareNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .malwareName)
            for stringfilterlist0 in malwareName {
                try malwareNameContainer.encode(stringfilterlist0)
            }
        }
        if let malwarePath = malwarePath {
            var malwarePathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .malwarePath)
            for stringfilterlist0 in malwarePath {
                try malwarePathContainer.encode(stringfilterlist0)
            }
        }
        if let malwareState = malwareState {
            var malwareStateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .malwareState)
            for stringfilterlist0 in malwareState {
                try malwareStateContainer.encode(stringfilterlist0)
            }
        }
        if let malwareType = malwareType {
            var malwareTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .malwareType)
            for stringfilterlist0 in malwareType {
                try malwareTypeContainer.encode(stringfilterlist0)
            }
        }
        if let networkDestinationDomain = networkDestinationDomain {
            var networkDestinationDomainContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkDestinationDomain)
            for stringfilterlist0 in networkDestinationDomain {
                try networkDestinationDomainContainer.encode(stringfilterlist0)
            }
        }
        if let networkDestinationIpV4 = networkDestinationIpV4 {
            var networkDestinationIpV4Container = encodeContainer.nestedUnkeyedContainer(forKey: .networkDestinationIpV4)
            for ipfilterlist0 in networkDestinationIpV4 {
                try networkDestinationIpV4Container.encode(ipfilterlist0)
            }
        }
        if let networkDestinationIpV6 = networkDestinationIpV6 {
            var networkDestinationIpV6Container = encodeContainer.nestedUnkeyedContainer(forKey: .networkDestinationIpV6)
            for ipfilterlist0 in networkDestinationIpV6 {
                try networkDestinationIpV6Container.encode(ipfilterlist0)
            }
        }
        if let networkDestinationPort = networkDestinationPort {
            var networkDestinationPortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkDestinationPort)
            for numberfilterlist0 in networkDestinationPort {
                try networkDestinationPortContainer.encode(numberfilterlist0)
            }
        }
        if let networkDirection = networkDirection {
            var networkDirectionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkDirection)
            for stringfilterlist0 in networkDirection {
                try networkDirectionContainer.encode(stringfilterlist0)
            }
        }
        if let networkProtocol = networkProtocol {
            var networkProtocolContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkProtocol)
            for stringfilterlist0 in networkProtocol {
                try networkProtocolContainer.encode(stringfilterlist0)
            }
        }
        if let networkSourceDomain = networkSourceDomain {
            var networkSourceDomainContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkSourceDomain)
            for stringfilterlist0 in networkSourceDomain {
                try networkSourceDomainContainer.encode(stringfilterlist0)
            }
        }
        if let networkSourceIpV4 = networkSourceIpV4 {
            var networkSourceIpV4Container = encodeContainer.nestedUnkeyedContainer(forKey: .networkSourceIpV4)
            for ipfilterlist0 in networkSourceIpV4 {
                try networkSourceIpV4Container.encode(ipfilterlist0)
            }
        }
        if let networkSourceIpV6 = networkSourceIpV6 {
            var networkSourceIpV6Container = encodeContainer.nestedUnkeyedContainer(forKey: .networkSourceIpV6)
            for ipfilterlist0 in networkSourceIpV6 {
                try networkSourceIpV6Container.encode(ipfilterlist0)
            }
        }
        if let networkSourceMac = networkSourceMac {
            var networkSourceMacContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkSourceMac)
            for stringfilterlist0 in networkSourceMac {
                try networkSourceMacContainer.encode(stringfilterlist0)
            }
        }
        if let networkSourcePort = networkSourcePort {
            var networkSourcePortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkSourcePort)
            for numberfilterlist0 in networkSourcePort {
                try networkSourcePortContainer.encode(numberfilterlist0)
            }
        }
        if let noteText = noteText {
            var noteTextContainer = encodeContainer.nestedUnkeyedContainer(forKey: .noteText)
            for stringfilterlist0 in noteText {
                try noteTextContainer.encode(stringfilterlist0)
            }
        }
        if let noteUpdatedAt = noteUpdatedAt {
            var noteUpdatedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .noteUpdatedAt)
            for datefilterlist0 in noteUpdatedAt {
                try noteUpdatedAtContainer.encode(datefilterlist0)
            }
        }
        if let noteUpdatedBy = noteUpdatedBy {
            var noteUpdatedByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .noteUpdatedBy)
            for stringfilterlist0 in noteUpdatedBy {
                try noteUpdatedByContainer.encode(stringfilterlist0)
            }
        }
        if let processLaunchedAt = processLaunchedAt {
            var processLaunchedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processLaunchedAt)
            for datefilterlist0 in processLaunchedAt {
                try processLaunchedAtContainer.encode(datefilterlist0)
            }
        }
        if let processName = processName {
            var processNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processName)
            for stringfilterlist0 in processName {
                try processNameContainer.encode(stringfilterlist0)
            }
        }
        if let processParentPid = processParentPid {
            var processParentPidContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processParentPid)
            for numberfilterlist0 in processParentPid {
                try processParentPidContainer.encode(numberfilterlist0)
            }
        }
        if let processPath = processPath {
            var processPathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processPath)
            for stringfilterlist0 in processPath {
                try processPathContainer.encode(stringfilterlist0)
            }
        }
        if let processPid = processPid {
            var processPidContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processPid)
            for numberfilterlist0 in processPid {
                try processPidContainer.encode(numberfilterlist0)
            }
        }
        if let processTerminatedAt = processTerminatedAt {
            var processTerminatedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processTerminatedAt)
            for datefilterlist0 in processTerminatedAt {
                try processTerminatedAtContainer.encode(datefilterlist0)
            }
        }
        if let productArn = productArn {
            var productArnContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productArn)
            for stringfilterlist0 in productArn {
                try productArnContainer.encode(stringfilterlist0)
            }
        }
        if let productFields = productFields {
            var productFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productFields)
            for mapfilterlist0 in productFields {
                try productFieldsContainer.encode(mapfilterlist0)
            }
        }
        if let productName = productName {
            var productNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productName)
            for stringfilterlist0 in productName {
                try productNameContainer.encode(stringfilterlist0)
            }
        }
        if let recommendationText = recommendationText {
            var recommendationTextContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationText)
            for stringfilterlist0 in recommendationText {
                try recommendationTextContainer.encode(stringfilterlist0)
            }
        }
        if let recordState = recordState {
            var recordStateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordState)
            for stringfilterlist0 in recordState {
                try recordStateContainer.encode(stringfilterlist0)
            }
        }
        if let relatedFindingsId = relatedFindingsId {
            var relatedFindingsIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedFindingsId)
            for stringfilterlist0 in relatedFindingsId {
                try relatedFindingsIdContainer.encode(stringfilterlist0)
            }
        }
        if let relatedFindingsProductArn = relatedFindingsProductArn {
            var relatedFindingsProductArnContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedFindingsProductArn)
            for stringfilterlist0 in relatedFindingsProductArn {
                try relatedFindingsProductArnContainer.encode(stringfilterlist0)
            }
        }
        if let resourceAwsEc2InstanceIamInstanceProfileArn = resourceAwsEc2InstanceIamInstanceProfileArn {
            var resourceAwsEc2InstanceIamInstanceProfileArnContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsEc2InstanceIamInstanceProfileArn)
            for stringfilterlist0 in resourceAwsEc2InstanceIamInstanceProfileArn {
                try resourceAwsEc2InstanceIamInstanceProfileArnContainer.encode(stringfilterlist0)
            }
        }
        if let resourceAwsEc2InstanceImageId = resourceAwsEc2InstanceImageId {
            var resourceAwsEc2InstanceImageIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsEc2InstanceImageId)
            for stringfilterlist0 in resourceAwsEc2InstanceImageId {
                try resourceAwsEc2InstanceImageIdContainer.encode(stringfilterlist0)
            }
        }
        if let resourceAwsEc2InstanceIpV4Addresses = resourceAwsEc2InstanceIpV4Addresses {
            var resourceAwsEc2InstanceIpV4AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsEc2InstanceIpV4Addresses)
            for ipfilterlist0 in resourceAwsEc2InstanceIpV4Addresses {
                try resourceAwsEc2InstanceIpV4AddressesContainer.encode(ipfilterlist0)
            }
        }
        if let resourceAwsEc2InstanceIpV6Addresses = resourceAwsEc2InstanceIpV6Addresses {
            var resourceAwsEc2InstanceIpV6AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsEc2InstanceIpV6Addresses)
            for ipfilterlist0 in resourceAwsEc2InstanceIpV6Addresses {
                try resourceAwsEc2InstanceIpV6AddressesContainer.encode(ipfilterlist0)
            }
        }
        if let resourceAwsEc2InstanceKeyName = resourceAwsEc2InstanceKeyName {
            var resourceAwsEc2InstanceKeyNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsEc2InstanceKeyName)
            for stringfilterlist0 in resourceAwsEc2InstanceKeyName {
                try resourceAwsEc2InstanceKeyNameContainer.encode(stringfilterlist0)
            }
        }
        if let resourceAwsEc2InstanceLaunchedAt = resourceAwsEc2InstanceLaunchedAt {
            var resourceAwsEc2InstanceLaunchedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsEc2InstanceLaunchedAt)
            for datefilterlist0 in resourceAwsEc2InstanceLaunchedAt {
                try resourceAwsEc2InstanceLaunchedAtContainer.encode(datefilterlist0)
            }
        }
        if let resourceAwsEc2InstanceSubnetId = resourceAwsEc2InstanceSubnetId {
            var resourceAwsEc2InstanceSubnetIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsEc2InstanceSubnetId)
            for stringfilterlist0 in resourceAwsEc2InstanceSubnetId {
                try resourceAwsEc2InstanceSubnetIdContainer.encode(stringfilterlist0)
            }
        }
        if let resourceAwsEc2InstanceType = resourceAwsEc2InstanceType {
            var resourceAwsEc2InstanceTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsEc2InstanceType)
            for stringfilterlist0 in resourceAwsEc2InstanceType {
                try resourceAwsEc2InstanceTypeContainer.encode(stringfilterlist0)
            }
        }
        if let resourceAwsEc2InstanceVpcId = resourceAwsEc2InstanceVpcId {
            var resourceAwsEc2InstanceVpcIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsEc2InstanceVpcId)
            for stringfilterlist0 in resourceAwsEc2InstanceVpcId {
                try resourceAwsEc2InstanceVpcIdContainer.encode(stringfilterlist0)
            }
        }
        if let resourceAwsIamAccessKeyCreatedAt = resourceAwsIamAccessKeyCreatedAt {
            var resourceAwsIamAccessKeyCreatedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsIamAccessKeyCreatedAt)
            for datefilterlist0 in resourceAwsIamAccessKeyCreatedAt {
                try resourceAwsIamAccessKeyCreatedAtContainer.encode(datefilterlist0)
            }
        }
        if let resourceAwsIamAccessKeyStatus = resourceAwsIamAccessKeyStatus {
            var resourceAwsIamAccessKeyStatusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsIamAccessKeyStatus)
            for stringfilterlist0 in resourceAwsIamAccessKeyStatus {
                try resourceAwsIamAccessKeyStatusContainer.encode(stringfilterlist0)
            }
        }
        if let resourceAwsIamAccessKeyUserName = resourceAwsIamAccessKeyUserName {
            var resourceAwsIamAccessKeyUserNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsIamAccessKeyUserName)
            for stringfilterlist0 in resourceAwsIamAccessKeyUserName {
                try resourceAwsIamAccessKeyUserNameContainer.encode(stringfilterlist0)
            }
        }
        if let resourceAwsS3BucketOwnerId = resourceAwsS3BucketOwnerId {
            var resourceAwsS3BucketOwnerIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsS3BucketOwnerId)
            for stringfilterlist0 in resourceAwsS3BucketOwnerId {
                try resourceAwsS3BucketOwnerIdContainer.encode(stringfilterlist0)
            }
        }
        if let resourceAwsS3BucketOwnerName = resourceAwsS3BucketOwnerName {
            var resourceAwsS3BucketOwnerNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsS3BucketOwnerName)
            for stringfilterlist0 in resourceAwsS3BucketOwnerName {
                try resourceAwsS3BucketOwnerNameContainer.encode(stringfilterlist0)
            }
        }
        if let resourceContainerImageId = resourceContainerImageId {
            var resourceContainerImageIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceContainerImageId)
            for stringfilterlist0 in resourceContainerImageId {
                try resourceContainerImageIdContainer.encode(stringfilterlist0)
            }
        }
        if let resourceContainerImageName = resourceContainerImageName {
            var resourceContainerImageNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceContainerImageName)
            for stringfilterlist0 in resourceContainerImageName {
                try resourceContainerImageNameContainer.encode(stringfilterlist0)
            }
        }
        if let resourceContainerLaunchedAt = resourceContainerLaunchedAt {
            var resourceContainerLaunchedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceContainerLaunchedAt)
            for datefilterlist0 in resourceContainerLaunchedAt {
                try resourceContainerLaunchedAtContainer.encode(datefilterlist0)
            }
        }
        if let resourceContainerName = resourceContainerName {
            var resourceContainerNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceContainerName)
            for stringfilterlist0 in resourceContainerName {
                try resourceContainerNameContainer.encode(stringfilterlist0)
            }
        }
        if let resourceDetailsOther = resourceDetailsOther {
            var resourceDetailsOtherContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceDetailsOther)
            for mapfilterlist0 in resourceDetailsOther {
                try resourceDetailsOtherContainer.encode(mapfilterlist0)
            }
        }
        if let resourceId = resourceId {
            var resourceIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceId)
            for stringfilterlist0 in resourceId {
                try resourceIdContainer.encode(stringfilterlist0)
            }
        }
        if let resourcePartition = resourcePartition {
            var resourcePartitionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourcePartition)
            for stringfilterlist0 in resourcePartition {
                try resourcePartitionContainer.encode(stringfilterlist0)
            }
        }
        if let resourceRegion = resourceRegion {
            var resourceRegionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceRegion)
            for stringfilterlist0 in resourceRegion {
                try resourceRegionContainer.encode(stringfilterlist0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for mapfilterlist0 in resourceTags {
                try resourceTagsContainer.encode(mapfilterlist0)
            }
        }
        if let resourceType = resourceType {
            var resourceTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceType)
            for stringfilterlist0 in resourceType {
                try resourceTypeContainer.encode(stringfilterlist0)
            }
        }
        if let severityLabel = severityLabel {
            var severityLabelContainer = encodeContainer.nestedUnkeyedContainer(forKey: .severityLabel)
            for stringfilterlist0 in severityLabel {
                try severityLabelContainer.encode(stringfilterlist0)
            }
        }
        if let severityNormalized = severityNormalized {
            var severityNormalizedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .severityNormalized)
            for numberfilterlist0 in severityNormalized {
                try severityNormalizedContainer.encode(numberfilterlist0)
            }
        }
        if let severityProduct = severityProduct {
            var severityProductContainer = encodeContainer.nestedUnkeyedContainer(forKey: .severityProduct)
            for numberfilterlist0 in severityProduct {
                try severityProductContainer.encode(numberfilterlist0)
            }
        }
        if let sourceUrl = sourceUrl {
            var sourceUrlContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceUrl)
            for stringfilterlist0 in sourceUrl {
                try sourceUrlContainer.encode(stringfilterlist0)
            }
        }
        if let threatIntelIndicatorCategory = threatIntelIndicatorCategory {
            var threatIntelIndicatorCategoryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatIntelIndicatorCategory)
            for stringfilterlist0 in threatIntelIndicatorCategory {
                try threatIntelIndicatorCategoryContainer.encode(stringfilterlist0)
            }
        }
        if let threatIntelIndicatorLastObservedAt = threatIntelIndicatorLastObservedAt {
            var threatIntelIndicatorLastObservedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatIntelIndicatorLastObservedAt)
            for datefilterlist0 in threatIntelIndicatorLastObservedAt {
                try threatIntelIndicatorLastObservedAtContainer.encode(datefilterlist0)
            }
        }
        if let threatIntelIndicatorSource = threatIntelIndicatorSource {
            var threatIntelIndicatorSourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatIntelIndicatorSource)
            for stringfilterlist0 in threatIntelIndicatorSource {
                try threatIntelIndicatorSourceContainer.encode(stringfilterlist0)
            }
        }
        if let threatIntelIndicatorSourceUrl = threatIntelIndicatorSourceUrl {
            var threatIntelIndicatorSourceUrlContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatIntelIndicatorSourceUrl)
            for stringfilterlist0 in threatIntelIndicatorSourceUrl {
                try threatIntelIndicatorSourceUrlContainer.encode(stringfilterlist0)
            }
        }
        if let threatIntelIndicatorType = threatIntelIndicatorType {
            var threatIntelIndicatorTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatIntelIndicatorType)
            for stringfilterlist0 in threatIntelIndicatorType {
                try threatIntelIndicatorTypeContainer.encode(stringfilterlist0)
            }
        }
        if let threatIntelIndicatorValue = threatIntelIndicatorValue {
            var threatIntelIndicatorValueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatIntelIndicatorValue)
            for stringfilterlist0 in threatIntelIndicatorValue {
                try threatIntelIndicatorValueContainer.encode(stringfilterlist0)
            }
        }
        if let title = title {
            var titleContainer = encodeContainer.nestedUnkeyedContainer(forKey: .title)
            for stringfilterlist0 in title {
                try titleContainer.encode(stringfilterlist0)
            }
        }
        if let type = type {
            var typeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .type)
            for stringfilterlist0 in type {
                try typeContainer.encode(stringfilterlist0)
            }
        }
        if let updatedAt = updatedAt {
            var updatedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updatedAt)
            for datefilterlist0 in updatedAt {
                try updatedAtContainer.encode(datefilterlist0)
            }
        }
        if let userDefinedFields = userDefinedFields {
            var userDefinedFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userDefinedFields)
            for mapfilterlist0 in userDefinedFields {
                try userDefinedFieldsContainer.encode(mapfilterlist0)
            }
        }
        if let verificationState = verificationState {
            var verificationStateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .verificationState)
            for stringfilterlist0 in verificationState {
                try verificationStateContainer.encode(stringfilterlist0)
            }
        }
        if let workflowState = workflowState {
            var workflowStateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workflowState)
            for stringfilterlist0 in workflowState {
                try workflowStateContainer.encode(stringfilterlist0)
            }
        }
        if let workflowStatus = workflowStatus {
            var workflowStatusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workflowStatus)
            for stringfilterlist0 in workflowStatus {
                try workflowStatusContainer.encode(stringfilterlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productArnContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .productArn)
        var productArnDecoded0:[StringFilter]? = nil
        if let productArnContainer = productArnContainer {
            productArnDecoded0 = [StringFilter]()
            for structure0 in productArnContainer {
                if let structure0 = structure0 {
                    productArnDecoded0?.append(structure0)
                }
            }
        }
        productArn = productArnDecoded0
        let awsAccountIdContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .awsAccountId)
        var awsAccountIdDecoded0:[StringFilter]? = nil
        if let awsAccountIdContainer = awsAccountIdContainer {
            awsAccountIdDecoded0 = [StringFilter]()
            for structure0 in awsAccountIdContainer {
                if let structure0 = structure0 {
                    awsAccountIdDecoded0?.append(structure0)
                }
            }
        }
        awsAccountId = awsAccountIdDecoded0
        let idContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .id)
        var idDecoded0:[StringFilter]? = nil
        if let idContainer = idContainer {
            idDecoded0 = [StringFilter]()
            for structure0 in idContainer {
                if let structure0 = structure0 {
                    idDecoded0?.append(structure0)
                }
            }
        }
        id = idDecoded0
        let generatorIdContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .generatorId)
        var generatorIdDecoded0:[StringFilter]? = nil
        if let generatorIdContainer = generatorIdContainer {
            generatorIdDecoded0 = [StringFilter]()
            for structure0 in generatorIdContainer {
                if let structure0 = structure0 {
                    generatorIdDecoded0?.append(structure0)
                }
            }
        }
        generatorId = generatorIdDecoded0
        let typeContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .type)
        var typeDecoded0:[StringFilter]? = nil
        if let typeContainer = typeContainer {
            typeDecoded0 = [StringFilter]()
            for structure0 in typeContainer {
                if let structure0 = structure0 {
                    typeDecoded0?.append(structure0)
                }
            }
        }
        type = typeDecoded0
        let firstObservedAtContainer = try containerValues.decodeIfPresent([DateFilter?].self, forKey: .firstObservedAt)
        var firstObservedAtDecoded0:[DateFilter]? = nil
        if let firstObservedAtContainer = firstObservedAtContainer {
            firstObservedAtDecoded0 = [DateFilter]()
            for structure0 in firstObservedAtContainer {
                if let structure0 = structure0 {
                    firstObservedAtDecoded0?.append(structure0)
                }
            }
        }
        firstObservedAt = firstObservedAtDecoded0
        let lastObservedAtContainer = try containerValues.decodeIfPresent([DateFilter?].self, forKey: .lastObservedAt)
        var lastObservedAtDecoded0:[DateFilter]? = nil
        if let lastObservedAtContainer = lastObservedAtContainer {
            lastObservedAtDecoded0 = [DateFilter]()
            for structure0 in lastObservedAtContainer {
                if let structure0 = structure0 {
                    lastObservedAtDecoded0?.append(structure0)
                }
            }
        }
        lastObservedAt = lastObservedAtDecoded0
        let createdAtContainer = try containerValues.decodeIfPresent([DateFilter?].self, forKey: .createdAt)
        var createdAtDecoded0:[DateFilter]? = nil
        if let createdAtContainer = createdAtContainer {
            createdAtDecoded0 = [DateFilter]()
            for structure0 in createdAtContainer {
                if let structure0 = structure0 {
                    createdAtDecoded0?.append(structure0)
                }
            }
        }
        createdAt = createdAtDecoded0
        let updatedAtContainer = try containerValues.decodeIfPresent([DateFilter?].self, forKey: .updatedAt)
        var updatedAtDecoded0:[DateFilter]? = nil
        if let updatedAtContainer = updatedAtContainer {
            updatedAtDecoded0 = [DateFilter]()
            for structure0 in updatedAtContainer {
                if let structure0 = structure0 {
                    updatedAtDecoded0?.append(structure0)
                }
            }
        }
        updatedAt = updatedAtDecoded0
        let severityProductContainer = try containerValues.decodeIfPresent([NumberFilter?].self, forKey: .severityProduct)
        var severityProductDecoded0:[NumberFilter]? = nil
        if let severityProductContainer = severityProductContainer {
            severityProductDecoded0 = [NumberFilter]()
            for structure0 in severityProductContainer {
                if let structure0 = structure0 {
                    severityProductDecoded0?.append(structure0)
                }
            }
        }
        severityProduct = severityProductDecoded0
        let severityNormalizedContainer = try containerValues.decodeIfPresent([NumberFilter?].self, forKey: .severityNormalized)
        var severityNormalizedDecoded0:[NumberFilter]? = nil
        if let severityNormalizedContainer = severityNormalizedContainer {
            severityNormalizedDecoded0 = [NumberFilter]()
            for structure0 in severityNormalizedContainer {
                if let structure0 = structure0 {
                    severityNormalizedDecoded0?.append(structure0)
                }
            }
        }
        severityNormalized = severityNormalizedDecoded0
        let severityLabelContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .severityLabel)
        var severityLabelDecoded0:[StringFilter]? = nil
        if let severityLabelContainer = severityLabelContainer {
            severityLabelDecoded0 = [StringFilter]()
            for structure0 in severityLabelContainer {
                if let structure0 = structure0 {
                    severityLabelDecoded0?.append(structure0)
                }
            }
        }
        severityLabel = severityLabelDecoded0
        let confidenceContainer = try containerValues.decodeIfPresent([NumberFilter?].self, forKey: .confidence)
        var confidenceDecoded0:[NumberFilter]? = nil
        if let confidenceContainer = confidenceContainer {
            confidenceDecoded0 = [NumberFilter]()
            for structure0 in confidenceContainer {
                if let structure0 = structure0 {
                    confidenceDecoded0?.append(structure0)
                }
            }
        }
        confidence = confidenceDecoded0
        let criticalityContainer = try containerValues.decodeIfPresent([NumberFilter?].self, forKey: .criticality)
        var criticalityDecoded0:[NumberFilter]? = nil
        if let criticalityContainer = criticalityContainer {
            criticalityDecoded0 = [NumberFilter]()
            for structure0 in criticalityContainer {
                if let structure0 = structure0 {
                    criticalityDecoded0?.append(structure0)
                }
            }
        }
        criticality = criticalityDecoded0
        let titleContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .title)
        var titleDecoded0:[StringFilter]? = nil
        if let titleContainer = titleContainer {
            titleDecoded0 = [StringFilter]()
            for structure0 in titleContainer {
                if let structure0 = structure0 {
                    titleDecoded0?.append(structure0)
                }
            }
        }
        title = titleDecoded0
        let descriptionContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .description)
        var descriptionDecoded0:[StringFilter]? = nil
        if let descriptionContainer = descriptionContainer {
            descriptionDecoded0 = [StringFilter]()
            for structure0 in descriptionContainer {
                if let structure0 = structure0 {
                    descriptionDecoded0?.append(structure0)
                }
            }
        }
        description = descriptionDecoded0
        let recommendationTextContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .recommendationText)
        var recommendationTextDecoded0:[StringFilter]? = nil
        if let recommendationTextContainer = recommendationTextContainer {
            recommendationTextDecoded0 = [StringFilter]()
            for structure0 in recommendationTextContainer {
                if let structure0 = structure0 {
                    recommendationTextDecoded0?.append(structure0)
                }
            }
        }
        recommendationText = recommendationTextDecoded0
        let sourceUrlContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .sourceUrl)
        var sourceUrlDecoded0:[StringFilter]? = nil
        if let sourceUrlContainer = sourceUrlContainer {
            sourceUrlDecoded0 = [StringFilter]()
            for structure0 in sourceUrlContainer {
                if let structure0 = structure0 {
                    sourceUrlDecoded0?.append(structure0)
                }
            }
        }
        sourceUrl = sourceUrlDecoded0
        let productFieldsContainer = try containerValues.decodeIfPresent([MapFilter?].self, forKey: .productFields)
        var productFieldsDecoded0:[MapFilter]? = nil
        if let productFieldsContainer = productFieldsContainer {
            productFieldsDecoded0 = [MapFilter]()
            for structure0 in productFieldsContainer {
                if let structure0 = structure0 {
                    productFieldsDecoded0?.append(structure0)
                }
            }
        }
        productFields = productFieldsDecoded0
        let productNameContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .productName)
        var productNameDecoded0:[StringFilter]? = nil
        if let productNameContainer = productNameContainer {
            productNameDecoded0 = [StringFilter]()
            for structure0 in productNameContainer {
                if let structure0 = structure0 {
                    productNameDecoded0?.append(structure0)
                }
            }
        }
        productName = productNameDecoded0
        let companyNameContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .companyName)
        var companyNameDecoded0:[StringFilter]? = nil
        if let companyNameContainer = companyNameContainer {
            companyNameDecoded0 = [StringFilter]()
            for structure0 in companyNameContainer {
                if let structure0 = structure0 {
                    companyNameDecoded0?.append(structure0)
                }
            }
        }
        companyName = companyNameDecoded0
        let userDefinedFieldsContainer = try containerValues.decodeIfPresent([MapFilter?].self, forKey: .userDefinedFields)
        var userDefinedFieldsDecoded0:[MapFilter]? = nil
        if let userDefinedFieldsContainer = userDefinedFieldsContainer {
            userDefinedFieldsDecoded0 = [MapFilter]()
            for structure0 in userDefinedFieldsContainer {
                if let structure0 = structure0 {
                    userDefinedFieldsDecoded0?.append(structure0)
                }
            }
        }
        userDefinedFields = userDefinedFieldsDecoded0
        let malwareNameContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .malwareName)
        var malwareNameDecoded0:[StringFilter]? = nil
        if let malwareNameContainer = malwareNameContainer {
            malwareNameDecoded0 = [StringFilter]()
            for structure0 in malwareNameContainer {
                if let structure0 = structure0 {
                    malwareNameDecoded0?.append(structure0)
                }
            }
        }
        malwareName = malwareNameDecoded0
        let malwareTypeContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .malwareType)
        var malwareTypeDecoded0:[StringFilter]? = nil
        if let malwareTypeContainer = malwareTypeContainer {
            malwareTypeDecoded0 = [StringFilter]()
            for structure0 in malwareTypeContainer {
                if let structure0 = structure0 {
                    malwareTypeDecoded0?.append(structure0)
                }
            }
        }
        malwareType = malwareTypeDecoded0
        let malwarePathContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .malwarePath)
        var malwarePathDecoded0:[StringFilter]? = nil
        if let malwarePathContainer = malwarePathContainer {
            malwarePathDecoded0 = [StringFilter]()
            for structure0 in malwarePathContainer {
                if let structure0 = structure0 {
                    malwarePathDecoded0?.append(structure0)
                }
            }
        }
        malwarePath = malwarePathDecoded0
        let malwareStateContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .malwareState)
        var malwareStateDecoded0:[StringFilter]? = nil
        if let malwareStateContainer = malwareStateContainer {
            malwareStateDecoded0 = [StringFilter]()
            for structure0 in malwareStateContainer {
                if let structure0 = structure0 {
                    malwareStateDecoded0?.append(structure0)
                }
            }
        }
        malwareState = malwareStateDecoded0
        let networkDirectionContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .networkDirection)
        var networkDirectionDecoded0:[StringFilter]? = nil
        if let networkDirectionContainer = networkDirectionContainer {
            networkDirectionDecoded0 = [StringFilter]()
            for structure0 in networkDirectionContainer {
                if let structure0 = structure0 {
                    networkDirectionDecoded0?.append(structure0)
                }
            }
        }
        networkDirection = networkDirectionDecoded0
        let networkProtocolContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .networkProtocol)
        var networkProtocolDecoded0:[StringFilter]? = nil
        if let networkProtocolContainer = networkProtocolContainer {
            networkProtocolDecoded0 = [StringFilter]()
            for structure0 in networkProtocolContainer {
                if let structure0 = structure0 {
                    networkProtocolDecoded0?.append(structure0)
                }
            }
        }
        networkProtocol = networkProtocolDecoded0
        let networkSourceIpV4Container = try containerValues.decodeIfPresent([IpFilter?].self, forKey: .networkSourceIpV4)
        var networkSourceIpV4Decoded0:[IpFilter]? = nil
        if let networkSourceIpV4Container = networkSourceIpV4Container {
            networkSourceIpV4Decoded0 = [IpFilter]()
            for structure0 in networkSourceIpV4Container {
                if let structure0 = structure0 {
                    networkSourceIpV4Decoded0?.append(structure0)
                }
            }
        }
        networkSourceIpV4 = networkSourceIpV4Decoded0
        let networkSourceIpV6Container = try containerValues.decodeIfPresent([IpFilter?].self, forKey: .networkSourceIpV6)
        var networkSourceIpV6Decoded0:[IpFilter]? = nil
        if let networkSourceIpV6Container = networkSourceIpV6Container {
            networkSourceIpV6Decoded0 = [IpFilter]()
            for structure0 in networkSourceIpV6Container {
                if let structure0 = structure0 {
                    networkSourceIpV6Decoded0?.append(structure0)
                }
            }
        }
        networkSourceIpV6 = networkSourceIpV6Decoded0
        let networkSourcePortContainer = try containerValues.decodeIfPresent([NumberFilter?].self, forKey: .networkSourcePort)
        var networkSourcePortDecoded0:[NumberFilter]? = nil
        if let networkSourcePortContainer = networkSourcePortContainer {
            networkSourcePortDecoded0 = [NumberFilter]()
            for structure0 in networkSourcePortContainer {
                if let structure0 = structure0 {
                    networkSourcePortDecoded0?.append(structure0)
                }
            }
        }
        networkSourcePort = networkSourcePortDecoded0
        let networkSourceDomainContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .networkSourceDomain)
        var networkSourceDomainDecoded0:[StringFilter]? = nil
        if let networkSourceDomainContainer = networkSourceDomainContainer {
            networkSourceDomainDecoded0 = [StringFilter]()
            for structure0 in networkSourceDomainContainer {
                if let structure0 = structure0 {
                    networkSourceDomainDecoded0?.append(structure0)
                }
            }
        }
        networkSourceDomain = networkSourceDomainDecoded0
        let networkSourceMacContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .networkSourceMac)
        var networkSourceMacDecoded0:[StringFilter]? = nil
        if let networkSourceMacContainer = networkSourceMacContainer {
            networkSourceMacDecoded0 = [StringFilter]()
            for structure0 in networkSourceMacContainer {
                if let structure0 = structure0 {
                    networkSourceMacDecoded0?.append(structure0)
                }
            }
        }
        networkSourceMac = networkSourceMacDecoded0
        let networkDestinationIpV4Container = try containerValues.decodeIfPresent([IpFilter?].self, forKey: .networkDestinationIpV4)
        var networkDestinationIpV4Decoded0:[IpFilter]? = nil
        if let networkDestinationIpV4Container = networkDestinationIpV4Container {
            networkDestinationIpV4Decoded0 = [IpFilter]()
            for structure0 in networkDestinationIpV4Container {
                if let structure0 = structure0 {
                    networkDestinationIpV4Decoded0?.append(structure0)
                }
            }
        }
        networkDestinationIpV4 = networkDestinationIpV4Decoded0
        let networkDestinationIpV6Container = try containerValues.decodeIfPresent([IpFilter?].self, forKey: .networkDestinationIpV6)
        var networkDestinationIpV6Decoded0:[IpFilter]? = nil
        if let networkDestinationIpV6Container = networkDestinationIpV6Container {
            networkDestinationIpV6Decoded0 = [IpFilter]()
            for structure0 in networkDestinationIpV6Container {
                if let structure0 = structure0 {
                    networkDestinationIpV6Decoded0?.append(structure0)
                }
            }
        }
        networkDestinationIpV6 = networkDestinationIpV6Decoded0
        let networkDestinationPortContainer = try containerValues.decodeIfPresent([NumberFilter?].self, forKey: .networkDestinationPort)
        var networkDestinationPortDecoded0:[NumberFilter]? = nil
        if let networkDestinationPortContainer = networkDestinationPortContainer {
            networkDestinationPortDecoded0 = [NumberFilter]()
            for structure0 in networkDestinationPortContainer {
                if let structure0 = structure0 {
                    networkDestinationPortDecoded0?.append(structure0)
                }
            }
        }
        networkDestinationPort = networkDestinationPortDecoded0
        let networkDestinationDomainContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .networkDestinationDomain)
        var networkDestinationDomainDecoded0:[StringFilter]? = nil
        if let networkDestinationDomainContainer = networkDestinationDomainContainer {
            networkDestinationDomainDecoded0 = [StringFilter]()
            for structure0 in networkDestinationDomainContainer {
                if let structure0 = structure0 {
                    networkDestinationDomainDecoded0?.append(structure0)
                }
            }
        }
        networkDestinationDomain = networkDestinationDomainDecoded0
        let processNameContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .processName)
        var processNameDecoded0:[StringFilter]? = nil
        if let processNameContainer = processNameContainer {
            processNameDecoded0 = [StringFilter]()
            for structure0 in processNameContainer {
                if let structure0 = structure0 {
                    processNameDecoded0?.append(structure0)
                }
            }
        }
        processName = processNameDecoded0
        let processPathContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .processPath)
        var processPathDecoded0:[StringFilter]? = nil
        if let processPathContainer = processPathContainer {
            processPathDecoded0 = [StringFilter]()
            for structure0 in processPathContainer {
                if let structure0 = structure0 {
                    processPathDecoded0?.append(structure0)
                }
            }
        }
        processPath = processPathDecoded0
        let processPidContainer = try containerValues.decodeIfPresent([NumberFilter?].self, forKey: .processPid)
        var processPidDecoded0:[NumberFilter]? = nil
        if let processPidContainer = processPidContainer {
            processPidDecoded0 = [NumberFilter]()
            for structure0 in processPidContainer {
                if let structure0 = structure0 {
                    processPidDecoded0?.append(structure0)
                }
            }
        }
        processPid = processPidDecoded0
        let processParentPidContainer = try containerValues.decodeIfPresent([NumberFilter?].self, forKey: .processParentPid)
        var processParentPidDecoded0:[NumberFilter]? = nil
        if let processParentPidContainer = processParentPidContainer {
            processParentPidDecoded0 = [NumberFilter]()
            for structure0 in processParentPidContainer {
                if let structure0 = structure0 {
                    processParentPidDecoded0?.append(structure0)
                }
            }
        }
        processParentPid = processParentPidDecoded0
        let processLaunchedAtContainer = try containerValues.decodeIfPresent([DateFilter?].self, forKey: .processLaunchedAt)
        var processLaunchedAtDecoded0:[DateFilter]? = nil
        if let processLaunchedAtContainer = processLaunchedAtContainer {
            processLaunchedAtDecoded0 = [DateFilter]()
            for structure0 in processLaunchedAtContainer {
                if let structure0 = structure0 {
                    processLaunchedAtDecoded0?.append(structure0)
                }
            }
        }
        processLaunchedAt = processLaunchedAtDecoded0
        let processTerminatedAtContainer = try containerValues.decodeIfPresent([DateFilter?].self, forKey: .processTerminatedAt)
        var processTerminatedAtDecoded0:[DateFilter]? = nil
        if let processTerminatedAtContainer = processTerminatedAtContainer {
            processTerminatedAtDecoded0 = [DateFilter]()
            for structure0 in processTerminatedAtContainer {
                if let structure0 = structure0 {
                    processTerminatedAtDecoded0?.append(structure0)
                }
            }
        }
        processTerminatedAt = processTerminatedAtDecoded0
        let threatIntelIndicatorTypeContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .threatIntelIndicatorType)
        var threatIntelIndicatorTypeDecoded0:[StringFilter]? = nil
        if let threatIntelIndicatorTypeContainer = threatIntelIndicatorTypeContainer {
            threatIntelIndicatorTypeDecoded0 = [StringFilter]()
            for structure0 in threatIntelIndicatorTypeContainer {
                if let structure0 = structure0 {
                    threatIntelIndicatorTypeDecoded0?.append(structure0)
                }
            }
        }
        threatIntelIndicatorType = threatIntelIndicatorTypeDecoded0
        let threatIntelIndicatorValueContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .threatIntelIndicatorValue)
        var threatIntelIndicatorValueDecoded0:[StringFilter]? = nil
        if let threatIntelIndicatorValueContainer = threatIntelIndicatorValueContainer {
            threatIntelIndicatorValueDecoded0 = [StringFilter]()
            for structure0 in threatIntelIndicatorValueContainer {
                if let structure0 = structure0 {
                    threatIntelIndicatorValueDecoded0?.append(structure0)
                }
            }
        }
        threatIntelIndicatorValue = threatIntelIndicatorValueDecoded0
        let threatIntelIndicatorCategoryContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .threatIntelIndicatorCategory)
        var threatIntelIndicatorCategoryDecoded0:[StringFilter]? = nil
        if let threatIntelIndicatorCategoryContainer = threatIntelIndicatorCategoryContainer {
            threatIntelIndicatorCategoryDecoded0 = [StringFilter]()
            for structure0 in threatIntelIndicatorCategoryContainer {
                if let structure0 = structure0 {
                    threatIntelIndicatorCategoryDecoded0?.append(structure0)
                }
            }
        }
        threatIntelIndicatorCategory = threatIntelIndicatorCategoryDecoded0
        let threatIntelIndicatorLastObservedAtContainer = try containerValues.decodeIfPresent([DateFilter?].self, forKey: .threatIntelIndicatorLastObservedAt)
        var threatIntelIndicatorLastObservedAtDecoded0:[DateFilter]? = nil
        if let threatIntelIndicatorLastObservedAtContainer = threatIntelIndicatorLastObservedAtContainer {
            threatIntelIndicatorLastObservedAtDecoded0 = [DateFilter]()
            for structure0 in threatIntelIndicatorLastObservedAtContainer {
                if let structure0 = structure0 {
                    threatIntelIndicatorLastObservedAtDecoded0?.append(structure0)
                }
            }
        }
        threatIntelIndicatorLastObservedAt = threatIntelIndicatorLastObservedAtDecoded0
        let threatIntelIndicatorSourceContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .threatIntelIndicatorSource)
        var threatIntelIndicatorSourceDecoded0:[StringFilter]? = nil
        if let threatIntelIndicatorSourceContainer = threatIntelIndicatorSourceContainer {
            threatIntelIndicatorSourceDecoded0 = [StringFilter]()
            for structure0 in threatIntelIndicatorSourceContainer {
                if let structure0 = structure0 {
                    threatIntelIndicatorSourceDecoded0?.append(structure0)
                }
            }
        }
        threatIntelIndicatorSource = threatIntelIndicatorSourceDecoded0
        let threatIntelIndicatorSourceUrlContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .threatIntelIndicatorSourceUrl)
        var threatIntelIndicatorSourceUrlDecoded0:[StringFilter]? = nil
        if let threatIntelIndicatorSourceUrlContainer = threatIntelIndicatorSourceUrlContainer {
            threatIntelIndicatorSourceUrlDecoded0 = [StringFilter]()
            for structure0 in threatIntelIndicatorSourceUrlContainer {
                if let structure0 = structure0 {
                    threatIntelIndicatorSourceUrlDecoded0?.append(structure0)
                }
            }
        }
        threatIntelIndicatorSourceUrl = threatIntelIndicatorSourceUrlDecoded0
        let resourceTypeContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .resourceType)
        var resourceTypeDecoded0:[StringFilter]? = nil
        if let resourceTypeContainer = resourceTypeContainer {
            resourceTypeDecoded0 = [StringFilter]()
            for structure0 in resourceTypeContainer {
                if let structure0 = structure0 {
                    resourceTypeDecoded0?.append(structure0)
                }
            }
        }
        resourceType = resourceTypeDecoded0
        let resourceIdContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .resourceId)
        var resourceIdDecoded0:[StringFilter]? = nil
        if let resourceIdContainer = resourceIdContainer {
            resourceIdDecoded0 = [StringFilter]()
            for structure0 in resourceIdContainer {
                if let structure0 = structure0 {
                    resourceIdDecoded0?.append(structure0)
                }
            }
        }
        resourceId = resourceIdDecoded0
        let resourcePartitionContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .resourcePartition)
        var resourcePartitionDecoded0:[StringFilter]? = nil
        if let resourcePartitionContainer = resourcePartitionContainer {
            resourcePartitionDecoded0 = [StringFilter]()
            for structure0 in resourcePartitionContainer {
                if let structure0 = structure0 {
                    resourcePartitionDecoded0?.append(structure0)
                }
            }
        }
        resourcePartition = resourcePartitionDecoded0
        let resourceRegionContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .resourceRegion)
        var resourceRegionDecoded0:[StringFilter]? = nil
        if let resourceRegionContainer = resourceRegionContainer {
            resourceRegionDecoded0 = [StringFilter]()
            for structure0 in resourceRegionContainer {
                if let structure0 = structure0 {
                    resourceRegionDecoded0?.append(structure0)
                }
            }
        }
        resourceRegion = resourceRegionDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([MapFilter?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[MapFilter]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [MapFilter]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let resourceAwsEc2InstanceTypeContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .resourceAwsEc2InstanceType)
        var resourceAwsEc2InstanceTypeDecoded0:[StringFilter]? = nil
        if let resourceAwsEc2InstanceTypeContainer = resourceAwsEc2InstanceTypeContainer {
            resourceAwsEc2InstanceTypeDecoded0 = [StringFilter]()
            for structure0 in resourceAwsEc2InstanceTypeContainer {
                if let structure0 = structure0 {
                    resourceAwsEc2InstanceTypeDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsEc2InstanceType = resourceAwsEc2InstanceTypeDecoded0
        let resourceAwsEc2InstanceImageIdContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .resourceAwsEc2InstanceImageId)
        var resourceAwsEc2InstanceImageIdDecoded0:[StringFilter]? = nil
        if let resourceAwsEc2InstanceImageIdContainer = resourceAwsEc2InstanceImageIdContainer {
            resourceAwsEc2InstanceImageIdDecoded0 = [StringFilter]()
            for structure0 in resourceAwsEc2InstanceImageIdContainer {
                if let structure0 = structure0 {
                    resourceAwsEc2InstanceImageIdDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsEc2InstanceImageId = resourceAwsEc2InstanceImageIdDecoded0
        let resourceAwsEc2InstanceIpV4AddressesContainer = try containerValues.decodeIfPresent([IpFilter?].self, forKey: .resourceAwsEc2InstanceIpV4Addresses)
        var resourceAwsEc2InstanceIpV4AddressesDecoded0:[IpFilter]? = nil
        if let resourceAwsEc2InstanceIpV4AddressesContainer = resourceAwsEc2InstanceIpV4AddressesContainer {
            resourceAwsEc2InstanceIpV4AddressesDecoded0 = [IpFilter]()
            for structure0 in resourceAwsEc2InstanceIpV4AddressesContainer {
                if let structure0 = structure0 {
                    resourceAwsEc2InstanceIpV4AddressesDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsEc2InstanceIpV4Addresses = resourceAwsEc2InstanceIpV4AddressesDecoded0
        let resourceAwsEc2InstanceIpV6AddressesContainer = try containerValues.decodeIfPresent([IpFilter?].self, forKey: .resourceAwsEc2InstanceIpV6Addresses)
        var resourceAwsEc2InstanceIpV6AddressesDecoded0:[IpFilter]? = nil
        if let resourceAwsEc2InstanceIpV6AddressesContainer = resourceAwsEc2InstanceIpV6AddressesContainer {
            resourceAwsEc2InstanceIpV6AddressesDecoded0 = [IpFilter]()
            for structure0 in resourceAwsEc2InstanceIpV6AddressesContainer {
                if let structure0 = structure0 {
                    resourceAwsEc2InstanceIpV6AddressesDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsEc2InstanceIpV6Addresses = resourceAwsEc2InstanceIpV6AddressesDecoded0
        let resourceAwsEc2InstanceKeyNameContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .resourceAwsEc2InstanceKeyName)
        var resourceAwsEc2InstanceKeyNameDecoded0:[StringFilter]? = nil
        if let resourceAwsEc2InstanceKeyNameContainer = resourceAwsEc2InstanceKeyNameContainer {
            resourceAwsEc2InstanceKeyNameDecoded0 = [StringFilter]()
            for structure0 in resourceAwsEc2InstanceKeyNameContainer {
                if let structure0 = structure0 {
                    resourceAwsEc2InstanceKeyNameDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsEc2InstanceKeyName = resourceAwsEc2InstanceKeyNameDecoded0
        let resourceAwsEc2InstanceIamInstanceProfileArnContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .resourceAwsEc2InstanceIamInstanceProfileArn)
        var resourceAwsEc2InstanceIamInstanceProfileArnDecoded0:[StringFilter]? = nil
        if let resourceAwsEc2InstanceIamInstanceProfileArnContainer = resourceAwsEc2InstanceIamInstanceProfileArnContainer {
            resourceAwsEc2InstanceIamInstanceProfileArnDecoded0 = [StringFilter]()
            for structure0 in resourceAwsEc2InstanceIamInstanceProfileArnContainer {
                if let structure0 = structure0 {
                    resourceAwsEc2InstanceIamInstanceProfileArnDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsEc2InstanceIamInstanceProfileArn = resourceAwsEc2InstanceIamInstanceProfileArnDecoded0
        let resourceAwsEc2InstanceVpcIdContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .resourceAwsEc2InstanceVpcId)
        var resourceAwsEc2InstanceVpcIdDecoded0:[StringFilter]? = nil
        if let resourceAwsEc2InstanceVpcIdContainer = resourceAwsEc2InstanceVpcIdContainer {
            resourceAwsEc2InstanceVpcIdDecoded0 = [StringFilter]()
            for structure0 in resourceAwsEc2InstanceVpcIdContainer {
                if let structure0 = structure0 {
                    resourceAwsEc2InstanceVpcIdDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsEc2InstanceVpcId = resourceAwsEc2InstanceVpcIdDecoded0
        let resourceAwsEc2InstanceSubnetIdContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .resourceAwsEc2InstanceSubnetId)
        var resourceAwsEc2InstanceSubnetIdDecoded0:[StringFilter]? = nil
        if let resourceAwsEc2InstanceSubnetIdContainer = resourceAwsEc2InstanceSubnetIdContainer {
            resourceAwsEc2InstanceSubnetIdDecoded0 = [StringFilter]()
            for structure0 in resourceAwsEc2InstanceSubnetIdContainer {
                if let structure0 = structure0 {
                    resourceAwsEc2InstanceSubnetIdDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsEc2InstanceSubnetId = resourceAwsEc2InstanceSubnetIdDecoded0
        let resourceAwsEc2InstanceLaunchedAtContainer = try containerValues.decodeIfPresent([DateFilter?].self, forKey: .resourceAwsEc2InstanceLaunchedAt)
        var resourceAwsEc2InstanceLaunchedAtDecoded0:[DateFilter]? = nil
        if let resourceAwsEc2InstanceLaunchedAtContainer = resourceAwsEc2InstanceLaunchedAtContainer {
            resourceAwsEc2InstanceLaunchedAtDecoded0 = [DateFilter]()
            for structure0 in resourceAwsEc2InstanceLaunchedAtContainer {
                if let structure0 = structure0 {
                    resourceAwsEc2InstanceLaunchedAtDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsEc2InstanceLaunchedAt = resourceAwsEc2InstanceLaunchedAtDecoded0
        let resourceAwsS3BucketOwnerIdContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .resourceAwsS3BucketOwnerId)
        var resourceAwsS3BucketOwnerIdDecoded0:[StringFilter]? = nil
        if let resourceAwsS3BucketOwnerIdContainer = resourceAwsS3BucketOwnerIdContainer {
            resourceAwsS3BucketOwnerIdDecoded0 = [StringFilter]()
            for structure0 in resourceAwsS3BucketOwnerIdContainer {
                if let structure0 = structure0 {
                    resourceAwsS3BucketOwnerIdDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsS3BucketOwnerId = resourceAwsS3BucketOwnerIdDecoded0
        let resourceAwsS3BucketOwnerNameContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .resourceAwsS3BucketOwnerName)
        var resourceAwsS3BucketOwnerNameDecoded0:[StringFilter]? = nil
        if let resourceAwsS3BucketOwnerNameContainer = resourceAwsS3BucketOwnerNameContainer {
            resourceAwsS3BucketOwnerNameDecoded0 = [StringFilter]()
            for structure0 in resourceAwsS3BucketOwnerNameContainer {
                if let structure0 = structure0 {
                    resourceAwsS3BucketOwnerNameDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsS3BucketOwnerName = resourceAwsS3BucketOwnerNameDecoded0
        let resourceAwsIamAccessKeyUserNameContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .resourceAwsIamAccessKeyUserName)
        var resourceAwsIamAccessKeyUserNameDecoded0:[StringFilter]? = nil
        if let resourceAwsIamAccessKeyUserNameContainer = resourceAwsIamAccessKeyUserNameContainer {
            resourceAwsIamAccessKeyUserNameDecoded0 = [StringFilter]()
            for structure0 in resourceAwsIamAccessKeyUserNameContainer {
                if let structure0 = structure0 {
                    resourceAwsIamAccessKeyUserNameDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsIamAccessKeyUserName = resourceAwsIamAccessKeyUserNameDecoded0
        let resourceAwsIamAccessKeyStatusContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .resourceAwsIamAccessKeyStatus)
        var resourceAwsIamAccessKeyStatusDecoded0:[StringFilter]? = nil
        if let resourceAwsIamAccessKeyStatusContainer = resourceAwsIamAccessKeyStatusContainer {
            resourceAwsIamAccessKeyStatusDecoded0 = [StringFilter]()
            for structure0 in resourceAwsIamAccessKeyStatusContainer {
                if let structure0 = structure0 {
                    resourceAwsIamAccessKeyStatusDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsIamAccessKeyStatus = resourceAwsIamAccessKeyStatusDecoded0
        let resourceAwsIamAccessKeyCreatedAtContainer = try containerValues.decodeIfPresent([DateFilter?].self, forKey: .resourceAwsIamAccessKeyCreatedAt)
        var resourceAwsIamAccessKeyCreatedAtDecoded0:[DateFilter]? = nil
        if let resourceAwsIamAccessKeyCreatedAtContainer = resourceAwsIamAccessKeyCreatedAtContainer {
            resourceAwsIamAccessKeyCreatedAtDecoded0 = [DateFilter]()
            for structure0 in resourceAwsIamAccessKeyCreatedAtContainer {
                if let structure0 = structure0 {
                    resourceAwsIamAccessKeyCreatedAtDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsIamAccessKeyCreatedAt = resourceAwsIamAccessKeyCreatedAtDecoded0
        let resourceContainerNameContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .resourceContainerName)
        var resourceContainerNameDecoded0:[StringFilter]? = nil
        if let resourceContainerNameContainer = resourceContainerNameContainer {
            resourceContainerNameDecoded0 = [StringFilter]()
            for structure0 in resourceContainerNameContainer {
                if let structure0 = structure0 {
                    resourceContainerNameDecoded0?.append(structure0)
                }
            }
        }
        resourceContainerName = resourceContainerNameDecoded0
        let resourceContainerImageIdContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .resourceContainerImageId)
        var resourceContainerImageIdDecoded0:[StringFilter]? = nil
        if let resourceContainerImageIdContainer = resourceContainerImageIdContainer {
            resourceContainerImageIdDecoded0 = [StringFilter]()
            for structure0 in resourceContainerImageIdContainer {
                if let structure0 = structure0 {
                    resourceContainerImageIdDecoded0?.append(structure0)
                }
            }
        }
        resourceContainerImageId = resourceContainerImageIdDecoded0
        let resourceContainerImageNameContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .resourceContainerImageName)
        var resourceContainerImageNameDecoded0:[StringFilter]? = nil
        if let resourceContainerImageNameContainer = resourceContainerImageNameContainer {
            resourceContainerImageNameDecoded0 = [StringFilter]()
            for structure0 in resourceContainerImageNameContainer {
                if let structure0 = structure0 {
                    resourceContainerImageNameDecoded0?.append(structure0)
                }
            }
        }
        resourceContainerImageName = resourceContainerImageNameDecoded0
        let resourceContainerLaunchedAtContainer = try containerValues.decodeIfPresent([DateFilter?].self, forKey: .resourceContainerLaunchedAt)
        var resourceContainerLaunchedAtDecoded0:[DateFilter]? = nil
        if let resourceContainerLaunchedAtContainer = resourceContainerLaunchedAtContainer {
            resourceContainerLaunchedAtDecoded0 = [DateFilter]()
            for structure0 in resourceContainerLaunchedAtContainer {
                if let structure0 = structure0 {
                    resourceContainerLaunchedAtDecoded0?.append(structure0)
                }
            }
        }
        resourceContainerLaunchedAt = resourceContainerLaunchedAtDecoded0
        let resourceDetailsOtherContainer = try containerValues.decodeIfPresent([MapFilter?].self, forKey: .resourceDetailsOther)
        var resourceDetailsOtherDecoded0:[MapFilter]? = nil
        if let resourceDetailsOtherContainer = resourceDetailsOtherContainer {
            resourceDetailsOtherDecoded0 = [MapFilter]()
            for structure0 in resourceDetailsOtherContainer {
                if let structure0 = structure0 {
                    resourceDetailsOtherDecoded0?.append(structure0)
                }
            }
        }
        resourceDetailsOther = resourceDetailsOtherDecoded0
        let complianceStatusContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .complianceStatus)
        var complianceStatusDecoded0:[StringFilter]? = nil
        if let complianceStatusContainer = complianceStatusContainer {
            complianceStatusDecoded0 = [StringFilter]()
            for structure0 in complianceStatusContainer {
                if let structure0 = structure0 {
                    complianceStatusDecoded0?.append(structure0)
                }
            }
        }
        complianceStatus = complianceStatusDecoded0
        let verificationStateContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .verificationState)
        var verificationStateDecoded0:[StringFilter]? = nil
        if let verificationStateContainer = verificationStateContainer {
            verificationStateDecoded0 = [StringFilter]()
            for structure0 in verificationStateContainer {
                if let structure0 = structure0 {
                    verificationStateDecoded0?.append(structure0)
                }
            }
        }
        verificationState = verificationStateDecoded0
        let workflowStateContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .workflowState)
        var workflowStateDecoded0:[StringFilter]? = nil
        if let workflowStateContainer = workflowStateContainer {
            workflowStateDecoded0 = [StringFilter]()
            for structure0 in workflowStateContainer {
                if let structure0 = structure0 {
                    workflowStateDecoded0?.append(structure0)
                }
            }
        }
        workflowState = workflowStateDecoded0
        let workflowStatusContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .workflowStatus)
        var workflowStatusDecoded0:[StringFilter]? = nil
        if let workflowStatusContainer = workflowStatusContainer {
            workflowStatusDecoded0 = [StringFilter]()
            for structure0 in workflowStatusContainer {
                if let structure0 = structure0 {
                    workflowStatusDecoded0?.append(structure0)
                }
            }
        }
        workflowStatus = workflowStatusDecoded0
        let recordStateContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .recordState)
        var recordStateDecoded0:[StringFilter]? = nil
        if let recordStateContainer = recordStateContainer {
            recordStateDecoded0 = [StringFilter]()
            for structure0 in recordStateContainer {
                if let structure0 = structure0 {
                    recordStateDecoded0?.append(structure0)
                }
            }
        }
        recordState = recordStateDecoded0
        let relatedFindingsProductArnContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .relatedFindingsProductArn)
        var relatedFindingsProductArnDecoded0:[StringFilter]? = nil
        if let relatedFindingsProductArnContainer = relatedFindingsProductArnContainer {
            relatedFindingsProductArnDecoded0 = [StringFilter]()
            for structure0 in relatedFindingsProductArnContainer {
                if let structure0 = structure0 {
                    relatedFindingsProductArnDecoded0?.append(structure0)
                }
            }
        }
        relatedFindingsProductArn = relatedFindingsProductArnDecoded0
        let relatedFindingsIdContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .relatedFindingsId)
        var relatedFindingsIdDecoded0:[StringFilter]? = nil
        if let relatedFindingsIdContainer = relatedFindingsIdContainer {
            relatedFindingsIdDecoded0 = [StringFilter]()
            for structure0 in relatedFindingsIdContainer {
                if let structure0 = structure0 {
                    relatedFindingsIdDecoded0?.append(structure0)
                }
            }
        }
        relatedFindingsId = relatedFindingsIdDecoded0
        let noteTextContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .noteText)
        var noteTextDecoded0:[StringFilter]? = nil
        if let noteTextContainer = noteTextContainer {
            noteTextDecoded0 = [StringFilter]()
            for structure0 in noteTextContainer {
                if let structure0 = structure0 {
                    noteTextDecoded0?.append(structure0)
                }
            }
        }
        noteText = noteTextDecoded0
        let noteUpdatedAtContainer = try containerValues.decodeIfPresent([DateFilter?].self, forKey: .noteUpdatedAt)
        var noteUpdatedAtDecoded0:[DateFilter]? = nil
        if let noteUpdatedAtContainer = noteUpdatedAtContainer {
            noteUpdatedAtDecoded0 = [DateFilter]()
            for structure0 in noteUpdatedAtContainer {
                if let structure0 = structure0 {
                    noteUpdatedAtDecoded0?.append(structure0)
                }
            }
        }
        noteUpdatedAt = noteUpdatedAtDecoded0
        let noteUpdatedByContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .noteUpdatedBy)
        var noteUpdatedByDecoded0:[StringFilter]? = nil
        if let noteUpdatedByContainer = noteUpdatedByContainer {
            noteUpdatedByDecoded0 = [StringFilter]()
            for structure0 in noteUpdatedByContainer {
                if let structure0 = structure0 {
                    noteUpdatedByDecoded0?.append(structure0)
                }
            }
        }
        noteUpdatedBy = noteUpdatedByDecoded0
        let keywordContainer = try containerValues.decodeIfPresent([KeywordFilter?].self, forKey: .keyword)
        var keywordDecoded0:[KeywordFilter]? = nil
        if let keywordContainer = keywordContainer {
            keywordDecoded0 = [KeywordFilter]()
            for structure0 in keywordContainer {
                if let structure0 = structure0 {
                    keywordDecoded0?.append(structure0)
                }
            }
        }
        keyword = keywordDecoded0
        let findingProviderFieldsConfidenceContainer = try containerValues.decodeIfPresent([NumberFilter?].self, forKey: .findingProviderFieldsConfidence)
        var findingProviderFieldsConfidenceDecoded0:[NumberFilter]? = nil
        if let findingProviderFieldsConfidenceContainer = findingProviderFieldsConfidenceContainer {
            findingProviderFieldsConfidenceDecoded0 = [NumberFilter]()
            for structure0 in findingProviderFieldsConfidenceContainer {
                if let structure0 = structure0 {
                    findingProviderFieldsConfidenceDecoded0?.append(structure0)
                }
            }
        }
        findingProviderFieldsConfidence = findingProviderFieldsConfidenceDecoded0
        let findingProviderFieldsCriticalityContainer = try containerValues.decodeIfPresent([NumberFilter?].self, forKey: .findingProviderFieldsCriticality)
        var findingProviderFieldsCriticalityDecoded0:[NumberFilter]? = nil
        if let findingProviderFieldsCriticalityContainer = findingProviderFieldsCriticalityContainer {
            findingProviderFieldsCriticalityDecoded0 = [NumberFilter]()
            for structure0 in findingProviderFieldsCriticalityContainer {
                if let structure0 = structure0 {
                    findingProviderFieldsCriticalityDecoded0?.append(structure0)
                }
            }
        }
        findingProviderFieldsCriticality = findingProviderFieldsCriticalityDecoded0
        let findingProviderFieldsRelatedFindingsIdContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .findingProviderFieldsRelatedFindingsId)
        var findingProviderFieldsRelatedFindingsIdDecoded0:[StringFilter]? = nil
        if let findingProviderFieldsRelatedFindingsIdContainer = findingProviderFieldsRelatedFindingsIdContainer {
            findingProviderFieldsRelatedFindingsIdDecoded0 = [StringFilter]()
            for structure0 in findingProviderFieldsRelatedFindingsIdContainer {
                if let structure0 = structure0 {
                    findingProviderFieldsRelatedFindingsIdDecoded0?.append(structure0)
                }
            }
        }
        findingProviderFieldsRelatedFindingsId = findingProviderFieldsRelatedFindingsIdDecoded0
        let findingProviderFieldsRelatedFindingsProductArnContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .findingProviderFieldsRelatedFindingsProductArn)
        var findingProviderFieldsRelatedFindingsProductArnDecoded0:[StringFilter]? = nil
        if let findingProviderFieldsRelatedFindingsProductArnContainer = findingProviderFieldsRelatedFindingsProductArnContainer {
            findingProviderFieldsRelatedFindingsProductArnDecoded0 = [StringFilter]()
            for structure0 in findingProviderFieldsRelatedFindingsProductArnContainer {
                if let structure0 = structure0 {
                    findingProviderFieldsRelatedFindingsProductArnDecoded0?.append(structure0)
                }
            }
        }
        findingProviderFieldsRelatedFindingsProductArn = findingProviderFieldsRelatedFindingsProductArnDecoded0
        let findingProviderFieldsSeverityLabelContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .findingProviderFieldsSeverityLabel)
        var findingProviderFieldsSeverityLabelDecoded0:[StringFilter]? = nil
        if let findingProviderFieldsSeverityLabelContainer = findingProviderFieldsSeverityLabelContainer {
            findingProviderFieldsSeverityLabelDecoded0 = [StringFilter]()
            for structure0 in findingProviderFieldsSeverityLabelContainer {
                if let structure0 = structure0 {
                    findingProviderFieldsSeverityLabelDecoded0?.append(structure0)
                }
            }
        }
        findingProviderFieldsSeverityLabel = findingProviderFieldsSeverityLabelDecoded0
        let findingProviderFieldsSeverityOriginalContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .findingProviderFieldsSeverityOriginal)
        var findingProviderFieldsSeverityOriginalDecoded0:[StringFilter]? = nil
        if let findingProviderFieldsSeverityOriginalContainer = findingProviderFieldsSeverityOriginalContainer {
            findingProviderFieldsSeverityOriginalDecoded0 = [StringFilter]()
            for structure0 in findingProviderFieldsSeverityOriginalContainer {
                if let structure0 = structure0 {
                    findingProviderFieldsSeverityOriginalDecoded0?.append(structure0)
                }
            }
        }
        findingProviderFieldsSeverityOriginal = findingProviderFieldsSeverityOriginalDecoded0
        let findingProviderFieldsTypesContainer = try containerValues.decodeIfPresent([StringFilter?].self, forKey: .findingProviderFieldsTypes)
        var findingProviderFieldsTypesDecoded0:[StringFilter]? = nil
        if let findingProviderFieldsTypesContainer = findingProviderFieldsTypesContainer {
            findingProviderFieldsTypesDecoded0 = [StringFilter]()
            for structure0 in findingProviderFieldsTypesContainer {
                if let structure0 = structure0 {
                    findingProviderFieldsTypesDecoded0?.append(structure0)
                }
            }
        }
        findingProviderFieldsTypes = findingProviderFieldsTypesDecoded0
    }
}

extension AwsSecurityFindingFilters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsSecurityFindingFilters(awsAccountId: \(String(describing: awsAccountId)), companyName: \(String(describing: companyName)), complianceStatus: \(String(describing: complianceStatus)), confidence: \(String(describing: confidence)), createdAt: \(String(describing: createdAt)), criticality: \(String(describing: criticality)), description: \(String(describing: description)), findingProviderFieldsConfidence: \(String(describing: findingProviderFieldsConfidence)), findingProviderFieldsCriticality: \(String(describing: findingProviderFieldsCriticality)), findingProviderFieldsRelatedFindingsId: \(String(describing: findingProviderFieldsRelatedFindingsId)), findingProviderFieldsRelatedFindingsProductArn: \(String(describing: findingProviderFieldsRelatedFindingsProductArn)), findingProviderFieldsSeverityLabel: \(String(describing: findingProviderFieldsSeverityLabel)), findingProviderFieldsSeverityOriginal: \(String(describing: findingProviderFieldsSeverityOriginal)), findingProviderFieldsTypes: \(String(describing: findingProviderFieldsTypes)), firstObservedAt: \(String(describing: firstObservedAt)), generatorId: \(String(describing: generatorId)), id: \(String(describing: id)), keyword: \(String(describing: keyword)), lastObservedAt: \(String(describing: lastObservedAt)), malwareName: \(String(describing: malwareName)), malwarePath: \(String(describing: malwarePath)), malwareState: \(String(describing: malwareState)), malwareType: \(String(describing: malwareType)), networkDestinationDomain: \(String(describing: networkDestinationDomain)), networkDestinationIpV4: \(String(describing: networkDestinationIpV4)), networkDestinationIpV6: \(String(describing: networkDestinationIpV6)), networkDestinationPort: \(String(describing: networkDestinationPort)), networkDirection: \(String(describing: networkDirection)), networkProtocol: \(String(describing: networkProtocol)), networkSourceDomain: \(String(describing: networkSourceDomain)), networkSourceIpV4: \(String(describing: networkSourceIpV4)), networkSourceIpV6: \(String(describing: networkSourceIpV6)), networkSourceMac: \(String(describing: networkSourceMac)), networkSourcePort: \(String(describing: networkSourcePort)), noteText: \(String(describing: noteText)), noteUpdatedAt: \(String(describing: noteUpdatedAt)), noteUpdatedBy: \(String(describing: noteUpdatedBy)), processLaunchedAt: \(String(describing: processLaunchedAt)), processName: \(String(describing: processName)), processParentPid: \(String(describing: processParentPid)), processPath: \(String(describing: processPath)), processPid: \(String(describing: processPid)), processTerminatedAt: \(String(describing: processTerminatedAt)), productArn: \(String(describing: productArn)), productFields: \(String(describing: productFields)), productName: \(String(describing: productName)), recommendationText: \(String(describing: recommendationText)), recordState: \(String(describing: recordState)), relatedFindingsId: \(String(describing: relatedFindingsId)), relatedFindingsProductArn: \(String(describing: relatedFindingsProductArn)), resourceAwsEc2InstanceIamInstanceProfileArn: \(String(describing: resourceAwsEc2InstanceIamInstanceProfileArn)), resourceAwsEc2InstanceImageId: \(String(describing: resourceAwsEc2InstanceImageId)), resourceAwsEc2InstanceIpV4Addresses: \(String(describing: resourceAwsEc2InstanceIpV4Addresses)), resourceAwsEc2InstanceIpV6Addresses: \(String(describing: resourceAwsEc2InstanceIpV6Addresses)), resourceAwsEc2InstanceKeyName: \(String(describing: resourceAwsEc2InstanceKeyName)), resourceAwsEc2InstanceLaunchedAt: \(String(describing: resourceAwsEc2InstanceLaunchedAt)), resourceAwsEc2InstanceSubnetId: \(String(describing: resourceAwsEc2InstanceSubnetId)), resourceAwsEc2InstanceType: \(String(describing: resourceAwsEc2InstanceType)), resourceAwsEc2InstanceVpcId: \(String(describing: resourceAwsEc2InstanceVpcId)), resourceAwsIamAccessKeyCreatedAt: \(String(describing: resourceAwsIamAccessKeyCreatedAt)), resourceAwsIamAccessKeyStatus: \(String(describing: resourceAwsIamAccessKeyStatus)), resourceAwsIamAccessKeyUserName: \(String(describing: resourceAwsIamAccessKeyUserName)), resourceAwsS3BucketOwnerId: \(String(describing: resourceAwsS3BucketOwnerId)), resourceAwsS3BucketOwnerName: \(String(describing: resourceAwsS3BucketOwnerName)), resourceContainerImageId: \(String(describing: resourceContainerImageId)), resourceContainerImageName: \(String(describing: resourceContainerImageName)), resourceContainerLaunchedAt: \(String(describing: resourceContainerLaunchedAt)), resourceContainerName: \(String(describing: resourceContainerName)), resourceDetailsOther: \(String(describing: resourceDetailsOther)), resourceId: \(String(describing: resourceId)), resourcePartition: \(String(describing: resourcePartition)), resourceRegion: \(String(describing: resourceRegion)), resourceTags: \(String(describing: resourceTags)), resourceType: \(String(describing: resourceType)), severityLabel: \(String(describing: severityLabel)), severityNormalized: \(String(describing: severityNormalized)), severityProduct: \(String(describing: severityProduct)), sourceUrl: \(String(describing: sourceUrl)), threatIntelIndicatorCategory: \(String(describing: threatIntelIndicatorCategory)), threatIntelIndicatorLastObservedAt: \(String(describing: threatIntelIndicatorLastObservedAt)), threatIntelIndicatorSource: \(String(describing: threatIntelIndicatorSource)), threatIntelIndicatorSourceUrl: \(String(describing: threatIntelIndicatorSourceUrl)), threatIntelIndicatorType: \(String(describing: threatIntelIndicatorType)), threatIntelIndicatorValue: \(String(describing: threatIntelIndicatorValue)), title: \(String(describing: title)), type: \(String(describing: type)), updatedAt: \(String(describing: updatedAt)), userDefinedFields: \(String(describing: userDefinedFields)), verificationState: \(String(describing: verificationState)), workflowState: \(String(describing: workflowState)), workflowStatus: \(String(describing: workflowStatus)))"}
}

/// <p>A collection of attributes that are applied to all active Security Hub-aggregated findings and
///          that result in a subset of findings that are included in this insight.</p>
///          <p>You can filter by up to 10 finding attributes. For each attribute, you can provide up to
///          20 filter values.</p>
public struct AwsSecurityFindingFilters: Equatable {
    /// <p>The AWS account ID that a finding is generated in.</p>
    public let awsAccountId: [StringFilter]?
    /// <p>The name of the findings provider (company) that owns the solution (product) that
    ///          generates findings.</p>
    public let companyName: [StringFilter]?
    /// <p>Exclusive to findings that are generated as the result of a check run against a specific
    ///          rule in a supported standard, such as CIS AWS Foundations. Contains security
    ///          standard-related finding details.</p>
    public let complianceStatus: [StringFilter]?
    /// <p>A finding's confidence. Confidence is defined as the likelihood that a finding
    ///          accurately identifies the behavior or issue that it was intended to identify.</p>
    ///          <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent
    ///          confidence and 100 means 100 percent confidence.</p>
    public let confidence: [NumberFilter]?
    /// <p>An ISO8601-formatted timestamp that indicates when the security-findings provider
    ///          captured the potential security issue that a finding captured.</p>
    public let createdAt: [DateFilter]?
    /// <p>The level of importance assigned to the resources associated with the finding.</p>
    ///          <p>A score of 0 means that the underlying resources have no criticality, and a score of 100
    ///          is reserved for the most critical resources.</p>
    public let criticality: [NumberFilter]?
    /// <p>A finding's description.</p>
    public let description: [StringFilter]?
    /// <p>The finding provider value for the finding confidence. Confidence is defined as the likelihood
    ///          that a finding accurately identifies the behavior or issue that it was intended to
    ///          identify.</p>
    ///          <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent
    ///          confidence and 100 means 100 percent confidence.</p>
    public let findingProviderFieldsConfidence: [NumberFilter]?
    /// <p>The finding provider value for the level of importance assigned to the resources associated with
    ///          the findings.</p>
    ///          <p>A score of 0 means that the underlying resources have no criticality, and a score of 100
    ///          is reserved for the most critical resources. </p>
    public let findingProviderFieldsCriticality: [NumberFilter]?
    /// <p>The finding identifier of a related finding that is identified by the finding provider.</p>
    public let findingProviderFieldsRelatedFindingsId: [StringFilter]?
    /// <p>The ARN of the solution that generated a related finding that is identified by the finding provider.</p>
    public let findingProviderFieldsRelatedFindingsProductArn: [StringFilter]?
    /// <p>The finding provider value for the severity label.</p>
    public let findingProviderFieldsSeverityLabel: [StringFilter]?
    /// <p>The finding provider's original value for the severity.</p>
    public let findingProviderFieldsSeverityOriginal: [StringFilter]?
    /// <p>One or more finding types that the finding provider assigned to the finding. Uses the format of <code>namespace/category/classifier</code>
    ///          that classify a finding.</p>
    ///          <p>Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual
    ///          Behaviors | Sensitive Data Identifications</p>
    public let findingProviderFieldsTypes: [StringFilter]?
    /// <p>An ISO8601-formatted timestamp that indicates when the security-findings provider first
    ///          observed the potential security issue that a finding captured.</p>
    public let firstObservedAt: [DateFilter]?
    /// <p>The identifier for the solution-specific component (a discrete unit of logic) that
    ///          generated a finding. In various security-findings providers' solutions, this generator can
    ///          be called a rule, a check, a detector, a plugin, etc.</p>
    public let generatorId: [StringFilter]?
    /// <p>The security findings provider-specific identifier for a finding.</p>
    public let id: [StringFilter]?
    /// <p>A keyword for a finding.</p>
    public let keyword: [KeywordFilter]?
    /// <p>An ISO8601-formatted timestamp that indicates when the security-findings provider most
    ///          recently observed the potential security issue that a finding captured.</p>
    public let lastObservedAt: [DateFilter]?
    /// <p>The name of the malware that was observed.</p>
    public let malwareName: [StringFilter]?
    /// <p>The filesystem path of the malware that was observed.</p>
    public let malwarePath: [StringFilter]?
    /// <p>The state of the malware that was observed.</p>
    public let malwareState: [StringFilter]?
    /// <p>The type of the malware that was observed.</p>
    public let malwareType: [StringFilter]?
    /// <p>The destination domain of network-related information about a finding.</p>
    public let networkDestinationDomain: [StringFilter]?
    /// <p>The destination IPv4 address of network-related information about a finding.</p>
    public let networkDestinationIpV4: [IpFilter]?
    /// <p>The destination IPv6 address of network-related information about a finding.</p>
    public let networkDestinationIpV6: [IpFilter]?
    /// <p>The destination port of network-related information about a finding.</p>
    public let networkDestinationPort: [NumberFilter]?
    /// <p>Indicates the direction of network traffic associated with a finding.</p>
    public let networkDirection: [StringFilter]?
    /// <p>The protocol of network-related information about a finding.</p>
    public let networkProtocol: [StringFilter]?
    /// <p>The source domain of network-related information about a finding.</p>
    public let networkSourceDomain: [StringFilter]?
    /// <p>The source IPv4 address of network-related information about a finding.</p>
    public let networkSourceIpV4: [IpFilter]?
    /// <p>The source IPv6 address of network-related information about a finding.</p>
    public let networkSourceIpV6: [IpFilter]?
    /// <p>The source media access control (MAC) address of network-related information about a
    ///          finding.</p>
    public let networkSourceMac: [StringFilter]?
    /// <p>The source port of network-related information about a finding.</p>
    public let networkSourcePort: [NumberFilter]?
    /// <p>The text of a note.</p>
    public let noteText: [StringFilter]?
    /// <p>The timestamp of when the note was updated.</p>
    public let noteUpdatedAt: [DateFilter]?
    /// <p>The principal that created a note.</p>
    public let noteUpdatedBy: [StringFilter]?
    /// <p>The date/time that the process was launched.</p>
    public let processLaunchedAt: [DateFilter]?
    /// <p>The name of the process.</p>
    public let processName: [StringFilter]?
    /// <p>The parent process ID.</p>
    public let processParentPid: [NumberFilter]?
    /// <p>The path to the process executable.</p>
    public let processPath: [StringFilter]?
    /// <p>The process ID.</p>
    public let processPid: [NumberFilter]?
    /// <p>The date/time that the process was terminated.</p>
    public let processTerminatedAt: [DateFilter]?
    /// <p>The ARN generated by Security Hub that uniquely identifies a third-party company
    ///          (security findings provider) after this provider's product (solution that generates
    ///          findings) is registered with Security Hub.</p>
    public let productArn: [StringFilter]?
    /// <p>A data type where security-findings providers can include additional solution-specific
    ///          details that aren't part of the defined <code>AwsSecurityFinding</code> format.</p>
    public let productFields: [MapFilter]?
    /// <p>The name of the solution (product) that generates findings.</p>
    public let productName: [StringFilter]?
    /// <p>The recommendation of what to do about the issue described in a finding.</p>
    public let recommendationText: [StringFilter]?
    /// <p>The updated record state for the finding.</p>
    public let recordState: [StringFilter]?
    /// <p>The solution-generated identifier for a related finding.</p>
    public let relatedFindingsId: [StringFilter]?
    /// <p>The ARN of the solution that generated a related finding.</p>
    public let relatedFindingsProductArn: [StringFilter]?
    /// <p>The IAM profile ARN of the instance.</p>
    public let resourceAwsEc2InstanceIamInstanceProfileArn: [StringFilter]?
    /// <p>The Amazon Machine Image (AMI) ID of the instance.</p>
    public let resourceAwsEc2InstanceImageId: [StringFilter]?
    /// <p>The IPv4 addresses associated with the instance.</p>
    public let resourceAwsEc2InstanceIpV4Addresses: [IpFilter]?
    /// <p>The IPv6 addresses associated with the instance.</p>
    public let resourceAwsEc2InstanceIpV6Addresses: [IpFilter]?
    /// <p>The key name associated with the instance.</p>
    public let resourceAwsEc2InstanceKeyName: [StringFilter]?
    /// <p>The date and time the instance was launched.</p>
    public let resourceAwsEc2InstanceLaunchedAt: [DateFilter]?
    /// <p>The identifier of the subnet that the instance was launched in.</p>
    public let resourceAwsEc2InstanceSubnetId: [StringFilter]?
    /// <p>The instance type of the instance.</p>
    public let resourceAwsEc2InstanceType: [StringFilter]?
    /// <p>The identifier of the VPC that the instance was launched in.</p>
    public let resourceAwsEc2InstanceVpcId: [StringFilter]?
    /// <p>The creation date/time of the IAM access key related to a finding.</p>
    public let resourceAwsIamAccessKeyCreatedAt: [DateFilter]?
    /// <p>The status of the IAM access key related to a finding.</p>
    public let resourceAwsIamAccessKeyStatus: [StringFilter]?
    /// <p>The user associated with the IAM access key related to a finding.</p>
    public let resourceAwsIamAccessKeyUserName: [StringFilter]?
    /// <p>The canonical user ID of the owner of the S3 bucket.</p>
    public let resourceAwsS3BucketOwnerId: [StringFilter]?
    /// <p>The display name of the owner of the S3 bucket.</p>
    public let resourceAwsS3BucketOwnerName: [StringFilter]?
    /// <p>The identifier of the image related to a finding.</p>
    public let resourceContainerImageId: [StringFilter]?
    /// <p>The name of the image related to a finding.</p>
    public let resourceContainerImageName: [StringFilter]?
    /// <p>The date/time that the container was started.</p>
    public let resourceContainerLaunchedAt: [DateFilter]?
    /// <p>The name of the container related to a finding.</p>
    public let resourceContainerName: [StringFilter]?
    /// <p>The details of a resource that doesn't have a specific subfield for the resource type
    ///          defined.</p>
    public let resourceDetailsOther: [MapFilter]?
    /// <p>The canonical identifier for the given resource type.</p>
    public let resourceId: [StringFilter]?
    /// <p>The canonical AWS partition name that the Region is assigned to.</p>
    public let resourcePartition: [StringFilter]?
    /// <p>The canonical AWS external Region name where this resource is located.</p>
    public let resourceRegion: [StringFilter]?
    /// <p>A list of AWS tags associated with a resource at the time the finding was
    ///          processed.</p>
    public let resourceTags: [MapFilter]?
    /// <p>Specifies the type of the resource that details are provided for.</p>
    public let resourceType: [StringFilter]?
    /// <p>The label of a finding's severity.</p>
    public let severityLabel: [StringFilter]?
    /// <p>The normalized severity of a finding.</p>
    @available(*, deprecated, message: "This filter is deprecated, use SeverityLabel or FindingProviderFieldsSeverityLabel instead.")
    public let severityNormalized: [NumberFilter]?
    /// <p>The native severity as defined by the security-findings provider's solution that
    ///          generated the finding.</p>
    @available(*, deprecated, message: "This filter is deprecated, use FindingProviiltersSeverityOriginal instead.")
    public let severityProduct: [NumberFilter]?
    /// <p>A URL that links to a page about the current finding in the security-findings provider's
    ///          solution.</p>
    public let sourceUrl: [StringFilter]?
    /// <p>The category of a threat intelligence indicator.</p>
    public let threatIntelIndicatorCategory: [StringFilter]?
    /// <p>The date/time of the last observation of a threat intelligence indicator.</p>
    public let threatIntelIndicatorLastObservedAt: [DateFilter]?
    /// <p>The source of the threat intelligence.</p>
    public let threatIntelIndicatorSource: [StringFilter]?
    /// <p>The URL for more details from the source of the threat intelligence.</p>
    public let threatIntelIndicatorSourceUrl: [StringFilter]?
    /// <p>The type of a threat intelligence indicator.</p>
    public let threatIntelIndicatorType: [StringFilter]?
    /// <p>The value of a threat intelligence indicator.</p>
    public let threatIntelIndicatorValue: [StringFilter]?
    /// <p>A finding's title.</p>
    public let title: [StringFilter]?
    /// <p>A finding type in the format of <code>namespace/category/classifier</code> that
    ///          classifies a finding.</p>
    public let type: [StringFilter]?
    /// <p>An ISO8601-formatted timestamp that indicates when the security-findings provider last
    ///          updated the finding record. </p>
    public let updatedAt: [DateFilter]?
    /// <p>A list of name/value string pairs associated with the finding. These are custom,
    ///          user-defined fields added to a finding. </p>
    public let userDefinedFields: [MapFilter]?
    /// <p>The veracity of a finding.</p>
    public let verificationState: [StringFilter]?
    /// <p>The workflow state of a finding.</p>
    ///          <p>Note that this field is deprecated. To search for a finding based on its workflow
    ///          status, use <code>WorkflowStatus</code>.</p>
    public let workflowState: [StringFilter]?
    /// <p>The status of the investigation into a finding. Allowed values are the following.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>NEW</code> - The initial state of a finding, before it is reviewed.</p>
    ///                <p>Security Hub also resets the workflow status from <code>NOTIFIED</code> or
    ///                   <code>RESOLVED</code> to <code>NEW</code> in the following cases:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>The record state changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>The compliance status changes from <code>PASSED</code> to either <code>WARNING</code>,
    ///                         <code>FAILED</code>, or <code>NOT_AVAILABLE</code>.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOTIFIED</code> - Indicates that the resource owner has been notified about
    ///                the security issue. Used when the initial reviewer is not the resource owner, and
    ///                needs intervention from the resource owner.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SUPPRESSED</code> - The finding will not be reviewed again and will not be
    ///                acted upon.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RESOLVED</code> - The finding was reviewed and remediated and is now
    ///                considered resolved. </p>
    ///             </li>
    ///          </ul>
    public let workflowStatus: [StringFilter]?

    public init (
        awsAccountId: [StringFilter]? = nil,
        companyName: [StringFilter]? = nil,
        complianceStatus: [StringFilter]? = nil,
        confidence: [NumberFilter]? = nil,
        createdAt: [DateFilter]? = nil,
        criticality: [NumberFilter]? = nil,
        description: [StringFilter]? = nil,
        findingProviderFieldsConfidence: [NumberFilter]? = nil,
        findingProviderFieldsCriticality: [NumberFilter]? = nil,
        findingProviderFieldsRelatedFindingsId: [StringFilter]? = nil,
        findingProviderFieldsRelatedFindingsProductArn: [StringFilter]? = nil,
        findingProviderFieldsSeverityLabel: [StringFilter]? = nil,
        findingProviderFieldsSeverityOriginal: [StringFilter]? = nil,
        findingProviderFieldsTypes: [StringFilter]? = nil,
        firstObservedAt: [DateFilter]? = nil,
        generatorId: [StringFilter]? = nil,
        id: [StringFilter]? = nil,
        keyword: [KeywordFilter]? = nil,
        lastObservedAt: [DateFilter]? = nil,
        malwareName: [StringFilter]? = nil,
        malwarePath: [StringFilter]? = nil,
        malwareState: [StringFilter]? = nil,
        malwareType: [StringFilter]? = nil,
        networkDestinationDomain: [StringFilter]? = nil,
        networkDestinationIpV4: [IpFilter]? = nil,
        networkDestinationIpV6: [IpFilter]? = nil,
        networkDestinationPort: [NumberFilter]? = nil,
        networkDirection: [StringFilter]? = nil,
        networkProtocol: [StringFilter]? = nil,
        networkSourceDomain: [StringFilter]? = nil,
        networkSourceIpV4: [IpFilter]? = nil,
        networkSourceIpV6: [IpFilter]? = nil,
        networkSourceMac: [StringFilter]? = nil,
        networkSourcePort: [NumberFilter]? = nil,
        noteText: [StringFilter]? = nil,
        noteUpdatedAt: [DateFilter]? = nil,
        noteUpdatedBy: [StringFilter]? = nil,
        processLaunchedAt: [DateFilter]? = nil,
        processName: [StringFilter]? = nil,
        processParentPid: [NumberFilter]? = nil,
        processPath: [StringFilter]? = nil,
        processPid: [NumberFilter]? = nil,
        processTerminatedAt: [DateFilter]? = nil,
        productArn: [StringFilter]? = nil,
        productFields: [MapFilter]? = nil,
        productName: [StringFilter]? = nil,
        recommendationText: [StringFilter]? = nil,
        recordState: [StringFilter]? = nil,
        relatedFindingsId: [StringFilter]? = nil,
        relatedFindingsProductArn: [StringFilter]? = nil,
        resourceAwsEc2InstanceIamInstanceProfileArn: [StringFilter]? = nil,
        resourceAwsEc2InstanceImageId: [StringFilter]? = nil,
        resourceAwsEc2InstanceIpV4Addresses: [IpFilter]? = nil,
        resourceAwsEc2InstanceIpV6Addresses: [IpFilter]? = nil,
        resourceAwsEc2InstanceKeyName: [StringFilter]? = nil,
        resourceAwsEc2InstanceLaunchedAt: [DateFilter]? = nil,
        resourceAwsEc2InstanceSubnetId: [StringFilter]? = nil,
        resourceAwsEc2InstanceType: [StringFilter]? = nil,
        resourceAwsEc2InstanceVpcId: [StringFilter]? = nil,
        resourceAwsIamAccessKeyCreatedAt: [DateFilter]? = nil,
        resourceAwsIamAccessKeyStatus: [StringFilter]? = nil,
        resourceAwsIamAccessKeyUserName: [StringFilter]? = nil,
        resourceAwsS3BucketOwnerId: [StringFilter]? = nil,
        resourceAwsS3BucketOwnerName: [StringFilter]? = nil,
        resourceContainerImageId: [StringFilter]? = nil,
        resourceContainerImageName: [StringFilter]? = nil,
        resourceContainerLaunchedAt: [DateFilter]? = nil,
        resourceContainerName: [StringFilter]? = nil,
        resourceDetailsOther: [MapFilter]? = nil,
        resourceId: [StringFilter]? = nil,
        resourcePartition: [StringFilter]? = nil,
        resourceRegion: [StringFilter]? = nil,
        resourceTags: [MapFilter]? = nil,
        resourceType: [StringFilter]? = nil,
        severityLabel: [StringFilter]? = nil,
        severityNormalized: [NumberFilter]? = nil,
        severityProduct: [NumberFilter]? = nil,
        sourceUrl: [StringFilter]? = nil,
        threatIntelIndicatorCategory: [StringFilter]? = nil,
        threatIntelIndicatorLastObservedAt: [DateFilter]? = nil,
        threatIntelIndicatorSource: [StringFilter]? = nil,
        threatIntelIndicatorSourceUrl: [StringFilter]? = nil,
        threatIntelIndicatorType: [StringFilter]? = nil,
        threatIntelIndicatorValue: [StringFilter]? = nil,
        title: [StringFilter]? = nil,
        type: [StringFilter]? = nil,
        updatedAt: [DateFilter]? = nil,
        userDefinedFields: [MapFilter]? = nil,
        verificationState: [StringFilter]? = nil,
        workflowState: [StringFilter]? = nil,
        workflowStatus: [StringFilter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.companyName = companyName
        self.complianceStatus = complianceStatus
        self.confidence = confidence
        self.createdAt = createdAt
        self.criticality = criticality
        self.description = description
        self.findingProviderFieldsConfidence = findingProviderFieldsConfidence
        self.findingProviderFieldsCriticality = findingProviderFieldsCriticality
        self.findingProviderFieldsRelatedFindingsId = findingProviderFieldsRelatedFindingsId
        self.findingProviderFieldsRelatedFindingsProductArn = findingProviderFieldsRelatedFindingsProductArn
        self.findingProviderFieldsSeverityLabel = findingProviderFieldsSeverityLabel
        self.findingProviderFieldsSeverityOriginal = findingProviderFieldsSeverityOriginal
        self.findingProviderFieldsTypes = findingProviderFieldsTypes
        self.firstObservedAt = firstObservedAt
        self.generatorId = generatorId
        self.id = id
        self.keyword = keyword
        self.lastObservedAt = lastObservedAt
        self.malwareName = malwareName
        self.malwarePath = malwarePath
        self.malwareState = malwareState
        self.malwareType = malwareType
        self.networkDestinationDomain = networkDestinationDomain
        self.networkDestinationIpV4 = networkDestinationIpV4
        self.networkDestinationIpV6 = networkDestinationIpV6
        self.networkDestinationPort = networkDestinationPort
        self.networkDirection = networkDirection
        self.networkProtocol = networkProtocol
        self.networkSourceDomain = networkSourceDomain
        self.networkSourceIpV4 = networkSourceIpV4
        self.networkSourceIpV6 = networkSourceIpV6
        self.networkSourceMac = networkSourceMac
        self.networkSourcePort = networkSourcePort
        self.noteText = noteText
        self.noteUpdatedAt = noteUpdatedAt
        self.noteUpdatedBy = noteUpdatedBy
        self.processLaunchedAt = processLaunchedAt
        self.processName = processName
        self.processParentPid = processParentPid
        self.processPath = processPath
        self.processPid = processPid
        self.processTerminatedAt = processTerminatedAt
        self.productArn = productArn
        self.productFields = productFields
        self.productName = productName
        self.recommendationText = recommendationText
        self.recordState = recordState
        self.relatedFindingsId = relatedFindingsId
        self.relatedFindingsProductArn = relatedFindingsProductArn
        self.resourceAwsEc2InstanceIamInstanceProfileArn = resourceAwsEc2InstanceIamInstanceProfileArn
        self.resourceAwsEc2InstanceImageId = resourceAwsEc2InstanceImageId
        self.resourceAwsEc2InstanceIpV4Addresses = resourceAwsEc2InstanceIpV4Addresses
        self.resourceAwsEc2InstanceIpV6Addresses = resourceAwsEc2InstanceIpV6Addresses
        self.resourceAwsEc2InstanceKeyName = resourceAwsEc2InstanceKeyName
        self.resourceAwsEc2InstanceLaunchedAt = resourceAwsEc2InstanceLaunchedAt
        self.resourceAwsEc2InstanceSubnetId = resourceAwsEc2InstanceSubnetId
        self.resourceAwsEc2InstanceType = resourceAwsEc2InstanceType
        self.resourceAwsEc2InstanceVpcId = resourceAwsEc2InstanceVpcId
        self.resourceAwsIamAccessKeyCreatedAt = resourceAwsIamAccessKeyCreatedAt
        self.resourceAwsIamAccessKeyStatus = resourceAwsIamAccessKeyStatus
        self.resourceAwsIamAccessKeyUserName = resourceAwsIamAccessKeyUserName
        self.resourceAwsS3BucketOwnerId = resourceAwsS3BucketOwnerId
        self.resourceAwsS3BucketOwnerName = resourceAwsS3BucketOwnerName
        self.resourceContainerImageId = resourceContainerImageId
        self.resourceContainerImageName = resourceContainerImageName
        self.resourceContainerLaunchedAt = resourceContainerLaunchedAt
        self.resourceContainerName = resourceContainerName
        self.resourceDetailsOther = resourceDetailsOther
        self.resourceId = resourceId
        self.resourcePartition = resourcePartition
        self.resourceRegion = resourceRegion
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.severityLabel = severityLabel
        self.severityNormalized = severityNormalized
        self.severityProduct = severityProduct
        self.sourceUrl = sourceUrl
        self.threatIntelIndicatorCategory = threatIntelIndicatorCategory
        self.threatIntelIndicatorLastObservedAt = threatIntelIndicatorLastObservedAt
        self.threatIntelIndicatorSource = threatIntelIndicatorSource
        self.threatIntelIndicatorSourceUrl = threatIntelIndicatorSourceUrl
        self.threatIntelIndicatorType = threatIntelIndicatorType
        self.threatIntelIndicatorValue = threatIntelIndicatorValue
        self.title = title
        self.type = type
        self.updatedAt = updatedAt
        self.userDefinedFields = userDefinedFields
        self.verificationState = verificationState
        self.workflowState = workflowState
        self.workflowStatus = workflowStatus
    }
}

extension AwsSecurityFindingIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case productArn = "ProductArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let productArn = productArn {
            try encodeContainer.encode(productArn, forKey: .productArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let productArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productArn)
        productArn = productArnDecoded
    }
}

extension AwsSecurityFindingIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsSecurityFindingIdentifier(id: \(String(describing: id)), productArn: \(String(describing: productArn)))"}
}

/// <p>Identifies a finding to update using <code>BatchUpdateFindings</code>.</p>
public struct AwsSecurityFindingIdentifier: Equatable {
    /// <p>The identifier of the finding that was specified by the finding provider.</p>
    public let id: String?
    /// <p>The ARN generated by Security Hub that uniquely identifies a product that generates findings.
    ///          This can be the ARN for a third-party product that is integrated with Security Hub, or the ARN for
    ///          a custom integration.</p>
    public let productArn: String?

    public init (
        id: String? = nil,
        productArn: String? = nil
    )
    {
        self.id = id
        self.productArn = productArn
    }
}

extension AwsSnsTopicDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsMasterKeyId = "KmsMasterKeyId"
        case owner = "Owner"
        case subscription = "Subscription"
        case topicName = "TopicName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsMasterKeyId = kmsMasterKeyId {
            try encodeContainer.encode(kmsMasterKeyId, forKey: .kmsMasterKeyId)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let subscription = subscription {
            var subscriptionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscription)
            for awssnstopicsubscriptionlist0 in subscription {
                try subscriptionContainer.encode(awssnstopicsubscriptionlist0)
            }
        }
        if let topicName = topicName {
            try encodeContainer.encode(topicName, forKey: .topicName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsMasterKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsMasterKeyId)
        kmsMasterKeyId = kmsMasterKeyIdDecoded
        let subscriptionContainer = try containerValues.decodeIfPresent([AwsSnsTopicSubscription?].self, forKey: .subscription)
        var subscriptionDecoded0:[AwsSnsTopicSubscription]? = nil
        if let subscriptionContainer = subscriptionContainer {
            subscriptionDecoded0 = [AwsSnsTopicSubscription]()
            for structure0 in subscriptionContainer {
                if let structure0 = structure0 {
                    subscriptionDecoded0?.append(structure0)
                }
            }
        }
        subscription = subscriptionDecoded0
        let topicNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicName)
        topicName = topicNameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
    }
}

extension AwsSnsTopicDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsSnsTopicDetails(kmsMasterKeyId: \(String(describing: kmsMasterKeyId)), owner: \(String(describing: owner)), subscription: \(String(describing: subscription)), topicName: \(String(describing: topicName)))"}
}

/// <p>A wrapper type for the topic's Amazon Resource Name (ARN).</p>
public struct AwsSnsTopicDetails: Equatable {
    /// <p>The ID of an AWS managed customer master key (CMK) for Amazon SNS or a custom
    ///          CMK.</p>
    public let kmsMasterKeyId: String?
    /// <p>The subscription's owner.</p>
    public let owner: String?
    /// <p>Subscription is an embedded property that describes the subscription endpoints of an Amazon SNS topic.</p>
    public let subscription: [AwsSnsTopicSubscription]?
    /// <p>The name of the topic.</p>
    public let topicName: String?

    public init (
        kmsMasterKeyId: String? = nil,
        owner: String? = nil,
        subscription: [AwsSnsTopicSubscription]? = nil,
        topicName: String? = nil
    )
    {
        self.kmsMasterKeyId = kmsMasterKeyId
        self.owner = owner
        self.subscription = subscription
        self.topicName = topicName
    }
}

extension AwsSnsTopicSubscription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpoint = "Endpoint"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protocol)
        `protocol` = protocolDecoded
    }
}

extension AwsSnsTopicSubscription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsSnsTopicSubscription(endpoint: \(String(describing: endpoint)), protocol: \(String(describing: `protocol`)))"}
}

/// <p>A wrapper type for the attributes of an Amazon SNS subscription.</p>
public struct AwsSnsTopicSubscription: Equatable {
    /// <p>The subscription's protocol.</p>
    public let `protocol`: String?
    /// <p>The subscription's endpoint (format depends on the protocol).</p>
    public let endpoint: String?

    public init (
        `protocol`: String? = nil,
        endpoint: String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.endpoint = endpoint
    }
}

extension AwsSqsQueueDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deadLetterTargetArn = "DeadLetterTargetArn"
        case kmsDataKeyReusePeriodSeconds = "KmsDataKeyReusePeriodSeconds"
        case kmsMasterKeyId = "KmsMasterKeyId"
        case queueName = "QueueName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deadLetterTargetArn = deadLetterTargetArn {
            try encodeContainer.encode(deadLetterTargetArn, forKey: .deadLetterTargetArn)
        }
        if kmsDataKeyReusePeriodSeconds != 0 {
            try encodeContainer.encode(kmsDataKeyReusePeriodSeconds, forKey: .kmsDataKeyReusePeriodSeconds)
        }
        if let kmsMasterKeyId = kmsMasterKeyId {
            try encodeContainer.encode(kmsMasterKeyId, forKey: .kmsMasterKeyId)
        }
        if let queueName = queueName {
            try encodeContainer.encode(queueName, forKey: .queueName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsDataKeyReusePeriodSecondsDecoded = try containerValues.decode(Int.self, forKey: .kmsDataKeyReusePeriodSeconds)
        kmsDataKeyReusePeriodSeconds = kmsDataKeyReusePeriodSecondsDecoded
        let kmsMasterKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsMasterKeyId)
        kmsMasterKeyId = kmsMasterKeyIdDecoded
        let queueNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queueName)
        queueName = queueNameDecoded
        let deadLetterTargetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deadLetterTargetArn)
        deadLetterTargetArn = deadLetterTargetArnDecoded
    }
}

extension AwsSqsQueueDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsSqsQueueDetails(deadLetterTargetArn: \(String(describing: deadLetterTargetArn)), kmsDataKeyReusePeriodSeconds: \(String(describing: kmsDataKeyReusePeriodSeconds)), kmsMasterKeyId: \(String(describing: kmsMasterKeyId)), queueName: \(String(describing: queueName)))"}
}

/// <p>Data about a queue.</p>
public struct AwsSqsQueueDetails: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dead-letter queue to which Amazon SQS moves
    ///          messages after the value of <code>maxReceiveCount</code> is exceeded. </p>
    public let deadLetterTargetArn: String?
    /// <p>The length of time, in seconds, for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling AWS KMS again.</p>
    public let kmsDataKeyReusePeriodSeconds: Int
    /// <p>The ID of an AWS managed customer master key (CMK) for Amazon SQS or a custom
    ///          CMK.</p>
    public let kmsMasterKeyId: String?
    /// <p>The name of the new queue.</p>
    public let queueName: String?

    public init (
        deadLetterTargetArn: String? = nil,
        kmsDataKeyReusePeriodSeconds: Int = 0,
        kmsMasterKeyId: String? = nil,
        queueName: String? = nil
    )
    {
        self.deadLetterTargetArn = deadLetterTargetArn
        self.kmsDataKeyReusePeriodSeconds = kmsDataKeyReusePeriodSeconds
        self.kmsMasterKeyId = kmsMasterKeyId
        self.queueName = queueName
    }
}

extension AwsSsmComplianceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceType = "ComplianceType"
        case compliantCriticalCount = "CompliantCriticalCount"
        case compliantHighCount = "CompliantHighCount"
        case compliantInformationalCount = "CompliantInformationalCount"
        case compliantLowCount = "CompliantLowCount"
        case compliantMediumCount = "CompliantMediumCount"
        case compliantUnspecifiedCount = "CompliantUnspecifiedCount"
        case executionType = "ExecutionType"
        case nonCompliantCriticalCount = "NonCompliantCriticalCount"
        case nonCompliantHighCount = "NonCompliantHighCount"
        case nonCompliantInformationalCount = "NonCompliantInformationalCount"
        case nonCompliantLowCount = "NonCompliantLowCount"
        case nonCompliantMediumCount = "NonCompliantMediumCount"
        case nonCompliantUnspecifiedCount = "NonCompliantUnspecifiedCount"
        case overallSeverity = "OverallSeverity"
        case patchBaselineId = "PatchBaselineId"
        case patchGroup = "PatchGroup"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if compliantCriticalCount != 0 {
            try encodeContainer.encode(compliantCriticalCount, forKey: .compliantCriticalCount)
        }
        if compliantHighCount != 0 {
            try encodeContainer.encode(compliantHighCount, forKey: .compliantHighCount)
        }
        if compliantInformationalCount != 0 {
            try encodeContainer.encode(compliantInformationalCount, forKey: .compliantInformationalCount)
        }
        if compliantLowCount != 0 {
            try encodeContainer.encode(compliantLowCount, forKey: .compliantLowCount)
        }
        if compliantMediumCount != 0 {
            try encodeContainer.encode(compliantMediumCount, forKey: .compliantMediumCount)
        }
        if compliantUnspecifiedCount != 0 {
            try encodeContainer.encode(compliantUnspecifiedCount, forKey: .compliantUnspecifiedCount)
        }
        if let executionType = executionType {
            try encodeContainer.encode(executionType, forKey: .executionType)
        }
        if nonCompliantCriticalCount != 0 {
            try encodeContainer.encode(nonCompliantCriticalCount, forKey: .nonCompliantCriticalCount)
        }
        if nonCompliantHighCount != 0 {
            try encodeContainer.encode(nonCompliantHighCount, forKey: .nonCompliantHighCount)
        }
        if nonCompliantInformationalCount != 0 {
            try encodeContainer.encode(nonCompliantInformationalCount, forKey: .nonCompliantInformationalCount)
        }
        if nonCompliantLowCount != 0 {
            try encodeContainer.encode(nonCompliantLowCount, forKey: .nonCompliantLowCount)
        }
        if nonCompliantMediumCount != 0 {
            try encodeContainer.encode(nonCompliantMediumCount, forKey: .nonCompliantMediumCount)
        }
        if nonCompliantUnspecifiedCount != 0 {
            try encodeContainer.encode(nonCompliantUnspecifiedCount, forKey: .nonCompliantUnspecifiedCount)
        }
        if let overallSeverity = overallSeverity {
            try encodeContainer.encode(overallSeverity, forKey: .overallSeverity)
        }
        if let patchBaselineId = patchBaselineId {
            try encodeContainer.encode(patchBaselineId, forKey: .patchBaselineId)
        }
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let compliantCriticalCountDecoded = try containerValues.decode(Int.self, forKey: .compliantCriticalCount)
        compliantCriticalCount = compliantCriticalCountDecoded
        let compliantHighCountDecoded = try containerValues.decode(Int.self, forKey: .compliantHighCount)
        compliantHighCount = compliantHighCountDecoded
        let compliantMediumCountDecoded = try containerValues.decode(Int.self, forKey: .compliantMediumCount)
        compliantMediumCount = compliantMediumCountDecoded
        let executionTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionType)
        executionType = executionTypeDecoded
        let nonCompliantCriticalCountDecoded = try containerValues.decode(Int.self, forKey: .nonCompliantCriticalCount)
        nonCompliantCriticalCount = nonCompliantCriticalCountDecoded
        let compliantInformationalCountDecoded = try containerValues.decode(Int.self, forKey: .compliantInformationalCount)
        compliantInformationalCount = compliantInformationalCountDecoded
        let nonCompliantInformationalCountDecoded = try containerValues.decode(Int.self, forKey: .nonCompliantInformationalCount)
        nonCompliantInformationalCount = nonCompliantInformationalCountDecoded
        let compliantUnspecifiedCountDecoded = try containerValues.decode(Int.self, forKey: .compliantUnspecifiedCount)
        compliantUnspecifiedCount = compliantUnspecifiedCountDecoded
        let nonCompliantLowCountDecoded = try containerValues.decode(Int.self, forKey: .nonCompliantLowCount)
        nonCompliantLowCount = nonCompliantLowCountDecoded
        let nonCompliantHighCountDecoded = try containerValues.decode(Int.self, forKey: .nonCompliantHighCount)
        nonCompliantHighCount = nonCompliantHighCountDecoded
        let compliantLowCountDecoded = try containerValues.decode(Int.self, forKey: .compliantLowCount)
        compliantLowCount = compliantLowCountDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let patchBaselineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patchBaselineId)
        patchBaselineId = patchBaselineIdDecoded
        let overallSeverityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .overallSeverity)
        overallSeverity = overallSeverityDecoded
        let nonCompliantMediumCountDecoded = try containerValues.decode(Int.self, forKey: .nonCompliantMediumCount)
        nonCompliantMediumCount = nonCompliantMediumCountDecoded
        let nonCompliantUnspecifiedCountDecoded = try containerValues.decode(Int.self, forKey: .nonCompliantUnspecifiedCount)
        nonCompliantUnspecifiedCount = nonCompliantUnspecifiedCountDecoded
        let patchGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
    }
}

extension AwsSsmComplianceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsSsmComplianceSummary(complianceType: \(String(describing: complianceType)), compliantCriticalCount: \(String(describing: compliantCriticalCount)), compliantHighCount: \(String(describing: compliantHighCount)), compliantInformationalCount: \(String(describing: compliantInformationalCount)), compliantLowCount: \(String(describing: compliantLowCount)), compliantMediumCount: \(String(describing: compliantMediumCount)), compliantUnspecifiedCount: \(String(describing: compliantUnspecifiedCount)), executionType: \(String(describing: executionType)), nonCompliantCriticalCount: \(String(describing: nonCompliantCriticalCount)), nonCompliantHighCount: \(String(describing: nonCompliantHighCount)), nonCompliantInformationalCount: \(String(describing: nonCompliantInformationalCount)), nonCompliantLowCount: \(String(describing: nonCompliantLowCount)), nonCompliantMediumCount: \(String(describing: nonCompliantMediumCount)), nonCompliantUnspecifiedCount: \(String(describing: nonCompliantUnspecifiedCount)), overallSeverity: \(String(describing: overallSeverity)), patchBaselineId: \(String(describing: patchBaselineId)), patchGroup: \(String(describing: patchGroup)), status: \(String(describing: status)))"}
}

/// <p>Provides the details about the compliance status for a patch.</p>
public struct AwsSsmComplianceSummary: Equatable {
    /// <p>The type of resource for which the compliance was determined. For
    ///             <code>AwsSsmPatchCompliance</code>, <code>ComplianceType</code> is <code>Patch</code>. </p>
    public let complianceType: String?
    /// <p>For the patches that are compliant, the number that have a severity of
    ///             <code>CRITICAL</code>.</p>
    public let compliantCriticalCount: Int
    /// <p>For the patches that are compliant, the number that have a severity of
    ///          <code>HIGH</code>.</p>
    public let compliantHighCount: Int
    /// <p>For the patches that are compliant, the number that have a severity of
    ///             <code>INFORMATIONAL</code>.</p>
    public let compliantInformationalCount: Int
    /// <p>For the patches that are compliant, the number that have a severity of
    ///          <code>LOW</code>.</p>
    public let compliantLowCount: Int
    /// <p>For the patches that are compliant, the number that have a severity of
    ///             <code>MEDIUM</code>.</p>
    public let compliantMediumCount: Int
    /// <p>For the patches that are compliant, the number that have a severity of
    ///             <code>UNSPECIFIED</code>.</p>
    public let compliantUnspecifiedCount: Int
    /// <p>The type of execution that was used determine compliance.</p>
    public let executionType: String?
    /// <p>For the patch items that are noncompliant, the number of items that have a severity of
    ///             <code>CRITICAL</code>.</p>
    public let nonCompliantCriticalCount: Int
    /// <p>For the patches that are noncompliant, the number that have a severity of
    ///             <code>HIGH</code>.</p>
    public let nonCompliantHighCount: Int
    /// <p>For the patches that are noncompliant, the number that have a severity of
    ///             <code>INFORMATIONAL</code>.</p>
    public let nonCompliantInformationalCount: Int
    /// <p>For the patches that are noncompliant, the number that have a severity of
    ///             <code>LOW</code>.</p>
    public let nonCompliantLowCount: Int
    /// <p>For the patches that are noncompliant, the number that have a severity of
    ///             <code>MEDIUM</code>.</p>
    public let nonCompliantMediumCount: Int
    /// <p>For the patches that are noncompliant, the number that have a severity of
    ///             <code>UNSPECIFIED</code>.</p>
    public let nonCompliantUnspecifiedCount: Int
    /// <p>The highest severity for the patches.</p>
    public let overallSeverity: String?
    /// <p>The identifier of the patch baseline. The patch baseline lists the patches that are
    ///          approved for installation.</p>
    public let patchBaselineId: String?
    /// <p>The identifier of the patch group for which compliance was determined. A patch group
    ///          uses tags to group EC2 instances that should have the same patch compliance.</p>
    public let patchGroup: String?
    /// <p>The current patch compliance status.</p>
    ///          <p>The possible status values are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>COMPLIANT</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NON_COMPLIANT</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UNSPECIFIED_DATA</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        complianceType: String? = nil,
        compliantCriticalCount: Int = 0,
        compliantHighCount: Int = 0,
        compliantInformationalCount: Int = 0,
        compliantLowCount: Int = 0,
        compliantMediumCount: Int = 0,
        compliantUnspecifiedCount: Int = 0,
        executionType: String? = nil,
        nonCompliantCriticalCount: Int = 0,
        nonCompliantHighCount: Int = 0,
        nonCompliantInformationalCount: Int = 0,
        nonCompliantLowCount: Int = 0,
        nonCompliantMediumCount: Int = 0,
        nonCompliantUnspecifiedCount: Int = 0,
        overallSeverity: String? = nil,
        patchBaselineId: String? = nil,
        patchGroup: String? = nil,
        status: String? = nil
    )
    {
        self.complianceType = complianceType
        self.compliantCriticalCount = compliantCriticalCount
        self.compliantHighCount = compliantHighCount
        self.compliantInformationalCount = compliantInformationalCount
        self.compliantLowCount = compliantLowCount
        self.compliantMediumCount = compliantMediumCount
        self.compliantUnspecifiedCount = compliantUnspecifiedCount
        self.executionType = executionType
        self.nonCompliantCriticalCount = nonCompliantCriticalCount
        self.nonCompliantHighCount = nonCompliantHighCount
        self.nonCompliantInformationalCount = nonCompliantInformationalCount
        self.nonCompliantLowCount = nonCompliantLowCount
        self.nonCompliantMediumCount = nonCompliantMediumCount
        self.nonCompliantUnspecifiedCount = nonCompliantUnspecifiedCount
        self.overallSeverity = overallSeverity
        self.patchBaselineId = patchBaselineId
        self.patchGroup = patchGroup
        self.status = status
    }
}

extension AwsSsmPatch: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceSummary = "ComplianceSummary"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceSummary = complianceSummary {
            try encodeContainer.encode(complianceSummary, forKey: .complianceSummary)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceSummaryDecoded = try containerValues.decodeIfPresent(AwsSsmComplianceSummary.self, forKey: .complianceSummary)
        complianceSummary = complianceSummaryDecoded
    }
}

extension AwsSsmPatch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsSsmPatch(complianceSummary: \(String(describing: complianceSummary)))"}
}

/// <p>Provides details about the compliance for a patch.</p>
public struct AwsSsmPatch: Equatable {
    /// <p>The compliance status details for the patch.</p>
    public let complianceSummary: AwsSsmComplianceSummary?

    public init (
        complianceSummary: AwsSsmComplianceSummary? = nil
    )
    {
        self.complianceSummary = complianceSummary
    }
}

extension AwsSsmPatchComplianceDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patch = "Patch"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patch = patch {
            try encodeContainer.encode(patch, forKey: .patch)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchDecoded = try containerValues.decodeIfPresent(AwsSsmPatch.self, forKey: .patch)
        patch = patchDecoded
    }
}

extension AwsSsmPatchComplianceDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsSsmPatchComplianceDetails(patch: \(String(describing: patch)))"}
}

/// <p>Provides information about the state of a patch on an instance based on the patch
///          baseline that was used to patch the instance.</p>
public struct AwsSsmPatchComplianceDetails: Equatable {
    /// <p>Information about the status of a patch.</p>
    public let patch: AwsSsmPatch?

    public init (
        patch: AwsSsmPatch? = nil
    )
    {
        self.patch = patch
    }
}

extension AwsWafWebAclDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultAction = "DefaultAction"
        case name = "Name"
        case rules = "Rules"
        case webAclId = "WebAclId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultAction = defaultAction {
            try encodeContainer.encode(defaultAction, forKey: .defaultAction)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for awswafwebaclrulelist0 in rules {
                try rulesContainer.encode(awswafwebaclrulelist0)
            }
        }
        if let webAclId = webAclId {
            try encodeContainer.encode(webAclId, forKey: .webAclId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let defaultActionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([AwsWafWebAclRule?].self, forKey: .rules)
        var rulesDecoded0:[AwsWafWebAclRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [AwsWafWebAclRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let webAclIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webAclId)
        webAclId = webAclIdDecoded
    }
}

extension AwsWafWebAclDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsWafWebAclDetails(defaultAction: \(String(describing: defaultAction)), name: \(String(describing: name)), rules: \(String(describing: rules)), webAclId: \(String(describing: webAclId)))"}
}

/// <p>Details about a WAF WebACL.</p>
public struct AwsWafWebAclDetails: Equatable {
    /// <p>The action to perform if none of the rules contained in the WebACL match.</p>
    public let defaultAction: String?
    /// <p>A friendly name or description of the WebACL. You can't change the name of a WebACL
    ///          after you create it.</p>
    public let name: String?
    /// <p>An array that contains the action for each rule in a WebACL, the priority of the rule,
    ///          and the ID of the rule.</p>
    public let rules: [AwsWafWebAclRule]?
    /// <p>A unique identifier for a WebACL.</p>
    public let webAclId: String?

    public init (
        defaultAction: String? = nil,
        name: String? = nil,
        rules: [AwsWafWebAclRule]? = nil,
        webAclId: String? = nil
    )
    {
        self.defaultAction = defaultAction
        self.name = name
        self.rules = rules
        self.webAclId = webAclId
    }
}

extension AwsWafWebAclRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case excludedRules = "ExcludedRules"
        case overrideAction = "OverrideAction"
        case priority = "Priority"
        case ruleId = "RuleId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let excludedRules = excludedRules {
            var excludedRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludedRules)
            for wafexcludedrulelist0 in excludedRules {
                try excludedRulesContainer.encode(wafexcludedrulelist0)
            }
        }
        if let overrideAction = overrideAction {
            try encodeContainer.encode(overrideAction, forKey: .overrideAction)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(WafAction.self, forKey: .action)
        action = actionDecoded
        let excludedRulesContainer = try containerValues.decodeIfPresent([WafExcludedRule?].self, forKey: .excludedRules)
        var excludedRulesDecoded0:[WafExcludedRule]? = nil
        if let excludedRulesContainer = excludedRulesContainer {
            excludedRulesDecoded0 = [WafExcludedRule]()
            for structure0 in excludedRulesContainer {
                if let structure0 = structure0 {
                    excludedRulesDecoded0?.append(structure0)
                }
            }
        }
        excludedRules = excludedRulesDecoded0
        let overrideActionDecoded = try containerValues.decodeIfPresent(WafOverrideAction.self, forKey: .overrideAction)
        overrideAction = overrideActionDecoded
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension AwsWafWebAclRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsWafWebAclRule(action: \(String(describing: action)), excludedRules: \(String(describing: excludedRules)), overrideAction: \(String(describing: overrideAction)), priority: \(String(describing: priority)), ruleId: \(String(describing: ruleId)), type: \(String(describing: type)))"}
}

/// <p>Details for a rule in a WAF WebACL.</p>
public struct AwsWafWebAclRule: Equatable {
    /// <p>Specifies the action that CloudFront or AWS WAF takes when a web request matches the
    ///          conditions in the rule. </p>
    public let action: WafAction?
    /// <p>Rules to exclude from a rule group.</p>
    public let excludedRules: [WafExcludedRule]?
    /// <p>Use the <code>OverrideAction</code> to test your RuleGroup.</p>
    ///          <p>Any rule in a RuleGroup can potentially block a request. If you set the
    ///             <code>OverrideAction</code> to <code>None</code>, the RuleGroup blocks a request if any
    ///          individual rule in the RuleGroup matches the request and is configured to block that
    ///          request.</p>
    ///          <p>However, if you first want to test the RuleGroup, set the <code>OverrideAction</code> to
    ///             <code>Count</code>. The RuleGroup then overrides any block action specified by
    ///          individual rules contained within the group. Instead of blocking matching requests, those
    ///          requests are counted.</p>
    ///          <p>
    ///             <code>ActivatedRule</code>|<code>OverrideAction</code> applies only when updating or
    ///          adding a RuleGroup to a WebACL. In this case you do not use
    ///             <code>ActivatedRule</code>|<code>Action</code>. For all other update requests,
    ///             <code>ActivatedRule</code>|<code>Action</code> is used instead of
    ///             <code>ActivatedRule</code>|<code>OverrideAction</code>. </p>
    public let overrideAction: WafOverrideAction?
    /// <p>Specifies the order in which the rules in a WebACL are evaluated. Rules with a lower
    ///          value for <code>Priority</code> are evaluated before rules with a higher value. The value
    ///          must be a unique integer. If you add multiple rules to a WebACL, the values do not need to
    ///          be consecutive.</p>
    public let priority: Int
    /// <p>The identifier for a rule.</p>
    public let ruleId: String?
    /// <p>The rule type.</p>
    ///          <p>Valid values: <code>REGULAR</code> | <code>RATE_BASED</code> | <code>GROUP</code>
    ///          </p>
    ///          <p>The default is <code>REGULAR</code>.</p>
    public let type: String?

    public init (
        action: WafAction? = nil,
        excludedRules: [WafExcludedRule]? = nil,
        overrideAction: WafOverrideAction? = nil,
        priority: Int = 0,
        ruleId: String? = nil,
        type: String? = nil
    )
    {
        self.action = action
        self.excludedRules = excludedRules
        self.overrideAction = overrideAction
        self.priority = priority
        self.ruleId = ruleId
        self.type = type
    }
}

public struct BatchDisableStandardsInputBodyMiddleware: Middleware {
    public let id: String = "BatchDisableStandardsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisableStandardsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisableStandardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisableStandardsInput>
    public typealias MOutput = OperationOutput<BatchDisableStandardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisableStandardsOutputError>
}

extension BatchDisableStandardsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDisableStandardsInput(standardsSubscriptionArns: \(String(describing: standardsSubscriptionArns)))"}
}

extension BatchDisableStandardsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case standardsSubscriptionArns = "StandardsSubscriptionArns"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let standardsSubscriptionArns = standardsSubscriptionArns {
            var standardsSubscriptionArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .standardsSubscriptionArns)
            for standardssubscriptionarns0 in standardsSubscriptionArns {
                try standardsSubscriptionArnsContainer.encode(standardssubscriptionarns0)
            }
        }
    }
}

public struct BatchDisableStandardsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDisableStandardsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisableStandardsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisableStandardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisableStandardsInput>
    public typealias MOutput = OperationOutput<BatchDisableStandardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisableStandardsOutputError>
}

public struct BatchDisableStandardsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDisableStandardsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisableStandardsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisableStandardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisableStandardsInput>
    public typealias MOutput = OperationOutput<BatchDisableStandardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisableStandardsOutputError>
}

public struct BatchDisableStandardsInput: Equatable {
    /// <p>The ARNs of the standards subscriptions to disable.</p>
    public let standardsSubscriptionArns: [String]?

    public init (
        standardsSubscriptionArns: [String]? = nil
    )
    {
        self.standardsSubscriptionArns = standardsSubscriptionArns
    }
}

struct BatchDisableStandardsInputBody: Equatable {
    public let standardsSubscriptionArns: [String]?
}

extension BatchDisableStandardsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case standardsSubscriptionArns = "StandardsSubscriptionArns"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsSubscriptionArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .standardsSubscriptionArns)
        var standardsSubscriptionArnsDecoded0:[String]? = nil
        if let standardsSubscriptionArnsContainer = standardsSubscriptionArnsContainer {
            standardsSubscriptionArnsDecoded0 = [String]()
            for string0 in standardsSubscriptionArnsContainer {
                if let string0 = string0 {
                    standardsSubscriptionArnsDecoded0?.append(string0)
                }
            }
        }
        standardsSubscriptionArns = standardsSubscriptionArnsDecoded0
    }
}

extension BatchDisableStandardsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisableStandardsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDisableStandardsOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisableStandardsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDisableStandardsOutputResponse(standardsSubscriptions: \(String(describing: standardsSubscriptions)))"}
}

extension BatchDisableStandardsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDisableStandardsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.standardsSubscriptions = output.standardsSubscriptions
        } else {
            self.standardsSubscriptions = nil
        }
    }
}

public struct BatchDisableStandardsOutputResponse: Equatable {
    /// <p>The details of the standards subscriptions that were disabled.</p>
    public let standardsSubscriptions: [StandardsSubscription]?

    public init (
        standardsSubscriptions: [StandardsSubscription]? = nil
    )
    {
        self.standardsSubscriptions = standardsSubscriptions
    }
}

struct BatchDisableStandardsOutputResponseBody: Equatable {
    public let standardsSubscriptions: [StandardsSubscription]?
}

extension BatchDisableStandardsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case standardsSubscriptions = "StandardsSubscriptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsSubscriptionsContainer = try containerValues.decodeIfPresent([StandardsSubscription?].self, forKey: .standardsSubscriptions)
        var standardsSubscriptionsDecoded0:[StandardsSubscription]? = nil
        if let standardsSubscriptionsContainer = standardsSubscriptionsContainer {
            standardsSubscriptionsDecoded0 = [StandardsSubscription]()
            for structure0 in standardsSubscriptionsContainer {
                if let structure0 = structure0 {
                    standardsSubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        standardsSubscriptions = standardsSubscriptionsDecoded0
    }
}

public struct BatchEnableStandardsInputBodyMiddleware: Middleware {
    public let id: String = "BatchEnableStandardsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchEnableStandardsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchEnableStandardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchEnableStandardsInput>
    public typealias MOutput = OperationOutput<BatchEnableStandardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchEnableStandardsOutputError>
}

extension BatchEnableStandardsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchEnableStandardsInput(standardsSubscriptionRequests: \(String(describing: standardsSubscriptionRequests)))"}
}

extension BatchEnableStandardsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case standardsSubscriptionRequests = "StandardsSubscriptionRequests"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let standardsSubscriptionRequests = standardsSubscriptionRequests {
            var standardsSubscriptionRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .standardsSubscriptionRequests)
            for standardssubscriptionrequests0 in standardsSubscriptionRequests {
                try standardsSubscriptionRequestsContainer.encode(standardssubscriptionrequests0)
            }
        }
    }
}

public struct BatchEnableStandardsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchEnableStandardsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchEnableStandardsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchEnableStandardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchEnableStandardsInput>
    public typealias MOutput = OperationOutput<BatchEnableStandardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchEnableStandardsOutputError>
}

public struct BatchEnableStandardsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchEnableStandardsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchEnableStandardsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchEnableStandardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchEnableStandardsInput>
    public typealias MOutput = OperationOutput<BatchEnableStandardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchEnableStandardsOutputError>
}

public struct BatchEnableStandardsInput: Equatable {
    /// <p>The list of standards checks to enable.</p>
    public let standardsSubscriptionRequests: [StandardsSubscriptionRequest]?

    public init (
        standardsSubscriptionRequests: [StandardsSubscriptionRequest]? = nil
    )
    {
        self.standardsSubscriptionRequests = standardsSubscriptionRequests
    }
}

struct BatchEnableStandardsInputBody: Equatable {
    public let standardsSubscriptionRequests: [StandardsSubscriptionRequest]?
}

extension BatchEnableStandardsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case standardsSubscriptionRequests = "StandardsSubscriptionRequests"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsSubscriptionRequestsContainer = try containerValues.decodeIfPresent([StandardsSubscriptionRequest?].self, forKey: .standardsSubscriptionRequests)
        var standardsSubscriptionRequestsDecoded0:[StandardsSubscriptionRequest]? = nil
        if let standardsSubscriptionRequestsContainer = standardsSubscriptionRequestsContainer {
            standardsSubscriptionRequestsDecoded0 = [StandardsSubscriptionRequest]()
            for structure0 in standardsSubscriptionRequestsContainer {
                if let structure0 = structure0 {
                    standardsSubscriptionRequestsDecoded0?.append(structure0)
                }
            }
        }
        standardsSubscriptionRequests = standardsSubscriptionRequestsDecoded0
    }
}

extension BatchEnableStandardsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchEnableStandardsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchEnableStandardsOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchEnableStandardsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchEnableStandardsOutputResponse(standardsSubscriptions: \(String(describing: standardsSubscriptions)))"}
}

extension BatchEnableStandardsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchEnableStandardsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.standardsSubscriptions = output.standardsSubscriptions
        } else {
            self.standardsSubscriptions = nil
        }
    }
}

public struct BatchEnableStandardsOutputResponse: Equatable {
    /// <p>The details of the standards subscriptions that were enabled.</p>
    public let standardsSubscriptions: [StandardsSubscription]?

    public init (
        standardsSubscriptions: [StandardsSubscription]? = nil
    )
    {
        self.standardsSubscriptions = standardsSubscriptions
    }
}

struct BatchEnableStandardsOutputResponseBody: Equatable {
    public let standardsSubscriptions: [StandardsSubscription]?
}

extension BatchEnableStandardsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case standardsSubscriptions = "StandardsSubscriptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsSubscriptionsContainer = try containerValues.decodeIfPresent([StandardsSubscription?].self, forKey: .standardsSubscriptions)
        var standardsSubscriptionsDecoded0:[StandardsSubscription]? = nil
        if let standardsSubscriptionsContainer = standardsSubscriptionsContainer {
            standardsSubscriptionsDecoded0 = [StandardsSubscription]()
            for structure0 in standardsSubscriptionsContainer {
                if let structure0 = structure0 {
                    standardsSubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        standardsSubscriptions = standardsSubscriptionsDecoded0
    }
}

public struct BatchImportFindingsInputBodyMiddleware: Middleware {
    public let id: String = "BatchImportFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchImportFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchImportFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchImportFindingsInput>
    public typealias MOutput = OperationOutput<BatchImportFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchImportFindingsOutputError>
}

extension BatchImportFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchImportFindingsInput(findings: \(String(describing: findings)))"}
}

extension BatchImportFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case findings = "Findings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findings = findings {
            var findingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findings)
            for batchimportfindingsrequestfindinglist0 in findings {
                try findingsContainer.encode(batchimportfindingsrequestfindinglist0)
            }
        }
    }
}

public struct BatchImportFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchImportFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchImportFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchImportFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchImportFindingsInput>
    public typealias MOutput = OperationOutput<BatchImportFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchImportFindingsOutputError>
}

public struct BatchImportFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchImportFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchImportFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchImportFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchImportFindingsInput>
    public typealias MOutput = OperationOutput<BatchImportFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchImportFindingsOutputError>
}

public struct BatchImportFindingsInput: Equatable {
    /// <p>A list of findings to import. To successfully import a finding, it must follow the
    ///             <a href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-findings-format.html">AWS Security Finding Format</a>. Maximum of 100 findings per request.</p>
    public let findings: [AwsSecurityFinding]?

    public init (
        findings: [AwsSecurityFinding]? = nil
    )
    {
        self.findings = findings
    }
}

struct BatchImportFindingsInputBody: Equatable {
    public let findings: [AwsSecurityFinding]?
}

extension BatchImportFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findings = "Findings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([AwsSecurityFinding?].self, forKey: .findings)
        var findingsDecoded0:[AwsSecurityFinding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [AwsSecurityFinding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
    }
}

extension BatchImportFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchImportFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchImportFindingsOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchImportFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchImportFindingsOutputResponse(failedCount: \(String(describing: failedCount)), failedFindings: \(String(describing: failedFindings)), successCount: \(String(describing: successCount)))"}
}

extension BatchImportFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchImportFindingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedCount = output.failedCount
            self.failedFindings = output.failedFindings
            self.successCount = output.successCount
        } else {
            self.failedCount = 0
            self.failedFindings = nil
            self.successCount = 0
        }
    }
}

public struct BatchImportFindingsOutputResponse: Equatable {
    /// <p>The number of findings that failed to import.</p>
    public let failedCount: Int
    /// <p>The list of findings that failed to import.</p>
    public let failedFindings: [ImportFindingsError]?
    /// <p>The number of findings that were successfully imported.</p>
    public let successCount: Int

    public init (
        failedCount: Int = 0,
        failedFindings: [ImportFindingsError]? = nil,
        successCount: Int = 0
    )
    {
        self.failedCount = failedCount
        self.failedFindings = failedFindings
        self.successCount = successCount
    }
}

struct BatchImportFindingsOutputResponseBody: Equatable {
    public let failedCount: Int
    public let successCount: Int
    public let failedFindings: [ImportFindingsError]?
}

extension BatchImportFindingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedCount = "FailedCount"
        case failedFindings = "FailedFindings"
        case successCount = "SuccessCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedCountDecoded = try containerValues.decode(Int.self, forKey: .failedCount)
        failedCount = failedCountDecoded
        let successCountDecoded = try containerValues.decode(Int.self, forKey: .successCount)
        successCount = successCountDecoded
        let failedFindingsContainer = try containerValues.decodeIfPresent([ImportFindingsError?].self, forKey: .failedFindings)
        var failedFindingsDecoded0:[ImportFindingsError]? = nil
        if let failedFindingsContainer = failedFindingsContainer {
            failedFindingsDecoded0 = [ImportFindingsError]()
            for structure0 in failedFindingsContainer {
                if let structure0 = structure0 {
                    failedFindingsDecoded0?.append(structure0)
                }
            }
        }
        failedFindings = failedFindingsDecoded0
    }
}

public struct BatchUpdateFindingsInputBodyMiddleware: Middleware {
    public let id: String = "BatchUpdateFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchUpdateFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchUpdateFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchUpdateFindingsInput>
    public typealias MOutput = OperationOutput<BatchUpdateFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchUpdateFindingsOutputError>
}

extension BatchUpdateFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchUpdateFindingsInput(confidence: \(String(describing: confidence)), criticality: \(String(describing: criticality)), findingIdentifiers: \(String(describing: findingIdentifiers)), note: \(String(describing: note)), relatedFindings: \(String(describing: relatedFindings)), severity: \(String(describing: severity)), types: \(String(describing: types)), userDefinedFields: \(String(describing: userDefinedFields)), verificationState: \(String(describing: verificationState)), workflow: \(String(describing: workflow)))"}
}

extension BatchUpdateFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case confidence = "Confidence"
        case criticality = "Criticality"
        case findingIdentifiers = "FindingIdentifiers"
        case note = "Note"
        case relatedFindings = "RelatedFindings"
        case severity = "Severity"
        case types = "Types"
        case userDefinedFields = "UserDefinedFields"
        case verificationState = "VerificationState"
        case workflow = "Workflow"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if confidence != 0 {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if criticality != 0 {
            try encodeContainer.encode(criticality, forKey: .criticality)
        }
        if let findingIdentifiers = findingIdentifiers {
            var findingIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIdentifiers)
            for awssecurityfindingidentifierlist0 in findingIdentifiers {
                try findingIdentifiersContainer.encode(awssecurityfindingidentifierlist0)
            }
        }
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let relatedFindings = relatedFindings {
            var relatedFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedFindings)
            for relatedfindinglist0 in relatedFindings {
                try relatedFindingsContainer.encode(relatedfindinglist0)
            }
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let types = types {
            var typesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .types)
            for typelist0 in types {
                try typesContainer.encode(typelist0)
            }
        }
        if let userDefinedFields = userDefinedFields {
            var userDefinedFieldsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .userDefinedFields)
            for (dictKey0, fieldmap0) in userDefinedFields {
                try userDefinedFieldsContainer.encode(fieldmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let verificationState = verificationState {
            try encodeContainer.encode(verificationState.rawValue, forKey: .verificationState)
        }
        if let workflow = workflow {
            try encodeContainer.encode(workflow, forKey: .workflow)
        }
    }
}

public struct BatchUpdateFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchUpdateFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchUpdateFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchUpdateFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchUpdateFindingsInput>
    public typealias MOutput = OperationOutput<BatchUpdateFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchUpdateFindingsOutputError>
}

public struct BatchUpdateFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchUpdateFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchUpdateFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchUpdateFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchUpdateFindingsInput>
    public typealias MOutput = OperationOutput<BatchUpdateFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchUpdateFindingsOutputError>
}

public struct BatchUpdateFindingsInput: Equatable {
    /// <p>The updated value for the finding confidence. Confidence is defined as the likelihood
    ///          that a finding accurately identifies the behavior or issue that it was intended to
    ///          identify.</p>
    ///          <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent
    ///          confidence and 100 means 100 percent confidence.</p>
    public let confidence: Int
    /// <p>The updated value for the level of importance assigned to the resources associated with
    ///          the findings.</p>
    ///          <p>A score of 0 means that the underlying resources have no criticality, and a score of 100
    ///          is reserved for the most critical resources. </p>
    public let criticality: Int
    /// <p>The list of findings to update. <code>BatchUpdateFindings</code> can be used to update
    ///          up to 100 findings at a time.</p>
    ///          <p>For each finding, the list provides the finding identifier and the ARN of the finding
    ///          provider.</p>
    public let findingIdentifiers: [AwsSecurityFindingIdentifier]?
    /// <p>The updated note.</p>
    public let note: NoteUpdate?
    /// <p>A list of findings that are related to the updated findings.</p>
    public let relatedFindings: [RelatedFinding]?
    /// <p>Used to update the finding severity.</p>
    public let severity: SeverityUpdate?
    /// <p>One or more finding types in the format of namespace/category/classifier that classify a
    ///          finding.</p>
    ///          <p>Valid namespace values are as follows.</p>
    ///          <ul>
    ///             <li>
    ///                <p>Software and Configuration Checks</p>
    ///             </li>
    ///             <li>
    ///                <p>TTPs</p>
    ///             </li>
    ///             <li>
    ///                <p>Effects</p>
    ///             </li>
    ///             <li>
    ///                <p>Unusual Behaviors</p>
    ///             </li>
    ///             <li>
    ///                <p>Sensitive Data Identifications </p>
    ///             </li>
    ///          </ul>
    public let types: [String]?
    /// <p>A list of name/value string pairs associated with the finding. These are custom,
    ///          user-defined fields added to a finding.</p>
    public let userDefinedFields: [String:String]?
    /// <p>Indicates the veracity of a finding.</p>
    ///          <p>The available values for <code>VerificationState</code> are  as follows.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>UNKNOWN</code> – The default disposition of a security finding</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TRUE_POSITIVE</code> – The security finding is confirmed</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FALSE_POSITIVE</code> – The security finding was determined to be a false
    ///                alarm</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>BENIGN_POSITIVE</code> – A special case of <code>TRUE_POSITIVE</code> where
    ///                the finding doesn't pose any threat, is expected, or both</p>
    ///             </li>
    ///          </ul>
    public let verificationState: VerificationState?
    /// <p>Used to update the workflow status of a finding.</p>
    ///          <p>The workflow status indicates the progress of the investigation into the finding. </p>
    public let workflow: WorkflowUpdate?

    public init (
        confidence: Int = 0,
        criticality: Int = 0,
        findingIdentifiers: [AwsSecurityFindingIdentifier]? = nil,
        note: NoteUpdate? = nil,
        relatedFindings: [RelatedFinding]? = nil,
        severity: SeverityUpdate? = nil,
        types: [String]? = nil,
        userDefinedFields: [String:String]? = nil,
        verificationState: VerificationState? = nil,
        workflow: WorkflowUpdate? = nil
    )
    {
        self.confidence = confidence
        self.criticality = criticality
        self.findingIdentifiers = findingIdentifiers
        self.note = note
        self.relatedFindings = relatedFindings
        self.severity = severity
        self.types = types
        self.userDefinedFields = userDefinedFields
        self.verificationState = verificationState
        self.workflow = workflow
    }
}

struct BatchUpdateFindingsInputBody: Equatable {
    public let findingIdentifiers: [AwsSecurityFindingIdentifier]?
    public let note: NoteUpdate?
    public let severity: SeverityUpdate?
    public let verificationState: VerificationState?
    public let confidence: Int
    public let criticality: Int
    public let types: [String]?
    public let userDefinedFields: [String:String]?
    public let workflow: WorkflowUpdate?
    public let relatedFindings: [RelatedFinding]?
}

extension BatchUpdateFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case confidence = "Confidence"
        case criticality = "Criticality"
        case findingIdentifiers = "FindingIdentifiers"
        case note = "Note"
        case relatedFindings = "RelatedFindings"
        case severity = "Severity"
        case types = "Types"
        case userDefinedFields = "UserDefinedFields"
        case verificationState = "VerificationState"
        case workflow = "Workflow"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdentifiersContainer = try containerValues.decodeIfPresent([AwsSecurityFindingIdentifier?].self, forKey: .findingIdentifiers)
        var findingIdentifiersDecoded0:[AwsSecurityFindingIdentifier]? = nil
        if let findingIdentifiersContainer = findingIdentifiersContainer {
            findingIdentifiersDecoded0 = [AwsSecurityFindingIdentifier]()
            for structure0 in findingIdentifiersContainer {
                if let structure0 = structure0 {
                    findingIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        findingIdentifiers = findingIdentifiersDecoded0
        let noteDecoded = try containerValues.decodeIfPresent(NoteUpdate.self, forKey: .note)
        note = noteDecoded
        let severityDecoded = try containerValues.decodeIfPresent(SeverityUpdate.self, forKey: .severity)
        severity = severityDecoded
        let verificationStateDecoded = try containerValues.decodeIfPresent(VerificationState.self, forKey: .verificationState)
        verificationState = verificationStateDecoded
        let confidenceDecoded = try containerValues.decode(Int.self, forKey: .confidence)
        confidence = confidenceDecoded
        let criticalityDecoded = try containerValues.decode(Int.self, forKey: .criticality)
        criticality = criticalityDecoded
        let typesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .types)
        var typesDecoded0:[String]? = nil
        if let typesContainer = typesContainer {
            typesDecoded0 = [String]()
            for string0 in typesContainer {
                if let string0 = string0 {
                    typesDecoded0?.append(string0)
                }
            }
        }
        types = typesDecoded0
        let userDefinedFieldsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .userDefinedFields)
        var userDefinedFieldsDecoded0: [String:String]? = nil
        if let userDefinedFieldsContainer = userDefinedFieldsContainer {
            userDefinedFieldsDecoded0 = [String:String]()
            for (key0, nonemptystring0) in userDefinedFieldsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    userDefinedFieldsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        userDefinedFields = userDefinedFieldsDecoded0
        let workflowDecoded = try containerValues.decodeIfPresent(WorkflowUpdate.self, forKey: .workflow)
        workflow = workflowDecoded
        let relatedFindingsContainer = try containerValues.decodeIfPresent([RelatedFinding?].self, forKey: .relatedFindings)
        var relatedFindingsDecoded0:[RelatedFinding]? = nil
        if let relatedFindingsContainer = relatedFindingsContainer {
            relatedFindingsDecoded0 = [RelatedFinding]()
            for structure0 in relatedFindingsContainer {
                if let structure0 = structure0 {
                    relatedFindingsDecoded0?.append(structure0)
                }
            }
        }
        relatedFindings = relatedFindingsDecoded0
    }
}

extension BatchUpdateFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchUpdateFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchUpdateFindingsOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchUpdateFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchUpdateFindingsOutputResponse(processedFindings: \(String(describing: processedFindings)), unprocessedFindings: \(String(describing: unprocessedFindings)))"}
}

extension BatchUpdateFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchUpdateFindingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.processedFindings = output.processedFindings
            self.unprocessedFindings = output.unprocessedFindings
        } else {
            self.processedFindings = nil
            self.unprocessedFindings = nil
        }
    }
}

public struct BatchUpdateFindingsOutputResponse: Equatable {
    /// <p>The list of findings that were updated successfully.</p>
    public let processedFindings: [AwsSecurityFindingIdentifier]?
    /// <p>The list of findings that were not updated.</p>
    public let unprocessedFindings: [BatchUpdateFindingsUnprocessedFinding]?

    public init (
        processedFindings: [AwsSecurityFindingIdentifier]? = nil,
        unprocessedFindings: [BatchUpdateFindingsUnprocessedFinding]? = nil
    )
    {
        self.processedFindings = processedFindings
        self.unprocessedFindings = unprocessedFindings
    }
}

struct BatchUpdateFindingsOutputResponseBody: Equatable {
    public let processedFindings: [AwsSecurityFindingIdentifier]?
    public let unprocessedFindings: [BatchUpdateFindingsUnprocessedFinding]?
}

extension BatchUpdateFindingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case processedFindings = "ProcessedFindings"
        case unprocessedFindings = "UnprocessedFindings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let processedFindingsContainer = try containerValues.decodeIfPresent([AwsSecurityFindingIdentifier?].self, forKey: .processedFindings)
        var processedFindingsDecoded0:[AwsSecurityFindingIdentifier]? = nil
        if let processedFindingsContainer = processedFindingsContainer {
            processedFindingsDecoded0 = [AwsSecurityFindingIdentifier]()
            for structure0 in processedFindingsContainer {
                if let structure0 = structure0 {
                    processedFindingsDecoded0?.append(structure0)
                }
            }
        }
        processedFindings = processedFindingsDecoded0
        let unprocessedFindingsContainer = try containerValues.decodeIfPresent([BatchUpdateFindingsUnprocessedFinding?].self, forKey: .unprocessedFindings)
        var unprocessedFindingsDecoded0:[BatchUpdateFindingsUnprocessedFinding]? = nil
        if let unprocessedFindingsContainer = unprocessedFindingsContainer {
            unprocessedFindingsDecoded0 = [BatchUpdateFindingsUnprocessedFinding]()
            for structure0 in unprocessedFindingsContainer {
                if let structure0 = structure0 {
                    unprocessedFindingsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedFindings = unprocessedFindingsDecoded0
    }
}

extension BatchUpdateFindingsUnprocessedFinding: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case findingIdentifier = "FindingIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let findingIdentifier = findingIdentifier {
            try encodeContainer.encode(findingIdentifier, forKey: .findingIdentifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdentifierDecoded = try containerValues.decodeIfPresent(AwsSecurityFindingIdentifier.self, forKey: .findingIdentifier)
        findingIdentifier = findingIdentifierDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension BatchUpdateFindingsUnprocessedFinding: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchUpdateFindingsUnprocessedFinding(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), findingIdentifier: \(String(describing: findingIdentifier)))"}
}

/// <p>A finding from a <code>BatchUpdateFindings</code> request that Security Hub was unable to
///          update.</p>
public struct BatchUpdateFindingsUnprocessedFinding: Equatable {
    /// <p>The code associated with the error.</p>
    public let errorCode: String?
    /// <p>The message associated with the error.</p>
    public let errorMessage: String?
    /// <p>The identifier of the finding that was not updated.</p>
    public let findingIdentifier: AwsSecurityFindingIdentifier?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        findingIdentifier: AwsSecurityFindingIdentifier? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.findingIdentifier = findingIdentifier
    }
}

extension Cell: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cellReference = "CellReference"
        case column = "Column"
        case columnName = "ColumnName"
        case row = "Row"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cellReference = cellReference {
            try encodeContainer.encode(cellReference, forKey: .cellReference)
        }
        if column != 0 {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let columnName = columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if row != 0 {
            try encodeContainer.encode(row, forKey: .row)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnDecoded = try containerValues.decode(Int.self, forKey: .column)
        column = columnDecoded
        let rowDecoded = try containerValues.decode(Int.self, forKey: .row)
        row = rowDecoded
        let columnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let cellReferenceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cellReference)
        cellReference = cellReferenceDecoded
    }
}

extension Cell: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Cell(cellReference: \(String(describing: cellReference)), column: \(String(describing: column)), columnName: \(String(describing: columnName)), row: \(String(describing: row)))"}
}

/// <p>An occurrence of sensitive data detected in a Microsoft Excel workbook, comma-separated value (CSV) file, or tab-separated value (TSV) file.</p>
public struct Cell: Equatable {
    /// <p>For a Microsoft Excel workbook, provides the location of the cell, as an absolute cell reference, that contains the data. For example, Sheet2!C5 for cell C5 on Sheet2.</p>
    public let cellReference: String?
    /// <p>The column number of the column that contains the data. For a Microsoft Excel workbook, the column number corresponds to the alphabetical column identifiers. For example, a value of 1 for Column corresponds to the A column in the workbook.</p>
    public let column: Int
    /// <p>The name of the column that contains the data.</p>
    public let columnName: String?
    /// <p>The row number of the row that contains the data.</p>
    public let row: Int

    public init (
        cellReference: String? = nil,
        column: Int = 0,
        columnName: String? = nil,
        row: Int = 0
    )
    {
        self.cellReference = cellReference
        self.column = column
        self.columnName = columnName
        self.row = row
    }
}

extension CidrBlockAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case cidrBlock = "CidrBlock"
        case cidrBlockState = "CidrBlockState"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let cidrBlock = cidrBlock {
            try encodeContainer.encode(cidrBlock, forKey: .cidrBlock)
        }
        if let cidrBlockState = cidrBlockState {
            try encodeContainer.encode(cidrBlockState, forKey: .cidrBlockState)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let cidrBlockDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cidrBlock)
        cidrBlock = cidrBlockDecoded
        let cidrBlockStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cidrBlockState)
        cidrBlockState = cidrBlockStateDecoded
    }
}

extension CidrBlockAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CidrBlockAssociation(associationId: \(String(describing: associationId)), cidrBlock: \(String(describing: cidrBlock)), cidrBlockState: \(String(describing: cidrBlockState)))"}
}

/// <p>An IPv4 CIDR block association.</p>
public struct CidrBlockAssociation: Equatable {
    /// <p>The association ID for the IPv4 CIDR block.</p>
    public let associationId: String?
    /// <p>The IPv4 CIDR block.</p>
    public let cidrBlock: String?
    /// <p>Information about the state of the IPv4 CIDR block.</p>
    public let cidrBlockState: String?

    public init (
        associationId: String? = nil,
        cidrBlock: String? = nil,
        cidrBlockState: String? = nil
    )
    {
        self.associationId = associationId
        self.cidrBlock = cidrBlock
        self.cidrBlockState = cidrBlockState
    }
}

extension City: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cityName = "CityName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cityName = cityName {
            try encodeContainer.encode(cityName, forKey: .cityName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cityNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cityName)
        cityName = cityNameDecoded
    }
}

extension City: CustomDebugStringConvertible {
    public var debugDescription: String {
        "City(cityName: \(String(describing: cityName)))"}
}

/// <p>Information about a city.</p>
public struct City: Equatable {
    /// <p>The name of the city.</p>
    public let cityName: String?

    public init (
        cityName: String? = nil
    )
    {
        self.cityName = cityName
    }
}

extension ClassificationResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalOccurrences = "AdditionalOccurrences"
        case customDataIdentifiers = "CustomDataIdentifiers"
        case mimeType = "MimeType"
        case sensitiveData = "SensitiveData"
        case sizeClassified = "SizeClassified"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if additionalOccurrences != false {
            try encodeContainer.encode(additionalOccurrences, forKey: .additionalOccurrences)
        }
        if let customDataIdentifiers = customDataIdentifiers {
            try encodeContainer.encode(customDataIdentifiers, forKey: .customDataIdentifiers)
        }
        if let mimeType = mimeType {
            try encodeContainer.encode(mimeType, forKey: .mimeType)
        }
        if let sensitiveData = sensitiveData {
            var sensitiveDataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sensitiveData)
            for sensitivedataresultlist0 in sensitiveData {
                try sensitiveDataContainer.encode(sensitivedataresultlist0)
            }
        }
        if sizeClassified != 0 {
            try encodeContainer.encode(sizeClassified, forKey: .sizeClassified)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mimeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mimeType)
        mimeType = mimeTypeDecoded
        let sizeClassifiedDecoded = try containerValues.decode(Int.self, forKey: .sizeClassified)
        sizeClassified = sizeClassifiedDecoded
        let additionalOccurrencesDecoded = try containerValues.decode(Bool.self, forKey: .additionalOccurrences)
        additionalOccurrences = additionalOccurrencesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ClassificationStatus.self, forKey: .status)
        status = statusDecoded
        let sensitiveDataContainer = try containerValues.decodeIfPresent([SensitiveDataResult?].self, forKey: .sensitiveData)
        var sensitiveDataDecoded0:[SensitiveDataResult]? = nil
        if let sensitiveDataContainer = sensitiveDataContainer {
            sensitiveDataDecoded0 = [SensitiveDataResult]()
            for structure0 in sensitiveDataContainer {
                if let structure0 = structure0 {
                    sensitiveDataDecoded0?.append(structure0)
                }
            }
        }
        sensitiveData = sensitiveDataDecoded0
        let customDataIdentifiersDecoded = try containerValues.decodeIfPresent(CustomDataIdentifiersResult.self, forKey: .customDataIdentifiers)
        customDataIdentifiers = customDataIdentifiersDecoded
    }
}

extension ClassificationResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClassificationResult(additionalOccurrences: \(String(describing: additionalOccurrences)), customDataIdentifiers: \(String(describing: customDataIdentifiers)), mimeType: \(String(describing: mimeType)), sensitiveData: \(String(describing: sensitiveData)), sizeClassified: \(String(describing: sizeClassified)), status: \(String(describing: status)))"}
}

/// <p>Details about the sensitive data that was detected on the resource.</p>
public struct ClassificationResult: Equatable {
    /// <p>Indicates whether there are additional occurrences of sensitive data that are not included in the finding. This occurs when the number of occurrences exceeds the maximum that can be included.</p>
    public let additionalOccurrences: Bool
    /// <p>Provides details about sensitive data that was identified based on customer-defined configuration.</p>
    public let customDataIdentifiers: CustomDataIdentifiersResult?
    /// <p>The type of content that the finding applies to.</p>
    public let mimeType: String?
    /// <p>Provides details about sensitive data that was identified based on built-in configuration.</p>
    public let sensitiveData: [SensitiveDataResult]?
    /// <p>The total size in bytes of the affected data.</p>
    public let sizeClassified: Int
    /// <p>The current status of the sensitive data detection.</p>
    public let status: ClassificationStatus?

    public init (
        additionalOccurrences: Bool = false,
        customDataIdentifiers: CustomDataIdentifiersResult? = nil,
        mimeType: String? = nil,
        sensitiveData: [SensitiveDataResult]? = nil,
        sizeClassified: Int = 0,
        status: ClassificationStatus? = nil
    )
    {
        self.additionalOccurrences = additionalOccurrences
        self.customDataIdentifiers = customDataIdentifiers
        self.mimeType = mimeType
        self.sensitiveData = sensitiveData
        self.sizeClassified = sizeClassified
        self.status = status
    }
}

extension ClassificationStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case reason = "Reason"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ClassificationStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClassificationStatus(code: \(String(describing: code)), reason: \(String(describing: reason)))"}
}

/// <p>Provides details about the current status of the sensitive data detection.</p>
public struct ClassificationStatus: Equatable {
    /// <p>The code that represents the status of the sensitive data detection.</p>
    public let code: String?
    /// <p>A longer description of the current status of the sensitive data detection.</p>
    public let reason: String?

    public init (
        code: String? = nil,
        reason: String? = nil
    )
    {
        self.code = code
        self.reason = reason
    }
}

extension Compliance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case relatedRequirements = "RelatedRequirements"
        case status = "Status"
        case statusReasons = "StatusReasons"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let relatedRequirements = relatedRequirements {
            var relatedRequirementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedRequirements)
            for relatedrequirementslist0 in relatedRequirements {
                try relatedRequirementsContainer.encode(relatedrequirementslist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReasons = statusReasons {
            var statusReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statusReasons)
            for statusreasonslist0 in statusReasons {
                try statusReasonsContainer.encode(statusreasonslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ComplianceStatus.self, forKey: .status)
        status = statusDecoded
        let relatedRequirementsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .relatedRequirements)
        var relatedRequirementsDecoded0:[String]? = nil
        if let relatedRequirementsContainer = relatedRequirementsContainer {
            relatedRequirementsDecoded0 = [String]()
            for string0 in relatedRequirementsContainer {
                if let string0 = string0 {
                    relatedRequirementsDecoded0?.append(string0)
                }
            }
        }
        relatedRequirements = relatedRequirementsDecoded0
        let statusReasonsContainer = try containerValues.decodeIfPresent([StatusReason?].self, forKey: .statusReasons)
        var statusReasonsDecoded0:[StatusReason]? = nil
        if let statusReasonsContainer = statusReasonsContainer {
            statusReasonsDecoded0 = [StatusReason]()
            for structure0 in statusReasonsContainer {
                if let structure0 = structure0 {
                    statusReasonsDecoded0?.append(structure0)
                }
            }
        }
        statusReasons = statusReasonsDecoded0
    }
}

extension Compliance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Compliance(relatedRequirements: \(String(describing: relatedRequirements)), status: \(String(describing: status)), statusReasons: \(String(describing: statusReasons)))"}
}

/// <p>Contains finding details that are specific to control-based findings. Only returned for
///          findings generated from controls.</p>
public struct Compliance: Equatable {
    /// <p>For a control, the industry or regulatory framework requirements that are related to the
    ///          control. The check for that control is aligned with these requirements.</p>
    public let relatedRequirements: [String]?
    /// <p>The result of a standards check.</p>
    ///          <p>The valid values for <code>Status</code> are as follows.</p>
    ///          <ul>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>PASSED</code> - Standards check passed for all evaluated
    ///                      resources.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>WARNING</code> - Some information is missing or this check is not
    ///                      supported for your configuration.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>FAILED</code> - Standards check failed for at least one evaluated
    ///                      resource.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>NOT_AVAILABLE</code> - Check could not be performed due to a service
    ///                      outage, API error, or because the result of the AWS Config evaluation was
    ///                         <code>NOT_APPLICABLE</code>. If the AWS Config evaluation result was
    ///                         <code>NOT_APPLICABLE</code>, then after 3 days, Security Hub automatically archives
    ///                      the finding.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let status: ComplianceStatus?
    /// <p>For findings generated from controls, a list of reasons behind the value of
    ///             <code>Status</code>. For the list of status reason codes and their meanings, see <a href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-results.html#securityhub-standards-results-asff">Standards-related information in the ASFF</a> in the
    ///             <i>AWS Security Hub User Guide</i>. </p>
    public let statusReasons: [StatusReason]?

    public init (
        relatedRequirements: [String]? = nil,
        status: ComplianceStatus? = nil,
        statusReasons: [StatusReason]? = nil
    )
    {
        self.relatedRequirements = relatedRequirements
        self.status = status
        self.statusReasons = statusReasons
    }
}

public enum ComplianceStatus {
    case failed
    case notAvailable
    case passed
    case warning
    case sdkUnknown(String)
}

extension ComplianceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComplianceStatus] {
        return [
            .failed,
            .notAvailable,
            .passed,
            .warning,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .notAvailable: return "NOT_AVAILABLE"
        case .passed: return "PASSED"
        case .warning: return "WARNING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComplianceStatus(rawValue: rawValue) ?? ComplianceStatus.sdkUnknown(rawValue)
    }
}

extension ContainerDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageId = "ImageId"
        case imageName = "ImageName"
        case launchedAt = "LaunchedAt"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let imageName = imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let launchedAt = launchedAt {
            try encodeContainer.encode(launchedAt, forKey: .launchedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let imageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let launchedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchedAt)
        launchedAt = launchedAtDecoded
    }
}

extension ContainerDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContainerDetails(imageId: \(String(describing: imageId)), imageName: \(String(describing: imageName)), launchedAt: \(String(describing: launchedAt)), name: \(String(describing: name)))"}
}

/// <p>Container details related to a finding.</p>
public struct ContainerDetails: Equatable {
    /// <p>The identifier of the image related to a finding.</p>
    public let imageId: String?
    /// <p>The name of the image related to a finding.</p>
    public let imageName: String?
    /// <p>Indicates when the container started.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let launchedAt: String?
    /// <p>The name of the container related to a finding.</p>
    public let name: String?

    public init (
        imageId: String? = nil,
        imageName: String? = nil,
        launchedAt: String? = nil,
        name: String? = nil
    )
    {
        self.imageId = imageId
        self.imageName = imageName
        self.launchedAt = launchedAt
        self.name = name
    }
}

public enum ControlStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension ControlStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ControlStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ControlStatus(rawValue: rawValue) ?? ControlStatus.sdkUnknown(rawValue)
    }
}

extension Country: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case countryCode = "CountryCode"
        case countryName = "CountryName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countryCode = countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let countryName = countryName {
            try encodeContainer.encode(countryName, forKey: .countryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let countryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .countryName)
        countryName = countryNameDecoded
    }
}

extension Country: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Country(countryCode: \(String(describing: countryCode)), countryName: \(String(describing: countryName)))"}
}

/// <p>Information about a country.</p>
public struct Country: Equatable {
    /// <p>The 2-letter ISO 3166 country code for the country.</p>
    public let countryCode: String?
    /// <p>The name of the country.</p>
    public let countryName: String?

    public init (
        countryCode: String? = nil,
        countryName: String? = nil
    )
    {
        self.countryCode = countryCode
        self.countryName = countryName
    }
}

public struct CreateActionTargetInputBodyMiddleware: Middleware {
    public let id: String = "CreateActionTargetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateActionTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateActionTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateActionTargetInput>
    public typealias MOutput = OperationOutput<CreateActionTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateActionTargetOutputError>
}

extension CreateActionTargetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateActionTargetInput(description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

extension CreateActionTargetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateActionTargetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateActionTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateActionTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateActionTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateActionTargetInput>
    public typealias MOutput = OperationOutput<CreateActionTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateActionTargetOutputError>
}

public struct CreateActionTargetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateActionTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateActionTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateActionTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateActionTargetInput>
    public typealias MOutput = OperationOutput<CreateActionTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateActionTargetOutputError>
}

public struct CreateActionTargetInput: Equatable {
    /// <p>The description for the custom action target.</p>
    public let description: String?
    /// <p>The ID for the custom action target.</p>
    public let id: String?
    /// <p>The name of the custom action target.</p>
    public let name: String?

    public init (
        description: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

struct CreateActionTargetInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let id: String?
}

extension CreateActionTargetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension CreateActionTargetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateActionTargetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateActionTargetOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceConflictException(ResourceConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateActionTargetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateActionTargetOutputResponse(actionTargetArn: \(String(describing: actionTargetArn)))"}
}

extension CreateActionTargetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateActionTargetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.actionTargetArn = output.actionTargetArn
        } else {
            self.actionTargetArn = nil
        }
    }
}

public struct CreateActionTargetOutputResponse: Equatable {
    /// <p>The ARN for the custom action target.</p>
    public let actionTargetArn: String?

    public init (
        actionTargetArn: String? = nil
    )
    {
        self.actionTargetArn = actionTargetArn
    }
}

struct CreateActionTargetOutputResponseBody: Equatable {
    public let actionTargetArn: String?
}

extension CreateActionTargetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionTargetArn = "ActionTargetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTargetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionTargetArn)
        actionTargetArn = actionTargetArnDecoded
    }
}

public struct CreateInsightInputBodyMiddleware: Middleware {
    public let id: String = "CreateInsightInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInsightInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInsightOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInsightInput>
    public typealias MOutput = OperationOutput<CreateInsightOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInsightOutputError>
}

extension CreateInsightInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInsightInput(filters: \(String(describing: filters)), groupByAttribute: \(String(describing: groupByAttribute)), name: \(String(describing: name)))"}
}

extension CreateInsightInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case groupByAttribute = "GroupByAttribute"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let groupByAttribute = groupByAttribute {
            try encodeContainer.encode(groupByAttribute, forKey: .groupByAttribute)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateInsightInputHeadersMiddleware: Middleware {
    public let id: String = "CreateInsightInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInsightInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInsightOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInsightInput>
    public typealias MOutput = OperationOutput<CreateInsightOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInsightOutputError>
}

public struct CreateInsightInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateInsightInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInsightInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInsightOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInsightInput>
    public typealias MOutput = OperationOutput<CreateInsightOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInsightOutputError>
}

public struct CreateInsightInput: Equatable {
    /// <p>One or more attributes used to filter the findings included in the insight. The insight
    ///          only includes findings that match the criteria defined in the filters.</p>
    public let filters: AwsSecurityFindingFilters?
    /// <p>The attribute used to group the findings for the insight. The grouping attribute
    ///          identifies the type of item that the insight applies to. For example, if an insight is
    ///          grouped by resource identifier, then the insight produces a list of resource
    ///          identifiers.</p>
    public let groupByAttribute: String?
    /// <p>The name of the custom insight to create.</p>
    public let name: String?

    public init (
        filters: AwsSecurityFindingFilters? = nil,
        groupByAttribute: String? = nil,
        name: String? = nil
    )
    {
        self.filters = filters
        self.groupByAttribute = groupByAttribute
        self.name = name
    }
}

struct CreateInsightInputBody: Equatable {
    public let name: String?
    public let filters: AwsSecurityFindingFilters?
    public let groupByAttribute: String?
}

extension CreateInsightInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case groupByAttribute = "GroupByAttribute"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(AwsSecurityFindingFilters.self, forKey: .filters)
        filters = filtersDecoded
        let groupByAttributeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupByAttribute)
        groupByAttribute = groupByAttributeDecoded
    }
}

extension CreateInsightOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInsightOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInsightOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceConflictException(ResourceConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInsightOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInsightOutputResponse(insightArn: \(String(describing: insightArn)))"}
}

extension CreateInsightOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateInsightOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.insightArn = output.insightArn
        } else {
            self.insightArn = nil
        }
    }
}

public struct CreateInsightOutputResponse: Equatable {
    /// <p>The ARN of the insight created.</p>
    public let insightArn: String?

    public init (
        insightArn: String? = nil
    )
    {
        self.insightArn = insightArn
    }
}

struct CreateInsightOutputResponseBody: Equatable {
    public let insightArn: String?
}

extension CreateInsightOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case insightArn = "InsightArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .insightArn)
        insightArn = insightArnDecoded
    }
}

public struct CreateMembersInputBodyMiddleware: Middleware {
    public let id: String = "CreateMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMembersInput>
    public typealias MOutput = OperationOutput<CreateMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMembersOutputError>
}

extension CreateMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMembersInput(accountDetails: \(String(describing: accountDetails)))"}
}

extension CreateMembersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountDetails = "AccountDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountDetails = accountDetails {
            var accountDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountDetails)
            for accountdetailslist0 in accountDetails {
                try accountDetailsContainer.encode(accountdetailslist0)
            }
        }
    }
}

public struct CreateMembersInputHeadersMiddleware: Middleware {
    public let id: String = "CreateMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMembersInput>
    public typealias MOutput = OperationOutput<CreateMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMembersOutputError>
}

public struct CreateMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMembersInput>
    public typealias MOutput = OperationOutput<CreateMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMembersOutputError>
}

public struct CreateMembersInput: Equatable {
    /// <p>The list of accounts to associate with the Security Hub administrator account. For each account, the
    ///          list includes the account ID and optionally the email address.</p>
    public let accountDetails: [AccountDetails]?

    public init (
        accountDetails: [AccountDetails]? = nil
    )
    {
        self.accountDetails = accountDetails
    }
}

struct CreateMembersInputBody: Equatable {
    public let accountDetails: [AccountDetails]?
}

extension CreateMembersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountDetails = "AccountDetails"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDetailsContainer = try containerValues.decodeIfPresent([AccountDetails?].self, forKey: .accountDetails)
        var accountDetailsDecoded0:[AccountDetails]? = nil
        if let accountDetailsContainer = accountDetailsContainer {
            accountDetailsDecoded0 = [AccountDetails]()
            for structure0 in accountDetailsContainer {
                if let structure0 = structure0 {
                    accountDetailsDecoded0?.append(structure0)
                }
            }
        }
        accountDetails = accountDetailsDecoded0
    }
}

extension CreateMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMembersOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceConflictException(ResourceConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMembersOutputResponse(unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension CreateMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateMembersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct CreateMembersOutputResponse: Equatable {
    /// <p>The list of AWS accounts that were not processed. For each account, the list includes
    ///          the account ID and the email address.</p>
    public let unprocessedAccounts: [Result]?

    public init (
        unprocessedAccounts: [Result]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct CreateMembersOutputResponseBody: Equatable {
    public let unprocessedAccounts: [Result]?
}

extension CreateMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([Result?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[Result]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [Result]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension CustomDataIdentifiersDetections: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case count = "Count"
        case name = "Name"
        case occurrences = "Occurrences"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let occurrences = occurrences {
            try encodeContainer.encode(occurrences, forKey: .occurrences)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decode(Int.self, forKey: .count)
        count = countDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let occurrencesDecoded = try containerValues.decodeIfPresent(Occurrences.self, forKey: .occurrences)
        occurrences = occurrencesDecoded
    }
}

extension CustomDataIdentifiersDetections: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomDataIdentifiersDetections(arn: \(String(describing: arn)), count: \(String(describing: count)), name: \(String(describing: name)), occurrences: \(String(describing: occurrences)))"}
}

/// <p>The list of detected instances of sensitive data.</p>
public struct CustomDataIdentifiersDetections: Equatable {
    /// <p>The ARN of the custom identifier that was used to detect the sensitive data.</p>
    public let arn: String?
    /// <p>The total number of occurrences of sensitive data that were detected.</p>
    public let count: Int
    /// <p>he name of the custom identifier that detected the sensitive data.</p>
    public let name: String?
    /// <p>Details about the sensitive data that was detected.</p>
    public let occurrences: Occurrences?

    public init (
        arn: String? = nil,
        count: Int = 0,
        name: String? = nil,
        occurrences: Occurrences? = nil
    )
    {
        self.arn = arn
        self.count = count
        self.name = name
        self.occurrences = occurrences
    }
}

extension CustomDataIdentifiersResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detections = "Detections"
        case totalCount = "TotalCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detections = detections {
            var detectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .detections)
            for customdataidentifiersdetectionslist0 in detections {
                try detectionsContainer.encode(customdataidentifiersdetectionslist0)
            }
        }
        if totalCount != 0 {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectionsContainer = try containerValues.decodeIfPresent([CustomDataIdentifiersDetections?].self, forKey: .detections)
        var detectionsDecoded0:[CustomDataIdentifiersDetections]? = nil
        if let detectionsContainer = detectionsContainer {
            detectionsDecoded0 = [CustomDataIdentifiersDetections]()
            for structure0 in detectionsContainer {
                if let structure0 = structure0 {
                    detectionsDecoded0?.append(structure0)
                }
            }
        }
        detections = detectionsDecoded0
        let totalCountDecoded = try containerValues.decode(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

extension CustomDataIdentifiersResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomDataIdentifiersResult(detections: \(String(describing: detections)), totalCount: \(String(describing: totalCount)))"}
}

/// <p>Contains an instance of sensitive data that was detected by a customer-defined identifier.</p>
public struct CustomDataIdentifiersResult: Equatable {
    /// <p>The list of detected instances of sensitive data.</p>
    public let detections: [CustomDataIdentifiersDetections]?
    /// <p>The total number of occurrences of sensitive data.</p>
    public let totalCount: Int

    public init (
        detections: [CustomDataIdentifiersDetections]? = nil,
        totalCount: Int = 0
    )
    {
        self.detections = detections
        self.totalCount = totalCount
    }
}

extension Cvss: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baseScore = "BaseScore"
        case baseVector = "BaseVector"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if baseScore != 0.0 {
            try encodeContainer.encode(baseScore, forKey: .baseScore)
        }
        if let baseVector = baseVector {
            try encodeContainer.encode(baseVector, forKey: .baseVector)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let baseScoreDecoded = try containerValues.decode(Double.self, forKey: .baseScore)
        baseScore = baseScoreDecoded
        let baseVectorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baseVector)
        baseVector = baseVectorDecoded
    }
}

extension Cvss: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Cvss(baseScore: \(String(describing: baseScore)), baseVector: \(String(describing: baseVector)), version: \(String(describing: version)))"}
}

/// <p>CVSS scores from the advisory related to the vulnerability.</p>
public struct Cvss: Equatable {
    /// <p>The base CVSS score.</p>
    public let baseScore: Double
    /// <p>The base scoring vector for the CVSS score.</p>
    public let baseVector: String?
    /// <p>The version of CVSS for the CVSS score.</p>
    public let version: String?

    public init (
        baseScore: Double = 0.0,
        baseVector: String? = nil,
        version: String? = nil
    )
    {
        self.baseScore = baseScore
        self.baseVector = baseVector
        self.version = version
    }
}

extension DataClassificationDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detailedResultsLocation = "DetailedResultsLocation"
        case result = "Result"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detailedResultsLocation = detailedResultsLocation {
            try encodeContainer.encode(detailedResultsLocation, forKey: .detailedResultsLocation)
        }
        if let result = result {
            try encodeContainer.encode(result, forKey: .result)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedResultsLocationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detailedResultsLocation)
        detailedResultsLocation = detailedResultsLocationDecoded
        let resultDecoded = try containerValues.decodeIfPresent(ClassificationResult.self, forKey: .result)
        result = resultDecoded
    }
}

extension DataClassificationDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataClassificationDetails(detailedResultsLocation: \(String(describing: detailedResultsLocation)), result: \(String(describing: result)))"}
}

/// <p>Provides details about sensitive data that was detected on a resource.</p>
public struct DataClassificationDetails: Equatable {
    /// <p>The path to the folder or file that contains the sensitive data.</p>
    public let detailedResultsLocation: String?
    /// <p>The details about the sensitive data that was detected on the resource.</p>
    public let result: ClassificationResult?

    public init (
        detailedResultsLocation: String? = nil,
        result: ClassificationResult? = nil
    )
    {
        self.detailedResultsLocation = detailedResultsLocation
        self.result = result
    }
}

extension DateFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dateRange = "DateRange"
        case end = "End"
        case start = "Start"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateRange = dateRange {
            try encodeContainer.encode(dateRange, forKey: .dateRange)
        }
        if let end = end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let start = start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(String.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(String.self, forKey: .end)
        end = endDecoded
        let dateRangeDecoded = try containerValues.decodeIfPresent(DateRange.self, forKey: .dateRange)
        dateRange = dateRangeDecoded
    }
}

extension DateFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DateFilter(dateRange: \(String(describing: dateRange)), end: \(String(describing: end)), start: \(String(describing: start)))"}
}

/// <p>A date filter for querying findings.</p>
public struct DateFilter: Equatable {
    /// <p>A date range for the date filter.</p>
    public let dateRange: DateRange?
    /// <p>An end date for the date filter.</p>
    public let end: String?
    /// <p>A start date for the date filter.</p>
    public let start: String?

    public init (
        dateRange: DateRange? = nil,
        end: String? = nil,
        start: String? = nil
    )
    {
        self.dateRange = dateRange
        self.end = end
        self.start = start
    }
}

extension DateRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case unit = "Unit"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if value != 0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decode(Int.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(DateRangeUnit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension DateRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DateRange(unit: \(String(describing: unit)), value: \(String(describing: value)))"}
}

/// <p>A date range for the date filter.</p>
public struct DateRange: Equatable {
    /// <p>A date range unit for the date filter.</p>
    public let unit: DateRangeUnit?
    /// <p>A date range value for the date filter.</p>
    public let value: Int

    public init (
        unit: DateRangeUnit? = nil,
        value: Int = 0
    )
    {
        self.unit = unit
        self.value = value
    }
}

public enum DateRangeUnit {
    case days
    case sdkUnknown(String)
}

extension DateRangeUnit : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DateRangeUnit] {
        return [
            .days,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .days: return "DAYS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DateRangeUnit(rawValue: rawValue) ?? DateRangeUnit.sdkUnknown(rawValue)
    }
}

public struct DeclineInvitationsInputBodyMiddleware: Middleware {
    public let id: String = "DeclineInvitationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeclineInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeclineInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeclineInvitationsInput>
    public typealias MOutput = OperationOutput<DeclineInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeclineInvitationsOutputError>
}

extension DeclineInvitationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeclineInvitationsInput(accountIds: \(String(describing: accountIds)))"}
}

extension DeclineInvitationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountidlist0 in accountIds {
                try accountIdsContainer.encode(accountidlist0)
            }
        }
    }
}

public struct DeclineInvitationsInputHeadersMiddleware: Middleware {
    public let id: String = "DeclineInvitationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeclineInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeclineInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeclineInvitationsInput>
    public typealias MOutput = OperationOutput<DeclineInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeclineInvitationsOutputError>
}

public struct DeclineInvitationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeclineInvitationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeclineInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeclineInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeclineInvitationsInput>
    public typealias MOutput = OperationOutput<DeclineInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeclineInvitationsOutputError>
}

public struct DeclineInvitationsInput: Equatable {
    /// <p>The list of account IDs for the accounts from which to decline the invitations to
    ///          Security Hub.</p>
    public let accountIds: [String]?

    public init (
        accountIds: [String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct DeclineInvitationsInputBody: Equatable {
    public let accountIds: [String]?
}

extension DeclineInvitationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeclineInvitationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeclineInvitationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeclineInvitationsOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeclineInvitationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeclineInvitationsOutputResponse(unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension DeclineInvitationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeclineInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeclineInvitationsOutputResponse: Equatable {
    /// <p>The list of AWS accounts that were not processed. For each account, the list includes
    ///          the account ID and the email address.</p>
    public let unprocessedAccounts: [Result]?

    public init (
        unprocessedAccounts: [Result]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeclineInvitationsOutputResponseBody: Equatable {
    public let unprocessedAccounts: [Result]?
}

extension DeclineInvitationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([Result?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[Result]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [Result]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension DeleteActionTargetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteActionTargetInput(actionTargetArn: \(String(describing: actionTargetArn)))"}
}

extension DeleteActionTargetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteActionTargetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteActionTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteActionTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteActionTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteActionTargetInput>
    public typealias MOutput = OperationOutput<DeleteActionTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteActionTargetOutputError>
}

public struct DeleteActionTargetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteActionTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteActionTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteActionTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteActionTargetInput>
    public typealias MOutput = OperationOutput<DeleteActionTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteActionTargetOutputError>
}

public struct DeleteActionTargetInput: Equatable {
    /// <p>The ARN of the custom action target to delete.</p>
    public let actionTargetArn: String?

    public init (
        actionTargetArn: String? = nil
    )
    {
        self.actionTargetArn = actionTargetArn
    }
}

struct DeleteActionTargetInputBody: Equatable {
}

extension DeleteActionTargetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteActionTargetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteActionTargetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteActionTargetOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteActionTargetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteActionTargetOutputResponse(actionTargetArn: \(String(describing: actionTargetArn)))"}
}

extension DeleteActionTargetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteActionTargetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.actionTargetArn = output.actionTargetArn
        } else {
            self.actionTargetArn = nil
        }
    }
}

public struct DeleteActionTargetOutputResponse: Equatable {
    /// <p>The ARN of the custom action target that was deleted.</p>
    public let actionTargetArn: String?

    public init (
        actionTargetArn: String? = nil
    )
    {
        self.actionTargetArn = actionTargetArn
    }
}

struct DeleteActionTargetOutputResponseBody: Equatable {
    public let actionTargetArn: String?
}

extension DeleteActionTargetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionTargetArn = "ActionTargetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTargetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionTargetArn)
        actionTargetArn = actionTargetArnDecoded
    }
}

extension DeleteInsightInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInsightInput(insightArn: \(String(describing: insightArn)))"}
}

extension DeleteInsightInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteInsightInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteInsightInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInsightInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInsightOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInsightInput>
    public typealias MOutput = OperationOutput<DeleteInsightOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInsightOutputError>
}

public struct DeleteInsightInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteInsightInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInsightInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInsightOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInsightInput>
    public typealias MOutput = OperationOutput<DeleteInsightOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInsightOutputError>
}

public struct DeleteInsightInput: Equatable {
    /// <p>The ARN of the insight to delete.</p>
    public let insightArn: String?

    public init (
        insightArn: String? = nil
    )
    {
        self.insightArn = insightArn
    }
}

struct DeleteInsightInputBody: Equatable {
}

extension DeleteInsightInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteInsightOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInsightOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInsightOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInsightOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInsightOutputResponse(insightArn: \(String(describing: insightArn)))"}
}

extension DeleteInsightOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteInsightOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.insightArn = output.insightArn
        } else {
            self.insightArn = nil
        }
    }
}

public struct DeleteInsightOutputResponse: Equatable {
    /// <p>The ARN of the insight that was deleted.</p>
    public let insightArn: String?

    public init (
        insightArn: String? = nil
    )
    {
        self.insightArn = insightArn
    }
}

struct DeleteInsightOutputResponseBody: Equatable {
    public let insightArn: String?
}

extension DeleteInsightOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case insightArn = "InsightArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .insightArn)
        insightArn = insightArnDecoded
    }
}

public struct DeleteInvitationsInputBodyMiddleware: Middleware {
    public let id: String = "DeleteInvitationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInvitationsInput>
    public typealias MOutput = OperationOutput<DeleteInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInvitationsOutputError>
}

extension DeleteInvitationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInvitationsInput(accountIds: \(String(describing: accountIds)))"}
}

extension DeleteInvitationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountidlist0 in accountIds {
                try accountIdsContainer.encode(accountidlist0)
            }
        }
    }
}

public struct DeleteInvitationsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteInvitationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInvitationsInput>
    public typealias MOutput = OperationOutput<DeleteInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInvitationsOutputError>
}

public struct DeleteInvitationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteInvitationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInvitationsInput>
    public typealias MOutput = OperationOutput<DeleteInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInvitationsOutputError>
}

public struct DeleteInvitationsInput: Equatable {
    /// <p>The list of the account IDs that sent the invitations to delete.</p>
    public let accountIds: [String]?

    public init (
        accountIds: [String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct DeleteInvitationsInputBody: Equatable {
    public let accountIds: [String]?
}

extension DeleteInvitationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeleteInvitationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInvitationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInvitationsOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInvitationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInvitationsOutputResponse(unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension DeleteInvitationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeleteInvitationsOutputResponse: Equatable {
    /// <p>The list of AWS accounts for which the invitations were not deleted. For each account,
    ///          the list includes the account ID and the email address.</p>
    public let unprocessedAccounts: [Result]?

    public init (
        unprocessedAccounts: [Result]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeleteInvitationsOutputResponseBody: Equatable {
    public let unprocessedAccounts: [Result]?
}

extension DeleteInvitationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([Result?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[Result]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [Result]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

public struct DeleteMembersInputBodyMiddleware: Middleware {
    public let id: String = "DeleteMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMembersInput>
    public typealias MOutput = OperationOutput<DeleteMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMembersOutputError>
}

extension DeleteMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMembersInput(accountIds: \(String(describing: accountIds)))"}
}

extension DeleteMembersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountidlist0 in accountIds {
                try accountIdsContainer.encode(accountidlist0)
            }
        }
    }
}

public struct DeleteMembersInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMembersInput>
    public typealias MOutput = OperationOutput<DeleteMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMembersOutputError>
}

public struct DeleteMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMembersInput>
    public typealias MOutput = OperationOutput<DeleteMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMembersOutputError>
}

public struct DeleteMembersInput: Equatable {
    /// <p>The list of account IDs for the member accounts to delete.</p>
    public let accountIds: [String]?

    public init (
        accountIds: [String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct DeleteMembersInputBody: Equatable {
    public let accountIds: [String]?
}

extension DeleteMembersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeleteMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMembersOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMembersOutputResponse(unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension DeleteMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteMembersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeleteMembersOutputResponse: Equatable {
    /// <p>The list of AWS accounts that were not deleted. For each account, the list includes the
    ///          account ID and the email address.</p>
    public let unprocessedAccounts: [Result]?

    public init (
        unprocessedAccounts: [Result]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeleteMembersOutputResponseBody: Equatable {
    public let unprocessedAccounts: [Result]?
}

extension DeleteMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([Result?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[Result]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [Result]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

public struct DescribeActionTargetsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeActionTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeActionTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeActionTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeActionTargetsInput>
    public typealias MOutput = OperationOutput<DescribeActionTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeActionTargetsOutputError>
}

extension DescribeActionTargetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeActionTargetsInput(actionTargetArns: \(String(describing: actionTargetArns)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeActionTargetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionTargetArns = "ActionTargetArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionTargetArns = actionTargetArns {
            var actionTargetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actionTargetArns)
            for arnlist0 in actionTargetArns {
                try actionTargetArnsContainer.encode(arnlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeActionTargetsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeActionTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeActionTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeActionTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeActionTargetsInput>
    public typealias MOutput = OperationOutput<DescribeActionTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeActionTargetsOutputError>
}

public struct DescribeActionTargetsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeActionTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeActionTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeActionTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeActionTargetsInput>
    public typealias MOutput = OperationOutput<DescribeActionTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeActionTargetsOutputError>
}

public struct DescribeActionTargetsInput: Equatable {
    /// <p>A list of custom action target ARNs for the custom action targets to retrieve.</p>
    public let actionTargetArns: [String]?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int
    /// <p>The token that is required for pagination. On your first call to the
    ///             <code>DescribeActionTargets</code> operation, set the value of this parameter to
    ///             <code>NULL</code>.</p>
    ///          <p>For subsequent calls to the operation, to continue listing data, set the value of this
    ///          parameter to the value returned from the previous response.</p>
    public let nextToken: String?

    public init (
        actionTargetArns: [String]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.actionTargetArns = actionTargetArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeActionTargetsInputBody: Equatable {
    public let actionTargetArns: [String]?
    public let nextToken: String?
    public let maxResults: Int
}

extension DescribeActionTargetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionTargetArns = "ActionTargetArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTargetArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .actionTargetArns)
        var actionTargetArnsDecoded0:[String]? = nil
        if let actionTargetArnsContainer = actionTargetArnsContainer {
            actionTargetArnsDecoded0 = [String]()
            for string0 in actionTargetArnsContainer {
                if let string0 = string0 {
                    actionTargetArnsDecoded0?.append(string0)
                }
            }
        }
        actionTargetArns = actionTargetArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeActionTargetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeActionTargetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeActionTargetsOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeActionTargetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeActionTargetsOutputResponse(actionTargets: \(String(describing: actionTargets)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeActionTargetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeActionTargetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.actionTargets = output.actionTargets
            self.nextToken = output.nextToken
        } else {
            self.actionTargets = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeActionTargetsOutputResponse: Equatable {
    /// <p>A list of <code>ActionTarget</code> objects. Each object includes the <code>ActionTargetArn</code>,
    ///             <code>Description</code>, and <code>Name</code> of a custom action target available in
    ///          Security Hub.</p>
    public let actionTargets: [ActionTarget]?
    /// <p>The pagination token to use to request the next page of results.</p>
    public let nextToken: String?

    public init (
        actionTargets: [ActionTarget]? = nil,
        nextToken: String? = nil
    )
    {
        self.actionTargets = actionTargets
        self.nextToken = nextToken
    }
}

struct DescribeActionTargetsOutputResponseBody: Equatable {
    public let actionTargets: [ActionTarget]?
    public let nextToken: String?
}

extension DescribeActionTargetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionTargets = "ActionTargets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTargetsContainer = try containerValues.decodeIfPresent([ActionTarget?].self, forKey: .actionTargets)
        var actionTargetsDecoded0:[ActionTarget]? = nil
        if let actionTargetsContainer = actionTargetsContainer {
            actionTargetsDecoded0 = [ActionTarget]()
            for structure0 in actionTargetsContainer {
                if let structure0 = structure0 {
                    actionTargetsDecoded0?.append(structure0)
                }
            }
        }
        actionTargets = actionTargetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeHubInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHubInput(hubArn: \(String(describing: hubArn)))"}
}

extension DescribeHubInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeHubInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeHubInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHubInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHubOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHubInput>
    public typealias MOutput = OperationOutput<DescribeHubOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHubOutputError>
}

public struct DescribeHubInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeHubInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHubInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHubOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let hubArn = input.operationInput.hubArn {
            let hubArnQueryItem = URLQueryItem(name: "HubArn".urlPercentEncoding(), value: String(hubArn).urlPercentEncoding())
            input.builder.withQueryItem(hubArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHubInput>
    public typealias MOutput = OperationOutput<DescribeHubOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHubOutputError>
}

public struct DescribeHubInput: Equatable {
    /// <p>The ARN of the Hub resource to retrieve.</p>
    public let hubArn: String?

    public init (
        hubArn: String? = nil
    )
    {
        self.hubArn = hubArn
    }
}

struct DescribeHubInputBody: Equatable {
}

extension DescribeHubInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeHubOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHubOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeHubOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHubOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHubOutputResponse(autoEnableControls: \(String(describing: autoEnableControls)), hubArn: \(String(describing: hubArn)), subscribedAt: \(String(describing: subscribedAt)))"}
}

extension DescribeHubOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeHubOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.autoEnableControls = output.autoEnableControls
            self.hubArn = output.hubArn
            self.subscribedAt = output.subscribedAt
        } else {
            self.autoEnableControls = false
            self.hubArn = nil
            self.subscribedAt = nil
        }
    }
}

public struct DescribeHubOutputResponse: Equatable {
    /// <p>Whether to automatically enable new controls when they are added to standards that are
    ///          enabled.</p>
    ///          <p>If set to <code>true</code>, then new controls for enabled standards are enabled
    ///          automatically. If set to <code>false</code>, then new controls are not enabled.</p>
    public let autoEnableControls: Bool
    /// <p>The ARN of the Hub resource that was retrieved.</p>
    public let hubArn: String?
    /// <p>The date and time when Security Hub was enabled in the account.</p>
    public let subscribedAt: String?

    public init (
        autoEnableControls: Bool = false,
        hubArn: String? = nil,
        subscribedAt: String? = nil
    )
    {
        self.autoEnableControls = autoEnableControls
        self.hubArn = hubArn
        self.subscribedAt = subscribedAt
    }
}

struct DescribeHubOutputResponseBody: Equatable {
    public let hubArn: String?
    public let subscribedAt: String?
    public let autoEnableControls: Bool
}

extension DescribeHubOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoEnableControls = "AutoEnableControls"
        case hubArn = "HubArn"
        case subscribedAt = "SubscribedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hubArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hubArn)
        hubArn = hubArnDecoded
        let subscribedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscribedAt)
        subscribedAt = subscribedAtDecoded
        let autoEnableControlsDecoded = try containerValues.decode(Bool.self, forKey: .autoEnableControls)
        autoEnableControls = autoEnableControlsDecoded
    }
}

extension DescribeOrganizationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrganizationConfigurationInput()"}
}

extension DescribeOrganizationConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeOrganizationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeOrganizationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationConfigurationOutputError>
}

public struct DescribeOrganizationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeOrganizationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationConfigurationOutputError>
}

public struct DescribeOrganizationConfigurationInput: Equatable {

    public init() {}
}

struct DescribeOrganizationConfigurationInputBody: Equatable {
}

extension DescribeOrganizationConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeOrganizationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrganizationConfigurationOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrganizationConfigurationOutputResponse(autoEnable: \(String(describing: autoEnable)), memberAccountLimitReached: \(String(describing: memberAccountLimitReached)))"}
}

extension DescribeOrganizationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeOrganizationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.autoEnable = output.autoEnable
            self.memberAccountLimitReached = output.memberAccountLimitReached
        } else {
            self.autoEnable = false
            self.memberAccountLimitReached = false
        }
    }
}

public struct DescribeOrganizationConfigurationOutputResponse: Equatable {
    /// <p>Whether to automatically enable Security Hub for new accounts in the organization.</p>
    ///          <p>If set to <code>true</code>, then Security Hub is enabled for new accounts. If set to false,
    ///          then new accounts are not added automatically.</p>
    public let autoEnable: Bool
    /// <p>Whether the maximum number of allowed member accounts are already associated with the
    ///          Security Hub administrator account.</p>
    public let memberAccountLimitReached: Bool

    public init (
        autoEnable: Bool = false,
        memberAccountLimitReached: Bool = false
    )
    {
        self.autoEnable = autoEnable
        self.memberAccountLimitReached = memberAccountLimitReached
    }
}

struct DescribeOrganizationConfigurationOutputResponseBody: Equatable {
    public let autoEnable: Bool
    public let memberAccountLimitReached: Bool
}

extension DescribeOrganizationConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoEnable = "AutoEnable"
        case memberAccountLimitReached = "MemberAccountLimitReached"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decode(Bool.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
        let memberAccountLimitReachedDecoded = try containerValues.decode(Bool.self, forKey: .memberAccountLimitReached)
        memberAccountLimitReached = memberAccountLimitReachedDecoded
    }
}

extension DescribeProductsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProductsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), productArn: \(String(describing: productArn)))"}
}

extension DescribeProductsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeProductsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProductsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProductsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProductsInput>
    public typealias MOutput = OperationOutput<DescribeProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProductsOutputError>
}

public struct DescribeProductsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProductsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProductsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let productArn = input.operationInput.productArn {
            let productArnQueryItem = URLQueryItem(name: "ProductArn".urlPercentEncoding(), value: String(productArn).urlPercentEncoding())
            input.builder.withQueryItem(productArnQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProductsInput>
    public typealias MOutput = OperationOutput<DescribeProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProductsOutputError>
}

public struct DescribeProductsInput: Equatable {
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int
    /// <p>The token that is required for pagination. On your first call to the
    ///             <code>DescribeProducts</code> operation, set the value of this parameter to
    ///             <code>NULL</code>.</p>
    ///          <p>For subsequent calls to the operation, to continue listing data, set the value of this
    ///          parameter to the value returned from the previous response.</p>
    public let nextToken: String?
    /// <p>The ARN of the integration to return.</p>
    public let productArn: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        productArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.productArn = productArn
    }
}

struct DescribeProductsInputBody: Equatable {
}

extension DescribeProductsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeProductsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProductsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProductsOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProductsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProductsOutputResponse(nextToken: \(String(describing: nextToken)), products: \(String(describing: products)))"}
}

extension DescribeProductsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeProductsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.products = output.products
        } else {
            self.nextToken = nil
            self.products = nil
        }
    }
}

public struct DescribeProductsOutputResponse: Equatable {
    /// <p>The pagination token to use to request the next page of results.</p>
    public let nextToken: String?
    /// <p>A list of products, including details for each product.</p>
    public let products: [Product]?

    public init (
        nextToken: String? = nil,
        products: [Product]? = nil
    )
    {
        self.nextToken = nextToken
        self.products = products
    }
}

struct DescribeProductsOutputResponseBody: Equatable {
    public let products: [Product]?
    public let nextToken: String?
}

extension DescribeProductsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case products = "Products"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productsContainer = try containerValues.decodeIfPresent([Product?].self, forKey: .products)
        var productsDecoded0:[Product]? = nil
        if let productsContainer = productsContainer {
            productsDecoded0 = [Product]()
            for structure0 in productsContainer {
                if let structure0 = structure0 {
                    productsDecoded0?.append(structure0)
                }
            }
        }
        products = productsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeStandardsControlsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStandardsControlsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), standardsSubscriptionArn: \(String(describing: standardsSubscriptionArn)))"}
}

extension DescribeStandardsControlsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeStandardsControlsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStandardsControlsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStandardsControlsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStandardsControlsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStandardsControlsInput>
    public typealias MOutput = OperationOutput<DescribeStandardsControlsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStandardsControlsOutputError>
}

public struct DescribeStandardsControlsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStandardsControlsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStandardsControlsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStandardsControlsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStandardsControlsInput>
    public typealias MOutput = OperationOutput<DescribeStandardsControlsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStandardsControlsOutputError>
}

public struct DescribeStandardsControlsInput: Equatable {
    /// <p>The maximum number of security standard controls to return.</p>
    public let maxResults: Int
    /// <p>The token that is required for pagination. On your first call to the
    ///             <code>DescribeStandardsControls</code> operation, set the value of this parameter to
    ///             <code>NULL</code>.</p>
    ///          <p>For subsequent calls to the operation, to continue listing data, set the value of this
    ///          parameter to the value returned from the previous response.</p>
    public let nextToken: String?
    /// <p>The ARN of a resource that represents your subscription to a supported standard. To get
    ///          the subscription ARNs of the standards you have enabled, use the <code>
    ///                <a>GetEnabledStandards</a>
    ///             </code> operation.</p>
    public let standardsSubscriptionArn: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        standardsSubscriptionArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.standardsSubscriptionArn = standardsSubscriptionArn
    }
}

struct DescribeStandardsControlsInputBody: Equatable {
}

extension DescribeStandardsControlsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeStandardsControlsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStandardsControlsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStandardsControlsOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStandardsControlsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStandardsControlsOutputResponse(controls: \(String(describing: controls)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeStandardsControlsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStandardsControlsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.controls = output.controls
            self.nextToken = output.nextToken
        } else {
            self.controls = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeStandardsControlsOutputResponse: Equatable {
    /// <p>A list of security standards controls.</p>
    public let controls: [StandardsControl]?
    /// <p>The pagination token to use to request the next page of results.</p>
    public let nextToken: String?

    public init (
        controls: [StandardsControl]? = nil,
        nextToken: String? = nil
    )
    {
        self.controls = controls
        self.nextToken = nextToken
    }
}

struct DescribeStandardsControlsOutputResponseBody: Equatable {
    public let controls: [StandardsControl]?
    public let nextToken: String?
}

extension DescribeStandardsControlsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case controls = "Controls"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlsContainer = try containerValues.decodeIfPresent([StandardsControl?].self, forKey: .controls)
        var controlsDecoded0:[StandardsControl]? = nil
        if let controlsContainer = controlsContainer {
            controlsDecoded0 = [StandardsControl]()
            for structure0 in controlsContainer {
                if let structure0 = structure0 {
                    controlsDecoded0?.append(structure0)
                }
            }
        }
        controls = controlsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeStandardsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStandardsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeStandardsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeStandardsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStandardsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStandardsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStandardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStandardsInput>
    public typealias MOutput = OperationOutput<DescribeStandardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStandardsOutputError>
}

public struct DescribeStandardsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStandardsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStandardsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStandardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStandardsInput>
    public typealias MOutput = OperationOutput<DescribeStandardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStandardsOutputError>
}

public struct DescribeStandardsInput: Equatable {
    /// <p>The maximum number of standards to return.</p>
    public let maxResults: Int
    /// <p>The token that is required for pagination. On your first call to the
    ///             <code>DescribeStandards</code> operation, set the value of this parameter to
    ///             <code>NULL</code>.</p>
    ///          <p>For subsequent calls to the operation, to continue listing data, set the value of this
    ///          parameter to the value returned from the previous response.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeStandardsInputBody: Equatable {
}

extension DescribeStandardsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeStandardsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStandardsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStandardsOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStandardsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStandardsOutputResponse(nextToken: \(String(describing: nextToken)), standards: \(String(describing: standards)))"}
}

extension DescribeStandardsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStandardsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.standards = output.standards
        } else {
            self.nextToken = nil
            self.standards = nil
        }
    }
}

public struct DescribeStandardsOutputResponse: Equatable {
    /// <p>The pagination token to use to request the next page of results.</p>
    public let nextToken: String?
    /// <p>A list of available standards.</p>
    public let standards: [Standard]?

    public init (
        nextToken: String? = nil,
        standards: [Standard]? = nil
    )
    {
        self.nextToken = nextToken
        self.standards = standards
    }
}

struct DescribeStandardsOutputResponseBody: Equatable {
    public let standards: [Standard]?
    public let nextToken: String?
}

extension DescribeStandardsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case standards = "Standards"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsContainer = try containerValues.decodeIfPresent([Standard?].self, forKey: .standards)
        var standardsDecoded0:[Standard]? = nil
        if let standardsContainer = standardsContainer {
            standardsDecoded0 = [Standard]()
            for structure0 in standardsContainer {
                if let structure0 = structure0 {
                    standardsDecoded0?.append(structure0)
                }
            }
        }
        standards = standardsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DisableImportFindingsForProductInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableImportFindingsForProductInput(productSubscriptionArn: \(String(describing: productSubscriptionArn)))"}
}

extension DisableImportFindingsForProductInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisableImportFindingsForProductInputHeadersMiddleware: Middleware {
    public let id: String = "DisableImportFindingsForProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableImportFindingsForProductInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableImportFindingsForProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableImportFindingsForProductInput>
    public typealias MOutput = OperationOutput<DisableImportFindingsForProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableImportFindingsForProductOutputError>
}

public struct DisableImportFindingsForProductInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableImportFindingsForProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableImportFindingsForProductInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableImportFindingsForProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableImportFindingsForProductInput>
    public typealias MOutput = OperationOutput<DisableImportFindingsForProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableImportFindingsForProductOutputError>
}

public struct DisableImportFindingsForProductInput: Equatable {
    /// <p>The ARN of the integrated product to disable the integration for.</p>
    public let productSubscriptionArn: String?

    public init (
        productSubscriptionArn: String? = nil
    )
    {
        self.productSubscriptionArn = productSubscriptionArn
    }
}

struct DisableImportFindingsForProductInputBody: Equatable {
}

extension DisableImportFindingsForProductInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisableImportFindingsForProductOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableImportFindingsForProductOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableImportFindingsForProductOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableImportFindingsForProductOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableImportFindingsForProductOutputResponse()"}
}

extension DisableImportFindingsForProductOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisableImportFindingsForProductOutputResponse: Equatable {

    public init() {}
}

struct DisableImportFindingsForProductOutputResponseBody: Equatable {
}

extension DisableImportFindingsForProductOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisableOrganizationAdminAccountInputBodyMiddleware: Middleware {
    public let id: String = "DisableOrganizationAdminAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<DisableOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableOrganizationAdminAccountOutputError>
}

extension DisableOrganizationAdminAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableOrganizationAdminAccountInput(adminAccountId: \(String(describing: adminAccountId)))"}
}

extension DisableOrganizationAdminAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adminAccountId = "AdminAccountId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
    }
}

public struct DisableOrganizationAdminAccountInputHeadersMiddleware: Middleware {
    public let id: String = "DisableOrganizationAdminAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<DisableOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableOrganizationAdminAccountOutputError>
}

public struct DisableOrganizationAdminAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableOrganizationAdminAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<DisableOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableOrganizationAdminAccountOutputError>
}

public struct DisableOrganizationAdminAccountInput: Equatable {
    /// <p>The AWS account identifier of the Security Hub administrator account.</p>
    public let adminAccountId: String?

    public init (
        adminAccountId: String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

struct DisableOrganizationAdminAccountInputBody: Equatable {
    public let adminAccountId: String?
}

extension DisableOrganizationAdminAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminAccountId = "AdminAccountId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
    }
}

extension DisableOrganizationAdminAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableOrganizationAdminAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableOrganizationAdminAccountOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableOrganizationAdminAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableOrganizationAdminAccountOutputResponse()"}
}

extension DisableOrganizationAdminAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisableOrganizationAdminAccountOutputResponse: Equatable {

    public init() {}
}

struct DisableOrganizationAdminAccountOutputResponseBody: Equatable {
}

extension DisableOrganizationAdminAccountOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisableSecurityHubInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableSecurityHubInput()"}
}

extension DisableSecurityHubInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisableSecurityHubInputHeadersMiddleware: Middleware {
    public let id: String = "DisableSecurityHubInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableSecurityHubInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableSecurityHubOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableSecurityHubInput>
    public typealias MOutput = OperationOutput<DisableSecurityHubOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableSecurityHubOutputError>
}

public struct DisableSecurityHubInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableSecurityHubInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableSecurityHubInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableSecurityHubOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableSecurityHubInput>
    public typealias MOutput = OperationOutput<DisableSecurityHubOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableSecurityHubOutputError>
}

public struct DisableSecurityHubInput: Equatable {

    public init() {}
}

struct DisableSecurityHubInputBody: Equatable {
}

extension DisableSecurityHubInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisableSecurityHubOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableSecurityHubOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableSecurityHubOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableSecurityHubOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableSecurityHubOutputResponse()"}
}

extension DisableSecurityHubOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisableSecurityHubOutputResponse: Equatable {

    public init() {}
}

struct DisableSecurityHubOutputResponseBody: Equatable {
}

extension DisableSecurityHubOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateFromAdministratorAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateFromAdministratorAccountInput()"}
}

extension DisassociateFromAdministratorAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateFromAdministratorAccountInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateFromAdministratorAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFromAdministratorAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFromAdministratorAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFromAdministratorAccountInput>
    public typealias MOutput = OperationOutput<DisassociateFromAdministratorAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFromAdministratorAccountOutputError>
}

public struct DisassociateFromAdministratorAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateFromAdministratorAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFromAdministratorAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFromAdministratorAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFromAdministratorAccountInput>
    public typealias MOutput = OperationOutput<DisassociateFromAdministratorAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFromAdministratorAccountOutputError>
}

public struct DisassociateFromAdministratorAccountInput: Equatable {

    public init() {}
}

struct DisassociateFromAdministratorAccountInputBody: Equatable {
}

extension DisassociateFromAdministratorAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateFromAdministratorAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateFromAdministratorAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateFromAdministratorAccountOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateFromAdministratorAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateFromAdministratorAccountOutputResponse()"}
}

extension DisassociateFromAdministratorAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateFromAdministratorAccountOutputResponse: Equatable {

    public init() {}
}

struct DisassociateFromAdministratorAccountOutputResponseBody: Equatable {
}

extension DisassociateFromAdministratorAccountOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateFromMasterAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateFromMasterAccountInput()"}
}

extension DisassociateFromMasterAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateFromMasterAccountInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateFromMasterAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFromMasterAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFromMasterAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFromMasterAccountInput>
    public typealias MOutput = OperationOutput<DisassociateFromMasterAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFromMasterAccountOutputError>
}

public struct DisassociateFromMasterAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateFromMasterAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFromMasterAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFromMasterAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFromMasterAccountInput>
    public typealias MOutput = OperationOutput<DisassociateFromMasterAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFromMasterAccountOutputError>
}

public struct DisassociateFromMasterAccountInput: Equatable {

    public init() {}
}

struct DisassociateFromMasterAccountInputBody: Equatable {
}

extension DisassociateFromMasterAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateFromMasterAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateFromMasterAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateFromMasterAccountOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateFromMasterAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateFromMasterAccountOutputResponse()"}
}

extension DisassociateFromMasterAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateFromMasterAccountOutputResponse: Equatable {

    public init() {}
}

struct DisassociateFromMasterAccountOutputResponseBody: Equatable {
}

extension DisassociateFromMasterAccountOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateMembersInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateMembersInput>
    public typealias MOutput = OperationOutput<DisassociateMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateMembersOutputError>
}

extension DisassociateMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateMembersInput(accountIds: \(String(describing: accountIds)))"}
}

extension DisassociateMembersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountidlist0 in accountIds {
                try accountIdsContainer.encode(accountidlist0)
            }
        }
    }
}

public struct DisassociateMembersInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateMembersInput>
    public typealias MOutput = OperationOutput<DisassociateMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateMembersOutputError>
}

public struct DisassociateMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateMembersInput>
    public typealias MOutput = OperationOutput<DisassociateMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateMembersOutputError>
}

public struct DisassociateMembersInput: Equatable {
    /// <p>The account IDs of the member accounts to disassociate from the administrator account.</p>
    public let accountIds: [String]?

    public init (
        accountIds: [String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct DisassociateMembersInputBody: Equatable {
    public let accountIds: [String]?
}

extension DisassociateMembersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DisassociateMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateMembersOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateMembersOutputResponse()"}
}

extension DisassociateMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateMembersOutputResponse: Equatable {

    public init() {}
}

struct DisassociateMembersOutputResponseBody: Equatable {
}

extension DisassociateMembersOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DnsRequestAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blocked = "Blocked"
        case domain = "Domain"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blocked != false {
            try encodeContainer.encode(blocked, forKey: .blocked)
        }
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let blockedDecoded = try containerValues.decode(Bool.self, forKey: .blocked)
        blocked = blockedDecoded
    }
}

extension DnsRequestAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DnsRequestAction(blocked: \(String(describing: blocked)), domain: \(String(describing: domain)), protocol: \(String(describing: `protocol`)))"}
}

/// <p>Provided if <code>ActionType</code> is <code>DNS_REQUEST</code>. It provides details
///          about the DNS request that was detected.</p>
public struct DnsRequestAction: Equatable {
    /// <p>The protocol that was used for the DNS request.</p>
    public let `protocol`: String?
    /// <p>Indicates whether the DNS request was blocked.</p>
    public let blocked: Bool
    /// <p>The DNS domain that is associated with the DNS request.</p>
    public let domain: String?

    public init (
        `protocol`: String? = nil,
        blocked: Bool = false,
        domain: String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.blocked = blocked
        self.domain = domain
    }
}

public struct EnableImportFindingsForProductInputBodyMiddleware: Middleware {
    public let id: String = "EnableImportFindingsForProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableImportFindingsForProductInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableImportFindingsForProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableImportFindingsForProductInput>
    public typealias MOutput = OperationOutput<EnableImportFindingsForProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableImportFindingsForProductOutputError>
}

extension EnableImportFindingsForProductInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableImportFindingsForProductInput(productArn: \(String(describing: productArn)))"}
}

extension EnableImportFindingsForProductInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case productArn = "ProductArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productArn = productArn {
            try encodeContainer.encode(productArn, forKey: .productArn)
        }
    }
}

public struct EnableImportFindingsForProductInputHeadersMiddleware: Middleware {
    public let id: String = "EnableImportFindingsForProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableImportFindingsForProductInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableImportFindingsForProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableImportFindingsForProductInput>
    public typealias MOutput = OperationOutput<EnableImportFindingsForProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableImportFindingsForProductOutputError>
}

public struct EnableImportFindingsForProductInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableImportFindingsForProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableImportFindingsForProductInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableImportFindingsForProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableImportFindingsForProductInput>
    public typealias MOutput = OperationOutput<EnableImportFindingsForProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableImportFindingsForProductOutputError>
}

public struct EnableImportFindingsForProductInput: Equatable {
    /// <p>The ARN of the product to enable the integration for.</p>
    public let productArn: String?

    public init (
        productArn: String? = nil
    )
    {
        self.productArn = productArn
    }
}

struct EnableImportFindingsForProductInputBody: Equatable {
    public let productArn: String?
}

extension EnableImportFindingsForProductInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case productArn = "ProductArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productArn)
        productArn = productArnDecoded
    }
}

extension EnableImportFindingsForProductOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableImportFindingsForProductOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableImportFindingsForProductOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceConflictException(ResourceConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableImportFindingsForProductOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableImportFindingsForProductOutputResponse(productSubscriptionArn: \(String(describing: productSubscriptionArn)))"}
}

extension EnableImportFindingsForProductOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EnableImportFindingsForProductOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.productSubscriptionArn = output.productSubscriptionArn
        } else {
            self.productSubscriptionArn = nil
        }
    }
}

public struct EnableImportFindingsForProductOutputResponse: Equatable {
    /// <p>The ARN of your subscription to the product to enable integrations for.</p>
    public let productSubscriptionArn: String?

    public init (
        productSubscriptionArn: String? = nil
    )
    {
        self.productSubscriptionArn = productSubscriptionArn
    }
}

struct EnableImportFindingsForProductOutputResponseBody: Equatable {
    public let productSubscriptionArn: String?
}

extension EnableImportFindingsForProductOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case productSubscriptionArn = "ProductSubscriptionArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productSubscriptionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productSubscriptionArn)
        productSubscriptionArn = productSubscriptionArnDecoded
    }
}

public struct EnableOrganizationAdminAccountInputBodyMiddleware: Middleware {
    public let id: String = "EnableOrganizationAdminAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<EnableOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableOrganizationAdminAccountOutputError>
}

extension EnableOrganizationAdminAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableOrganizationAdminAccountInput(adminAccountId: \(String(describing: adminAccountId)))"}
}

extension EnableOrganizationAdminAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adminAccountId = "AdminAccountId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
    }
}

public struct EnableOrganizationAdminAccountInputHeadersMiddleware: Middleware {
    public let id: String = "EnableOrganizationAdminAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<EnableOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableOrganizationAdminAccountOutputError>
}

public struct EnableOrganizationAdminAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableOrganizationAdminAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<EnableOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableOrganizationAdminAccountOutputError>
}

public struct EnableOrganizationAdminAccountInput: Equatable {
    /// <p>The AWS account identifier of the account to designate as the Security Hub administrator
    ///          account.</p>
    public let adminAccountId: String?

    public init (
        adminAccountId: String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

struct EnableOrganizationAdminAccountInputBody: Equatable {
    public let adminAccountId: String?
}

extension EnableOrganizationAdminAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminAccountId = "AdminAccountId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
    }
}

extension EnableOrganizationAdminAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableOrganizationAdminAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableOrganizationAdminAccountOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableOrganizationAdminAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableOrganizationAdminAccountOutputResponse()"}
}

extension EnableOrganizationAdminAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct EnableOrganizationAdminAccountOutputResponse: Equatable {

    public init() {}
}

struct EnableOrganizationAdminAccountOutputResponseBody: Equatable {
}

extension EnableOrganizationAdminAccountOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct EnableSecurityHubInputBodyMiddleware: Middleware {
    public let id: String = "EnableSecurityHubInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableSecurityHubInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableSecurityHubOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableSecurityHubInput>
    public typealias MOutput = OperationOutput<EnableSecurityHubOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableSecurityHubOutputError>
}

extension EnableSecurityHubInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableSecurityHubInput(enableDefaultStandards: \(String(describing: enableDefaultStandards)), tags: \(String(describing: tags)))"}
}

extension EnableSecurityHubInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enableDefaultStandards = "EnableDefaultStandards"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enableDefaultStandards != false {
            try encodeContainer.encode(enableDefaultStandards, forKey: .enableDefaultStandards)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct EnableSecurityHubInputHeadersMiddleware: Middleware {
    public let id: String = "EnableSecurityHubInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableSecurityHubInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableSecurityHubOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableSecurityHubInput>
    public typealias MOutput = OperationOutput<EnableSecurityHubOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableSecurityHubOutputError>
}

public struct EnableSecurityHubInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableSecurityHubInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableSecurityHubInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableSecurityHubOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableSecurityHubInput>
    public typealias MOutput = OperationOutput<EnableSecurityHubOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableSecurityHubOutputError>
}

public struct EnableSecurityHubInput: Equatable {
    /// <p>Whether to enable the security standards that Security Hub has designated as automatically
    ///          enabled. If you do not provide a value for <code>EnableDefaultStandards</code>, it is set
    ///          to <code>true</code>. To not enable the automatically enabled standards, set
    ///             <code>EnableDefaultStandards</code> to <code>false</code>.</p>
    public let enableDefaultStandards: Bool
    /// <p>The tags to add to the hub resource when you enable Security Hub.</p>
    public let tags: [String:String]?

    public init (
        enableDefaultStandards: Bool = false,
        tags: [String:String]? = nil
    )
    {
        self.enableDefaultStandards = enableDefaultStandards
        self.tags = tags
    }
}

struct EnableSecurityHubInputBody: Equatable {
    public let tags: [String:String]?
    public let enableDefaultStandards: Bool
}

extension EnableSecurityHubInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case enableDefaultStandards = "EnableDefaultStandards"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let enableDefaultStandardsDecoded = try containerValues.decode(Bool.self, forKey: .enableDefaultStandards)
        enableDefaultStandards = enableDefaultStandardsDecoded
    }
}

extension EnableSecurityHubOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableSecurityHubOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableSecurityHubOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case limitExceededException(LimitExceededException)
    case resourceConflictException(ResourceConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableSecurityHubOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableSecurityHubOutputResponse()"}
}

extension EnableSecurityHubOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct EnableSecurityHubOutputResponse: Equatable {

    public init() {}
}

struct EnableSecurityHubOutputResponseBody: Equatable {
}

extension EnableSecurityHubOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension FindingProviderFields: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case confidence = "Confidence"
        case criticality = "Criticality"
        case relatedFindings = "RelatedFindings"
        case severity = "Severity"
        case types = "Types"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if confidence != 0 {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if criticality != 0 {
            try encodeContainer.encode(criticality, forKey: .criticality)
        }
        if let relatedFindings = relatedFindings {
            var relatedFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedFindings)
            for relatedfindinglist0 in relatedFindings {
                try relatedFindingsContainer.encode(relatedfindinglist0)
            }
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let types = types {
            var typesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .types)
            for typelist0 in types {
                try typesContainer.encode(typelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let confidenceDecoded = try containerValues.decode(Int.self, forKey: .confidence)
        confidence = confidenceDecoded
        let criticalityDecoded = try containerValues.decode(Int.self, forKey: .criticality)
        criticality = criticalityDecoded
        let relatedFindingsContainer = try containerValues.decodeIfPresent([RelatedFinding?].self, forKey: .relatedFindings)
        var relatedFindingsDecoded0:[RelatedFinding]? = nil
        if let relatedFindingsContainer = relatedFindingsContainer {
            relatedFindingsDecoded0 = [RelatedFinding]()
            for structure0 in relatedFindingsContainer {
                if let structure0 = structure0 {
                    relatedFindingsDecoded0?.append(structure0)
                }
            }
        }
        relatedFindings = relatedFindingsDecoded0
        let severityDecoded = try containerValues.decodeIfPresent(FindingProviderSeverity.self, forKey: .severity)
        severity = severityDecoded
        let typesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .types)
        var typesDecoded0:[String]? = nil
        if let typesContainer = typesContainer {
            typesDecoded0 = [String]()
            for string0 in typesContainer {
                if let string0 = string0 {
                    typesDecoded0?.append(string0)
                }
            }
        }
        types = typesDecoded0
    }
}

extension FindingProviderFields: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FindingProviderFields(confidence: \(String(describing: confidence)), criticality: \(String(describing: criticality)), relatedFindings: \(String(describing: relatedFindings)), severity: \(String(describing: severity)), types: \(String(describing: types)))"}
}

/// <p>In a <code>BatchImportFindings</code> request, finding providers use <code>FindingProviderFields</code> to provide and update values for confidence, criticality, related findings, severity, and types.</p>
public struct FindingProviderFields: Equatable {
    /// <p>A finding's confidence. Confidence is defined as the likelihood that a finding
    ///          accurately identifies the behavior or issue that it was intended to identify.</p>
    ///          <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent
    ///          confidence and 100 means 100 percent confidence.</p>
    public let confidence: Int
    /// <p>The level of importance assigned to the resources associated with the finding.</p>
    ///          <p>A score of 0 means that the underlying resources have no criticality, and a score of 100
    ///          is reserved for the most critical resources.</p>
    public let criticality: Int
    /// <p>A list of findings that are related to the current finding.</p>
    public let relatedFindings: [RelatedFinding]?
    /// <p>The severity of a finding.</p>
    public let severity: FindingProviderSeverity?
    /// <p>One or more finding types in the format of <code>namespace/category/classifier</code>
    ///          that classify a finding.</p>
    ///          <p>Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual
    ///          Behaviors | Sensitive Data Identifications</p>
    public let types: [String]?

    public init (
        confidence: Int = 0,
        criticality: Int = 0,
        relatedFindings: [RelatedFinding]? = nil,
        severity: FindingProviderSeverity? = nil,
        types: [String]? = nil
    )
    {
        self.confidence = confidence
        self.criticality = criticality
        self.relatedFindings = relatedFindings
        self.severity = severity
        self.types = types
    }
}

extension FindingProviderSeverity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case label = "Label"
        case original = "Original"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let label = label {
            try encodeContainer.encode(label.rawValue, forKey: .label)
        }
        if let original = original {
            try encodeContainer.encode(original, forKey: .original)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelDecoded = try containerValues.decodeIfPresent(SeverityLabel.self, forKey: .label)
        label = labelDecoded
        let originalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .original)
        original = originalDecoded
    }
}

extension FindingProviderSeverity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FindingProviderSeverity(label: \(String(describing: label)), original: \(String(describing: original)))"}
}

/// <p>The severity assigned to the finding by the finding provider.</p>
public struct FindingProviderSeverity: Equatable {
    /// <p>The severity label assigned to the finding by the finding provider.</p>
    public let label: SeverityLabel?
    /// <p>The finding provider's original value for the severity.</p>
    public let original: String?

    public init (
        label: SeverityLabel? = nil,
        original: String? = nil
    )
    {
        self.label = label
        self.original = original
    }
}

extension GeoLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lat = "Lat"
        case lon = "Lon"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if lat != 0.0 {
            try encodeContainer.encode(lat, forKey: .lat)
        }
        if lon != 0.0 {
            try encodeContainer.encode(lon, forKey: .lon)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lonDecoded = try containerValues.decode(Double.self, forKey: .lon)
        lon = lonDecoded
        let latDecoded = try containerValues.decode(Double.self, forKey: .lat)
        lat = latDecoded
    }
}

extension GeoLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GeoLocation(lat: \(String(describing: lat)), lon: \(String(describing: lon)))"}
}

/// <p>Provides the latitude and longitude coordinates of a location.</p>
public struct GeoLocation: Equatable {
    /// <p>The latitude of the location.</p>
    public let lat: Double
    /// <p>The longitude of the location.</p>
    public let lon: Double

    public init (
        lat: Double = 0.0,
        lon: Double = 0.0
    )
    {
        self.lat = lat
        self.lon = lon
    }
}

extension GetAdministratorAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAdministratorAccountInput()"}
}

extension GetAdministratorAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAdministratorAccountInputHeadersMiddleware: Middleware {
    public let id: String = "GetAdministratorAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAdministratorAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAdministratorAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAdministratorAccountInput>
    public typealias MOutput = OperationOutput<GetAdministratorAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAdministratorAccountOutputError>
}

public struct GetAdministratorAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAdministratorAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAdministratorAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAdministratorAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAdministratorAccountInput>
    public typealias MOutput = OperationOutput<GetAdministratorAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAdministratorAccountOutputError>
}

public struct GetAdministratorAccountInput: Equatable {

    public init() {}
}

struct GetAdministratorAccountInputBody: Equatable {
}

extension GetAdministratorAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAdministratorAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAdministratorAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAdministratorAccountOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAdministratorAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAdministratorAccountOutputResponse(administrator: \(String(describing: administrator)))"}
}

extension GetAdministratorAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAdministratorAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.administrator = output.administrator
        } else {
            self.administrator = nil
        }
    }
}

public struct GetAdministratorAccountOutputResponse: Equatable {
    /// <p>Details about an invitation.</p>
    public let administrator: Invitation?

    public init (
        administrator: Invitation? = nil
    )
    {
        self.administrator = administrator
    }
}

struct GetAdministratorAccountOutputResponseBody: Equatable {
    public let administrator: Invitation?
}

extension GetAdministratorAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case administrator = "Administrator"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let administratorDecoded = try containerValues.decodeIfPresent(Invitation.self, forKey: .administrator)
        administrator = administratorDecoded
    }
}

public struct GetEnabledStandardsInputBodyMiddleware: Middleware {
    public let id: String = "GetEnabledStandardsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEnabledStandardsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEnabledStandardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEnabledStandardsInput>
    public typealias MOutput = OperationOutput<GetEnabledStandardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEnabledStandardsOutputError>
}

extension GetEnabledStandardsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEnabledStandardsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), standardsSubscriptionArns: \(String(describing: standardsSubscriptionArns)))"}
}

extension GetEnabledStandardsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case standardsSubscriptionArns = "StandardsSubscriptionArns"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let standardsSubscriptionArns = standardsSubscriptionArns {
            var standardsSubscriptionArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .standardsSubscriptionArns)
            for standardssubscriptionarns0 in standardsSubscriptionArns {
                try standardsSubscriptionArnsContainer.encode(standardssubscriptionarns0)
            }
        }
    }
}

public struct GetEnabledStandardsInputHeadersMiddleware: Middleware {
    public let id: String = "GetEnabledStandardsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEnabledStandardsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEnabledStandardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEnabledStandardsInput>
    public typealias MOutput = OperationOutput<GetEnabledStandardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEnabledStandardsOutputError>
}

public struct GetEnabledStandardsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEnabledStandardsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEnabledStandardsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEnabledStandardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEnabledStandardsInput>
    public typealias MOutput = OperationOutput<GetEnabledStandardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEnabledStandardsOutputError>
}

public struct GetEnabledStandardsInput: Equatable {
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int
    /// <p>The token that is required for pagination. On your first call to the
    ///             <code>GetEnabledStandards</code> operation, set the value of this parameter to
    ///             <code>NULL</code>.</p>
    ///          <p>For subsequent calls to the operation, to continue listing data, set the value of this
    ///          parameter to the value returned from the previous response.</p>
    public let nextToken: String?
    /// <p>The list of the standards subscription ARNs for the standards to retrieve.</p>
    public let standardsSubscriptionArns: [String]?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        standardsSubscriptionArns: [String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.standardsSubscriptionArns = standardsSubscriptionArns
    }
}

struct GetEnabledStandardsInputBody: Equatable {
    public let standardsSubscriptionArns: [String]?
    public let nextToken: String?
    public let maxResults: Int
}

extension GetEnabledStandardsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case standardsSubscriptionArns = "StandardsSubscriptionArns"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsSubscriptionArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .standardsSubscriptionArns)
        var standardsSubscriptionArnsDecoded0:[String]? = nil
        if let standardsSubscriptionArnsContainer = standardsSubscriptionArnsContainer {
            standardsSubscriptionArnsDecoded0 = [String]()
            for string0 in standardsSubscriptionArnsContainer {
                if let string0 = string0 {
                    standardsSubscriptionArnsDecoded0?.append(string0)
                }
            }
        }
        standardsSubscriptionArns = standardsSubscriptionArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetEnabledStandardsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEnabledStandardsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEnabledStandardsOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEnabledStandardsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEnabledStandardsOutputResponse(nextToken: \(String(describing: nextToken)), standardsSubscriptions: \(String(describing: standardsSubscriptions)))"}
}

extension GetEnabledStandardsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEnabledStandardsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.standardsSubscriptions = output.standardsSubscriptions
        } else {
            self.nextToken = nil
            self.standardsSubscriptions = nil
        }
    }
}

public struct GetEnabledStandardsOutputResponse: Equatable {
    /// <p>The pagination token to use to request the next page of results.</p>
    public let nextToken: String?
    /// <p>The list of <code>StandardsSubscriptions</code> objects that include information about
    ///          the enabled standards.</p>
    public let standardsSubscriptions: [StandardsSubscription]?

    public init (
        nextToken: String? = nil,
        standardsSubscriptions: [StandardsSubscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.standardsSubscriptions = standardsSubscriptions
    }
}

struct GetEnabledStandardsOutputResponseBody: Equatable {
    public let standardsSubscriptions: [StandardsSubscription]?
    public let nextToken: String?
}

extension GetEnabledStandardsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case standardsSubscriptions = "StandardsSubscriptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsSubscriptionsContainer = try containerValues.decodeIfPresent([StandardsSubscription?].self, forKey: .standardsSubscriptions)
        var standardsSubscriptionsDecoded0:[StandardsSubscription]? = nil
        if let standardsSubscriptionsContainer = standardsSubscriptionsContainer {
            standardsSubscriptionsDecoded0 = [StandardsSubscription]()
            for structure0 in standardsSubscriptionsContainer {
                if let structure0 = structure0 {
                    standardsSubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        standardsSubscriptions = standardsSubscriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetFindingsInputBodyMiddleware: Middleware {
    public let id: String = "GetFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingsInput>
    public typealias MOutput = OperationOutput<GetFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingsOutputError>
}

extension GetFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFindingsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortCriteria: \(String(describing: sortCriteria)))"}
}

extension GetFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sortcriteria0 in sortCriteria {
                try sortCriteriaContainer.encode(sortcriteria0)
            }
        }
    }
}

public struct GetFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "GetFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingsInput>
    public typealias MOutput = OperationOutput<GetFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingsOutputError>
}

public struct GetFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingsInput>
    public typealias MOutput = OperationOutput<GetFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingsOutputError>
}

public struct GetFindingsInput: Equatable {
    /// <p>The finding attributes used to define a condition to filter the returned
    ///          findings.</p>
    ///          <p>You can filter by up to 10 finding attributes. For each attribute, you can provide up to
    ///          20 filter values.</p>
    ///          <p>Note that in the available filter fields, <code>WorkflowState</code> is deprecated. To
    ///          search for a finding based on its workflow status, use <code>WorkflowStatus</code>.</p>
    public let filters: AwsSecurityFindingFilters?
    /// <p>The maximum number of findings to return.</p>
    public let maxResults: Int
    /// <p>The token that is required for pagination. On your first call to the
    ///             <code>GetFindings</code> operation, set the value of this parameter to
    ///          <code>NULL</code>.</p>
    ///          <p>For subsequent calls to the operation, to continue listing data, set the value of this
    ///          parameter to the value returned from the previous response.</p>
    public let nextToken: String?
    /// <p>The finding attributes used to sort the list of returned findings.</p>
    public let sortCriteria: [SortCriterion]?

    public init (
        filters: AwsSecurityFindingFilters? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        sortCriteria: [SortCriterion]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct GetFindingsInputBody: Equatable {
    public let filters: AwsSecurityFindingFilters?
    public let sortCriteria: [SortCriterion]?
    public let nextToken: String?
    public let maxResults: Int
}

extension GetFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(AwsSecurityFindingFilters.self, forKey: .filters)
        filters = filtersDecoded
        let sortCriteriaContainer = try containerValues.decodeIfPresent([SortCriterion?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[SortCriterion]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [SortCriterion]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFindingsOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFindingsOutputResponse(findings: \(String(describing: findings)), nextToken: \(String(describing: nextToken)))"}
}

extension GetFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFindingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.findings = output.findings
            self.nextToken = output.nextToken
        } else {
            self.findings = nil
            self.nextToken = nil
        }
    }
}

public struct GetFindingsOutputResponse: Equatable {
    /// <p>The findings that matched the filters specified in the request.</p>
    public let findings: [AwsSecurityFinding]?
    /// <p>The pagination token to use to request the next page of results.</p>
    public let nextToken: String?

    public init (
        findings: [AwsSecurityFinding]? = nil,
        nextToken: String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

struct GetFindingsOutputResponseBody: Equatable {
    public let findings: [AwsSecurityFinding]?
    public let nextToken: String?
}

extension GetFindingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findings = "Findings"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([AwsSecurityFinding?].self, forKey: .findings)
        var findingsDecoded0:[AwsSecurityFinding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [AwsSecurityFinding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetInsightResultsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInsightResultsInput(insightArn: \(String(describing: insightArn)))"}
}

extension GetInsightResultsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetInsightResultsInputHeadersMiddleware: Middleware {
    public let id: String = "GetInsightResultsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInsightResultsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInsightResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInsightResultsInput>
    public typealias MOutput = OperationOutput<GetInsightResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInsightResultsOutputError>
}

public struct GetInsightResultsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInsightResultsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInsightResultsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInsightResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInsightResultsInput>
    public typealias MOutput = OperationOutput<GetInsightResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInsightResultsOutputError>
}

public struct GetInsightResultsInput: Equatable {
    /// <p>The ARN of the insight for which to return results.</p>
    public let insightArn: String?

    public init (
        insightArn: String? = nil
    )
    {
        self.insightArn = insightArn
    }
}

struct GetInsightResultsInputBody: Equatable {
}

extension GetInsightResultsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetInsightResultsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInsightResultsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInsightResultsOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInsightResultsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInsightResultsOutputResponse(insightResults: \(String(describing: insightResults)))"}
}

extension GetInsightResultsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetInsightResultsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.insightResults = output.insightResults
        } else {
            self.insightResults = nil
        }
    }
}

public struct GetInsightResultsOutputResponse: Equatable {
    /// <p>The insight results returned by the operation.</p>
    public let insightResults: InsightResults?

    public init (
        insightResults: InsightResults? = nil
    )
    {
        self.insightResults = insightResults
    }
}

struct GetInsightResultsOutputResponseBody: Equatable {
    public let insightResults: InsightResults?
}

extension GetInsightResultsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case insightResults = "InsightResults"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightResultsDecoded = try containerValues.decodeIfPresent(InsightResults.self, forKey: .insightResults)
        insightResults = insightResultsDecoded
    }
}

public struct GetInsightsInputBodyMiddleware: Middleware {
    public let id: String = "GetInsightsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInsightsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInsightsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInsightsInput>
    public typealias MOutput = OperationOutput<GetInsightsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInsightsOutputError>
}

extension GetInsightsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInsightsInput(insightArns: \(String(describing: insightArns)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetInsightsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case insightArns = "InsightArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightArns = insightArns {
            var insightArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .insightArns)
            for arnlist0 in insightArns {
                try insightArnsContainer.encode(arnlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetInsightsInputHeadersMiddleware: Middleware {
    public let id: String = "GetInsightsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInsightsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInsightsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInsightsInput>
    public typealias MOutput = OperationOutput<GetInsightsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInsightsOutputError>
}

public struct GetInsightsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInsightsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInsightsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInsightsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInsightsInput>
    public typealias MOutput = OperationOutput<GetInsightsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInsightsOutputError>
}

public struct GetInsightsInput: Equatable {
    /// <p>The ARNs of the insights to describe. If you do not provide any insight ARNs, then
    ///             <code>GetInsights</code> returns all of your custom insights. It does not return any
    ///          managed insights.</p>
    public let insightArns: [String]?
    /// <p>The maximum number of items to return in the response.</p>
    public let maxResults: Int
    /// <p>The token that is required for pagination. On your first call to the
    ///             <code>GetInsights</code> operation, set the value of this parameter to
    ///          <code>NULL</code>.</p>
    ///          <p>For subsequent calls to the operation, to continue listing data, set the value of this
    ///          parameter to the value returned from the previous response.</p>
    public let nextToken: String?

    public init (
        insightArns: [String]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.insightArns = insightArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetInsightsInputBody: Equatable {
    public let insightArns: [String]?
    public let nextToken: String?
    public let maxResults: Int
}

extension GetInsightsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case insightArns = "InsightArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .insightArns)
        var insightArnsDecoded0:[String]? = nil
        if let insightArnsContainer = insightArnsContainer {
            insightArnsDecoded0 = [String]()
            for string0 in insightArnsContainer {
                if let string0 = string0 {
                    insightArnsDecoded0?.append(string0)
                }
            }
        }
        insightArns = insightArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetInsightsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInsightsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInsightsOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInsightsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInsightsOutputResponse(insights: \(String(describing: insights)), nextToken: \(String(describing: nextToken)))"}
}

extension GetInsightsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetInsightsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.insights = output.insights
            self.nextToken = output.nextToken
        } else {
            self.insights = nil
            self.nextToken = nil
        }
    }
}

public struct GetInsightsOutputResponse: Equatable {
    /// <p>The insights returned by the operation.</p>
    public let insights: [Insight]?
    /// <p>The pagination token to use to request the next page of results.</p>
    public let nextToken: String?

    public init (
        insights: [Insight]? = nil,
        nextToken: String? = nil
    )
    {
        self.insights = insights
        self.nextToken = nextToken
    }
}

struct GetInsightsOutputResponseBody: Equatable {
    public let insights: [Insight]?
    public let nextToken: String?
}

extension GetInsightsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case insights = "Insights"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightsContainer = try containerValues.decodeIfPresent([Insight?].self, forKey: .insights)
        var insightsDecoded0:[Insight]? = nil
        if let insightsContainer = insightsContainer {
            insightsDecoded0 = [Insight]()
            for structure0 in insightsContainer {
                if let structure0 = structure0 {
                    insightsDecoded0?.append(structure0)
                }
            }
        }
        insights = insightsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetInvitationsCountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInvitationsCountInput()"}
}

extension GetInvitationsCountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetInvitationsCountInputHeadersMiddleware: Middleware {
    public let id: String = "GetInvitationsCountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInvitationsCountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInvitationsCountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInvitationsCountInput>
    public typealias MOutput = OperationOutput<GetInvitationsCountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInvitationsCountOutputError>
}

public struct GetInvitationsCountInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInvitationsCountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInvitationsCountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInvitationsCountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInvitationsCountInput>
    public typealias MOutput = OperationOutput<GetInvitationsCountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInvitationsCountOutputError>
}

public struct GetInvitationsCountInput: Equatable {

    public init() {}
}

struct GetInvitationsCountInputBody: Equatable {
}

extension GetInvitationsCountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetInvitationsCountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInvitationsCountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInvitationsCountOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInvitationsCountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInvitationsCountOutputResponse(invitationsCount: \(String(describing: invitationsCount)))"}
}

extension GetInvitationsCountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetInvitationsCountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.invitationsCount = output.invitationsCount
        } else {
            self.invitationsCount = 0
        }
    }
}

public struct GetInvitationsCountOutputResponse: Equatable {
    /// <p>The number of all membership invitations sent to this Security Hub member account, not
    ///          including the currently accepted invitation.</p>
    public let invitationsCount: Int

    public init (
        invitationsCount: Int = 0
    )
    {
        self.invitationsCount = invitationsCount
    }
}

struct GetInvitationsCountOutputResponseBody: Equatable {
    public let invitationsCount: Int
}

extension GetInvitationsCountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invitationsCount = "InvitationsCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitationsCountDecoded = try containerValues.decode(Int.self, forKey: .invitationsCount)
        invitationsCount = invitationsCountDecoded
    }
}

extension GetMasterAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMasterAccountInput()"}
}

extension GetMasterAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetMasterAccountInputHeadersMiddleware: Middleware {
    public let id: String = "GetMasterAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMasterAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMasterAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMasterAccountInput>
    public typealias MOutput = OperationOutput<GetMasterAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMasterAccountOutputError>
}

public struct GetMasterAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMasterAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMasterAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMasterAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMasterAccountInput>
    public typealias MOutput = OperationOutput<GetMasterAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMasterAccountOutputError>
}

public struct GetMasterAccountInput: Equatable {

    public init() {}
}

struct GetMasterAccountInputBody: Equatable {
}

extension GetMasterAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetMasterAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMasterAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMasterAccountOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMasterAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMasterAccountOutputResponse(master: \(String(describing: master)))"}
}

extension GetMasterAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMasterAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.master = output.master
        } else {
            self.master = nil
        }
    }
}

public struct GetMasterAccountOutputResponse: Equatable {
    /// <p>A list of details about the Security Hub administrator account for the current member account.
    ///       </p>
    public let master: Invitation?

    public init (
        master: Invitation? = nil
    )
    {
        self.master = master
    }
}

struct GetMasterAccountOutputResponseBody: Equatable {
    public let master: Invitation?
}

extension GetMasterAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case master = "Master"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let masterDecoded = try containerValues.decodeIfPresent(Invitation.self, forKey: .master)
        master = masterDecoded
    }
}

public struct GetMembersInputBodyMiddleware: Middleware {
    public let id: String = "GetMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMembersInput>
    public typealias MOutput = OperationOutput<GetMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMembersOutputError>
}

extension GetMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMembersInput(accountIds: \(String(describing: accountIds)))"}
}

extension GetMembersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountidlist0 in accountIds {
                try accountIdsContainer.encode(accountidlist0)
            }
        }
    }
}

public struct GetMembersInputHeadersMiddleware: Middleware {
    public let id: String = "GetMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMembersInput>
    public typealias MOutput = OperationOutput<GetMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMembersOutputError>
}

public struct GetMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMembersInput>
    public typealias MOutput = OperationOutput<GetMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMembersOutputError>
}

public struct GetMembersInput: Equatable {
    /// <p>The list of account IDs for the Security Hub member accounts to return the details for. </p>
    public let accountIds: [String]?

    public init (
        accountIds: [String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct GetMembersInputBody: Equatable {
    public let accountIds: [String]?
}

extension GetMembersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension GetMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMembersOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMembersOutputResponse(members: \(String(describing: members)), unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension GetMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMembersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.members = output.members
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.members = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct GetMembersOutputResponse: Equatable {
    /// <p>The list of details about the Security Hub member accounts.</p>
    public let members: [Member]?
    /// <p>The list of AWS accounts that could not be processed. For each account, the list
    ///          includes the account ID and the email address.</p>
    public let unprocessedAccounts: [Result]?

    public init (
        members: [Member]? = nil,
        unprocessedAccounts: [Result]? = nil
    )
    {
        self.members = members
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct GetMembersOutputResponseBody: Equatable {
    public let members: [Member]?
    public let unprocessedAccounts: [Result]?
}

extension GetMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case members = "Members"
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([Member?].self, forKey: .members)
        var membersDecoded0:[Member]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [Member]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([Result?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[Result]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [Result]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension IcmpTypeCode: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if code != 0 {
            try encodeContainer.encode(code, forKey: .code)
        }
        if type != 0 {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decode(Int.self, forKey: .code)
        code = codeDecoded
        let typeDecoded = try containerValues.decode(Int.self, forKey: .type)
        type = typeDecoded
    }
}

extension IcmpTypeCode: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IcmpTypeCode(code: \(String(describing: code)), type: \(String(describing: type)))"}
}

/// <p>An Internet Control Message Protocol (ICMP) type and code.</p>
public struct IcmpTypeCode: Equatable {
    /// <p>The ICMP code for which to deny or allow access. To deny or allow all codes, use the value -1.</p>
    public let code: Int
    /// <p>The ICMP type for which to deny or allow access. To deny or allow all types, use the value -1.</p>
    public let type: Int

    public init (
        code: Int = 0,
        type: Int = 0
    )
    {
        self.code = code
        self.type = type
    }
}

extension ImportFindingsError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ImportFindingsError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportFindingsError(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), id: \(String(describing: id)))"}
}

/// <p>The list of the findings that cannot be imported. For each finding, the list provides
///          the error.</p>
public struct ImportFindingsError: Equatable {
    /// <p>The code of the error returned by the <code>BatchImportFindings</code> operation.</p>
    public let errorCode: String?
    /// <p>The message of the error returned by the <code>BatchImportFindings</code>
    ///          operation.</p>
    public let errorMessage: String?
    /// <p>The identifier of the finding that could not be updated.</p>
    public let id: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        id: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.id = id
    }
}

extension Insight: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case groupByAttribute = "GroupByAttribute"
        case insightArn = "InsightArn"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let groupByAttribute = groupByAttribute {
            try encodeContainer.encode(groupByAttribute, forKey: .groupByAttribute)
        }
        if let insightArn = insightArn {
            try encodeContainer.encode(insightArn, forKey: .insightArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .insightArn)
        insightArn = insightArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(AwsSecurityFindingFilters.self, forKey: .filters)
        filters = filtersDecoded
        let groupByAttributeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupByAttribute)
        groupByAttribute = groupByAttributeDecoded
    }
}

extension Insight: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Insight(filters: \(String(describing: filters)), groupByAttribute: \(String(describing: groupByAttribute)), insightArn: \(String(describing: insightArn)), name: \(String(describing: name)))"}
}

/// <p>Contains information about a Security Hub insight.</p>
public struct Insight: Equatable {
    /// <p>One or more attributes used to filter the findings included in the insight. The insight
    ///          only includes findings that match the criteria defined in the filters.</p>
    public let filters: AwsSecurityFindingFilters?
    /// <p>The grouping attribute for the insight's findings. Indicates how to group the matching
    ///          findings, and identifies the type of item that the insight applies to. For example, if an
    ///          insight is grouped by resource identifier, then the insight produces a list of resource
    ///          identifiers.</p>
    public let groupByAttribute: String?
    /// <p>The ARN of a Security Hub insight.</p>
    public let insightArn: String?
    /// <p>The name of a Security Hub insight.</p>
    public let name: String?

    public init (
        filters: AwsSecurityFindingFilters? = nil,
        groupByAttribute: String? = nil,
        insightArn: String? = nil,
        name: String? = nil
    )
    {
        self.filters = filters
        self.groupByAttribute = groupByAttribute
        self.insightArn = insightArn
        self.name = name
    }
}

extension InsightResultValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case count = "Count"
        case groupByAttributeValue = "GroupByAttributeValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let groupByAttributeValue = groupByAttributeValue {
            try encodeContainer.encode(groupByAttributeValue, forKey: .groupByAttributeValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupByAttributeValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupByAttributeValue)
        groupByAttributeValue = groupByAttributeValueDecoded
        let countDecoded = try containerValues.decode(Int.self, forKey: .count)
        count = countDecoded
    }
}

extension InsightResultValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsightResultValue(count: \(String(describing: count)), groupByAttributeValue: \(String(describing: groupByAttributeValue)))"}
}

/// <p>The insight result values returned by the <code>GetInsightResults</code>
///          operation.</p>
public struct InsightResultValue: Equatable {
    /// <p>The number of findings returned for each <code>GroupByAttributeValue</code>.</p>
    public let count: Int
    /// <p>The value of the attribute that the findings are grouped by for the insight whose
    ///          results are returned by the <code>GetInsightResults</code> operation.</p>
    public let groupByAttributeValue: String?

    public init (
        count: Int = 0,
        groupByAttributeValue: String? = nil
    )
    {
        self.count = count
        self.groupByAttributeValue = groupByAttributeValue
    }
}

extension InsightResults: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupByAttribute = "GroupByAttribute"
        case insightArn = "InsightArn"
        case resultValues = "ResultValues"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupByAttribute = groupByAttribute {
            try encodeContainer.encode(groupByAttribute, forKey: .groupByAttribute)
        }
        if let insightArn = insightArn {
            try encodeContainer.encode(insightArn, forKey: .insightArn)
        }
        if let resultValues = resultValues {
            var resultValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resultValues)
            for insightresultvaluelist0 in resultValues {
                try resultValuesContainer.encode(insightresultvaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .insightArn)
        insightArn = insightArnDecoded
        let groupByAttributeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupByAttribute)
        groupByAttribute = groupByAttributeDecoded
        let resultValuesContainer = try containerValues.decodeIfPresent([InsightResultValue?].self, forKey: .resultValues)
        var resultValuesDecoded0:[InsightResultValue]? = nil
        if let resultValuesContainer = resultValuesContainer {
            resultValuesDecoded0 = [InsightResultValue]()
            for structure0 in resultValuesContainer {
                if let structure0 = structure0 {
                    resultValuesDecoded0?.append(structure0)
                }
            }
        }
        resultValues = resultValuesDecoded0
    }
}

extension InsightResults: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsightResults(groupByAttribute: \(String(describing: groupByAttribute)), insightArn: \(String(describing: insightArn)), resultValues: \(String(describing: resultValues)))"}
}

/// <p>The insight results returned by the <code>GetInsightResults</code> operation.</p>
public struct InsightResults: Equatable {
    /// <p>The attribute that the findings are grouped by for the insight whose results are
    ///          returned by the <code>GetInsightResults</code> operation.</p>
    public let groupByAttribute: String?
    /// <p>The ARN of the insight whose results are returned by the <code>GetInsightResults</code>
    ///          operation.</p>
    public let insightArn: String?
    /// <p>The list of insight result values returned by the <code>GetInsightResults</code>
    ///          operation.</p>
    public let resultValues: [InsightResultValue]?

    public init (
        groupByAttribute: String? = nil,
        insightArn: String? = nil,
        resultValues: [InsightResultValue]? = nil
    )
    {
        self.groupByAttribute = groupByAttribute
        self.insightArn = insightArn
        self.resultValues = resultValues
    }
}

public enum IntegrationType {
    case receiveFindingsFromSecurityHub
    case sendFindingsToSecurityHub
    case updateFindingsInSecurityHub
    case sdkUnknown(String)
}

extension IntegrationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IntegrationType] {
        return [
            .receiveFindingsFromSecurityHub,
            .sendFindingsToSecurityHub,
            .updateFindingsInSecurityHub,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .receiveFindingsFromSecurityHub: return "RECEIVE_FINDINGS_FROM_SECURITY_HUB"
        case .sendFindingsToSecurityHub: return "SEND_FINDINGS_TO_SECURITY_HUB"
        case .updateFindingsInSecurityHub: return "UPDATE_FINDINGS_IN_SECURITY_HUB"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IntegrationType(rawValue: rawValue) ?? IntegrationType.sdkUnknown(rawValue)
    }
}

extension InternalException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension InternalException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Internal server error.</p>
public struct InternalException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InternalExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension InternalExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension InvalidAccessException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidAccessException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension InvalidAccessException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidAccessExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is an issue with the account used to make the request. Either Security Hub is not enabled
///          for the account, or the account does not have permission to perform this action.</p>
public struct InvalidAccessException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidAccessExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension InvalidAccessExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension InvalidInputException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInputException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension InvalidInputException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because you supplied an invalid or out-of-range value for an
///          input parameter.</p>
public struct InvalidInputException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidInputExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension InvalidInputExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension Invitation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case invitationId = "InvitationId"
        case invitedAt = "InvitedAt"
        case memberStatus = "MemberStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let invitationId = invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let invitedAt = invitedAt {
            try encodeContainer.encode(invitedAt.timeIntervalSince1970, forKey: .invitedAt)
        }
        if let memberStatus = memberStatus {
            try encodeContainer.encode(memberStatus, forKey: .memberStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
        let invitedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
        let memberStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memberStatus)
        memberStatus = memberStatusDecoded
    }
}

extension Invitation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Invitation(accountId: \(String(describing: accountId)), invitationId: \(String(describing: invitationId)), invitedAt: \(String(describing: invitedAt)), memberStatus: \(String(describing: memberStatus)))"}
}

/// <p>Details about an invitation.</p>
public struct Invitation: Equatable {
    /// <p>The account ID of the Security Hub administrator account that the invitation was sent from.</p>
    public let accountId: String?
    /// <p>The ID of the invitation sent to the member account.</p>
    public let invitationId: String?
    /// <p>The timestamp of when the invitation was sent.</p>
    public let invitedAt: Date?
    /// <p>The current status of the association between the member and administrator accounts.</p>
    public let memberStatus: String?

    public init (
        accountId: String? = nil,
        invitationId: String? = nil,
        invitedAt: Date? = nil,
        memberStatus: String? = nil
    )
    {
        self.accountId = accountId
        self.invitationId = invitationId
        self.invitedAt = invitedAt
        self.memberStatus = memberStatus
    }
}

public struct InviteMembersInputBodyMiddleware: Middleware {
    public let id: String = "InviteMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InviteMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<InviteMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InviteMembersInput>
    public typealias MOutput = OperationOutput<InviteMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InviteMembersOutputError>
}

extension InviteMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InviteMembersInput(accountIds: \(String(describing: accountIds)))"}
}

extension InviteMembersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountidlist0 in accountIds {
                try accountIdsContainer.encode(accountidlist0)
            }
        }
    }
}

public struct InviteMembersInputHeadersMiddleware: Middleware {
    public let id: String = "InviteMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InviteMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<InviteMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InviteMembersInput>
    public typealias MOutput = OperationOutput<InviteMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InviteMembersOutputError>
}

public struct InviteMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "InviteMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InviteMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<InviteMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InviteMembersInput>
    public typealias MOutput = OperationOutput<InviteMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InviteMembersOutputError>
}

public struct InviteMembersInput: Equatable {
    /// <p>The list of account IDs of the AWS accounts to invite to Security Hub as members. </p>
    public let accountIds: [String]?

    public init (
        accountIds: [String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct InviteMembersInputBody: Equatable {
    public let accountIds: [String]?
}

extension InviteMembersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension InviteMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InviteMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InviteMembersOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InviteMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InviteMembersOutputResponse(unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension InviteMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InviteMembersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct InviteMembersOutputResponse: Equatable {
    /// <p>The list of AWS accounts that could not be processed. For each account, the list
    ///          includes the account ID and the email address.</p>
    public let unprocessedAccounts: [Result]?

    public init (
        unprocessedAccounts: [Result]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct InviteMembersOutputResponseBody: Equatable {
    public let unprocessedAccounts: [Result]?
}

extension InviteMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([Result?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[Result]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [Result]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension IpFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cidr)
        cidr = cidrDecoded
    }
}

extension IpFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IpFilter(cidr: \(String(describing: cidr)))"}
}

/// <p>The IP filter for querying findings.</p>
public struct IpFilter: Equatable {
    /// <p>A finding's CIDR value.</p>
    public let cidr: String?

    public init (
        cidr: String? = nil
    )
    {
        self.cidr = cidr
    }
}

extension IpOrganizationDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case asn = "Asn"
        case asnOrg = "AsnOrg"
        case isp = "Isp"
        case org = "Org"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let asnOrg = asnOrg {
            try encodeContainer.encode(asnOrg, forKey: .asnOrg)
        }
        if let isp = isp {
            try encodeContainer.encode(isp, forKey: .isp)
        }
        if let org = org {
            try encodeContainer.encode(org, forKey: .org)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let asnDecoded = try containerValues.decode(Int.self, forKey: .asn)
        asn = asnDecoded
        let asnOrgDecoded = try containerValues.decodeIfPresent(String.self, forKey: .asnOrg)
        asnOrg = asnOrgDecoded
        let ispDecoded = try containerValues.decodeIfPresent(String.self, forKey: .isp)
        isp = ispDecoded
        let orgDecoded = try containerValues.decodeIfPresent(String.self, forKey: .org)
        org = orgDecoded
    }
}

extension IpOrganizationDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IpOrganizationDetails(asn: \(String(describing: asn)), asnOrg: \(String(describing: asnOrg)), isp: \(String(describing: isp)), org: \(String(describing: org)))"}
}

/// <p>Provides information about an internet provider.</p>
public struct IpOrganizationDetails: Equatable {
    /// <p>The Autonomous System Number (ASN) of the internet provider</p>
    public let asn: Int
    /// <p>The name of the organization that registered the ASN.</p>
    public let asnOrg: String?
    /// <p>The ISP information for the internet provider.</p>
    public let isp: String?
    /// <p>The name of the internet provider.</p>
    public let org: String?

    public init (
        asn: Int = 0,
        asnOrg: String? = nil,
        isp: String? = nil,
        org: String? = nil
    )
    {
        self.asn = asn
        self.asnOrg = asnOrg
        self.isp = isp
        self.org = org
    }
}

extension Ipv6CidrBlockAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case cidrBlockState = "CidrBlockState"
        case ipv6CidrBlock = "Ipv6CidrBlock"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let cidrBlockState = cidrBlockState {
            try encodeContainer.encode(cidrBlockState, forKey: .cidrBlockState)
        }
        if let ipv6CidrBlock = ipv6CidrBlock {
            try encodeContainer.encode(ipv6CidrBlock, forKey: .ipv6CidrBlock)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let ipv6CidrBlockDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipv6CidrBlock)
        ipv6CidrBlock = ipv6CidrBlockDecoded
        let cidrBlockStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cidrBlockState)
        cidrBlockState = cidrBlockStateDecoded
    }
}

extension Ipv6CidrBlockAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Ipv6CidrBlockAssociation(associationId: \(String(describing: associationId)), cidrBlockState: \(String(describing: cidrBlockState)), ipv6CidrBlock: \(String(describing: ipv6CidrBlock)))"}
}

/// <p>An IPV6 CIDR block association.</p>
public struct Ipv6CidrBlockAssociation: Equatable {
    /// <p>The association ID for the IPv6 CIDR block.</p>
    public let associationId: String?
    /// <p>Information about the state of the CIDR block.</p>
    public let cidrBlockState: String?
    /// <p>The IPv6 CIDR block.</p>
    public let ipv6CidrBlock: String?

    public init (
        associationId: String? = nil,
        cidrBlockState: String? = nil,
        ipv6CidrBlock: String? = nil
    )
    {
        self.associationId = associationId
        self.cidrBlockState = cidrBlockState
        self.ipv6CidrBlock = ipv6CidrBlock
    }
}

extension KeywordFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension KeywordFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeywordFilter(value: \(String(describing: value)))"}
}

/// <p>A keyword filter for querying findings.</p>
public struct KeywordFilter: Equatable {
    /// <p>A value for the keyword.</p>
    public let value: String?

    public init (
        value: String? = nil
    )
    {
        self.value = value
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because it attempted to create resources beyond the current AWS
///          account or throttling limits. The error code describes the limit exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension ListEnabledProductsForImportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEnabledProductsForImportInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEnabledProductsForImportInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListEnabledProductsForImportInputHeadersMiddleware: Middleware {
    public let id: String = "ListEnabledProductsForImportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEnabledProductsForImportInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEnabledProductsForImportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEnabledProductsForImportInput>
    public typealias MOutput = OperationOutput<ListEnabledProductsForImportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEnabledProductsForImportOutputError>
}

public struct ListEnabledProductsForImportInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEnabledProductsForImportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEnabledProductsForImportInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEnabledProductsForImportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEnabledProductsForImportInput>
    public typealias MOutput = OperationOutput<ListEnabledProductsForImportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEnabledProductsForImportOutputError>
}

public struct ListEnabledProductsForImportInput: Equatable {
    /// <p>The maximum number of items to return in the response.</p>
    public let maxResults: Int
    /// <p>The token that is required for pagination. On your first call to the
    ///             <code>ListEnabledProductsForImport</code> operation, set the value of this parameter to
    ///             <code>NULL</code>.</p>
    ///          <p>For subsequent calls to the operation, to continue listing data, set the value of this
    ///          parameter to the value returned from the previous response.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnabledProductsForImportInputBody: Equatable {
}

extension ListEnabledProductsForImportInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListEnabledProductsForImportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEnabledProductsForImportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEnabledProductsForImportOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEnabledProductsForImportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEnabledProductsForImportOutputResponse(nextToken: \(String(describing: nextToken)), productSubscriptions: \(String(describing: productSubscriptions)))"}
}

extension ListEnabledProductsForImportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEnabledProductsForImportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.productSubscriptions = output.productSubscriptions
        } else {
            self.nextToken = nil
            self.productSubscriptions = nil
        }
    }
}

public struct ListEnabledProductsForImportOutputResponse: Equatable {
    /// <p>The pagination token to use to request the next page of results.</p>
    public let nextToken: String?
    /// <p>The list of ARNs for the resources that represent your subscriptions to products. </p>
    public let productSubscriptions: [String]?

    public init (
        nextToken: String? = nil,
        productSubscriptions: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.productSubscriptions = productSubscriptions
    }
}

struct ListEnabledProductsForImportOutputResponseBody: Equatable {
    public let productSubscriptions: [String]?
    public let nextToken: String?
}

extension ListEnabledProductsForImportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case productSubscriptions = "ProductSubscriptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productSubscriptionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .productSubscriptions)
        var productSubscriptionsDecoded0:[String]? = nil
        if let productSubscriptionsContainer = productSubscriptionsContainer {
            productSubscriptionsDecoded0 = [String]()
            for string0 in productSubscriptionsContainer {
                if let string0 = string0 {
                    productSubscriptionsDecoded0?.append(string0)
                }
            }
        }
        productSubscriptions = productSubscriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInvitationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInvitationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInvitationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListInvitationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListInvitationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInvitationsInput>
    public typealias MOutput = OperationOutput<ListInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInvitationsOutputError>
}

public struct ListInvitationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInvitationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInvitationsInput>
    public typealias MOutput = OperationOutput<ListInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInvitationsOutputError>
}

public struct ListInvitationsInput: Equatable {
    /// <p>The maximum number of items to return in the response. </p>
    public let maxResults: Int
    /// <p>The token that is required for pagination. On your first call to the
    ///             <code>ListInvitations</code> operation, set the value of this parameter to
    ///             <code>NULL</code>.</p>
    ///          <p>For subsequent calls to the operation, to continue listing data, set the value of this
    ///          parameter to the value returned from the previous response.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInvitationsInputBody: Equatable {
}

extension ListInvitationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListInvitationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInvitationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInvitationsOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInvitationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInvitationsOutputResponse(invitations: \(String(describing: invitations)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInvitationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.invitations = output.invitations
            self.nextToken = output.nextToken
        } else {
            self.invitations = nil
            self.nextToken = nil
        }
    }
}

public struct ListInvitationsOutputResponse: Equatable {
    /// <p>The details of the invitations returned by the operation.</p>
    public let invitations: [Invitation]?
    /// <p>The pagination token to use to request the next page of results.</p>
    public let nextToken: String?

    public init (
        invitations: [Invitation]? = nil,
        nextToken: String? = nil
    )
    {
        self.invitations = invitations
        self.nextToken = nextToken
    }
}

struct ListInvitationsOutputResponseBody: Equatable {
    public let invitations: [Invitation]?
    public let nextToken: String?
}

extension ListInvitationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invitations = "Invitations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitationsContainer = try containerValues.decodeIfPresent([Invitation?].self, forKey: .invitations)
        var invitationsDecoded0:[Invitation]? = nil
        if let invitationsContainer = invitationsContainer {
            invitationsDecoded0 = [Invitation]()
            for structure0 in invitationsContainer {
                if let structure0 = structure0 {
                    invitationsDecoded0?.append(structure0)
                }
            }
        }
        invitations = invitationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMembersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), onlyAssociated: \(String(describing: onlyAssociated)))"}
}

extension ListMembersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListMembersInputHeadersMiddleware: Middleware {
    public let id: String = "ListMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMembersInput>
    public typealias MOutput = OperationOutput<ListMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMembersOutputError>
}

public struct ListMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        let onlyAssociatedQueryItem = URLQueryItem(name: "OnlyAssociated".urlPercentEncoding(), value: String(input.operationInput.onlyAssociated).urlPercentEncoding())
        input.builder.withQueryItem(onlyAssociatedQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMembersInput>
    public typealias MOutput = OperationOutput<ListMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMembersOutputError>
}

public struct ListMembersInput: Equatable {
    /// <p>The maximum number of items to return in the response. </p>
    public let maxResults: Int
    /// <p>The token that is required for pagination. On your first call to the
    ///             <code>ListMembers</code> operation, set the value of this parameter to
    ///          <code>NULL</code>.</p>
    ///          <p>For subsequent calls to the operation, to continue listing data, set the value of this
    ///          parameter to the value returned from the previous response.</p>
    public let nextToken: String?
    /// <p>Specifies which member accounts to include in the response based on their relationship
    ///          status with the administrator account. The default value is <code>TRUE</code>.</p>
    ///          <p>If <code>OnlyAssociated</code> is set to <code>TRUE</code>, the response includes member
    ///          accounts whose relationship status with the administrator account is set to <code>ENABLED</code>.</p>
    ///          <p>If <code>OnlyAssociated</code> is set to <code>FALSE</code>, the response includes all
    ///          existing member accounts. </p>
    public let onlyAssociated: Bool

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        onlyAssociated: Bool = false
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.onlyAssociated = onlyAssociated
    }
}

struct ListMembersInputBody: Equatable {
}

extension ListMembersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMembersOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMembersOutputResponse(members: \(String(describing: members)), nextToken: \(String(describing: nextToken)))"}
}

extension ListMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListMembersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListMembersOutputResponse: Equatable {
    /// <p>Member details returned by the operation.</p>
    public let members: [Member]?
    /// <p>The pagination token to use to request the next page of results.</p>
    public let nextToken: String?

    public init (
        members: [Member]? = nil,
        nextToken: String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListMembersOutputResponseBody: Equatable {
    public let members: [Member]?
    public let nextToken: String?
}

extension ListMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case members = "Members"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([Member?].self, forKey: .members)
        var membersDecoded0:[Member]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [Member]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOrganizationAdminAccountsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOrganizationAdminAccountsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListOrganizationAdminAccountsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListOrganizationAdminAccountsInputHeadersMiddleware: Middleware {
    public let id: String = "ListOrganizationAdminAccountsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOrganizationAdminAccountsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOrganizationAdminAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOrganizationAdminAccountsInput>
    public typealias MOutput = OperationOutput<ListOrganizationAdminAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOrganizationAdminAccountsOutputError>
}

public struct ListOrganizationAdminAccountsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOrganizationAdminAccountsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOrganizationAdminAccountsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOrganizationAdminAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOrganizationAdminAccountsInput>
    public typealias MOutput = OperationOutput<ListOrganizationAdminAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOrganizationAdminAccountsOutputError>
}

public struct ListOrganizationAdminAccountsInput: Equatable {
    /// <p>The maximum number of items to return in the response.</p>
    public let maxResults: Int
    /// <p>The token that is required for pagination. On your first call to the
    ///             <code>ListOrganizationAdminAccounts</code> operation, set the value of this parameter to
    ///             <code>NULL</code>. For subsequent calls to the operation, to continue listing data, set
    ///          the value of this parameter to the value returned from the previous response. </p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOrganizationAdminAccountsInputBody: Equatable {
}

extension ListOrganizationAdminAccountsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListOrganizationAdminAccountsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOrganizationAdminAccountsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOrganizationAdminAccountsOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOrganizationAdminAccountsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOrganizationAdminAccountsOutputResponse(adminAccounts: \(String(describing: adminAccounts)), nextToken: \(String(describing: nextToken)))"}
}

extension ListOrganizationAdminAccountsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOrganizationAdminAccountsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.adminAccounts = output.adminAccounts
            self.nextToken = output.nextToken
        } else {
            self.adminAccounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListOrganizationAdminAccountsOutputResponse: Equatable {
    /// <p>The list of Security Hub administrator accounts.</p>
    public let adminAccounts: [AdminAccount]?
    /// <p>The pagination token to use to request the next page of results.</p>
    public let nextToken: String?

    public init (
        adminAccounts: [AdminAccount]? = nil,
        nextToken: String? = nil
    )
    {
        self.adminAccounts = adminAccounts
        self.nextToken = nextToken
    }
}

struct ListOrganizationAdminAccountsOutputResponseBody: Equatable {
    public let adminAccounts: [AdminAccount]?
    public let nextToken: String?
}

extension ListOrganizationAdminAccountsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminAccounts = "AdminAccounts"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountsContainer = try containerValues.decodeIfPresent([AdminAccount?].self, forKey: .adminAccounts)
        var adminAccountsDecoded0:[AdminAccount]? = nil
        if let adminAccountsContainer = adminAccountsContainer {
            adminAccountsDecoded0 = [AdminAccount]()
            for structure0 in adminAccountsContainer {
                if let structure0 = structure0 {
                    adminAccountsDecoded0?.append(structure0)
                }
            }
        }
        adminAccounts = adminAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN of the resource to retrieve tags for.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags associated with a resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LoadBalancerState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case reason = "Reason"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension LoadBalancerState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoadBalancerState(code: \(String(describing: code)), reason: \(String(describing: reason)))"}
}

/// <p>Information about the state of the load balancer.</p>
public struct LoadBalancerState: Equatable {
    /// <p>The state code. The initial state of the load balancer is provisioning.</p>
    ///          <p>After the load balancer is fully set up and ready to route traffic, its state is
    ///          active.</p>
    ///          <p>If the load balancer could not be set up, its state is failed. </p>
    public let code: String?
    /// <p>A description of the state.</p>
    public let reason: String?

    public init (
        code: String? = nil,
        reason: String? = nil
    )
    {
        self.code = code
        self.reason = reason
    }
}

extension Malware: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case path = "Path"
        case state = "State"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(MalwareType.self, forKey: .type)
        type = typeDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MalwareState.self, forKey: .state)
        state = stateDecoded
    }
}

extension Malware: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Malware(name: \(String(describing: name)), path: \(String(describing: path)), state: \(String(describing: state)), type: \(String(describing: type)))"}
}

/// <p>A list of malware related to a finding.</p>
public struct Malware: Equatable {
    /// <p>The name of the malware that was observed.</p>
    public let name: String?
    /// <p>The file system path of the malware that was observed.</p>
    public let path: String?
    /// <p>The state of the malware that was observed.</p>
    public let state: MalwareState?
    /// <p>The type of the malware that was observed.</p>
    public let type: MalwareType?

    public init (
        name: String? = nil,
        path: String? = nil,
        state: MalwareState? = nil,
        type: MalwareType? = nil
    )
    {
        self.name = name
        self.path = path
        self.state = state
        self.type = type
    }
}

public enum MalwareState {
    case observed
    case removalFailed
    case removed
    case sdkUnknown(String)
}

extension MalwareState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MalwareState] {
        return [
            .observed,
            .removalFailed,
            .removed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .observed: return "OBSERVED"
        case .removalFailed: return "REMOVAL_FAILED"
        case .removed: return "REMOVED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MalwareState(rawValue: rawValue) ?? MalwareState.sdkUnknown(rawValue)
    }
}

public enum MalwareType {
    case adware
    case blendedThreat
    case botnetAgent
    case coinMiner
    case exploitKit
    case keylogger
    case macro
    case potentiallyUnwanted
    case ransomware
    case remoteAccess
    case rootkit
    case spyware
    case trojan
    case virus
    case worm
    case sdkUnknown(String)
}

extension MalwareType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MalwareType] {
        return [
            .adware,
            .blendedThreat,
            .botnetAgent,
            .coinMiner,
            .exploitKit,
            .keylogger,
            .macro,
            .potentiallyUnwanted,
            .ransomware,
            .remoteAccess,
            .rootkit,
            .spyware,
            .trojan,
            .virus,
            .worm,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .adware: return "ADWARE"
        case .blendedThreat: return "BLENDED_THREAT"
        case .botnetAgent: return "BOTNET_AGENT"
        case .coinMiner: return "COIN_MINER"
        case .exploitKit: return "EXPLOIT_KIT"
        case .keylogger: return "KEYLOGGER"
        case .macro: return "MACRO"
        case .potentiallyUnwanted: return "POTENTIALLY_UNWANTED"
        case .ransomware: return "RANSOMWARE"
        case .remoteAccess: return "REMOTE_ACCESS"
        case .rootkit: return "ROOTKIT"
        case .spyware: return "SPYWARE"
        case .trojan: return "TROJAN"
        case .virus: return "VIRUS"
        case .worm: return "WORM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MalwareType(rawValue: rawValue) ?? MalwareType.sdkUnknown(rawValue)
    }
}

extension MapFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparison = "Comparison"
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparison = comparison {
            try encodeContainer.encode(comparison.rawValue, forKey: .comparison)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let comparisonDecoded = try containerValues.decodeIfPresent(MapFilterComparison.self, forKey: .comparison)
        comparison = comparisonDecoded
    }
}

extension MapFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MapFilter(comparison: \(String(describing: comparison)), key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A map filter for querying findings. Each map filter provides the field to check, the
///          value to look for, and the comparison operator.</p>
public struct MapFilter: Equatable {
    /// <p>The condition to apply to the key value when querying for findings with a map
    ///          filter.</p>
    ///          <p>To search for values that exactly match the filter value, use <code>EQUALS</code>. For
    ///          example, for the <code>ResourceTags</code> field, the filter <code>Department EQUALS
    ///             Security</code> matches findings that have the value <code>Security</code> for the tag
    ///             <code>Department</code>.</p>
    ///          <p>To search for values other than the filter value, use <code>NOT_EQUALS</code>. For
    ///          example, for the <code>ResourceTags</code> field, the filter <code>Department NOT_EQUALS
    ///             Finance</code> matches findings that do not have the value <code>Finance</code> for the
    ///          tag <code>Department</code>.</p>
    ///          <p>
    ///             <code>EQUALS</code> filters on the same field are joined by <code>OR</code>. A finding
    ///          matches if it matches any one of those filters.</p>
    ///          <p>
    ///             <code>NOT_EQUALS</code> filters on the same field are joined by <code>AND</code>. A
    ///          finding matches only if it matches all of those filters.</p>
    ///          <p>You cannot have both an <code>EQUALS</code> filter and a <code>NOT_EQUALS</code> filter
    ///          on the same field.</p>
    public let comparison: MapFilterComparison?
    /// <p>The key of the map filter. For example, for <code>ResourceTags</code>, <code>Key</code>
    ///          identifies the name of the tag. For <code>UserDefinedFields</code>, <code>Key</code> is the
    ///          name of the field.</p>
    public let key: String?
    /// <p>The value for the key in the map filter. Filter values are case sensitive. For example,
    ///          one of the values for a tag called <code>Department</code> might be <code>Security</code>.
    ///          If you provide <code>security</code> as the filter value, then there is no match.</p>
    public let value: String?

    public init (
        comparison: MapFilterComparison? = nil,
        key: String? = nil,
        value: String? = nil
    )
    {
        self.comparison = comparison
        self.key = key
        self.value = value
    }
}

public enum MapFilterComparison {
    case equals
    case notEquals
    case sdkUnknown(String)
}

extension MapFilterComparison : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MapFilterComparison] {
        return [
            .equals,
            .notEquals,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .equals: return "EQUALS"
        case .notEquals: return "NOT_EQUALS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MapFilterComparison(rawValue: rawValue) ?? MapFilterComparison.sdkUnknown(rawValue)
    }
}

extension Member: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case administratorId = "AdministratorId"
        case email = "Email"
        case invitedAt = "InvitedAt"
        case masterId = "MasterId"
        case memberStatus = "MemberStatus"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let administratorId = administratorId {
            try encodeContainer.encode(administratorId, forKey: .administratorId)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let invitedAt = invitedAt {
            try encodeContainer.encode(invitedAt.timeIntervalSince1970, forKey: .invitedAt)
        }
        if let masterId = masterId {
            try encodeContainer.encode(masterId, forKey: .masterId)
        }
        if let memberStatus = memberStatus {
            try encodeContainer.encode(memberStatus, forKey: .memberStatus)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let masterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterId)
        masterId = masterIdDecoded
        let administratorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .administratorId)
        administratorId = administratorIdDecoded
        let memberStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memberStatus)
        memberStatus = memberStatusDecoded
        let invitedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension Member: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Member(accountId: \(String(describing: accountId)), administratorId: \(String(describing: administratorId)), email: \(String(describing: email)), invitedAt: \(String(describing: invitedAt)), masterId: \(String(describing: masterId)), memberStatus: \(String(describing: memberStatus)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>The details about a member account.</p>
public struct Member: Equatable {
    /// <p>The AWS account ID of the member account.</p>
    public let accountId: String?
    /// <p>The AWS account ID of the Security Hub administrator account associated with this member account.</p>
    public let administratorId: String?
    /// <p>The email address of the member account.</p>
    public let email: String?
    /// <p>A timestamp for the date and time when the invitation was sent to the member
    ///          account.</p>
    public let invitedAt: Date?
    /// <p>This is replaced by <code>AdministratorID</code>.</p>
    ///          <p>The AWS account ID of the Security Hub administrator account associated with this member account.</p>
    @available(*, deprecated, message: "This field is deprecated, use AdministratorId instead.")
    public let masterId: String?
    /// <p>The status of the relationship between the member account and its administrator account.
    ///       </p>
    ///          <p>The status can have one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATED</code> - Indicates that the administrator account added the member account,
    ///                but has not yet invited the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INVITED</code> - Indicates that the administrator account invited the member
    ///                account. The member account has not yet responded to the invitation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ENABLED</code> - Indicates that the member account is currently active. For
    ///                manually invited member accounts, indicates that the member account accepted the
    ///                invitation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>REMOVED</code> - Indicates that the administrator account disassociated the member
    ///                account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RESIGNED</code> - Indicates that the member account disassociated themselves
    ///                from the administrator account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETED</code> - Indicates that the administrator account deleted the member
    ///                account.</p>
    ///             </li>
    ///          </ul>
    public let memberStatus: String?
    /// <p>The timestamp for the date and time when the member account was updated.</p>
    public let updatedAt: Date?

    public init (
        accountId: String? = nil,
        administratorId: String? = nil,
        email: String? = nil,
        invitedAt: Date? = nil,
        masterId: String? = nil,
        memberStatus: String? = nil,
        updatedAt: Date? = nil
    )
    {
        self.accountId = accountId
        self.administratorId = administratorId
        self.email = email
        self.invitedAt = invitedAt
        self.masterId = masterId
        self.memberStatus = memberStatus
        self.updatedAt = updatedAt
    }
}

extension Network: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationDomain = "DestinationDomain"
        case destinationIpV4 = "DestinationIpV4"
        case destinationIpV6 = "DestinationIpV6"
        case destinationPort = "DestinationPort"
        case direction = "Direction"
        case openPortRange = "OpenPortRange"
        case `protocol` = "Protocol"
        case sourceDomain = "SourceDomain"
        case sourceIpV4 = "SourceIpV4"
        case sourceIpV6 = "SourceIpV6"
        case sourceMac = "SourceMac"
        case sourcePort = "SourcePort"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationDomain = destinationDomain {
            try encodeContainer.encode(destinationDomain, forKey: .destinationDomain)
        }
        if let destinationIpV4 = destinationIpV4 {
            try encodeContainer.encode(destinationIpV4, forKey: .destinationIpV4)
        }
        if let destinationIpV6 = destinationIpV6 {
            try encodeContainer.encode(destinationIpV6, forKey: .destinationIpV6)
        }
        if destinationPort != 0 {
            try encodeContainer.encode(destinationPort, forKey: .destinationPort)
        }
        if let direction = direction {
            try encodeContainer.encode(direction.rawValue, forKey: .direction)
        }
        if let openPortRange = openPortRange {
            try encodeContainer.encode(openPortRange, forKey: .openPortRange)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
        if let sourceDomain = sourceDomain {
            try encodeContainer.encode(sourceDomain, forKey: .sourceDomain)
        }
        if let sourceIpV4 = sourceIpV4 {
            try encodeContainer.encode(sourceIpV4, forKey: .sourceIpV4)
        }
        if let sourceIpV6 = sourceIpV6 {
            try encodeContainer.encode(sourceIpV6, forKey: .sourceIpV6)
        }
        if let sourceMac = sourceMac {
            try encodeContainer.encode(sourceMac, forKey: .sourceMac)
        }
        if sourcePort != 0 {
            try encodeContainer.encode(sourcePort, forKey: .sourcePort)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directionDecoded = try containerValues.decodeIfPresent(NetworkDirection.self, forKey: .direction)
        direction = directionDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let openPortRangeDecoded = try containerValues.decodeIfPresent(PortRange.self, forKey: .openPortRange)
        openPortRange = openPortRangeDecoded
        let sourceIpV4Decoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceIpV4)
        sourceIpV4 = sourceIpV4Decoded
        let sourceIpV6Decoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceIpV6)
        sourceIpV6 = sourceIpV6Decoded
        let sourcePortDecoded = try containerValues.decode(Int.self, forKey: .sourcePort)
        sourcePort = sourcePortDecoded
        let sourceDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceDomain)
        sourceDomain = sourceDomainDecoded
        let sourceMacDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceMac)
        sourceMac = sourceMacDecoded
        let destinationIpV4Decoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationIpV4)
        destinationIpV4 = destinationIpV4Decoded
        let destinationIpV6Decoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationIpV6)
        destinationIpV6 = destinationIpV6Decoded
        let destinationPortDecoded = try containerValues.decode(Int.self, forKey: .destinationPort)
        destinationPort = destinationPortDecoded
        let destinationDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationDomain)
        destinationDomain = destinationDomainDecoded
    }
}

extension Network: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Network(destinationDomain: \(String(describing: destinationDomain)), destinationIpV4: \(String(describing: destinationIpV4)), destinationIpV6: \(String(describing: destinationIpV6)), destinationPort: \(String(describing: destinationPort)), direction: \(String(describing: direction)), openPortRange: \(String(describing: openPortRange)), protocol: \(String(describing: `protocol`)), sourceDomain: \(String(describing: sourceDomain)), sourceIpV4: \(String(describing: sourceIpV4)), sourceIpV6: \(String(describing: sourceIpV6)), sourceMac: \(String(describing: sourceMac)), sourcePort: \(String(describing: sourcePort)))"}
}

/// <p>The details of network-related information about a finding.</p>
public struct Network: Equatable {
    /// <p>The protocol of network-related information about a finding.</p>
    public let `protocol`: String?
    /// <p>The destination domain of network-related information about a finding.</p>
    public let destinationDomain: String?
    /// <p>The destination IPv4 address of network-related information about a finding.</p>
    public let destinationIpV4: String?
    /// <p>The destination IPv6 address of network-related information about a finding.</p>
    public let destinationIpV6: String?
    /// <p>The destination port of network-related information about a finding.</p>
    public let destinationPort: Int
    /// <p>The direction of network traffic associated with a finding.</p>
    public let direction: NetworkDirection?
    /// <p>The range of open ports that is present on the network.</p>
    public let openPortRange: PortRange?
    /// <p>The source domain of network-related information about a finding.</p>
    public let sourceDomain: String?
    /// <p>The source IPv4 address of network-related information about a finding.</p>
    public let sourceIpV4: String?
    /// <p>The source IPv6 address of network-related information about a finding.</p>
    public let sourceIpV6: String?
    /// <p>The source media access control (MAC) address of network-related information about a
    ///          finding.</p>
    public let sourceMac: String?
    /// <p>The source port of network-related information about a finding.</p>
    public let sourcePort: Int

    public init (
        `protocol`: String? = nil,
        destinationDomain: String? = nil,
        destinationIpV4: String? = nil,
        destinationIpV6: String? = nil,
        destinationPort: Int = 0,
        direction: NetworkDirection? = nil,
        openPortRange: PortRange? = nil,
        sourceDomain: String? = nil,
        sourceIpV4: String? = nil,
        sourceIpV6: String? = nil,
        sourceMac: String? = nil,
        sourcePort: Int = 0
    )
    {
        self.`protocol` = `protocol`
        self.destinationDomain = destinationDomain
        self.destinationIpV4 = destinationIpV4
        self.destinationIpV6 = destinationIpV6
        self.destinationPort = destinationPort
        self.direction = direction
        self.openPortRange = openPortRange
        self.sourceDomain = sourceDomain
        self.sourceIpV4 = sourceIpV4
        self.sourceIpV6 = sourceIpV6
        self.sourceMac = sourceMac
        self.sourcePort = sourcePort
    }
}

extension NetworkConnectionAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blocked = "Blocked"
        case connectionDirection = "ConnectionDirection"
        case localPortDetails = "LocalPortDetails"
        case `protocol` = "Protocol"
        case remoteIpDetails = "RemoteIpDetails"
        case remotePortDetails = "RemotePortDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blocked != false {
            try encodeContainer.encode(blocked, forKey: .blocked)
        }
        if let connectionDirection = connectionDirection {
            try encodeContainer.encode(connectionDirection, forKey: .connectionDirection)
        }
        if let localPortDetails = localPortDetails {
            try encodeContainer.encode(localPortDetails, forKey: .localPortDetails)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
        if let remoteIpDetails = remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
        if let remotePortDetails = remotePortDetails {
            try encodeContainer.encode(remotePortDetails, forKey: .remotePortDetails)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDirectionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionDirection)
        connectionDirection = connectionDirectionDecoded
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(ActionRemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
        let remotePortDetailsDecoded = try containerValues.decodeIfPresent(ActionRemotePortDetails.self, forKey: .remotePortDetails)
        remotePortDetails = remotePortDetailsDecoded
        let localPortDetailsDecoded = try containerValues.decodeIfPresent(ActionLocalPortDetails.self, forKey: .localPortDetails)
        localPortDetails = localPortDetailsDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let blockedDecoded = try containerValues.decode(Bool.self, forKey: .blocked)
        blocked = blockedDecoded
    }
}

extension NetworkConnectionAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkConnectionAction(blocked: \(String(describing: blocked)), connectionDirection: \(String(describing: connectionDirection)), localPortDetails: \(String(describing: localPortDetails)), protocol: \(String(describing: `protocol`)), remoteIpDetails: \(String(describing: remoteIpDetails)), remotePortDetails: \(String(describing: remotePortDetails)))"}
}

/// <p>Provided if <code>ActionType</code> is <code>NETWORK_CONNECTION</code>. It provides
///          details about the attempted network connection that was detected.</p>
public struct NetworkConnectionAction: Equatable {
    /// <p>The protocol used to make the network connection request.</p>
    public let `protocol`: String?
    /// <p>Indicates whether the network connection attempt was blocked.</p>
    public let blocked: Bool
    /// <p>The direction of the network connection request (<code>IN</code> or
    ///          <code>OUT</code>).</p>
    public let connectionDirection: String?
    /// <p>Information about the port on the EC2 instance.</p>
    public let localPortDetails: ActionLocalPortDetails?
    /// <p>Information about the remote IP address that issued the network connection
    ///          request.</p>
    public let remoteIpDetails: ActionRemoteIpDetails?
    /// <p>Information about the port on the remote IP address.</p>
    public let remotePortDetails: ActionRemotePortDetails?

    public init (
        `protocol`: String? = nil,
        blocked: Bool = false,
        connectionDirection: String? = nil,
        localPortDetails: ActionLocalPortDetails? = nil,
        remoteIpDetails: ActionRemoteIpDetails? = nil,
        remotePortDetails: ActionRemotePortDetails? = nil
    )
    {
        self.`protocol` = `protocol`
        self.blocked = blocked
        self.connectionDirection = connectionDirection
        self.localPortDetails = localPortDetails
        self.remoteIpDetails = remoteIpDetails
        self.remotePortDetails = remotePortDetails
    }
}

public enum NetworkDirection {
    case `in`
    case out
    case sdkUnknown(String)
}

extension NetworkDirection : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NetworkDirection] {
        return [
            .in,
            .out,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .in: return "IN"
        case .out: return "OUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NetworkDirection(rawValue: rawValue) ?? NetworkDirection.sdkUnknown(rawValue)
    }
}

extension NetworkHeader: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destination = "Destination"
        case `protocol` = "Protocol"
        case source = "Source"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(NetworkPathComponentDetails.self, forKey: .destination)
        destination = destinationDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(NetworkPathComponentDetails.self, forKey: .source)
        source = sourceDecoded
    }
}

extension NetworkHeader: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkHeader(destination: \(String(describing: destination)), protocol: \(String(describing: `protocol`)), source: \(String(describing: source)))"}
}

/// <p>Details about a network path component that occurs before or after the current
///          component.</p>
public struct NetworkHeader: Equatable {
    /// <p>The protocol used for the component.</p>
    public let `protocol`: String?
    /// <p>Information about the destination of the component.</p>
    public let destination: NetworkPathComponentDetails?
    /// <p>Information about the origin of the component.</p>
    public let source: NetworkPathComponentDetails?

    public init (
        `protocol`: String? = nil,
        destination: NetworkPathComponentDetails? = nil,
        source: NetworkPathComponentDetails? = nil
    )
    {
        self.`protocol` = `protocol`
        self.destination = destination
        self.source = source
    }
}

extension NetworkPathComponent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case componentId = "ComponentId"
        case componentType = "ComponentType"
        case egress = "Egress"
        case ingress = "Ingress"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentId = componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let componentType = componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
        if let egress = egress {
            try encodeContainer.encode(egress, forKey: .egress)
        }
        if let ingress = ingress {
            try encodeContainer.encode(ingress, forKey: .ingress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let componentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentType)
        componentType = componentTypeDecoded
        let egressDecoded = try containerValues.decodeIfPresent(NetworkHeader.self, forKey: .egress)
        egress = egressDecoded
        let ingressDecoded = try containerValues.decodeIfPresent(NetworkHeader.self, forKey: .ingress)
        ingress = ingressDecoded
    }
}

extension NetworkPathComponent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkPathComponent(componentId: \(String(describing: componentId)), componentType: \(String(describing: componentType)), egress: \(String(describing: egress)), ingress: \(String(describing: ingress)))"}
}

/// <p>Information about a network path component.</p>
public struct NetworkPathComponent: Equatable {
    /// <p>The identifier of a component in the network path.</p>
    public let componentId: String?
    /// <p>The type of component.</p>
    public let componentType: String?
    /// <p>Information about the component that comes after the current component in the network
    ///          path.</p>
    public let egress: NetworkHeader?
    /// <p>Information about the component that comes before the current node in the network
    ///          path.</p>
    public let ingress: NetworkHeader?

    public init (
        componentId: String? = nil,
        componentType: String? = nil,
        egress: NetworkHeader? = nil,
        ingress: NetworkHeader? = nil
    )
    {
        self.componentId = componentId
        self.componentType = componentType
        self.egress = egress
        self.ingress = ingress
    }
}

extension NetworkPathComponentDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case portRanges = "PortRanges"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            var addressContainer = encodeContainer.nestedUnkeyedContainer(forKey: .address)
            for stringlist0 in address {
                try addressContainer.encode(stringlist0)
            }
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portrangelist0 in portRanges {
                try portRangesContainer.encode(portrangelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressContainer = try containerValues.decodeIfPresent([String?].self, forKey: .address)
        var addressDecoded0:[String]? = nil
        if let addressContainer = addressContainer {
            addressDecoded0 = [String]()
            for string0 in addressContainer {
                if let string0 = string0 {
                    addressDecoded0?.append(string0)
                }
            }
        }
        address = addressDecoded0
        let portRangesContainer = try containerValues.decodeIfPresent([PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
    }
}

extension NetworkPathComponentDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkPathComponentDetails(address: \(String(describing: address)), portRanges: \(String(describing: portRanges)))"}
}

/// <p>Information about the destination of the next component in the network path.</p>
public struct NetworkPathComponentDetails: Equatable {
    /// <p>The IP addresses of the destination.</p>
    public let address: [String]?
    /// <p>A list of port ranges for the destination.</p>
    public let portRanges: [PortRange]?

    public init (
        address: [String]? = nil,
        portRanges: [PortRange]? = nil
    )
    {
        self.address = address
        self.portRanges = portRanges
    }
}

extension Note: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case text = "Text"
        case updatedAt = "UpdatedAt"
        case updatedBy = "UpdatedBy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt, forKey: .updatedAt)
        }
        if let updatedBy = updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension Note: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Note(text: \(String(describing: text)), updatedAt: \(String(describing: updatedAt)), updatedBy: \(String(describing: updatedBy)))"}
}

/// <p>A user-defined note added to a finding.</p>
public struct Note: Equatable {
    /// <p>The text of a note.</p>
    public let text: String?
    /// <p>The timestamp of when the note was updated.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let updatedAt: String?
    /// <p>The principal that created a note.</p>
    public let updatedBy: String?

    public init (
        text: String? = nil,
        updatedAt: String? = nil,
        updatedBy: String? = nil
    )
    {
        self.text = text
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension NoteUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case text = "Text"
        case updatedBy = "UpdatedBy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let updatedBy = updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension NoteUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoteUpdate(text: \(String(describing: text)), updatedBy: \(String(describing: updatedBy)))"}
}

/// <p>The updated note.</p>
public struct NoteUpdate: Equatable {
    /// <p>The updated note text.</p>
    public let text: String?
    /// <p>The principal that updated the note.</p>
    public let updatedBy: String?

    public init (
        text: String? = nil,
        updatedBy: String? = nil
    )
    {
        self.text = text
        self.updatedBy = updatedBy
    }
}

extension NumberFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eq = "Eq"
        case gte = "Gte"
        case lte = "Lte"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if eq != 0.0 {
            try encodeContainer.encode(eq, forKey: .eq)
        }
        if gte != 0.0 {
            try encodeContainer.encode(gte, forKey: .gte)
        }
        if lte != 0.0 {
            try encodeContainer.encode(lte, forKey: .lte)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gteDecoded = try containerValues.decode(Double.self, forKey: .gte)
        gte = gteDecoded
        let lteDecoded = try containerValues.decode(Double.self, forKey: .lte)
        lte = lteDecoded
        let eqDecoded = try containerValues.decode(Double.self, forKey: .eq)
        eq = eqDecoded
    }
}

extension NumberFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NumberFilter(eq: \(String(describing: eq)), gte: \(String(describing: gte)), lte: \(String(describing: lte)))"}
}

/// <p>A number filter for querying findings.</p>
public struct NumberFilter: Equatable {
    /// <p>The equal-to condition to be applied to a single field when querying for
    ///          findings.</p>
    public let eq: Double
    /// <p>The greater-than-equal condition to be applied to a single field when querying for
    ///          findings. </p>
    public let gte: Double
    /// <p>The less-than-equal condition to be applied to a single field when querying for
    ///          findings. </p>
    public let lte: Double

    public init (
        eq: Double = 0.0,
        gte: Double = 0.0,
        lte: Double = 0.0
    )
    {
        self.eq = eq
        self.gte = gte
        self.lte = lte
    }
}

extension Occurrences: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cells = "Cells"
        case lineRanges = "LineRanges"
        case offsetRanges = "OffsetRanges"
        case pages = "Pages"
        case records = "Records"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for cells0 in cells {
                try cellsContainer.encode(cells0)
            }
        }
        if let lineRanges = lineRanges {
            var lineRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lineRanges)
            for ranges0 in lineRanges {
                try lineRangesContainer.encode(ranges0)
            }
        }
        if let offsetRanges = offsetRanges {
            var offsetRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .offsetRanges)
            for ranges0 in offsetRanges {
                try offsetRangesContainer.encode(ranges0)
            }
        }
        if let pages = pages {
            var pagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pages)
            for pages0 in pages {
                try pagesContainer.encode(pages0)
            }
        }
        if let records = records {
            var recordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .records)
            for records0 in records {
                try recordsContainer.encode(records0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lineRangesContainer = try containerValues.decodeIfPresent([Range?].self, forKey: .lineRanges)
        var lineRangesDecoded0:[Range]? = nil
        if let lineRangesContainer = lineRangesContainer {
            lineRangesDecoded0 = [Range]()
            for structure0 in lineRangesContainer {
                if let structure0 = structure0 {
                    lineRangesDecoded0?.append(structure0)
                }
            }
        }
        lineRanges = lineRangesDecoded0
        let offsetRangesContainer = try containerValues.decodeIfPresent([Range?].self, forKey: .offsetRanges)
        var offsetRangesDecoded0:[Range]? = nil
        if let offsetRangesContainer = offsetRangesContainer {
            offsetRangesDecoded0 = [Range]()
            for structure0 in offsetRangesContainer {
                if let structure0 = structure0 {
                    offsetRangesDecoded0?.append(structure0)
                }
            }
        }
        offsetRanges = offsetRangesDecoded0
        let pagesContainer = try containerValues.decodeIfPresent([Page?].self, forKey: .pages)
        var pagesDecoded0:[Page]? = nil
        if let pagesContainer = pagesContainer {
            pagesDecoded0 = [Page]()
            for structure0 in pagesContainer {
                if let structure0 = structure0 {
                    pagesDecoded0?.append(structure0)
                }
            }
        }
        pages = pagesDecoded0
        let recordsContainer = try containerValues.decodeIfPresent([Record?].self, forKey: .records)
        var recordsDecoded0:[Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let cellsContainer = try containerValues.decodeIfPresent([Cell?].self, forKey: .cells)
        var cellsDecoded0:[Cell]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Cell]()
            for structure0 in cellsContainer {
                if let structure0 = structure0 {
                    cellsDecoded0?.append(structure0)
                }
            }
        }
        cells = cellsDecoded0
    }
}

extension Occurrences: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Occurrences(cells: \(String(describing: cells)), lineRanges: \(String(describing: lineRanges)), offsetRanges: \(String(describing: offsetRanges)), pages: \(String(describing: pages)), records: \(String(describing: records)))"}
}

/// <p>The detected occurrences of sensitive data.</p>
public struct Occurrences: Equatable {
    /// <p>Occurrences of sensitive data detected in Microsoft Excel workbooks, comma-separated value (CSV) files, or tab-separated value (TSV) files.</p>
    public let cells: [Cell]?
    /// <p>Occurrences of sensitive data detected in a non-binary text file or a Microsoft Word file. Non-binary text files include files such as HTML, XML, JSON, and TXT files.</p>
    public let lineRanges: [Range]?
    /// <p>Occurrences of sensitive data detected in a binary text file.</p>
    public let offsetRanges: [Range]?
    /// <p>Occurrences of sensitive data in an Adobe Portable Document Format (PDF) file.</p>
    public let pages: [Page]?
    /// <p>Occurrences of sensitive data in an Apache Avro object container or an Apache Parquet file.</p>
    public let records: [Record]?

    public init (
        cells: [Cell]? = nil,
        lineRanges: [Range]? = nil,
        offsetRanges: [Range]? = nil,
        pages: [Page]? = nil,
        records: [Record]? = nil
    )
    {
        self.cells = cells
        self.lineRanges = lineRanges
        self.offsetRanges = offsetRanges
        self.pages = pages
        self.records = records
    }
}

extension Page: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lineRange = "LineRange"
        case offsetRange = "OffsetRange"
        case pageNumber = "PageNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lineRange = lineRange {
            try encodeContainer.encode(lineRange, forKey: .lineRange)
        }
        if let offsetRange = offsetRange {
            try encodeContainer.encode(offsetRange, forKey: .offsetRange)
        }
        if pageNumber != 0 {
            try encodeContainer.encode(pageNumber, forKey: .pageNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageNumberDecoded = try containerValues.decode(Int.self, forKey: .pageNumber)
        pageNumber = pageNumberDecoded
        let lineRangeDecoded = try containerValues.decodeIfPresent(Range.self, forKey: .lineRange)
        lineRange = lineRangeDecoded
        let offsetRangeDecoded = try containerValues.decodeIfPresent(Range.self, forKey: .offsetRange)
        offsetRange = offsetRangeDecoded
    }
}

extension Page: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Page(lineRange: \(String(describing: lineRange)), offsetRange: \(String(describing: offsetRange)), pageNumber: \(String(describing: pageNumber)))"}
}

/// <p>An occurrence of sensitive data in an Adobe Portable Document Format (PDF) file.</p>
public struct Page: Equatable {
    /// <p>An occurrence of sensitive data detected in a non-binary text file or a Microsoft Word file. Non-binary text files include files such as HTML, XML, JSON, and TXT files.</p>
    public let lineRange: Range?
    /// <p>An occurrence of sensitive data detected in a binary text file.</p>
    public let offsetRange: Range?
    /// <p>The page number of the page that contains the sensitive data.</p>
    public let pageNumber: Int

    public init (
        lineRange: Range? = nil,
        offsetRange: Range? = nil,
        pageNumber: Int = 0
    )
    {
        self.lineRange = lineRange
        self.offsetRange = offsetRange
        self.pageNumber = pageNumber
    }
}

public enum Partition {
    case aws
    case awsCn
    case awsUsGov
    case sdkUnknown(String)
}

extension Partition : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Partition] {
        return [
            .aws,
            .awsCn,
            .awsUsGov,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aws: return "aws"
        case .awsCn: return "aws-cn"
        case .awsUsGov: return "aws-us-gov"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Partition(rawValue: rawValue) ?? Partition.sdkUnknown(rawValue)
    }
}

extension PatchSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failedCount = "FailedCount"
        case id = "Id"
        case installedCount = "InstalledCount"
        case installedOtherCount = "InstalledOtherCount"
        case installedPendingReboot = "InstalledPendingReboot"
        case installedRejectedCount = "InstalledRejectedCount"
        case missingCount = "MissingCount"
        case operation = "Operation"
        case operationEndTime = "OperationEndTime"
        case operationStartTime = "OperationStartTime"
        case rebootOption = "RebootOption"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if failedCount != 0 {
            try encodeContainer.encode(failedCount, forKey: .failedCount)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if installedCount != 0 {
            try encodeContainer.encode(installedCount, forKey: .installedCount)
        }
        if installedOtherCount != 0 {
            try encodeContainer.encode(installedOtherCount, forKey: .installedOtherCount)
        }
        if installedPendingReboot != 0 {
            try encodeContainer.encode(installedPendingReboot, forKey: .installedPendingReboot)
        }
        if installedRejectedCount != 0 {
            try encodeContainer.encode(installedRejectedCount, forKey: .installedRejectedCount)
        }
        if missingCount != 0 {
            try encodeContainer.encode(missingCount, forKey: .missingCount)
        }
        if let operation = operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let operationEndTime = operationEndTime {
            try encodeContainer.encode(operationEndTime, forKey: .operationEndTime)
        }
        if let operationStartTime = operationStartTime {
            try encodeContainer.encode(operationStartTime, forKey: .operationStartTime)
        }
        if let rebootOption = rebootOption {
            try encodeContainer.encode(rebootOption, forKey: .rebootOption)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let installedCountDecoded = try containerValues.decode(Int.self, forKey: .installedCount)
        installedCount = installedCountDecoded
        let missingCountDecoded = try containerValues.decode(Int.self, forKey: .missingCount)
        missingCount = missingCountDecoded
        let failedCountDecoded = try containerValues.decode(Int.self, forKey: .failedCount)
        failedCount = failedCountDecoded
        let installedOtherCountDecoded = try containerValues.decode(Int.self, forKey: .installedOtherCount)
        installedOtherCount = installedOtherCountDecoded
        let installedRejectedCountDecoded = try containerValues.decode(Int.self, forKey: .installedRejectedCount)
        installedRejectedCount = installedRejectedCountDecoded
        let installedPendingRebootDecoded = try containerValues.decode(Int.self, forKey: .installedPendingReboot)
        installedPendingReboot = installedPendingRebootDecoded
        let operationStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationStartTime)
        operationStartTime = operationStartTimeDecoded
        let operationEndTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationEndTime)
        operationEndTime = operationEndTimeDecoded
        let rebootOptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rebootOption)
        rebootOption = rebootOptionDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
    }
}

extension PatchSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PatchSummary(failedCount: \(String(describing: failedCount)), id: \(String(describing: id)), installedCount: \(String(describing: installedCount)), installedOtherCount: \(String(describing: installedOtherCount)), installedPendingReboot: \(String(describing: installedPendingReboot)), installedRejectedCount: \(String(describing: installedRejectedCount)), missingCount: \(String(describing: missingCount)), operation: \(String(describing: operation)), operationEndTime: \(String(describing: operationEndTime)), operationStartTime: \(String(describing: operationStartTime)), rebootOption: \(String(describing: rebootOption)))"}
}

/// <p>Provides an overview of the patch compliance status for an instance against a selected
///          compliance standard.</p>
public struct PatchSummary: Equatable {
    /// <p>The number of patches from the compliance standard that failed to install.</p>
    public let failedCount: Int
    /// <p>The identifier of the compliance standard that was used to determine the patch
    ///          compliance status.</p>
    public let id: String?
    /// <p>The number of patches from the compliance standard that were installed
    ///          successfully.</p>
    public let installedCount: Int
    /// <p>The number of installed patches that are not part of the compliance standard.</p>
    public let installedOtherCount: Int
    /// <p>The number of patches that were applied, but that require the instance to be rebooted in
    ///          order to be marked as installed.</p>
    public let installedPendingReboot: Int
    /// <p>The number of patches that are installed but are also on a list of patches that the
    ///          customer rejected.</p>
    public let installedRejectedCount: Int
    /// <p>The number of patches that are part of the compliance standard but are not installed.
    ///          The count includes patches that failed to install.</p>
    public let missingCount: Int
    /// <p>The type of patch operation performed. For Patch Manager, the values are
    ///             <code>SCAN</code> and <code>INSTALL</code>. </p>
    public let operation: String?
    /// <p>Indicates when the operation completed.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let operationEndTime: String?
    /// <p>Indicates when the operation started.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let operationStartTime: String?
    /// <p>The reboot option specified for the instance.</p>
    public let rebootOption: String?

    public init (
        failedCount: Int = 0,
        id: String? = nil,
        installedCount: Int = 0,
        installedOtherCount: Int = 0,
        installedPendingReboot: Int = 0,
        installedRejectedCount: Int = 0,
        missingCount: Int = 0,
        operation: String? = nil,
        operationEndTime: String? = nil,
        operationStartTime: String? = nil,
        rebootOption: String? = nil
    )
    {
        self.failedCount = failedCount
        self.id = id
        self.installedCount = installedCount
        self.installedOtherCount = installedOtherCount
        self.installedPendingReboot = installedPendingReboot
        self.installedRejectedCount = installedRejectedCount
        self.missingCount = missingCount
        self.operation = operation
        self.operationEndTime = operationEndTime
        self.operationStartTime = operationStartTime
        self.rebootOption = rebootOption
    }
}

extension PortProbeAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blocked = "Blocked"
        case portProbeDetails = "PortProbeDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blocked != false {
            try encodeContainer.encode(blocked, forKey: .blocked)
        }
        if let portProbeDetails = portProbeDetails {
            var portProbeDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portProbeDetails)
            for portprobedetaillist0 in portProbeDetails {
                try portProbeDetailsContainer.encode(portprobedetaillist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portProbeDetailsContainer = try containerValues.decodeIfPresent([PortProbeDetail?].self, forKey: .portProbeDetails)
        var portProbeDetailsDecoded0:[PortProbeDetail]? = nil
        if let portProbeDetailsContainer = portProbeDetailsContainer {
            portProbeDetailsDecoded0 = [PortProbeDetail]()
            for structure0 in portProbeDetailsContainer {
                if let structure0 = structure0 {
                    portProbeDetailsDecoded0?.append(structure0)
                }
            }
        }
        portProbeDetails = portProbeDetailsDecoded0
        let blockedDecoded = try containerValues.decode(Bool.self, forKey: .blocked)
        blocked = blockedDecoded
    }
}

extension PortProbeAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PortProbeAction(blocked: \(String(describing: blocked)), portProbeDetails: \(String(describing: portProbeDetails)))"}
}

/// <p>Provided if <code>ActionType</code> is <code>PORT_PROBE</code>. It provides details
///          about the attempted port probe that was detected.</p>
public struct PortProbeAction: Equatable {
    /// <p>Indicates whether the port probe was blocked.</p>
    public let blocked: Bool
    /// <p>Information about the ports affected by the port probe.</p>
    public let portProbeDetails: [PortProbeDetail]?

    public init (
        blocked: Bool = false,
        portProbeDetails: [PortProbeDetail]? = nil
    )
    {
        self.blocked = blocked
        self.portProbeDetails = portProbeDetails
    }
}

extension PortProbeDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case localIpDetails = "LocalIpDetails"
        case localPortDetails = "LocalPortDetails"
        case remoteIpDetails = "RemoteIpDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let localIpDetails = localIpDetails {
            try encodeContainer.encode(localIpDetails, forKey: .localIpDetails)
        }
        if let localPortDetails = localPortDetails {
            try encodeContainer.encode(localPortDetails, forKey: .localPortDetails)
        }
        if let remoteIpDetails = remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localPortDetailsDecoded = try containerValues.decodeIfPresent(ActionLocalPortDetails.self, forKey: .localPortDetails)
        localPortDetails = localPortDetailsDecoded
        let localIpDetailsDecoded = try containerValues.decodeIfPresent(ActionLocalIpDetails.self, forKey: .localIpDetails)
        localIpDetails = localIpDetailsDecoded
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(ActionRemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
    }
}

extension PortProbeDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PortProbeDetail(localIpDetails: \(String(describing: localIpDetails)), localPortDetails: \(String(describing: localPortDetails)), remoteIpDetails: \(String(describing: remoteIpDetails)))"}
}

/// <p>A port scan that was part of the port probe. For each scan, PortProbeDetails provides
///          information about the local IP address and port that were scanned, and the remote IP
///          address that the scan originated from.</p>
public struct PortProbeDetail: Equatable {
    /// <p>Provides information about the IP address where the scanned port is located.</p>
    public let localIpDetails: ActionLocalIpDetails?
    /// <p>Provides information about the port that was scanned.</p>
    public let localPortDetails: ActionLocalPortDetails?
    /// <p>Provides information about the remote IP address that performed the scan.</p>
    public let remoteIpDetails: ActionRemoteIpDetails?

    public init (
        localIpDetails: ActionLocalIpDetails? = nil,
        localPortDetails: ActionLocalPortDetails? = nil,
        remoteIpDetails: ActionRemoteIpDetails? = nil
    )
    {
        self.localIpDetails = localIpDetails
        self.localPortDetails = localPortDetails
        self.remoteIpDetails = remoteIpDetails
    }
}

extension PortRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case begin = "Begin"
        case end = "End"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if begin != 0 {
            try encodeContainer.encode(begin, forKey: .begin)
        }
        if end != 0 {
            try encodeContainer.encode(end, forKey: .end)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginDecoded = try containerValues.decode(Int.self, forKey: .begin)
        begin = beginDecoded
        let endDecoded = try containerValues.decode(Int.self, forKey: .end)
        end = endDecoded
    }
}

extension PortRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PortRange(begin: \(String(describing: begin)), end: \(String(describing: end)))"}
}

/// <p>A range of ports.</p>
public struct PortRange: Equatable {
    /// <p>The first port in the port range.</p>
    public let begin: Int
    /// <p>The last port in the port range.</p>
    public let end: Int

    public init (
        begin: Int = 0,
        end: Int = 0
    )
    {
        self.begin = begin
        self.end = end
    }
}

extension PortRangeFromTo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case from = "From"
        case to = "To"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if from != 0 {
            try encodeContainer.encode(from, forKey: .from)
        }
        if to != 0 {
            try encodeContainer.encode(to, forKey: .to)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decode(Int.self, forKey: .from)
        from = fromDecoded
        let toDecoded = try containerValues.decode(Int.self, forKey: .to)
        to = toDecoded
    }
}

extension PortRangeFromTo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PortRangeFromTo(from: \(String(describing: from)), to: \(String(describing: to)))"}
}

/// <p>A range of ports.</p>
public struct PortRangeFromTo: Equatable {
    /// <p>The first port in the port range.</p>
    public let from: Int
    /// <p>The last port in the port range.</p>
    public let to: Int

    public init (
        from: Int = 0,
        to: Int = 0
    )
    {
        self.from = from
        self.to = to
    }
}

extension ProcessDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case launchedAt = "LaunchedAt"
        case name = "Name"
        case parentPid = "ParentPid"
        case path = "Path"
        case pid = "Pid"
        case terminatedAt = "TerminatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchedAt = launchedAt {
            try encodeContainer.encode(launchedAt, forKey: .launchedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if parentPid != 0 {
            try encodeContainer.encode(parentPid, forKey: .parentPid)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if pid != 0 {
            try encodeContainer.encode(pid, forKey: .pid)
        }
        if let terminatedAt = terminatedAt {
            try encodeContainer.encode(terminatedAt, forKey: .terminatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let pidDecoded = try containerValues.decode(Int.self, forKey: .pid)
        pid = pidDecoded
        let parentPidDecoded = try containerValues.decode(Int.self, forKey: .parentPid)
        parentPid = parentPidDecoded
        let launchedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchedAt)
        launchedAt = launchedAtDecoded
        let terminatedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .terminatedAt)
        terminatedAt = terminatedAtDecoded
    }
}

extension ProcessDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProcessDetails(launchedAt: \(String(describing: launchedAt)), name: \(String(describing: name)), parentPid: \(String(describing: parentPid)), path: \(String(describing: path)), pid: \(String(describing: pid)), terminatedAt: \(String(describing: terminatedAt)))"}
}

/// <p>The details of process-related information about a finding.</p>
public struct ProcessDetails: Equatable {
    /// <p>Indicates when the process was launched.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let launchedAt: String?
    /// <p>The name of the process.</p>
    public let name: String?
    /// <p>The parent process ID.</p>
    public let parentPid: Int
    /// <p>The path to the process executable.</p>
    public let path: String?
    /// <p>The process ID.</p>
    public let pid: Int
    /// <p>Indicates when the process was terminated.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let terminatedAt: String?

    public init (
        launchedAt: String? = nil,
        name: String? = nil,
        parentPid: Int = 0,
        path: String? = nil,
        pid: Int = 0,
        terminatedAt: String? = nil
    )
    {
        self.launchedAt = launchedAt
        self.name = name
        self.parentPid = parentPid
        self.path = path
        self.pid = pid
        self.terminatedAt = terminatedAt
    }
}

extension Product: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activationUrl = "ActivationUrl"
        case categories = "Categories"
        case companyName = "CompanyName"
        case description = "Description"
        case integrationTypes = "IntegrationTypes"
        case marketplaceUrl = "MarketplaceUrl"
        case productArn = "ProductArn"
        case productName = "ProductName"
        case productSubscriptionResourcePolicy = "ProductSubscriptionResourcePolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationUrl = activationUrl {
            try encodeContainer.encode(activationUrl, forKey: .activationUrl)
        }
        if let categories = categories {
            var categoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categories)
            for categorylist0 in categories {
                try categoriesContainer.encode(categorylist0)
            }
        }
        if let companyName = companyName {
            try encodeContainer.encode(companyName, forKey: .companyName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let integrationTypes = integrationTypes {
            var integrationTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integrationTypes)
            for integrationtypelist0 in integrationTypes {
                try integrationTypesContainer.encode(integrationtypelist0.rawValue)
            }
        }
        if let marketplaceUrl = marketplaceUrl {
            try encodeContainer.encode(marketplaceUrl, forKey: .marketplaceUrl)
        }
        if let productArn = productArn {
            try encodeContainer.encode(productArn, forKey: .productArn)
        }
        if let productName = productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let productSubscriptionResourcePolicy = productSubscriptionResourcePolicy {
            try encodeContainer.encode(productSubscriptionResourcePolicy, forKey: .productSubscriptionResourcePolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productArn)
        productArn = productArnDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productName)
        productName = productNameDecoded
        let companyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .companyName)
        companyName = companyNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let categoriesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .categories)
        var categoriesDecoded0:[String]? = nil
        if let categoriesContainer = categoriesContainer {
            categoriesDecoded0 = [String]()
            for string0 in categoriesContainer {
                if let string0 = string0 {
                    categoriesDecoded0?.append(string0)
                }
            }
        }
        categories = categoriesDecoded0
        let integrationTypesContainer = try containerValues.decodeIfPresent([IntegrationType?].self, forKey: .integrationTypes)
        var integrationTypesDecoded0:[IntegrationType]? = nil
        if let integrationTypesContainer = integrationTypesContainer {
            integrationTypesDecoded0 = [IntegrationType]()
            for string0 in integrationTypesContainer {
                if let string0 = string0 {
                    integrationTypesDecoded0?.append(string0)
                }
            }
        }
        integrationTypes = integrationTypesDecoded0
        let marketplaceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marketplaceUrl)
        marketplaceUrl = marketplaceUrlDecoded
        let activationUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activationUrl)
        activationUrl = activationUrlDecoded
        let productSubscriptionResourcePolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productSubscriptionResourcePolicy)
        productSubscriptionResourcePolicy = productSubscriptionResourcePolicyDecoded
    }
}

extension Product: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Product(activationUrl: \(String(describing: activationUrl)), categories: \(String(describing: categories)), companyName: \(String(describing: companyName)), description: \(String(describing: description)), integrationTypes: \(String(describing: integrationTypes)), marketplaceUrl: \(String(describing: marketplaceUrl)), productArn: \(String(describing: productArn)), productName: \(String(describing: productName)), productSubscriptionResourcePolicy: \(String(describing: productSubscriptionResourcePolicy)))"}
}

/// <p>Contains details about a product.</p>
public struct Product: Equatable {
    /// <p>The URL to the service or product documentation about the integration with Security Hub, including how to activate the integration.</p>
    public let activationUrl: String?
    /// <p>The categories assigned to the product.</p>
    public let categories: [String]?
    /// <p>The name of the company that provides the product.</p>
    public let companyName: String?
    /// <p>A description of the product.</p>
    public let description: String?
    /// <p>The types of integration that the product supports. Available values are the
    ///          following.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SEND_FINDINGS_TO_SECURITY_HUB</code> - The integration sends
    ///                findings to Security Hub.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RECEIVE_FINDINGS_FROM_SECURITY_HUB</code> - The integration
    ///                receives findings from Security Hub.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_FINDINGS_IN_SECURITY_HUB</code> - The integration does not send new findings to Security Hub, but does make updates to the findings that it receives from Security Hub.</p>
    ///             </li>
    ///          </ul>
    public let integrationTypes: [IntegrationType]?
    /// <p>For integrations with AWS services, the AWS Console URL from which to activate the service.</p>
    ///          <p>For integrations with third-party products, the AWS Marketplace URL from which to subscribe to or purchase the product.</p>
    public let marketplaceUrl: String?
    /// <p>The ARN assigned to the product.</p>
    public let productArn: String?
    /// <p>The name of the product.</p>
    public let productName: String?
    /// <p>The resource policy associated with the product.</p>
    public let productSubscriptionResourcePolicy: String?

    public init (
        activationUrl: String? = nil,
        categories: [String]? = nil,
        companyName: String? = nil,
        description: String? = nil,
        integrationTypes: [IntegrationType]? = nil,
        marketplaceUrl: String? = nil,
        productArn: String? = nil,
        productName: String? = nil,
        productSubscriptionResourcePolicy: String? = nil
    )
    {
        self.activationUrl = activationUrl
        self.categories = categories
        self.companyName = companyName
        self.description = description
        self.integrationTypes = integrationTypes
        self.marketplaceUrl = marketplaceUrl
        self.productArn = productArn
        self.productName = productName
        self.productSubscriptionResourcePolicy = productSubscriptionResourcePolicy
    }
}

extension Range: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case end = "End"
        case start = "Start"
        case startColumn = "StartColumn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if end != 0 {
            try encodeContainer.encode(end, forKey: .end)
        }
        if start != 0 {
            try encodeContainer.encode(start, forKey: .start)
        }
        if startColumn != 0 {
            try encodeContainer.encode(startColumn, forKey: .startColumn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decode(Int.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decode(Int.self, forKey: .end)
        end = endDecoded
        let startColumnDecoded = try containerValues.decode(Int.self, forKey: .startColumn)
        startColumn = startColumnDecoded
    }
}

extension Range: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Range(end: \(String(describing: end)), start: \(String(describing: start)), startColumn: \(String(describing: startColumn)))"}
}

/// <p>Identifies where the sensitive data begins and ends.</p>
public struct Range: Equatable {
    /// <p>The number of lines (for a line range) or characters (for an offset range) from the beginning of the file to the end of the sensitive data.</p>
    public let end: Int
    /// <p>The number of lines (for a line range) or characters (for an offset range) from the beginning of the file to the end of the sensitive data.</p>
    public let start: Int
    /// <p>In the line where the sensitive data starts, the column within the line where the sensitive data starts.</p>
    public let startColumn: Int

    public init (
        end: Int = 0,
        start: Int = 0,
        startColumn: Int = 0
    )
    {
        self.end = end
        self.start = start
        self.startColumn = startColumn
    }
}

extension Recommendation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case text = "Text"
        case url = "Url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension Recommendation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Recommendation(text: \(String(describing: text)), url: \(String(describing: url)))"}
}

/// <p>A recommendation on how to remediate the issue identified in a finding.</p>
public struct Recommendation: Equatable {
    /// <p>Describes the recommended steps to take to remediate an issue identified in a finding.</p>
    public let text: String?
    /// <p>A URL to a page or site that contains information about how to remediate a finding.</p>
    public let url: String?

    public init (
        text: String? = nil,
        url: String? = nil
    )
    {
        self.text = text
        self.url = url
    }
}

extension Record: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jsonPath = "JsonPath"
        case recordIndex = "RecordIndex"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jsonPath = jsonPath {
            try encodeContainer.encode(jsonPath, forKey: .jsonPath)
        }
        if recordIndex != 0 {
            try encodeContainer.encode(recordIndex, forKey: .recordIndex)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jsonPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jsonPath)
        jsonPath = jsonPathDecoded
        let recordIndexDecoded = try containerValues.decode(Int.self, forKey: .recordIndex)
        recordIndex = recordIndexDecoded
    }
}

extension Record: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Record(jsonPath: \(String(describing: jsonPath)), recordIndex: \(String(describing: recordIndex)))"}
}

/// <p>An occurrence of sensitive data in an Apache Avro object container or an Apache Parquet file.</p>
public struct Record: Equatable {
    /// <p>The path, as a JSONPath expression, to the field in the record that contains the data. If the field name is longer than 20 characters, it is truncated. If the path is longer than 250 characters, it is truncated.</p>
    public let jsonPath: String?
    /// <p>The record index, starting from 0, for the record that contains the data.</p>
    public let recordIndex: Int

    public init (
        jsonPath: String? = nil,
        recordIndex: Int = 0
    )
    {
        self.jsonPath = jsonPath
        self.recordIndex = recordIndex
    }
}

public enum RecordState {
    case active
    case archived
    case sdkUnknown(String)
}

extension RecordState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RecordState] {
        return [
            .active,
            .archived,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .archived: return "ARCHIVED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RecordState(rawValue: rawValue) ?? RecordState.sdkUnknown(rawValue)
    }
}

extension RelatedFinding: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case productArn = "ProductArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let productArn = productArn {
            try encodeContainer.encode(productArn, forKey: .productArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productArn)
        productArn = productArnDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension RelatedFinding: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RelatedFinding(id: \(String(describing: id)), productArn: \(String(describing: productArn)))"}
}

/// <p>Details about a related finding.</p>
public struct RelatedFinding: Equatable {
    /// <p>The product-generated identifier for a related finding.</p>
    public let id: String?
    /// <p>The ARN of the product that generated a related finding.</p>
    public let productArn: String?

    public init (
        id: String? = nil,
        productArn: String? = nil
    )
    {
        self.id = id
        self.productArn = productArn
    }
}

extension Remediation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recommendation = "Recommendation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommendation = recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationDecoded = try containerValues.decodeIfPresent(Recommendation.self, forKey: .recommendation)
        recommendation = recommendationDecoded
    }
}

extension Remediation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Remediation(recommendation: \(String(describing: recommendation)))"}
}

/// <p>Details about the remediation steps for a finding.</p>
public struct Remediation: Equatable {
    /// <p>A recommendation on the steps to take to remediate the issue identified by a finding.</p>
    public let recommendation: Recommendation?

    public init (
        recommendation: Recommendation? = nil
    )
    {
        self.recommendation = recommendation
    }
}

extension Resource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataClassification = "DataClassification"
        case details = "Details"
        case id = "Id"
        case partition = "Partition"
        case region = "Region"
        case resourceRole = "ResourceRole"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataClassification = dataClassification {
            try encodeContainer.encode(dataClassification, forKey: .dataClassification)
        }
        if let details = details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let partition = partition {
            try encodeContainer.encode(partition.rawValue, forKey: .partition)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resourceRole = resourceRole {
            try encodeContainer.encode(resourceRole, forKey: .resourceRole)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, fieldmap0) in tags {
                try tagsContainer.encode(fieldmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let partitionDecoded = try containerValues.decodeIfPresent(Partition.self, forKey: .partition)
        partition = partitionDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let resourceRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceRole)
        resourceRole = resourceRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, nonemptystring0) in tagsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    tagsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        tags = tagsDecoded0
        let dataClassificationDecoded = try containerValues.decodeIfPresent(DataClassificationDetails.self, forKey: .dataClassification)
        dataClassification = dataClassificationDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(ResourceDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

extension Resource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Resource(dataClassification: \(String(describing: dataClassification)), details: \(String(describing: details)), id: \(String(describing: id)), partition: \(String(describing: partition)), region: \(String(describing: region)), resourceRole: \(String(describing: resourceRole)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

/// <p>A resource related to a finding.</p>
public struct Resource: Equatable {
    /// <p>Contains information about sensitive data that was detected on the resource.</p>
    public let dataClassification: DataClassificationDetails?
    /// <p>Additional details about the resource related to a finding.</p>
    public let details: ResourceDetails?
    /// <p>The canonical identifier for the given resource type.</p>
    public let id: String?
    /// <p>The canonical AWS partition name that the Region is assigned to.</p>
    public let partition: Partition?
    /// <p>The canonical AWS external Region name where this resource is located.</p>
    public let region: String?
    /// <p>Identifies the role of the resource in the finding. A resource is either the actor or target of the finding activity,</p>
    public let resourceRole: String?
    /// <p>A list of AWS tags associated with a resource at the time the finding was
    ///          processed.</p>
    public let tags: [String:String]?
    /// <p>The type of the resource that details are provided for. If possible, set
    ///             <code>Type</code> to one of the supported resource types. For example, if the resource
    ///          is an EC2 instance, then set <code>Type</code> to <code>AwsEc2Instance</code>.</p>
    ///          <p>If the resource does not match any of the provided types, then set <code>Type</code> to
    ///             <code>Other</code>. </p>
    public let type: String?

    public init (
        dataClassification: DataClassificationDetails? = nil,
        details: ResourceDetails? = nil,
        id: String? = nil,
        partition: Partition? = nil,
        region: String? = nil,
        resourceRole: String? = nil,
        tags: [String:String]? = nil,
        type: String? = nil
    )
    {
        self.dataClassification = dataClassification
        self.details = details
        self.id = id
        self.partition = partition
        self.region = region
        self.resourceRole = resourceRole
        self.tags = tags
        self.type = type
    }
}

extension ResourceConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceConflictException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension ResourceConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource specified in the request conflicts with an existing resource.</p>
public struct ResourceConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceConflictExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension ResourceConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension ResourceDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsApiGatewayRestApi = "AwsApiGatewayRestApi"
        case awsApiGatewayStage = "AwsApiGatewayStage"
        case awsApiGatewayV2Api = "AwsApiGatewayV2Api"
        case awsApiGatewayV2Stage = "AwsApiGatewayV2Stage"
        case awsAutoScalingAutoScalingGroup = "AwsAutoScalingAutoScalingGroup"
        case awsCertificateManagerCertificate = "AwsCertificateManagerCertificate"
        case awsCloudFrontDistribution = "AwsCloudFrontDistribution"
        case awsCloudTrailTrail = "AwsCloudTrailTrail"
        case awsCodeBuildProject = "AwsCodeBuildProject"
        case awsDynamoDbTable = "AwsDynamoDbTable"
        case awsEc2Eip = "AwsEc2Eip"
        case awsEc2Instance = "AwsEc2Instance"
        case awsEc2NetworkAcl = "AwsEc2NetworkAcl"
        case awsEc2NetworkInterface = "AwsEc2NetworkInterface"
        case awsEc2SecurityGroup = "AwsEc2SecurityGroup"
        case awsEc2Subnet = "AwsEc2Subnet"
        case awsEc2Volume = "AwsEc2Volume"
        case awsEc2Vpc = "AwsEc2Vpc"
        case awsElasticBeanstalkEnvironment = "AwsElasticBeanstalkEnvironment"
        case awsElasticsearchDomain = "AwsElasticsearchDomain"
        case awsElbLoadBalancer = "AwsElbLoadBalancer"
        case awsElbv2LoadBalancer = "AwsElbv2LoadBalancer"
        case awsIamAccessKey = "AwsIamAccessKey"
        case awsIamGroup = "AwsIamGroup"
        case awsIamPolicy = "AwsIamPolicy"
        case awsIamRole = "AwsIamRole"
        case awsIamUser = "AwsIamUser"
        case awsKmsKey = "AwsKmsKey"
        case awsLambdaFunction = "AwsLambdaFunction"
        case awsLambdaLayerVersion = "AwsLambdaLayerVersion"
        case awsRdsDbCluster = "AwsRdsDbCluster"
        case awsRdsDbClusterSnapshot = "AwsRdsDbClusterSnapshot"
        case awsRdsDbInstance = "AwsRdsDbInstance"
        case awsRdsDbSnapshot = "AwsRdsDbSnapshot"
        case awsRedshiftCluster = "AwsRedshiftCluster"
        case awsS3AccountPublicAccessBlock = "AwsS3AccountPublicAccessBlock"
        case awsS3Bucket = "AwsS3Bucket"
        case awsS3Object = "AwsS3Object"
        case awsSecretsManagerSecret = "AwsSecretsManagerSecret"
        case awsSnsTopic = "AwsSnsTopic"
        case awsSqsQueue = "AwsSqsQueue"
        case awsSsmPatchCompliance = "AwsSsmPatchCompliance"
        case awsWafWebAcl = "AwsWafWebAcl"
        case container = "Container"
        case other = "Other"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsApiGatewayRestApi = awsApiGatewayRestApi {
            try encodeContainer.encode(awsApiGatewayRestApi, forKey: .awsApiGatewayRestApi)
        }
        if let awsApiGatewayStage = awsApiGatewayStage {
            try encodeContainer.encode(awsApiGatewayStage, forKey: .awsApiGatewayStage)
        }
        if let awsApiGatewayV2Api = awsApiGatewayV2Api {
            try encodeContainer.encode(awsApiGatewayV2Api, forKey: .awsApiGatewayV2Api)
        }
        if let awsApiGatewayV2Stage = awsApiGatewayV2Stage {
            try encodeContainer.encode(awsApiGatewayV2Stage, forKey: .awsApiGatewayV2Stage)
        }
        if let awsAutoScalingAutoScalingGroup = awsAutoScalingAutoScalingGroup {
            try encodeContainer.encode(awsAutoScalingAutoScalingGroup, forKey: .awsAutoScalingAutoScalingGroup)
        }
        if let awsCertificateManagerCertificate = awsCertificateManagerCertificate {
            try encodeContainer.encode(awsCertificateManagerCertificate, forKey: .awsCertificateManagerCertificate)
        }
        if let awsCloudFrontDistribution = awsCloudFrontDistribution {
            try encodeContainer.encode(awsCloudFrontDistribution, forKey: .awsCloudFrontDistribution)
        }
        if let awsCloudTrailTrail = awsCloudTrailTrail {
            try encodeContainer.encode(awsCloudTrailTrail, forKey: .awsCloudTrailTrail)
        }
        if let awsCodeBuildProject = awsCodeBuildProject {
            try encodeContainer.encode(awsCodeBuildProject, forKey: .awsCodeBuildProject)
        }
        if let awsDynamoDbTable = awsDynamoDbTable {
            try encodeContainer.encode(awsDynamoDbTable, forKey: .awsDynamoDbTable)
        }
        if let awsEc2Eip = awsEc2Eip {
            try encodeContainer.encode(awsEc2Eip, forKey: .awsEc2Eip)
        }
        if let awsEc2Instance = awsEc2Instance {
            try encodeContainer.encode(awsEc2Instance, forKey: .awsEc2Instance)
        }
        if let awsEc2NetworkAcl = awsEc2NetworkAcl {
            try encodeContainer.encode(awsEc2NetworkAcl, forKey: .awsEc2NetworkAcl)
        }
        if let awsEc2NetworkInterface = awsEc2NetworkInterface {
            try encodeContainer.encode(awsEc2NetworkInterface, forKey: .awsEc2NetworkInterface)
        }
        if let awsEc2SecurityGroup = awsEc2SecurityGroup {
            try encodeContainer.encode(awsEc2SecurityGroup, forKey: .awsEc2SecurityGroup)
        }
        if let awsEc2Subnet = awsEc2Subnet {
            try encodeContainer.encode(awsEc2Subnet, forKey: .awsEc2Subnet)
        }
        if let awsEc2Volume = awsEc2Volume {
            try encodeContainer.encode(awsEc2Volume, forKey: .awsEc2Volume)
        }
        if let awsEc2Vpc = awsEc2Vpc {
            try encodeContainer.encode(awsEc2Vpc, forKey: .awsEc2Vpc)
        }
        if let awsElasticBeanstalkEnvironment = awsElasticBeanstalkEnvironment {
            try encodeContainer.encode(awsElasticBeanstalkEnvironment, forKey: .awsElasticBeanstalkEnvironment)
        }
        if let awsElasticsearchDomain = awsElasticsearchDomain {
            try encodeContainer.encode(awsElasticsearchDomain, forKey: .awsElasticsearchDomain)
        }
        if let awsElbLoadBalancer = awsElbLoadBalancer {
            try encodeContainer.encode(awsElbLoadBalancer, forKey: .awsElbLoadBalancer)
        }
        if let awsElbv2LoadBalancer = awsElbv2LoadBalancer {
            try encodeContainer.encode(awsElbv2LoadBalancer, forKey: .awsElbv2LoadBalancer)
        }
        if let awsIamAccessKey = awsIamAccessKey {
            try encodeContainer.encode(awsIamAccessKey, forKey: .awsIamAccessKey)
        }
        if let awsIamGroup = awsIamGroup {
            try encodeContainer.encode(awsIamGroup, forKey: .awsIamGroup)
        }
        if let awsIamPolicy = awsIamPolicy {
            try encodeContainer.encode(awsIamPolicy, forKey: .awsIamPolicy)
        }
        if let awsIamRole = awsIamRole {
            try encodeContainer.encode(awsIamRole, forKey: .awsIamRole)
        }
        if let awsIamUser = awsIamUser {
            try encodeContainer.encode(awsIamUser, forKey: .awsIamUser)
        }
        if let awsKmsKey = awsKmsKey {
            try encodeContainer.encode(awsKmsKey, forKey: .awsKmsKey)
        }
        if let awsLambdaFunction = awsLambdaFunction {
            try encodeContainer.encode(awsLambdaFunction, forKey: .awsLambdaFunction)
        }
        if let awsLambdaLayerVersion = awsLambdaLayerVersion {
            try encodeContainer.encode(awsLambdaLayerVersion, forKey: .awsLambdaLayerVersion)
        }
        if let awsRdsDbCluster = awsRdsDbCluster {
            try encodeContainer.encode(awsRdsDbCluster, forKey: .awsRdsDbCluster)
        }
        if let awsRdsDbClusterSnapshot = awsRdsDbClusterSnapshot {
            try encodeContainer.encode(awsRdsDbClusterSnapshot, forKey: .awsRdsDbClusterSnapshot)
        }
        if let awsRdsDbInstance = awsRdsDbInstance {
            try encodeContainer.encode(awsRdsDbInstance, forKey: .awsRdsDbInstance)
        }
        if let awsRdsDbSnapshot = awsRdsDbSnapshot {
            try encodeContainer.encode(awsRdsDbSnapshot, forKey: .awsRdsDbSnapshot)
        }
        if let awsRedshiftCluster = awsRedshiftCluster {
            try encodeContainer.encode(awsRedshiftCluster, forKey: .awsRedshiftCluster)
        }
        if let awsS3AccountPublicAccessBlock = awsS3AccountPublicAccessBlock {
            try encodeContainer.encode(awsS3AccountPublicAccessBlock, forKey: .awsS3AccountPublicAccessBlock)
        }
        if let awsS3Bucket = awsS3Bucket {
            try encodeContainer.encode(awsS3Bucket, forKey: .awsS3Bucket)
        }
        if let awsS3Object = awsS3Object {
            try encodeContainer.encode(awsS3Object, forKey: .awsS3Object)
        }
        if let awsSecretsManagerSecret = awsSecretsManagerSecret {
            try encodeContainer.encode(awsSecretsManagerSecret, forKey: .awsSecretsManagerSecret)
        }
        if let awsSnsTopic = awsSnsTopic {
            try encodeContainer.encode(awsSnsTopic, forKey: .awsSnsTopic)
        }
        if let awsSqsQueue = awsSqsQueue {
            try encodeContainer.encode(awsSqsQueue, forKey: .awsSqsQueue)
        }
        if let awsSsmPatchCompliance = awsSsmPatchCompliance {
            try encodeContainer.encode(awsSsmPatchCompliance, forKey: .awsSsmPatchCompliance)
        }
        if let awsWafWebAcl = awsWafWebAcl {
            try encodeContainer.encode(awsWafWebAcl, forKey: .awsWafWebAcl)
        }
        if let container = container {
            try encodeContainer.encode(container, forKey: .container)
        }
        if let other = other {
            var otherContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .other)
            for (dictKey0, fieldmap0) in other {
                try otherContainer.encode(fieldmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAutoScalingAutoScalingGroupDecoded = try containerValues.decodeIfPresent(AwsAutoScalingAutoScalingGroupDetails.self, forKey: .awsAutoScalingAutoScalingGroup)
        awsAutoScalingAutoScalingGroup = awsAutoScalingAutoScalingGroupDecoded
        let awsCodeBuildProjectDecoded = try containerValues.decodeIfPresent(AwsCodeBuildProjectDetails.self, forKey: .awsCodeBuildProject)
        awsCodeBuildProject = awsCodeBuildProjectDecoded
        let awsCloudFrontDistributionDecoded = try containerValues.decodeIfPresent(AwsCloudFrontDistributionDetails.self, forKey: .awsCloudFrontDistribution)
        awsCloudFrontDistribution = awsCloudFrontDistributionDecoded
        let awsEc2InstanceDecoded = try containerValues.decodeIfPresent(AwsEc2InstanceDetails.self, forKey: .awsEc2Instance)
        awsEc2Instance = awsEc2InstanceDecoded
        let awsEc2NetworkInterfaceDecoded = try containerValues.decodeIfPresent(AwsEc2NetworkInterfaceDetails.self, forKey: .awsEc2NetworkInterface)
        awsEc2NetworkInterface = awsEc2NetworkInterfaceDecoded
        let awsEc2SecurityGroupDecoded = try containerValues.decodeIfPresent(AwsEc2SecurityGroupDetails.self, forKey: .awsEc2SecurityGroup)
        awsEc2SecurityGroup = awsEc2SecurityGroupDecoded
        let awsEc2VolumeDecoded = try containerValues.decodeIfPresent(AwsEc2VolumeDetails.self, forKey: .awsEc2Volume)
        awsEc2Volume = awsEc2VolumeDecoded
        let awsEc2VpcDecoded = try containerValues.decodeIfPresent(AwsEc2VpcDetails.self, forKey: .awsEc2Vpc)
        awsEc2Vpc = awsEc2VpcDecoded
        let awsEc2EipDecoded = try containerValues.decodeIfPresent(AwsEc2EipDetails.self, forKey: .awsEc2Eip)
        awsEc2Eip = awsEc2EipDecoded
        let awsEc2SubnetDecoded = try containerValues.decodeIfPresent(AwsEc2SubnetDetails.self, forKey: .awsEc2Subnet)
        awsEc2Subnet = awsEc2SubnetDecoded
        let awsEc2NetworkAclDecoded = try containerValues.decodeIfPresent(AwsEc2NetworkAclDetails.self, forKey: .awsEc2NetworkAcl)
        awsEc2NetworkAcl = awsEc2NetworkAclDecoded
        let awsElbv2LoadBalancerDecoded = try containerValues.decodeIfPresent(AwsElbv2LoadBalancerDetails.self, forKey: .awsElbv2LoadBalancer)
        awsElbv2LoadBalancer = awsElbv2LoadBalancerDecoded
        let awsElasticBeanstalkEnvironmentDecoded = try containerValues.decodeIfPresent(AwsElasticBeanstalkEnvironmentDetails.self, forKey: .awsElasticBeanstalkEnvironment)
        awsElasticBeanstalkEnvironment = awsElasticBeanstalkEnvironmentDecoded
        let awsElasticsearchDomainDecoded = try containerValues.decodeIfPresent(AwsElasticsearchDomainDetails.self, forKey: .awsElasticsearchDomain)
        awsElasticsearchDomain = awsElasticsearchDomainDecoded
        let awsS3BucketDecoded = try containerValues.decodeIfPresent(AwsS3BucketDetails.self, forKey: .awsS3Bucket)
        awsS3Bucket = awsS3BucketDecoded
        let awsS3AccountPublicAccessBlockDecoded = try containerValues.decodeIfPresent(AwsS3AccountPublicAccessBlockDetails.self, forKey: .awsS3AccountPublicAccessBlock)
        awsS3AccountPublicAccessBlock = awsS3AccountPublicAccessBlockDecoded
        let awsS3ObjectDecoded = try containerValues.decodeIfPresent(AwsS3ObjectDetails.self, forKey: .awsS3Object)
        awsS3Object = awsS3ObjectDecoded
        let awsSecretsManagerSecretDecoded = try containerValues.decodeIfPresent(AwsSecretsManagerSecretDetails.self, forKey: .awsSecretsManagerSecret)
        awsSecretsManagerSecret = awsSecretsManagerSecretDecoded
        let awsIamAccessKeyDecoded = try containerValues.decodeIfPresent(AwsIamAccessKeyDetails.self, forKey: .awsIamAccessKey)
        awsIamAccessKey = awsIamAccessKeyDecoded
        let awsIamUserDecoded = try containerValues.decodeIfPresent(AwsIamUserDetails.self, forKey: .awsIamUser)
        awsIamUser = awsIamUserDecoded
        let awsIamPolicyDecoded = try containerValues.decodeIfPresent(AwsIamPolicyDetails.self, forKey: .awsIamPolicy)
        awsIamPolicy = awsIamPolicyDecoded
        let awsApiGatewayV2StageDecoded = try containerValues.decodeIfPresent(AwsApiGatewayV2StageDetails.self, forKey: .awsApiGatewayV2Stage)
        awsApiGatewayV2Stage = awsApiGatewayV2StageDecoded
        let awsApiGatewayV2ApiDecoded = try containerValues.decodeIfPresent(AwsApiGatewayV2ApiDetails.self, forKey: .awsApiGatewayV2Api)
        awsApiGatewayV2Api = awsApiGatewayV2ApiDecoded
        let awsDynamoDbTableDecoded = try containerValues.decodeIfPresent(AwsDynamoDbTableDetails.self, forKey: .awsDynamoDbTable)
        awsDynamoDbTable = awsDynamoDbTableDecoded
        let awsApiGatewayStageDecoded = try containerValues.decodeIfPresent(AwsApiGatewayStageDetails.self, forKey: .awsApiGatewayStage)
        awsApiGatewayStage = awsApiGatewayStageDecoded
        let awsApiGatewayRestApiDecoded = try containerValues.decodeIfPresent(AwsApiGatewayRestApiDetails.self, forKey: .awsApiGatewayRestApi)
        awsApiGatewayRestApi = awsApiGatewayRestApiDecoded
        let awsCloudTrailTrailDecoded = try containerValues.decodeIfPresent(AwsCloudTrailTrailDetails.self, forKey: .awsCloudTrailTrail)
        awsCloudTrailTrail = awsCloudTrailTrailDecoded
        let awsSsmPatchComplianceDecoded = try containerValues.decodeIfPresent(AwsSsmPatchComplianceDetails.self, forKey: .awsSsmPatchCompliance)
        awsSsmPatchCompliance = awsSsmPatchComplianceDecoded
        let awsCertificateManagerCertificateDecoded = try containerValues.decodeIfPresent(AwsCertificateManagerCertificateDetails.self, forKey: .awsCertificateManagerCertificate)
        awsCertificateManagerCertificate = awsCertificateManagerCertificateDecoded
        let awsRedshiftClusterDecoded = try containerValues.decodeIfPresent(AwsRedshiftClusterDetails.self, forKey: .awsRedshiftCluster)
        awsRedshiftCluster = awsRedshiftClusterDecoded
        let awsElbLoadBalancerDecoded = try containerValues.decodeIfPresent(AwsElbLoadBalancerDetails.self, forKey: .awsElbLoadBalancer)
        awsElbLoadBalancer = awsElbLoadBalancerDecoded
        let awsIamGroupDecoded = try containerValues.decodeIfPresent(AwsIamGroupDetails.self, forKey: .awsIamGroup)
        awsIamGroup = awsIamGroupDecoded
        let awsIamRoleDecoded = try containerValues.decodeIfPresent(AwsIamRoleDetails.self, forKey: .awsIamRole)
        awsIamRole = awsIamRoleDecoded
        let awsKmsKeyDecoded = try containerValues.decodeIfPresent(AwsKmsKeyDetails.self, forKey: .awsKmsKey)
        awsKmsKey = awsKmsKeyDecoded
        let awsLambdaFunctionDecoded = try containerValues.decodeIfPresent(AwsLambdaFunctionDetails.self, forKey: .awsLambdaFunction)
        awsLambdaFunction = awsLambdaFunctionDecoded
        let awsLambdaLayerVersionDecoded = try containerValues.decodeIfPresent(AwsLambdaLayerVersionDetails.self, forKey: .awsLambdaLayerVersion)
        awsLambdaLayerVersion = awsLambdaLayerVersionDecoded
        let awsRdsDbInstanceDecoded = try containerValues.decodeIfPresent(AwsRdsDbInstanceDetails.self, forKey: .awsRdsDbInstance)
        awsRdsDbInstance = awsRdsDbInstanceDecoded
        let awsSnsTopicDecoded = try containerValues.decodeIfPresent(AwsSnsTopicDetails.self, forKey: .awsSnsTopic)
        awsSnsTopic = awsSnsTopicDecoded
        let awsSqsQueueDecoded = try containerValues.decodeIfPresent(AwsSqsQueueDetails.self, forKey: .awsSqsQueue)
        awsSqsQueue = awsSqsQueueDecoded
        let awsWafWebAclDecoded = try containerValues.decodeIfPresent(AwsWafWebAclDetails.self, forKey: .awsWafWebAcl)
        awsWafWebAcl = awsWafWebAclDecoded
        let awsRdsDbSnapshotDecoded = try containerValues.decodeIfPresent(AwsRdsDbSnapshotDetails.self, forKey: .awsRdsDbSnapshot)
        awsRdsDbSnapshot = awsRdsDbSnapshotDecoded
        let awsRdsDbClusterSnapshotDecoded = try containerValues.decodeIfPresent(AwsRdsDbClusterSnapshotDetails.self, forKey: .awsRdsDbClusterSnapshot)
        awsRdsDbClusterSnapshot = awsRdsDbClusterSnapshotDecoded
        let awsRdsDbClusterDecoded = try containerValues.decodeIfPresent(AwsRdsDbClusterDetails.self, forKey: .awsRdsDbCluster)
        awsRdsDbCluster = awsRdsDbClusterDecoded
        let containerDecoded = try containerValues.decodeIfPresent(ContainerDetails.self, forKey: .container)
        container = containerDecoded
        let otherContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .other)
        var otherDecoded0: [String:String]? = nil
        if let otherContainer = otherContainer {
            otherDecoded0 = [String:String]()
            for (key0, nonemptystring0) in otherContainer {
                if let nonemptystring0 = nonemptystring0 {
                    otherDecoded0?[key0] = nonemptystring0
                }
            }
        }
        other = otherDecoded0
    }
}

extension ResourceDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceDetails(awsApiGatewayRestApi: \(String(describing: awsApiGatewayRestApi)), awsApiGatewayStage: \(String(describing: awsApiGatewayStage)), awsApiGatewayV2Api: \(String(describing: awsApiGatewayV2Api)), awsApiGatewayV2Stage: \(String(describing: awsApiGatewayV2Stage)), awsAutoScalingAutoScalingGroup: \(String(describing: awsAutoScalingAutoScalingGroup)), awsCertificateManagerCertificate: \(String(describing: awsCertificateManagerCertificate)), awsCloudFrontDistribution: \(String(describing: awsCloudFrontDistribution)), awsCloudTrailTrail: \(String(describing: awsCloudTrailTrail)), awsCodeBuildProject: \(String(describing: awsCodeBuildProject)), awsDynamoDbTable: \(String(describing: awsDynamoDbTable)), awsEc2Eip: \(String(describing: awsEc2Eip)), awsEc2Instance: \(String(describing: awsEc2Instance)), awsEc2NetworkAcl: \(String(describing: awsEc2NetworkAcl)), awsEc2NetworkInterface: \(String(describing: awsEc2NetworkInterface)), awsEc2SecurityGroup: \(String(describing: awsEc2SecurityGroup)), awsEc2Subnet: \(String(describing: awsEc2Subnet)), awsEc2Volume: \(String(describing: awsEc2Volume)), awsEc2Vpc: \(String(describing: awsEc2Vpc)), awsElasticBeanstalkEnvironment: \(String(describing: awsElasticBeanstalkEnvironment)), awsElasticsearchDomain: \(String(describing: awsElasticsearchDomain)), awsElbLoadBalancer: \(String(describing: awsElbLoadBalancer)), awsElbv2LoadBalancer: \(String(describing: awsElbv2LoadBalancer)), awsIamAccessKey: \(String(describing: awsIamAccessKey)), awsIamGroup: \(String(describing: awsIamGroup)), awsIamPolicy: \(String(describing: awsIamPolicy)), awsIamRole: \(String(describing: awsIamRole)), awsIamUser: \(String(describing: awsIamUser)), awsKmsKey: \(String(describing: awsKmsKey)), awsLambdaFunction: \(String(describing: awsLambdaFunction)), awsLambdaLayerVersion: \(String(describing: awsLambdaLayerVersion)), awsRdsDbCluster: \(String(describing: awsRdsDbCluster)), awsRdsDbClusterSnapshot: \(String(describing: awsRdsDbClusterSnapshot)), awsRdsDbInstance: \(String(describing: awsRdsDbInstance)), awsRdsDbSnapshot: \(String(describing: awsRdsDbSnapshot)), awsRedshiftCluster: \(String(describing: awsRedshiftCluster)), awsS3AccountPublicAccessBlock: \(String(describing: awsS3AccountPublicAccessBlock)), awsS3Bucket: \(String(describing: awsS3Bucket)), awsS3Object: \(String(describing: awsS3Object)), awsSecretsManagerSecret: \(String(describing: awsSecretsManagerSecret)), awsSnsTopic: \(String(describing: awsSnsTopic)), awsSqsQueue: \(String(describing: awsSqsQueue)), awsSsmPatchCompliance: \(String(describing: awsSsmPatchCompliance)), awsWafWebAcl: \(String(describing: awsWafWebAcl)), container: \(String(describing: container)), other: \(String(describing: other)))"}
}

/// <p>Additional details about a resource related to a finding.</p>
///          <p>To provide the details, use the object that corresponds to the resource type. For
///          example, if the resource type is <code>AwsEc2Instance</code>, then you use the
///             <code>AwsEc2Instance</code> object to provide the details.</p>
///          <p>If the type-specific object does not contain all of the fields you want to populate,
///          then you use the <code>Other</code> object to populate those additional fields.</p>
///          <p>You also use the <code>Other</code> object to populate the details when the selected
///          type does not have a corresponding object.</p>
public struct ResourceDetails: Equatable {
    /// <p>Provides information about a REST API in version 1 of Amazon API Gateway.</p>
    public let awsApiGatewayRestApi: AwsApiGatewayRestApiDetails?
    /// <p>Provides information about a version 1 Amazon API Gateway stage.</p>
    public let awsApiGatewayStage: AwsApiGatewayStageDetails?
    /// <p>Provides information about a version 2 API in Amazon API Gateway.</p>
    public let awsApiGatewayV2Api: AwsApiGatewayV2ApiDetails?
    /// <p>Provides information about a version 2 stage for Amazon API Gateway.</p>
    public let awsApiGatewayV2Stage: AwsApiGatewayV2StageDetails?
    /// <p>Details for an autoscaling group.</p>
    public let awsAutoScalingAutoScalingGroup: AwsAutoScalingAutoScalingGroupDetails?
    /// <p>Provides details about an AWS Certificate Manager (ACM) certificate.</p>
    public let awsCertificateManagerCertificate: AwsCertificateManagerCertificateDetails?
    /// <p>Details about a CloudFront distribution.</p>
    public let awsCloudFrontDistribution: AwsCloudFrontDistributionDetails?
    /// <p>Provides details about a CloudTrail trail.</p>
    public let awsCloudTrailTrail: AwsCloudTrailTrailDetails?
    /// <p>Details for an AWS CodeBuild project.</p>
    public let awsCodeBuildProject: AwsCodeBuildProjectDetails?
    /// <p>Details about a DynamoDB table.</p>
    public let awsDynamoDbTable: AwsDynamoDbTableDetails?
    /// <p>Details about an Elastic IP address.</p>
    public let awsEc2Eip: AwsEc2EipDetails?
    /// <p>Details about an Amazon EC2 instance related to a finding.</p>
    public let awsEc2Instance: AwsEc2InstanceDetails?
    /// <p>Details about an EC2 network access control list (ACL).</p>
    public let awsEc2NetworkAcl: AwsEc2NetworkAclDetails?
    /// <p>Details for an Amazon EC2 network interface.</p>
    public let awsEc2NetworkInterface: AwsEc2NetworkInterfaceDetails?
    /// <p>Details for an EC2 security group.</p>
    public let awsEc2SecurityGroup: AwsEc2SecurityGroupDetails?
    /// <p>Details about a subnet in EC2.</p>
    public let awsEc2Subnet: AwsEc2SubnetDetails?
    /// <p>Details for an EC2 volume.</p>
    public let awsEc2Volume: AwsEc2VolumeDetails?
    /// <p>Details for an EC2 VPC.</p>
    public let awsEc2Vpc: AwsEc2VpcDetails?
    /// <p>Details about an Elastic Beanstalk environment.</p>
    public let awsElasticBeanstalkEnvironment: AwsElasticBeanstalkEnvironmentDetails?
    /// <p>Details for an Elasticsearch domain.</p>
    public let awsElasticsearchDomain: AwsElasticsearchDomainDetails?
    /// <p>contains details about a Classic Load Balancer.</p>
    public let awsElbLoadBalancer: AwsElbLoadBalancerDetails?
    /// <p>Details about a load balancer.</p>
    public let awsElbv2LoadBalancer: AwsElbv2LoadBalancerDetails?
    /// <p>Details about an IAM access key related to a finding.</p>
    public let awsIamAccessKey: AwsIamAccessKeyDetails?
    /// <p>Contains details about an IAM group.</p>
    public let awsIamGroup: AwsIamGroupDetails?
    /// <p>Details about an IAM permissions policy.</p>
    public let awsIamPolicy: AwsIamPolicyDetails?
    /// <p>Details about an IAM role.</p>
    public let awsIamRole: AwsIamRoleDetails?
    /// <p>Details about an IAM user.</p>
    public let awsIamUser: AwsIamUserDetails?
    /// <p>Details about a KMS key.</p>
    public let awsKmsKey: AwsKmsKeyDetails?
    /// <p>Details about a Lambda function.</p>
    public let awsLambdaFunction: AwsLambdaFunctionDetails?
    /// <p>Details for a Lambda layer version.</p>
    public let awsLambdaLayerVersion: AwsLambdaLayerVersionDetails?
    /// <p>Details about an Amazon RDS database cluster.</p>
    public let awsRdsDbCluster: AwsRdsDbClusterDetails?
    /// <p>Details about an Amazon RDS database cluster snapshot.</p>
    public let awsRdsDbClusterSnapshot: AwsRdsDbClusterSnapshotDetails?
    /// <p>Details about an Amazon RDS database instance.</p>
    public let awsRdsDbInstance: AwsRdsDbInstanceDetails?
    /// <p>Details about an Amazon RDS database snapshot.</p>
    public let awsRdsDbSnapshot: AwsRdsDbSnapshotDetails?
    /// <p>Contains details about an Amazon Redshift cluster.</p>
    public let awsRedshiftCluster: AwsRedshiftClusterDetails?
    /// <p>Details about the Amazon S3 Public Access Block configuration for an account.</p>
    public let awsS3AccountPublicAccessBlock: AwsS3AccountPublicAccessBlockDetails?
    /// <p>Details about an Amazon S3 bucket related to a finding.</p>
    public let awsS3Bucket: AwsS3BucketDetails?
    /// <p>Details about an Amazon S3 object related to a finding.</p>
    public let awsS3Object: AwsS3ObjectDetails?
    /// <p>Details about a Secrets Manager secret.</p>
    public let awsSecretsManagerSecret: AwsSecretsManagerSecretDetails?
    /// <p>Details about an SNS topic.</p>
    public let awsSnsTopic: AwsSnsTopicDetails?
    /// <p>Details about an SQS queue.</p>
    public let awsSqsQueue: AwsSqsQueueDetails?
    /// <p>Provides information about the state of a patch on an instance based on the patch baseline that was used to patch the instance.</p>
    public let awsSsmPatchCompliance: AwsSsmPatchComplianceDetails?
    /// <p>Details for a WAF WebACL.</p>
    public let awsWafWebAcl: AwsWafWebAclDetails?
    /// <p>Details about a container resource related to a finding.</p>
    public let container: ContainerDetails?
    /// <p>Details about a resource that are not available in a type-specific details object. Use
    ///          the <code>Other</code> object in the following cases.</p>
    ///          <ul>
    ///             <li>
    ///                <p>The type-specific object does not contain all of the fields that you want to
    ///                populate. In this case, first use the type-specific object to populate those fields.
    ///                Use the <code>Other</code> object to populate the fields that are missing from the
    ///                type-specific object.</p>
    ///             </li>
    ///             <li>
    ///                <p>The resource type does not have a corresponding object. This includes resources
    ///                for which the type is <code>Other</code>. </p>
    ///             </li>
    ///          </ul>
    public let other: [String:String]?

    public init (
        awsApiGatewayRestApi: AwsApiGatewayRestApiDetails? = nil,
        awsApiGatewayStage: AwsApiGatewayStageDetails? = nil,
        awsApiGatewayV2Api: AwsApiGatewayV2ApiDetails? = nil,
        awsApiGatewayV2Stage: AwsApiGatewayV2StageDetails? = nil,
        awsAutoScalingAutoScalingGroup: AwsAutoScalingAutoScalingGroupDetails? = nil,
        awsCertificateManagerCertificate: AwsCertificateManagerCertificateDetails? = nil,
        awsCloudFrontDistribution: AwsCloudFrontDistributionDetails? = nil,
        awsCloudTrailTrail: AwsCloudTrailTrailDetails? = nil,
        awsCodeBuildProject: AwsCodeBuildProjectDetails? = nil,
        awsDynamoDbTable: AwsDynamoDbTableDetails? = nil,
        awsEc2Eip: AwsEc2EipDetails? = nil,
        awsEc2Instance: AwsEc2InstanceDetails? = nil,
        awsEc2NetworkAcl: AwsEc2NetworkAclDetails? = nil,
        awsEc2NetworkInterface: AwsEc2NetworkInterfaceDetails? = nil,
        awsEc2SecurityGroup: AwsEc2SecurityGroupDetails? = nil,
        awsEc2Subnet: AwsEc2SubnetDetails? = nil,
        awsEc2Volume: AwsEc2VolumeDetails? = nil,
        awsEc2Vpc: AwsEc2VpcDetails? = nil,
        awsElasticBeanstalkEnvironment: AwsElasticBeanstalkEnvironmentDetails? = nil,
        awsElasticsearchDomain: AwsElasticsearchDomainDetails? = nil,
        awsElbLoadBalancer: AwsElbLoadBalancerDetails? = nil,
        awsElbv2LoadBalancer: AwsElbv2LoadBalancerDetails? = nil,
        awsIamAccessKey: AwsIamAccessKeyDetails? = nil,
        awsIamGroup: AwsIamGroupDetails? = nil,
        awsIamPolicy: AwsIamPolicyDetails? = nil,
        awsIamRole: AwsIamRoleDetails? = nil,
        awsIamUser: AwsIamUserDetails? = nil,
        awsKmsKey: AwsKmsKeyDetails? = nil,
        awsLambdaFunction: AwsLambdaFunctionDetails? = nil,
        awsLambdaLayerVersion: AwsLambdaLayerVersionDetails? = nil,
        awsRdsDbCluster: AwsRdsDbClusterDetails? = nil,
        awsRdsDbClusterSnapshot: AwsRdsDbClusterSnapshotDetails? = nil,
        awsRdsDbInstance: AwsRdsDbInstanceDetails? = nil,
        awsRdsDbSnapshot: AwsRdsDbSnapshotDetails? = nil,
        awsRedshiftCluster: AwsRedshiftClusterDetails? = nil,
        awsS3AccountPublicAccessBlock: AwsS3AccountPublicAccessBlockDetails? = nil,
        awsS3Bucket: AwsS3BucketDetails? = nil,
        awsS3Object: AwsS3ObjectDetails? = nil,
        awsSecretsManagerSecret: AwsSecretsManagerSecretDetails? = nil,
        awsSnsTopic: AwsSnsTopicDetails? = nil,
        awsSqsQueue: AwsSqsQueueDetails? = nil,
        awsSsmPatchCompliance: AwsSsmPatchComplianceDetails? = nil,
        awsWafWebAcl: AwsWafWebAclDetails? = nil,
        container: ContainerDetails? = nil,
        other: [String:String]? = nil
    )
    {
        self.awsApiGatewayRestApi = awsApiGatewayRestApi
        self.awsApiGatewayStage = awsApiGatewayStage
        self.awsApiGatewayV2Api = awsApiGatewayV2Api
        self.awsApiGatewayV2Stage = awsApiGatewayV2Stage
        self.awsAutoScalingAutoScalingGroup = awsAutoScalingAutoScalingGroup
        self.awsCertificateManagerCertificate = awsCertificateManagerCertificate
        self.awsCloudFrontDistribution = awsCloudFrontDistribution
        self.awsCloudTrailTrail = awsCloudTrailTrail
        self.awsCodeBuildProject = awsCodeBuildProject
        self.awsDynamoDbTable = awsDynamoDbTable
        self.awsEc2Eip = awsEc2Eip
        self.awsEc2Instance = awsEc2Instance
        self.awsEc2NetworkAcl = awsEc2NetworkAcl
        self.awsEc2NetworkInterface = awsEc2NetworkInterface
        self.awsEc2SecurityGroup = awsEc2SecurityGroup
        self.awsEc2Subnet = awsEc2Subnet
        self.awsEc2Volume = awsEc2Volume
        self.awsEc2Vpc = awsEc2Vpc
        self.awsElasticBeanstalkEnvironment = awsElasticBeanstalkEnvironment
        self.awsElasticsearchDomain = awsElasticsearchDomain
        self.awsElbLoadBalancer = awsElbLoadBalancer
        self.awsElbv2LoadBalancer = awsElbv2LoadBalancer
        self.awsIamAccessKey = awsIamAccessKey
        self.awsIamGroup = awsIamGroup
        self.awsIamPolicy = awsIamPolicy
        self.awsIamRole = awsIamRole
        self.awsIamUser = awsIamUser
        self.awsKmsKey = awsKmsKey
        self.awsLambdaFunction = awsLambdaFunction
        self.awsLambdaLayerVersion = awsLambdaLayerVersion
        self.awsRdsDbCluster = awsRdsDbCluster
        self.awsRdsDbClusterSnapshot = awsRdsDbClusterSnapshot
        self.awsRdsDbInstance = awsRdsDbInstance
        self.awsRdsDbSnapshot = awsRdsDbSnapshot
        self.awsRedshiftCluster = awsRedshiftCluster
        self.awsS3AccountPublicAccessBlock = awsS3AccountPublicAccessBlock
        self.awsS3Bucket = awsS3Bucket
        self.awsS3Object = awsS3Object
        self.awsSecretsManagerSecret = awsSecretsManagerSecret
        self.awsSnsTopic = awsSnsTopic
        self.awsSqsQueue = awsSqsQueue
        self.awsSsmPatchCompliance = awsSsmPatchCompliance
        self.awsWafWebAcl = awsWafWebAcl
        self.container = container
        self.other = other
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because we can't find the specified resource.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension Result: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case processingResult = "ProcessingResult"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let processingResult = processingResult {
            try encodeContainer.encode(processingResult, forKey: .processingResult)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let processingResultDecoded = try containerValues.decodeIfPresent(String.self, forKey: .processingResult)
        processingResult = processingResultDecoded
    }
}

extension Result: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Result(accountId: \(String(describing: accountId)), processingResult: \(String(describing: processingResult)))"}
}

/// <p>Details about the account that was not processed.</p>
public struct Result: Equatable {
    /// <p>An AWS account ID of the account that was not processed.</p>
    public let accountId: String?
    /// <p>The reason that the account was not processed.</p>
    public let processingResult: String?

    public init (
        accountId: String? = nil,
        processingResult: String? = nil
    )
    {
        self.accountId = accountId
        self.processingResult = processingResult
    }
}

extension SensitiveDataDetections: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case count = "Count"
        case occurrences = "Occurrences"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let occurrences = occurrences {
            try encodeContainer.encode(occurrences, forKey: .occurrences)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decode(Int.self, forKey: .count)
        count = countDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let occurrencesDecoded = try containerValues.decodeIfPresent(Occurrences.self, forKey: .occurrences)
        occurrences = occurrencesDecoded
    }
}

extension SensitiveDataDetections: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SensitiveDataDetections(count: \(String(describing: count)), occurrences: \(String(describing: occurrences)), type: \(String(describing: type)))"}
}

/// <p>The list of detected instances of sensitive data.</p>
public struct SensitiveDataDetections: Equatable {
    /// <p>The total number of occurrences of sensitive data that were detected.</p>
    public let count: Int
    /// <p>Details about the sensitive data that was detected.</p>
    public let occurrences: Occurrences?
    /// <p>The type of sensitive data that was detected. For example, the type might indicate that the data is an email address.</p>
    public let type: String?

    public init (
        count: Int = 0,
        occurrences: Occurrences? = nil,
        type: String? = nil
    )
    {
        self.count = count
        self.occurrences = occurrences
        self.type = type
    }
}

extension SensitiveDataResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case category = "Category"
        case detections = "Detections"
        case totalCount = "TotalCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let detections = detections {
            var detectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .detections)
            for sensitivedatadetectionslist0 in detections {
                try detectionsContainer.encode(sensitivedatadetectionslist0)
            }
        }
        if totalCount != 0 {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .category)
        category = categoryDecoded
        let detectionsContainer = try containerValues.decodeIfPresent([SensitiveDataDetections?].self, forKey: .detections)
        var detectionsDecoded0:[SensitiveDataDetections]? = nil
        if let detectionsContainer = detectionsContainer {
            detectionsDecoded0 = [SensitiveDataDetections]()
            for structure0 in detectionsContainer {
                if let structure0 = structure0 {
                    detectionsDecoded0?.append(structure0)
                }
            }
        }
        detections = detectionsDecoded0
        let totalCountDecoded = try containerValues.decode(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

extension SensitiveDataResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SensitiveDataResult(category: \(String(describing: category)), detections: \(String(describing: detections)), totalCount: \(String(describing: totalCount)))"}
}

/// <p>Contains a detected instance of sensitive data that are based on built-in identifiers.</p>
public struct SensitiveDataResult: Equatable {
    /// <p>The category of sensitive data that was detected. For example, the category can indicate that the sensitive data involved credentials, financial information, or personal information.</p>
    public let category: String?
    /// <p>The list of detected instances of sensitive data.</p>
    public let detections: [SensitiveDataDetections]?
    /// <p>The total number of occurrences of sensitive data.</p>
    public let totalCount: Int

    public init (
        category: String? = nil,
        detections: [SensitiveDataDetections]? = nil,
        totalCount: Int = 0
    )
    {
        self.category = category
        self.detections = detections
        self.totalCount = totalCount
    }
}

extension Severity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case label = "Label"
        case normalized = "Normalized"
        case original = "Original"
        case product = "Product"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let label = label {
            try encodeContainer.encode(label.rawValue, forKey: .label)
        }
        if normalized != 0 {
            try encodeContainer.encode(normalized, forKey: .normalized)
        }
        if let original = original {
            try encodeContainer.encode(original, forKey: .original)
        }
        if product != 0.0 {
            try encodeContainer.encode(product, forKey: .product)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productDecoded = try containerValues.decode(Double.self, forKey: .product)
        product = productDecoded
        let labelDecoded = try containerValues.decodeIfPresent(SeverityLabel.self, forKey: .label)
        label = labelDecoded
        let normalizedDecoded = try containerValues.decode(Int.self, forKey: .normalized)
        normalized = normalizedDecoded
        let originalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .original)
        original = originalDecoded
    }
}

extension Severity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Severity(label: \(String(describing: label)), normalized: \(String(describing: normalized)), original: \(String(describing: original)), product: \(String(describing: product)))"}
}

/// <p>The severity of the finding.</p>
///          <p>The finding provider can provide the initial severity. The finding provider can only
///          update the severity if it has not been updated using
///          <code>BatchUpdateFindings</code>.</p>
///          <p>The finding must have either <code>Label</code> or <code>Normalized</code> populated. If
///          only one of these attributes is populated, then Security Hub automatically populates the other
///          one. If neither attribute is populated, then the finding is invalid. <code>Label</code> is
///          the preferred attribute.</p>
public struct Severity: Equatable {
    /// <p>The severity value of the finding. The allowed values are the following.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>INFORMATIONAL</code> - No issue was found.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LOW</code> - The issue does not require action on its own.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MEDIUM</code> - The issue must be addressed but not urgently.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>HIGH</code> - The issue must be addressed as a priority.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CRITICAL</code> - The issue must be remediated immediately to avoid it
    ///                escalating.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you provide <code>Normalized</code> and do not provide <code>Label</code>, then
    ///             <code>Label</code> is set automatically as follows. </p>
    ///          <ul>
    ///             <li>
    ///                <p>0 - <code>INFORMATIONAL</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>1–39 - <code>LOW</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>40–69 - <code>MEDIUM</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>70–89 - <code>HIGH</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>90–100 - <code>CRITICAL</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let label: SeverityLabel?
    /// <p>Deprecated. The normalized severity of a finding. This attribute is being deprecated.
    ///          Instead of providing <code>Normalized</code>, provide <code>Label</code>.</p>
    ///          <p>If you provide <code>Label</code> and do not provide <code>Normalized</code>, then
    ///             <code>Normalized</code> is set automatically as follows.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>INFORMATIONAL</code> - 0</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LOW</code> - 1</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MEDIUM</code> - 40</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>HIGH</code> - 70</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CRITICAL</code> - 90</p>
    ///             </li>
    ///          </ul>
    public let normalized: Int
    /// <p>The native severity from the finding product that generated the finding.</p>
    public let original: String?
    /// <p>Deprecated. This attribute is being deprecated. Instead of providing
    ///             <code>Product</code>, provide <code>Original</code>.</p>
    ///          <p>The native severity as defined by the AWS service or integrated partner product that
    ///          generated the finding.</p>
    public let product: Double

    public init (
        label: SeverityLabel? = nil,
        normalized: Int = 0,
        original: String? = nil,
        product: Double = 0.0
    )
    {
        self.label = label
        self.normalized = normalized
        self.original = original
        self.product = product
    }
}

public enum SeverityLabel {
    case critical
    case high
    case informational
    case low
    case medium
    case sdkUnknown(String)
}

extension SeverityLabel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SeverityLabel] {
        return [
            .critical,
            .high,
            .informational,
            .low,
            .medium,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .critical: return "CRITICAL"
        case .high: return "HIGH"
        case .informational: return "INFORMATIONAL"
        case .low: return "LOW"
        case .medium: return "MEDIUM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SeverityLabel(rawValue: rawValue) ?? SeverityLabel.sdkUnknown(rawValue)
    }
}

public enum SeverityRating {
    case critical
    case high
    case low
    case medium
    case sdkUnknown(String)
}

extension SeverityRating : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SeverityRating] {
        return [
            .critical,
            .high,
            .low,
            .medium,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .critical: return "CRITICAL"
        case .high: return "HIGH"
        case .low: return "LOW"
        case .medium: return "MEDIUM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SeverityRating(rawValue: rawValue) ?? SeverityRating.sdkUnknown(rawValue)
    }
}

extension SeverityUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case label = "Label"
        case normalized = "Normalized"
        case product = "Product"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let label = label {
            try encodeContainer.encode(label.rawValue, forKey: .label)
        }
        if normalized != 0 {
            try encodeContainer.encode(normalized, forKey: .normalized)
        }
        if product != 0.0 {
            try encodeContainer.encode(product, forKey: .product)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let normalizedDecoded = try containerValues.decode(Int.self, forKey: .normalized)
        normalized = normalizedDecoded
        let productDecoded = try containerValues.decode(Double.self, forKey: .product)
        product = productDecoded
        let labelDecoded = try containerValues.decodeIfPresent(SeverityLabel.self, forKey: .label)
        label = labelDecoded
    }
}

extension SeverityUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SeverityUpdate(label: \(String(describing: label)), normalized: \(String(describing: normalized)), product: \(String(describing: product)))"}
}

/// <p>Updates to the severity information for a finding.</p>
public struct SeverityUpdate: Equatable {
    /// <p>The severity value of the finding. The allowed values are the following.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>INFORMATIONAL</code> - No issue was found.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LOW</code> - The issue does not require action on its own.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MEDIUM</code> - The issue must be addressed but not urgently.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>HIGH</code> - The issue must be addressed as a priority.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CRITICAL</code> - The issue must be remediated immediately to avoid it
    ///                escalating.</p>
    ///             </li>
    ///          </ul>
    public let label: SeverityLabel?
    /// <p>The normalized severity for the finding. This attribute is to be deprecated in favor of
    ///             <code>Label</code>.</p>
    ///          <p>If you provide <code>Normalized</code> and do not provide <code>Label</code>,
    ///             <code>Label</code> is set automatically as follows.</p>
    ///          <ul>
    ///             <li>
    ///                <p>0 - <code>INFORMATIONAL</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>1–39 - <code>LOW</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>40–69 - <code>MEDIUM</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>70–89 - <code>HIGH</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>90–100 - <code>CRITICAL</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let normalized: Int
    /// <p>The native severity as defined by the AWS service or integrated partner product that
    ///          generated the finding.</p>
    public let product: Double

    public init (
        label: SeverityLabel? = nil,
        normalized: Int = 0,
        product: Double = 0.0
    )
    {
        self.label = label
        self.normalized = normalized
        self.product = product
    }
}

extension SoftwarePackage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case architecture = "Architecture"
        case epoch = "Epoch"
        case name = "Name"
        case release = "Release"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = architecture {
            try encodeContainer.encode(architecture, forKey: .architecture)
        }
        if let epoch = epoch {
            try encodeContainer.encode(epoch, forKey: .epoch)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let release = release {
            try encodeContainer.encode(release, forKey: .release)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let epochDecoded = try containerValues.decodeIfPresent(String.self, forKey: .epoch)
        epoch = epochDecoded
        let releaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .release)
        release = releaseDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .architecture)
        architecture = architectureDecoded
    }
}

extension SoftwarePackage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SoftwarePackage(architecture: \(String(describing: architecture)), epoch: \(String(describing: epoch)), name: \(String(describing: name)), release: \(String(describing: release)), version: \(String(describing: version)))"}
}

/// <p>Information about a software package.</p>
public struct SoftwarePackage: Equatable {
    /// <p>The architecture used for the software package.</p>
    public let architecture: String?
    /// <p>The epoch of the software package.</p>
    public let epoch: String?
    /// <p>The name of the software package.</p>
    public let name: String?
    /// <p>The release of the software package.</p>
    public let release: String?
    /// <p>The version of the software package.</p>
    public let version: String?

    public init (
        architecture: String? = nil,
        epoch: String? = nil,
        name: String? = nil,
        release: String? = nil,
        version: String? = nil
    )
    {
        self.architecture = architecture
        self.epoch = epoch
        self.name = name
        self.release = release
        self.version = version
    }
}

extension SortCriterion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case field = "Field"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let field = field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .field)
        field = fieldDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension SortCriterion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SortCriterion(field: \(String(describing: field)), sortOrder: \(String(describing: sortOrder)))"}
}

/// <p>A collection of finding attributes used to sort findings.</p>
public struct SortCriterion: Equatable {
    /// <p>The finding attribute used to sort findings.</p>
    public let field: String?
    /// <p>The order used to sort findings.</p>
    public let sortOrder: SortOrder?

    public init (
        field: String? = nil,
        sortOrder: SortOrder? = nil
    )
    {
        self.field = field
        self.sortOrder = sortOrder
    }
}

public enum SortOrder {
    case ascending
    case descending
    case sdkUnknown(String)
}

extension SortOrder : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SortOrder] {
        return [
            .ascending,
            .descending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ascending: return "asc"
        case .descending: return "desc"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
    }
}

extension Standard: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case enabledByDefault = "EnabledByDefault"
        case name = "Name"
        case standardsArn = "StandardsArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if enabledByDefault != false {
            try encodeContainer.encode(enabledByDefault, forKey: .enabledByDefault)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let standardsArn = standardsArn {
            try encodeContainer.encode(standardsArn, forKey: .standardsArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .standardsArn)
        standardsArn = standardsArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let enabledByDefaultDecoded = try containerValues.decode(Bool.self, forKey: .enabledByDefault)
        enabledByDefault = enabledByDefaultDecoded
    }
}

extension Standard: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Standard(description: \(String(describing: description)), enabledByDefault: \(String(describing: enabledByDefault)), name: \(String(describing: name)), standardsArn: \(String(describing: standardsArn)))"}
}

/// <p>Provides information about a specific standard.</p>
public struct Standard: Equatable {
    /// <p>A description of the standard.</p>
    public let description: String?
    /// <p>Whether the standard is enabled by default. When Security Hub is enabled from the console, if a
    ///          standard is enabled by default, the check box for that standard is selected by
    ///          default.</p>
    ///          <p>When Security Hub is enabled using the <code>EnableSecurityHub</code> API operation, the
    ///          standard is enabled by default unless <code>EnableDefaultStandards</code> is set to
    ///             <code>false</code>.</p>
    public let enabledByDefault: Bool
    /// <p>The name of the standard.</p>
    public let name: String?
    /// <p>The ARN of a standard.</p>
    public let standardsArn: String?

    public init (
        description: String? = nil,
        enabledByDefault: Bool = false,
        name: String? = nil,
        standardsArn: String? = nil
    )
    {
        self.description = description
        self.enabledByDefault = enabledByDefault
        self.name = name
        self.standardsArn = standardsArn
    }
}

extension StandardsControl: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case controlId = "ControlId"
        case controlStatus = "ControlStatus"
        case controlStatusUpdatedAt = "ControlStatusUpdatedAt"
        case description = "Description"
        case disabledReason = "DisabledReason"
        case relatedRequirements = "RelatedRequirements"
        case remediationUrl = "RemediationUrl"
        case severityRating = "SeverityRating"
        case standardsControlArn = "StandardsControlArn"
        case title = "Title"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlId = controlId {
            try encodeContainer.encode(controlId, forKey: .controlId)
        }
        if let controlStatus = controlStatus {
            try encodeContainer.encode(controlStatus.rawValue, forKey: .controlStatus)
        }
        if let controlStatusUpdatedAt = controlStatusUpdatedAt {
            try encodeContainer.encode(controlStatusUpdatedAt.timeIntervalSince1970, forKey: .controlStatusUpdatedAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disabledReason = disabledReason {
            try encodeContainer.encode(disabledReason, forKey: .disabledReason)
        }
        if let relatedRequirements = relatedRequirements {
            var relatedRequirementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedRequirements)
            for relatedrequirementslist0 in relatedRequirements {
                try relatedRequirementsContainer.encode(relatedrequirementslist0)
            }
        }
        if let remediationUrl = remediationUrl {
            try encodeContainer.encode(remediationUrl, forKey: .remediationUrl)
        }
        if let severityRating = severityRating {
            try encodeContainer.encode(severityRating.rawValue, forKey: .severityRating)
        }
        if let standardsControlArn = standardsControlArn {
            try encodeContainer.encode(standardsControlArn, forKey: .standardsControlArn)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsControlArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .standardsControlArn)
        standardsControlArn = standardsControlArnDecoded
        let controlStatusDecoded = try containerValues.decodeIfPresent(ControlStatus.self, forKey: .controlStatus)
        controlStatus = controlStatusDecoded
        let disabledReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .disabledReason)
        disabledReason = disabledReasonDecoded
        let controlStatusUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .controlStatusUpdatedAt)
        controlStatusUpdatedAt = controlStatusUpdatedAtDecoded
        let controlIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .controlId)
        controlId = controlIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let remediationUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .remediationUrl)
        remediationUrl = remediationUrlDecoded
        let severityRatingDecoded = try containerValues.decodeIfPresent(SeverityRating.self, forKey: .severityRating)
        severityRating = severityRatingDecoded
        let relatedRequirementsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .relatedRequirements)
        var relatedRequirementsDecoded0:[String]? = nil
        if let relatedRequirementsContainer = relatedRequirementsContainer {
            relatedRequirementsDecoded0 = [String]()
            for string0 in relatedRequirementsContainer {
                if let string0 = string0 {
                    relatedRequirementsDecoded0?.append(string0)
                }
            }
        }
        relatedRequirements = relatedRequirementsDecoded0
    }
}

extension StandardsControl: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StandardsControl(controlId: \(String(describing: controlId)), controlStatus: \(String(describing: controlStatus)), controlStatusUpdatedAt: \(String(describing: controlStatusUpdatedAt)), description: \(String(describing: description)), disabledReason: \(String(describing: disabledReason)), relatedRequirements: \(String(describing: relatedRequirements)), remediationUrl: \(String(describing: remediationUrl)), severityRating: \(String(describing: severityRating)), standardsControlArn: \(String(describing: standardsControlArn)), title: \(String(describing: title)))"}
}

/// <p>Details for an individual security standard control.</p>
public struct StandardsControl: Equatable {
    /// <p>The identifier of the security standard control.</p>
    public let controlId: String?
    /// <p>The current status of the security standard control. Indicates whether the control is
    ///          enabled or disabled. Security Hub does not check against disabled controls.</p>
    public let controlStatus: ControlStatus?
    /// <p>The date and time that the status of the security standard control was most recently
    ///          updated.</p>
    public let controlStatusUpdatedAt: Date?
    /// <p>The longer description of the security standard control. Provides information about what
    ///          the control is checking for.</p>
    public let description: String?
    /// <p>The reason provided for the most recent change in status for the control.</p>
    public let disabledReason: String?
    /// <p>The list of requirements that are related to this control.</p>
    public let relatedRequirements: [String]?
    /// <p>A link to remediation information for the control in the Security Hub user
    ///          documentation.</p>
    public let remediationUrl: String?
    /// <p>The severity of findings generated from this security standard control.</p>
    ///          <p>The finding severity is based on an assessment of how easy it would be to compromise AWS
    ///          resources if the issue is detected.</p>
    public let severityRating: SeverityRating?
    /// <p>The ARN of the security standard control.</p>
    public let standardsControlArn: String?
    /// <p>The title of the security standard control.</p>
    public let title: String?

    public init (
        controlId: String? = nil,
        controlStatus: ControlStatus? = nil,
        controlStatusUpdatedAt: Date? = nil,
        description: String? = nil,
        disabledReason: String? = nil,
        relatedRequirements: [String]? = nil,
        remediationUrl: String? = nil,
        severityRating: SeverityRating? = nil,
        standardsControlArn: String? = nil,
        title: String? = nil
    )
    {
        self.controlId = controlId
        self.controlStatus = controlStatus
        self.controlStatusUpdatedAt = controlStatusUpdatedAt
        self.description = description
        self.disabledReason = disabledReason
        self.relatedRequirements = relatedRequirements
        self.remediationUrl = remediationUrl
        self.severityRating = severityRating
        self.standardsControlArn = standardsControlArn
        self.title = title
    }
}

public enum StandardsStatus {
    case deleting
    case failed
    case incomplete
    case pending
    case ready
    case sdkUnknown(String)
}

extension StandardsStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StandardsStatus] {
        return [
            .deleting,
            .failed,
            .incomplete,
            .pending,
            .ready,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .incomplete: return "INCOMPLETE"
        case .pending: return "PENDING"
        case .ready: return "READY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StandardsStatus(rawValue: rawValue) ?? StandardsStatus.sdkUnknown(rawValue)
    }
}

extension StandardsSubscription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case standardsArn = "StandardsArn"
        case standardsInput = "StandardsInput"
        case standardsStatus = "StandardsStatus"
        case standardsSubscriptionArn = "StandardsSubscriptionArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let standardsArn = standardsArn {
            try encodeContainer.encode(standardsArn, forKey: .standardsArn)
        }
        if let standardsInput = standardsInput {
            var standardsInputContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .standardsInput)
            for (dictKey0, standardsinputparametermap0) in standardsInput {
                try standardsInputContainer.encode(standardsinputparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let standardsStatus = standardsStatus {
            try encodeContainer.encode(standardsStatus.rawValue, forKey: .standardsStatus)
        }
        if let standardsSubscriptionArn = standardsSubscriptionArn {
            try encodeContainer.encode(standardsSubscriptionArn, forKey: .standardsSubscriptionArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsSubscriptionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .standardsSubscriptionArn)
        standardsSubscriptionArn = standardsSubscriptionArnDecoded
        let standardsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .standardsArn)
        standardsArn = standardsArnDecoded
        let standardsInputContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .standardsInput)
        var standardsInputDecoded0: [String:String]? = nil
        if let standardsInputContainer = standardsInputContainer {
            standardsInputDecoded0 = [String:String]()
            for (key0, nonemptystring0) in standardsInputContainer {
                if let nonemptystring0 = nonemptystring0 {
                    standardsInputDecoded0?[key0] = nonemptystring0
                }
            }
        }
        standardsInput = standardsInputDecoded0
        let standardsStatusDecoded = try containerValues.decodeIfPresent(StandardsStatus.self, forKey: .standardsStatus)
        standardsStatus = standardsStatusDecoded
    }
}

extension StandardsSubscription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StandardsSubscription(standardsArn: \(String(describing: standardsArn)), standardsInput: \(String(describing: standardsInput)), standardsStatus: \(String(describing: standardsStatus)), standardsSubscriptionArn: \(String(describing: standardsSubscriptionArn)))"}
}

/// <p>A resource that represents your subscription to a supported standard.</p>
public struct StandardsSubscription: Equatable {
    /// <p>The ARN of a standard.</p>
    public let standardsArn: String?
    /// <p>A key-value pair of input for the standard.</p>
    public let standardsInput: [String:String]?
    /// <p>The status of the standard subscription.</p>
    ///          <p>The status values are as follows:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PENDING</code> - Standard is in the process of being enabled.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>READY</code> - Standard is enabled.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INCOMPLETE</code> - Standard could not be enabled completely. Some controls may not be available.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETING</code> - Standard is in the process of being disabled.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> - Standard could not be disabled.</p>
    ///             </li>
    ///          </ul>
    public let standardsStatus: StandardsStatus?
    /// <p>The ARN of a resource that represents your subscription to a supported standard.</p>
    public let standardsSubscriptionArn: String?

    public init (
        standardsArn: String? = nil,
        standardsInput: [String:String]? = nil,
        standardsStatus: StandardsStatus? = nil,
        standardsSubscriptionArn: String? = nil
    )
    {
        self.standardsArn = standardsArn
        self.standardsInput = standardsInput
        self.standardsStatus = standardsStatus
        self.standardsSubscriptionArn = standardsSubscriptionArn
    }
}

extension StandardsSubscriptionRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case standardsArn = "StandardsArn"
        case standardsInput = "StandardsInput"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let standardsArn = standardsArn {
            try encodeContainer.encode(standardsArn, forKey: .standardsArn)
        }
        if let standardsInput = standardsInput {
            var standardsInputContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .standardsInput)
            for (dictKey0, standardsinputparametermap0) in standardsInput {
                try standardsInputContainer.encode(standardsinputparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .standardsArn)
        standardsArn = standardsArnDecoded
        let standardsInputContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .standardsInput)
        var standardsInputDecoded0: [String:String]? = nil
        if let standardsInputContainer = standardsInputContainer {
            standardsInputDecoded0 = [String:String]()
            for (key0, nonemptystring0) in standardsInputContainer {
                if let nonemptystring0 = nonemptystring0 {
                    standardsInputDecoded0?[key0] = nonemptystring0
                }
            }
        }
        standardsInput = standardsInputDecoded0
    }
}

extension StandardsSubscriptionRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StandardsSubscriptionRequest(standardsArn: \(String(describing: standardsArn)), standardsInput: \(String(describing: standardsInput)))"}
}

/// <p>The standard that you want to enable.</p>
public struct StandardsSubscriptionRequest: Equatable {
    /// <p>The ARN of the standard that you want to enable. To view the list of available standards
    ///          and their ARNs, use the <code>
    ///                <a>DescribeStandards</a>
    ///             </code> operation.</p>
    public let standardsArn: String?
    /// <p>A key-value pair of input for the standard.</p>
    public let standardsInput: [String:String]?

    public init (
        standardsArn: String? = nil,
        standardsInput: [String:String]? = nil
    )
    {
        self.standardsArn = standardsArn
        self.standardsInput = standardsInput
    }
}

extension StatusReason: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case reasonCode = "ReasonCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let reasonCode = reasonCode {
            try encodeContainer.encode(reasonCode, forKey: .reasonCode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reasonCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reasonCode)
        reasonCode = reasonCodeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension StatusReason: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StatusReason(description: \(String(describing: description)), reasonCode: \(String(describing: reasonCode)))"}
}

/// <p>Provides additional context for the value of <code>Compliance.Status</code>.</p>
public struct StatusReason: Equatable {
    /// <p>The corresponding description for the status reason code.</p>
    public let description: String?
    /// <p>A code that represents a reason for the control status. For the list of status reason
    ///          codes and their meanings, see <a href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-results.html#securityhub-standards-results-asff">Standards-related information in the ASFF</a> in the
    ///             <i>AWS Security Hub User Guide</i>. </p>
    public let reasonCode: String?

    public init (
        description: String? = nil,
        reasonCode: String? = nil
    )
    {
        self.description = description
        self.reasonCode = reasonCode
    }
}

extension StringFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparison = "Comparison"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparison = comparison {
            try encodeContainer.encode(comparison.rawValue, forKey: .comparison)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let comparisonDecoded = try containerValues.decodeIfPresent(StringFilterComparison.self, forKey: .comparison)
        comparison = comparisonDecoded
    }
}

extension StringFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StringFilter(comparison: \(String(describing: comparison)), value: \(String(describing: value)))"}
}

/// <p>A string filter for querying findings.</p>
public struct StringFilter: Equatable {
    /// <p>The condition to apply to a string value when querying for findings. To search for
    ///          values that contain the filter criteria value, use one of the following comparison
    ///          operators:</p>
    ///          <ul>
    ///             <li>
    ///                <p>To search for values that exactly match the filter value, use
    ///                <code>EQUALS</code>.</p>
    ///                <p>For example, the filter <code>ResourceType EQUALS AwsEc2SecurityGroup</code> only
    ///                matches findings that have a resource type of
    ///                <code>AwsEc2SecurityGroup</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To search for values that start with the filter value, use
    ///                <code>PREFIX</code>.</p>
    ///                <p>For example, the filter <code>ResourceType PREFIX AwsIam</code> matches findings
    ///                that have a resource type that starts with <code>AwsIam</code>. Findings with a
    ///                resource type of <code>AwsIamPolicy</code>, <code>AwsIamRole</code>, or
    ///                   <code>AwsIamUser</code> would all match.</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <code>EQUALS</code> and <code>PREFIX</code> filters on the same field are joined by
    ///             <code>OR</code>. A finding matches if it matches any one of those filters.</p>
    ///          <p>To search for values that do not contain the filter criteria value, use one of the
    ///          following comparison operators:</p>
    ///          <ul>
    ///             <li>
    ///                <p>To search for values that do not exactly match the filter value, use
    ///                   <code>NOT_EQUALS</code>.</p>
    ///                <p>For example, the filter <code>ResourceType NOT_EQUALS AwsIamPolicy</code> matches
    ///                findings that have a resource type other than <code>AwsIamPolicy</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To search for values that do not start with the filter value, use
    ///                   <code>PREFIX_NOT_EQUALS</code>.</p>
    ///                <p>For example, the filter <code>ResourceType PREFIX_NOT_EQUALS AwsIam</code> matches
    ///                findings that have a resource type that does not start with <code>AwsIam</code>.
    ///                Findings with a resource type of <code>AwsIamPolicy</code>, <code>AwsIamRole</code>,
    ///                or <code>AwsIamUser</code> would all be excluded from the results.</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <code>NOT_EQUALS</code> and <code>PREFIX_NOT_EQUALS</code> filters on the same field are
    ///          joined by <code>AND</code>. A finding matches only if it matches all of those
    ///          filters.</p>
    ///          <p>For filters on the same field, you cannot provide both an <code>EQUALS</code> filter and
    ///          a <code>NOT_EQUALS</code> or <code>PREFIX_NOT_EQUALS</code> filter. Combining filters in
    ///          this way always returns an error, even if the provided filter values would return valid
    ///          results.</p>
    ///          <p>You can combine <code>PREFIX</code> filters with <code>NOT_EQUALS</code> or
    ///             <code>PREFIX_NOT_EQUALS</code> filters for the same field. Security Hub first processes the
    ///             <code>PREFIX</code> filters, then the <code>NOT_EQUALS</code> or
    ///             <code>PREFIX_NOT_EQUALS</code> filters.</p>
    ///          <p> For example, for the following filter, Security Hub first identifies findings that have
    ///          resource types that start with either <code>AwsIAM</code> or <code>AwsEc2</code>. It then
    ///          excludes findings that have a resource type of <code>AwsIamPolicy</code> and findings that
    ///          have a resource type of <code>AwsEc2NetworkInterface</code>.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ResourceType PREFIX AwsIam</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ResourceType PREFIX AwsEc2</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ResourceType NOT_EQUALS AwsIamPolicy</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ResourceType NOT_EQUALS AwsEc2NetworkInterface</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let comparison: StringFilterComparison?
    /// <p>The string filter value. Filter values are case sensitive. For example, the product name
    ///          for control-based findings is <code>Security Hub</code>. If you provide <code>security hub</code>
    ///          as the filter text, then there is no match.</p>
    public let value: String?

    public init (
        comparison: StringFilterComparison? = nil,
        value: String? = nil
    )
    {
        self.comparison = comparison
        self.value = value
    }
}

public enum StringFilterComparison {
    case equals
    case notEquals
    case prefix
    case prefixNotEquals
    case sdkUnknown(String)
}

extension StringFilterComparison : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StringFilterComparison] {
        return [
            .equals,
            .notEquals,
            .prefix,
            .prefixNotEquals,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .equals: return "EQUALS"
        case .notEquals: return "NOT_EQUALS"
        case .prefix: return "PREFIX"
        case .prefixNotEquals: return "PREFIX_NOT_EQUALS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StringFilterComparison(rawValue: rawValue) ?? StringFilterComparison.sdkUnknown(rawValue)
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ARN of the resource to apply the tags to.</p>
    public let resourceArn: String?
    /// <p>The tags to add to the resource. You can add up to 50 tags at a time. The tag keys can be no longer than 128 characters. The tag values can be no longer than 256 characters.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThreatIntelIndicator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case category = "Category"
        case lastObservedAt = "LastObservedAt"
        case source = "Source"
        case sourceUrl = "SourceUrl"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let lastObservedAt = lastObservedAt {
            try encodeContainer.encode(lastObservedAt, forKey: .lastObservedAt)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceUrl = sourceUrl {
            try encodeContainer.encode(sourceUrl, forKey: .sourceUrl)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ThreatIntelIndicatorType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(ThreatIntelIndicatorCategory.self, forKey: .category)
        category = categoryDecoded
        let lastObservedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastObservedAt)
        lastObservedAt = lastObservedAtDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let sourceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceUrl)
        sourceUrl = sourceUrlDecoded
    }
}

extension ThreatIntelIndicator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThreatIntelIndicator(category: \(String(describing: category)), lastObservedAt: \(String(describing: lastObservedAt)), source: \(String(describing: source)), sourceUrl: \(String(describing: sourceUrl)), type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>Details about the threat intelligence related to a finding.</p>
public struct ThreatIntelIndicator: Equatable {
    /// <p>The category of a threat intelligence indicator.</p>
    public let category: ThreatIntelIndicatorCategory?
    /// <p>Indicates when the most recent instance of a threat intelligence indicator was
    ///          observed.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let lastObservedAt: String?
    /// <p>The source of the threat intelligence indicator.</p>
    public let source: String?
    /// <p>The URL to the page or site where you can get more information about the threat
    ///          intelligence indicator.</p>
    public let sourceUrl: String?
    /// <p>The type of threat intelligence indicator.</p>
    public let type: ThreatIntelIndicatorType?
    /// <p>The value of a threat intelligence indicator.</p>
    public let value: String?

    public init (
        category: ThreatIntelIndicatorCategory? = nil,
        lastObservedAt: String? = nil,
        source: String? = nil,
        sourceUrl: String? = nil,
        type: ThreatIntelIndicatorType? = nil,
        value: String? = nil
    )
    {
        self.category = category
        self.lastObservedAt = lastObservedAt
        self.source = source
        self.sourceUrl = sourceUrl
        self.type = type
        self.value = value
    }
}

public enum ThreatIntelIndicatorCategory {
    case backdoor
    case cardStealer
    case commandAndControl
    case dropSite
    case exploitSite
    case keylogger
    case sdkUnknown(String)
}

extension ThreatIntelIndicatorCategory : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ThreatIntelIndicatorCategory] {
        return [
            .backdoor,
            .cardStealer,
            .commandAndControl,
            .dropSite,
            .exploitSite,
            .keylogger,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .backdoor: return "BACKDOOR"
        case .cardStealer: return "CARD_STEALER"
        case .commandAndControl: return "COMMAND_AND_CONTROL"
        case .dropSite: return "DROP_SITE"
        case .exploitSite: return "EXPLOIT_SITE"
        case .keylogger: return "KEYLOGGER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ThreatIntelIndicatorCategory(rawValue: rawValue) ?? ThreatIntelIndicatorCategory.sdkUnknown(rawValue)
    }
}

public enum ThreatIntelIndicatorType {
    case domain
    case emailAddress
    case hashMd5
    case hashSha1
    case hashSha256
    case hashSha512
    case ipv4Address
    case ipv6Address
    case mutex
    case process
    case url
    case sdkUnknown(String)
}

extension ThreatIntelIndicatorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ThreatIntelIndicatorType] {
        return [
            .domain,
            .emailAddress,
            .hashMd5,
            .hashSha1,
            .hashSha256,
            .hashSha512,
            .ipv4Address,
            .ipv6Address,
            .mutex,
            .process,
            .url,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .domain: return "DOMAIN"
        case .emailAddress: return "EMAIL_ADDRESS"
        case .hashMd5: return "HASH_MD5"
        case .hashSha1: return "HASH_SHA1"
        case .hashSha256: return "HASH_SHA256"
        case .hashSha512: return "HASH_SHA512"
        case .ipv4Address: return "IPV4_ADDRESS"
        case .ipv6Address: return "IPV6_ADDRESS"
        case .mutex: return "MUTEX"
        case .process: return "PROCESS"
        case .url: return "URL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ThreatIntelIndicatorType(rawValue: rawValue) ?? ThreatIntelIndicatorType.sdkUnknown(rawValue)
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the resource to remove the tags from.</p>
    public let resourceArn: String?
    /// <p>The tag keys associated with the tags to remove from the resource. You can remove up to 50 tags at a time.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateActionTargetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateActionTargetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateActionTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateActionTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateActionTargetInput>
    public typealias MOutput = OperationOutput<UpdateActionTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateActionTargetOutputError>
}

extension UpdateActionTargetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateActionTargetInput(actionTargetArn: \(String(describing: actionTargetArn)), description: \(String(describing: description)), name: \(String(describing: name)))"}
}

extension UpdateActionTargetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateActionTargetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateActionTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateActionTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateActionTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateActionTargetInput>
    public typealias MOutput = OperationOutput<UpdateActionTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateActionTargetOutputError>
}

public struct UpdateActionTargetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateActionTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateActionTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateActionTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateActionTargetInput>
    public typealias MOutput = OperationOutput<UpdateActionTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateActionTargetOutputError>
}

public struct UpdateActionTargetInput: Equatable {
    /// <p>The ARN of the custom action target to update.</p>
    public let actionTargetArn: String?
    /// <p>The updated description for the custom action target.</p>
    public let description: String?
    /// <p>The updated name of the custom action target.</p>
    public let name: String?

    public init (
        actionTargetArn: String? = nil,
        description: String? = nil,
        name: String? = nil
    )
    {
        self.actionTargetArn = actionTargetArn
        self.description = description
        self.name = name
    }
}

struct UpdateActionTargetInputBody: Equatable {
    public let name: String?
    public let description: String?
}

extension UpdateActionTargetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateActionTargetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateActionTargetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateActionTargetOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateActionTargetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateActionTargetOutputResponse()"}
}

extension UpdateActionTargetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateActionTargetOutputResponse: Equatable {

    public init() {}
}

struct UpdateActionTargetOutputResponseBody: Equatable {
}

extension UpdateActionTargetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateFindingsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFindingsInput>
    public typealias MOutput = OperationOutput<UpdateFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFindingsOutputError>
}

extension UpdateFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFindingsInput(filters: \(String(describing: filters)), note: \(String(describing: note)), recordState: \(String(describing: recordState)))"}
}

extension UpdateFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case note = "Note"
        case recordState = "RecordState"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let recordState = recordState {
            try encodeContainer.encode(recordState.rawValue, forKey: .recordState)
        }
    }
}

public struct UpdateFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFindingsInput>
    public typealias MOutput = OperationOutput<UpdateFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFindingsOutputError>
}

public struct UpdateFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFindingsInput>
    public typealias MOutput = OperationOutput<UpdateFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFindingsOutputError>
}

public struct UpdateFindingsInput: Equatable {
    /// <p>A collection of attributes that specify which findings you want to update.</p>
    public let filters: AwsSecurityFindingFilters?
    /// <p>The updated note for the finding.</p>
    public let note: NoteUpdate?
    /// <p>The updated record state for the finding.</p>
    public let recordState: RecordState?

    public init (
        filters: AwsSecurityFindingFilters? = nil,
        note: NoteUpdate? = nil,
        recordState: RecordState? = nil
    )
    {
        self.filters = filters
        self.note = note
        self.recordState = recordState
    }
}

struct UpdateFindingsInputBody: Equatable {
    public let filters: AwsSecurityFindingFilters?
    public let note: NoteUpdate?
    public let recordState: RecordState?
}

extension UpdateFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case note = "Note"
        case recordState = "RecordState"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(AwsSecurityFindingFilters.self, forKey: .filters)
        filters = filtersDecoded
        let noteDecoded = try containerValues.decodeIfPresent(NoteUpdate.self, forKey: .note)
        note = noteDecoded
        let recordStateDecoded = try containerValues.decodeIfPresent(RecordState.self, forKey: .recordState)
        recordState = recordStateDecoded
    }
}

extension UpdateFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFindingsOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFindingsOutputResponse()"}
}

extension UpdateFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFindingsOutputResponse: Equatable {

    public init() {}
}

struct UpdateFindingsOutputResponseBody: Equatable {
}

extension UpdateFindingsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateInsightInputBodyMiddleware: Middleware {
    public let id: String = "UpdateInsightInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInsightInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInsightOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInsightInput>
    public typealias MOutput = OperationOutput<UpdateInsightOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInsightOutputError>
}

extension UpdateInsightInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInsightInput(filters: \(String(describing: filters)), groupByAttribute: \(String(describing: groupByAttribute)), insightArn: \(String(describing: insightArn)), name: \(String(describing: name)))"}
}

extension UpdateInsightInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case groupByAttribute = "GroupByAttribute"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let groupByAttribute = groupByAttribute {
            try encodeContainer.encode(groupByAttribute, forKey: .groupByAttribute)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateInsightInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateInsightInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInsightInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInsightOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInsightInput>
    public typealias MOutput = OperationOutput<UpdateInsightOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInsightOutputError>
}

public struct UpdateInsightInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateInsightInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInsightInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInsightOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInsightInput>
    public typealias MOutput = OperationOutput<UpdateInsightOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInsightOutputError>
}

public struct UpdateInsightInput: Equatable {
    /// <p>The updated filters that define this insight.</p>
    public let filters: AwsSecurityFindingFilters?
    /// <p>The updated <code>GroupBy</code> attribute that defines this insight.</p>
    public let groupByAttribute: String?
    /// <p>The ARN of the insight that you want to update.</p>
    public let insightArn: String?
    /// <p>The updated name for the insight.</p>
    public let name: String?

    public init (
        filters: AwsSecurityFindingFilters? = nil,
        groupByAttribute: String? = nil,
        insightArn: String? = nil,
        name: String? = nil
    )
    {
        self.filters = filters
        self.groupByAttribute = groupByAttribute
        self.insightArn = insightArn
        self.name = name
    }
}

struct UpdateInsightInputBody: Equatable {
    public let name: String?
    public let filters: AwsSecurityFindingFilters?
    public let groupByAttribute: String?
}

extension UpdateInsightInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case groupByAttribute = "GroupByAttribute"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(AwsSecurityFindingFilters.self, forKey: .filters)
        filters = filtersDecoded
        let groupByAttributeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupByAttribute)
        groupByAttribute = groupByAttributeDecoded
    }
}

extension UpdateInsightOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInsightOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateInsightOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInsightOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInsightOutputResponse()"}
}

extension UpdateInsightOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateInsightOutputResponse: Equatable {

    public init() {}
}

struct UpdateInsightOutputResponseBody: Equatable {
}

extension UpdateInsightOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateOrganizationConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateOrganizationConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOrganizationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOrganizationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOrganizationConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateOrganizationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOrganizationConfigurationOutputError>
}

extension UpdateOrganizationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateOrganizationConfigurationInput(autoEnable: \(String(describing: autoEnable)))"}
}

extension UpdateOrganizationConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoEnable = "AutoEnable"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }
}

public struct UpdateOrganizationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateOrganizationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOrganizationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOrganizationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOrganizationConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateOrganizationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOrganizationConfigurationOutputError>
}

public struct UpdateOrganizationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateOrganizationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOrganizationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOrganizationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOrganizationConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateOrganizationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOrganizationConfigurationOutputError>
}

public struct UpdateOrganizationConfigurationInput: Equatable {
    /// <p>Whether to automatically enable Security Hub for new accounts in the organization.</p>
    ///          <p>By default, this is <code>false</code>, and new accounts are not added
    ///          automatically.</p>
    ///          <p>To automatically enable Security Hub for new accounts, set this to <code>true</code>.</p>
    public let autoEnable: Bool

    public init (
        autoEnable: Bool = false
    )
    {
        self.autoEnable = autoEnable
    }
}

struct UpdateOrganizationConfigurationInputBody: Equatable {
    public let autoEnable: Bool
}

extension UpdateOrganizationConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoEnable = "AutoEnable"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decode(Bool.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
    }
}

extension UpdateOrganizationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateOrganizationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateOrganizationConfigurationOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOrganizationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateOrganizationConfigurationOutputResponse()"}
}

extension UpdateOrganizationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateOrganizationConfigurationOutputResponse: Equatable {

    public init() {}
}

struct UpdateOrganizationConfigurationOutputResponseBody: Equatable {
}

extension UpdateOrganizationConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateSecurityHubConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSecurityHubConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSecurityHubConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSecurityHubConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSecurityHubConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateSecurityHubConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSecurityHubConfigurationOutputError>
}

extension UpdateSecurityHubConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSecurityHubConfigurationInput(autoEnableControls: \(String(describing: autoEnableControls)))"}
}

extension UpdateSecurityHubConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoEnableControls = "AutoEnableControls"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnableControls != false {
            try encodeContainer.encode(autoEnableControls, forKey: .autoEnableControls)
        }
    }
}

public struct UpdateSecurityHubConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSecurityHubConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSecurityHubConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSecurityHubConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSecurityHubConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateSecurityHubConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSecurityHubConfigurationOutputError>
}

public struct UpdateSecurityHubConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSecurityHubConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSecurityHubConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSecurityHubConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSecurityHubConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateSecurityHubConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSecurityHubConfigurationOutputError>
}

public struct UpdateSecurityHubConfigurationInput: Equatable {
    /// <p>Whether to automatically enable new controls when they are added to standards that are
    ///          enabled.</p>
    ///          <p>By default, this is set to <code>true</code>, and new controls are enabled
    ///          automatically. To not automatically enable new controls, set this to <code>false</code>.
    ///       </p>
    public let autoEnableControls: Bool

    public init (
        autoEnableControls: Bool = false
    )
    {
        self.autoEnableControls = autoEnableControls
    }
}

struct UpdateSecurityHubConfigurationInputBody: Equatable {
    public let autoEnableControls: Bool
}

extension UpdateSecurityHubConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoEnableControls = "AutoEnableControls"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableControlsDecoded = try containerValues.decode(Bool.self, forKey: .autoEnableControls)
        autoEnableControls = autoEnableControlsDecoded
    }
}

extension UpdateSecurityHubConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSecurityHubConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSecurityHubConfigurationOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSecurityHubConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSecurityHubConfigurationOutputResponse()"}
}

extension UpdateSecurityHubConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateSecurityHubConfigurationOutputResponse: Equatable {

    public init() {}
}

struct UpdateSecurityHubConfigurationOutputResponseBody: Equatable {
}

extension UpdateSecurityHubConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateStandardsControlInputBodyMiddleware: Middleware {
    public let id: String = "UpdateStandardsControlInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStandardsControlInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStandardsControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStandardsControlInput>
    public typealias MOutput = OperationOutput<UpdateStandardsControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStandardsControlOutputError>
}

extension UpdateStandardsControlInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStandardsControlInput(controlStatus: \(String(describing: controlStatus)), disabledReason: \(String(describing: disabledReason)), standardsControlArn: \(String(describing: standardsControlArn)))"}
}

extension UpdateStandardsControlInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case controlStatus = "ControlStatus"
        case disabledReason = "DisabledReason"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlStatus = controlStatus {
            try encodeContainer.encode(controlStatus.rawValue, forKey: .controlStatus)
        }
        if let disabledReason = disabledReason {
            try encodeContainer.encode(disabledReason, forKey: .disabledReason)
        }
    }
}

public struct UpdateStandardsControlInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateStandardsControlInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStandardsControlInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStandardsControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStandardsControlInput>
    public typealias MOutput = OperationOutput<UpdateStandardsControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStandardsControlOutputError>
}

public struct UpdateStandardsControlInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateStandardsControlInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStandardsControlInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStandardsControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStandardsControlInput>
    public typealias MOutput = OperationOutput<UpdateStandardsControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStandardsControlOutputError>
}

public struct UpdateStandardsControlInput: Equatable {
    /// <p>The updated status of the security standard control.</p>
    public let controlStatus: ControlStatus?
    /// <p>A description of the reason why you are disabling a security standard control. If you
    ///          are disabling a control, then this is required.</p>
    public let disabledReason: String?
    /// <p>The ARN of the security standard control to enable or disable.</p>
    public let standardsControlArn: String?

    public init (
        controlStatus: ControlStatus? = nil,
        disabledReason: String? = nil,
        standardsControlArn: String? = nil
    )
    {
        self.controlStatus = controlStatus
        self.disabledReason = disabledReason
        self.standardsControlArn = standardsControlArn
    }
}

struct UpdateStandardsControlInputBody: Equatable {
    public let controlStatus: ControlStatus?
    public let disabledReason: String?
}

extension UpdateStandardsControlInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case controlStatus = "ControlStatus"
        case disabledReason = "DisabledReason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlStatusDecoded = try containerValues.decodeIfPresent(ControlStatus.self, forKey: .controlStatus)
        controlStatus = controlStatusDecoded
        let disabledReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .disabledReason)
        disabledReason = disabledReasonDecoded
    }
}

extension UpdateStandardsControlOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStandardsControlOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStandardsControlOutputError: Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStandardsControlOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStandardsControlOutputResponse()"}
}

extension UpdateStandardsControlOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateStandardsControlOutputResponse: Equatable {

    public init() {}
}

struct UpdateStandardsControlOutputResponseBody: Equatable {
}

extension UpdateStandardsControlOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum VerificationState {
    case benignPositive
    case falsePositive
    case truePositive
    case unknown
    case sdkUnknown(String)
}

extension VerificationState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VerificationState] {
        return [
            .benignPositive,
            .falsePositive,
            .truePositive,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .benignPositive: return "BENIGN_POSITIVE"
        case .falsePositive: return "FALSE_POSITIVE"
        case .truePositive: return "TRUE_POSITIVE"
        case .unknown: return "UNKNOWN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VerificationState(rawValue: rawValue) ?? VerificationState.sdkUnknown(rawValue)
    }
}

extension Vulnerability: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cvss = "Cvss"
        case id = "Id"
        case referenceUrls = "ReferenceUrls"
        case relatedVulnerabilities = "RelatedVulnerabilities"
        case vendor = "Vendor"
        case vulnerablePackages = "VulnerablePackages"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cvss = cvss {
            var cvssContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cvss)
            for cvsslist0 in cvss {
                try cvssContainer.encode(cvsslist0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let referenceUrls = referenceUrls {
            var referenceUrlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceUrls)
            for stringlist0 in referenceUrls {
                try referenceUrlsContainer.encode(stringlist0)
            }
        }
        if let relatedVulnerabilities = relatedVulnerabilities {
            var relatedVulnerabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedVulnerabilities)
            for stringlist0 in relatedVulnerabilities {
                try relatedVulnerabilitiesContainer.encode(stringlist0)
            }
        }
        if let vendor = vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
        if let vulnerablePackages = vulnerablePackages {
            var vulnerablePackagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vulnerablePackages)
            for softwarepackagelist0 in vulnerablePackages {
                try vulnerablePackagesContainer.encode(softwarepackagelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let vulnerablePackagesContainer = try containerValues.decodeIfPresent([SoftwarePackage?].self, forKey: .vulnerablePackages)
        var vulnerablePackagesDecoded0:[SoftwarePackage]? = nil
        if let vulnerablePackagesContainer = vulnerablePackagesContainer {
            vulnerablePackagesDecoded0 = [SoftwarePackage]()
            for structure0 in vulnerablePackagesContainer {
                if let structure0 = structure0 {
                    vulnerablePackagesDecoded0?.append(structure0)
                }
            }
        }
        vulnerablePackages = vulnerablePackagesDecoded0
        let cvssContainer = try containerValues.decodeIfPresent([Cvss?].self, forKey: .cvss)
        var cvssDecoded0:[Cvss]? = nil
        if let cvssContainer = cvssContainer {
            cvssDecoded0 = [Cvss]()
            for structure0 in cvssContainer {
                if let structure0 = structure0 {
                    cvssDecoded0?.append(structure0)
                }
            }
        }
        cvss = cvssDecoded0
        let relatedVulnerabilitiesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .relatedVulnerabilities)
        var relatedVulnerabilitiesDecoded0:[String]? = nil
        if let relatedVulnerabilitiesContainer = relatedVulnerabilitiesContainer {
            relatedVulnerabilitiesDecoded0 = [String]()
            for string0 in relatedVulnerabilitiesContainer {
                if let string0 = string0 {
                    relatedVulnerabilitiesDecoded0?.append(string0)
                }
            }
        }
        relatedVulnerabilities = relatedVulnerabilitiesDecoded0
        let vendorDecoded = try containerValues.decodeIfPresent(VulnerabilityVendor.self, forKey: .vendor)
        vendor = vendorDecoded
        let referenceUrlsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .referenceUrls)
        var referenceUrlsDecoded0:[String]? = nil
        if let referenceUrlsContainer = referenceUrlsContainer {
            referenceUrlsDecoded0 = [String]()
            for string0 in referenceUrlsContainer {
                if let string0 = string0 {
                    referenceUrlsDecoded0?.append(string0)
                }
            }
        }
        referenceUrls = referenceUrlsDecoded0
    }
}

extension Vulnerability: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Vulnerability(cvss: \(String(describing: cvss)), id: \(String(describing: id)), referenceUrls: \(String(describing: referenceUrls)), relatedVulnerabilities: \(String(describing: relatedVulnerabilities)), vendor: \(String(describing: vendor)), vulnerablePackages: \(String(describing: vulnerablePackages)))"}
}

/// <p>A vulnerability associated with a finding.</p>
public struct Vulnerability: Equatable {
    /// <p>CVSS scores from the advisory related to the vulnerability.</p>
    public let cvss: [Cvss]?
    /// <p>The identifier of the vulnerability.</p>
    public let id: String?
    /// <p>A list of URLs that provide additional information about the vulnerability.</p>
    public let referenceUrls: [String]?
    /// <p>List of vulnerabilities that are related to this vulnerability.</p>
    public let relatedVulnerabilities: [String]?
    /// <p>Information about the vendor that generates the vulnerability report.</p>
    public let vendor: VulnerabilityVendor?
    /// <p>List of software packages that have the vulnerability.</p>
    public let vulnerablePackages: [SoftwarePackage]?

    public init (
        cvss: [Cvss]? = nil,
        id: String? = nil,
        referenceUrls: [String]? = nil,
        relatedVulnerabilities: [String]? = nil,
        vendor: VulnerabilityVendor? = nil,
        vulnerablePackages: [SoftwarePackage]? = nil
    )
    {
        self.cvss = cvss
        self.id = id
        self.referenceUrls = referenceUrls
        self.relatedVulnerabilities = relatedVulnerabilities
        self.vendor = vendor
        self.vulnerablePackages = vulnerablePackages
    }
}

extension VulnerabilityVendor: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case url = "Url"
        case vendorCreatedAt = "VendorCreatedAt"
        case vendorSeverity = "VendorSeverity"
        case vendorUpdatedAt = "VendorUpdatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let vendorCreatedAt = vendorCreatedAt {
            try encodeContainer.encode(vendorCreatedAt, forKey: .vendorCreatedAt)
        }
        if let vendorSeverity = vendorSeverity {
            try encodeContainer.encode(vendorSeverity, forKey: .vendorSeverity)
        }
        if let vendorUpdatedAt = vendorUpdatedAt {
            try encodeContainer.encode(vendorUpdatedAt, forKey: .vendorUpdatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
        let vendorSeverityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vendorSeverity)
        vendorSeverity = vendorSeverityDecoded
        let vendorCreatedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vendorCreatedAt)
        vendorCreatedAt = vendorCreatedAtDecoded
        let vendorUpdatedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vendorUpdatedAt)
        vendorUpdatedAt = vendorUpdatedAtDecoded
    }
}

extension VulnerabilityVendor: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VulnerabilityVendor(name: \(String(describing: name)), url: \(String(describing: url)), vendorCreatedAt: \(String(describing: vendorCreatedAt)), vendorSeverity: \(String(describing: vendorSeverity)), vendorUpdatedAt: \(String(describing: vendorUpdatedAt)))"}
}

/// <p>A vendor that generates a vulnerability report.</p>
public struct VulnerabilityVendor: Equatable {
    /// <p>The name of the vendor.</p>
    public let name: String?
    /// <p>The URL of the vulnerability advisory.</p>
    public let url: String?
    /// <p>Indicates when the vulnerability advisory was created.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let vendorCreatedAt: String?
    /// <p>The severity that the vendor assigned to the vulnerability.</p>
    public let vendorSeverity: String?
    /// <p>Indicates when the vulnerability advisory was last updated.</p>
    ///          <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet
    ///             Date/Time Format</a>. The value cannot contain spaces. For example,
    ///             <code>2020-03-22T13:22:13.933Z</code>.</p>
    public let vendorUpdatedAt: String?

    public init (
        name: String? = nil,
        url: String? = nil,
        vendorCreatedAt: String? = nil,
        vendorSeverity: String? = nil,
        vendorUpdatedAt: String? = nil
    )
    {
        self.name = name
        self.url = url
        self.vendorCreatedAt = vendorCreatedAt
        self.vendorSeverity = vendorSeverity
        self.vendorUpdatedAt = vendorUpdatedAt
    }
}

extension WafAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension WafAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WafAction(type: \(String(describing: type)))"}
}

/// <p>Details about the action that CloudFront or AWS WAF takes when a web request matches the
///          conditions in the rule. </p>
public struct WafAction: Equatable {
    /// <p>Specifies how you want AWS WAF to respond to requests that match the settings in a
    ///          rule.</p>
    ///          <p>Valid settings include the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ALLOW</code> - AWS WAF allows requests</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>BLOCK</code> - AWS WAF blocks requests</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>COUNT</code> - AWS WAF increments a counter of the requests that match all
    ///                of the conditions in the rule. AWS WAF then continues to inspect the web request
    ///                based on the remaining rules in the web ACL. You can't specify <code>COUNT</code> for
    ///                the default action for a WebACL.</p>
    ///             </li>
    ///          </ul>
    public let type: String?

    public init (
        type: String? = nil
    )
    {
        self.type = type
    }
}

extension WafExcludedRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ruleId = "RuleId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
    }
}

extension WafExcludedRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WafExcludedRule(ruleId: \(String(describing: ruleId)))"}
}

/// <p>Details about a rule to exclude from a rule group.</p>
public struct WafExcludedRule: Equatable {
    /// <p>The unique identifier for the rule to exclude from the rule group.</p>
    public let ruleId: String?

    public init (
        ruleId: String? = nil
    )
    {
        self.ruleId = ruleId
    }
}

extension WafOverrideAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension WafOverrideAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WafOverrideAction(type: \(String(describing: type)))"}
}

/// <p>Details about an override action for a rule.</p>
public struct WafOverrideAction: Equatable {
    /// <p>
    ///             <code>COUNT</code> overrides the action specified by the individual rule within a
    ///             <code>RuleGroup</code> .</p>
    ///          <p>If set to <code>NONE</code>, the rule's action takes place.</p>
    public let type: String?

    public init (
        type: String? = nil
    )
    {
        self.type = type
    }
}

extension Workflow: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(WorkflowStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension Workflow: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Workflow(status: \(String(describing: status)))"}
}

/// <p>Provides information about the status of the investigation into a finding.</p>
public struct Workflow: Equatable {
    /// <p>The status of the investigation into the finding. The allowed values are the
    ///          following.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>NEW</code> - The initial state of a finding, before it is reviewed.</p>
    ///                <p>Security Hub also resets the workflow status from <code>NOTIFIED</code> or
    ///                   <code>RESOLVED</code> to <code>NEW</code> in the following cases:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>RecordState</code> changes from <code>ARCHIVED</code> to
    ///                         <code>ACTIVE</code>.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>ComplianceStatus</code> changes from <code>PASSED</code> to either
    ///                         <code>WARNING</code>, <code>FAILED</code>, or
    ///                      <code>NOT_AVAILABLE</code>.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOTIFIED</code> - Indicates that you notified the resource owner about the
    ///                security issue. Used when the initial reviewer is not the resource owner, and needs
    ///                intervention from the resource owner.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SUPPRESSED</code> - The finding will not be reviewed again and will not be
    ///                acted upon.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RESOLVED</code> - The finding was reviewed and remediated and is now
    ///                considered resolved. </p>
    ///             </li>
    ///          </ul>
    public let status: WorkflowStatus?

    public init (
        status: WorkflowStatus? = nil
    )
    {
        self.status = status
    }
}

@available(*, deprecated, message: "This field is deprecated, use Workflow.Status instead.")
public enum WorkflowState {
    case assigned
    case deferred
    case inProgress
    case new
    case resolved
    case sdkUnknown(String)
}

extension WorkflowState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WorkflowState] {
        return [
            .assigned,
            .deferred,
            .inProgress,
            .new,
            .resolved,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .assigned: return "ASSIGNED"
        case .deferred: return "DEFERRED"
        case .inProgress: return "IN_PROGRESS"
        case .new: return "NEW"
        case .resolved: return "RESOLVED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WorkflowState(rawValue: rawValue) ?? WorkflowState.sdkUnknown(rawValue)
    }
}

public enum WorkflowStatus {
    case new
    case notified
    case resolved
    case suppressed
    case sdkUnknown(String)
}

extension WorkflowStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WorkflowStatus] {
        return [
            .new,
            .notified,
            .resolved,
            .suppressed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .new: return "NEW"
        case .notified: return "NOTIFIED"
        case .resolved: return "RESOLVED"
        case .suppressed: return "SUPPRESSED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WorkflowStatus(rawValue: rawValue) ?? WorkflowStatus.sdkUnknown(rawValue)
    }
}

extension WorkflowUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(WorkflowStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension WorkflowUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkflowUpdate(status: \(String(describing: status)))"}
}

/// <p>Used to update information about the investigation into the finding.</p>
public struct WorkflowUpdate: Equatable {
    /// <p>The status of the investigation into the finding. The allowed values are the
    ///          following.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>NEW</code> - The initial state of a finding, before it is reviewed.</p>
    ///                <p>Security Hub also resets <code>WorkFlowStatus</code> from <code>NOTIFIED</code> or
    ///                   <code>RESOLVED</code> to <code>NEW</code> in the following cases:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>The record state changes from <code>ARCHIVED</code> to
    ///                      <code>ACTIVE</code>.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>The compliance status changes from <code>PASSED</code> to either
    ///                         <code>WARNING</code>, <code>FAILED</code>, or
    ///                      <code>NOT_AVAILABLE</code>.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOTIFIED</code> - Indicates that you notified the resource owner about the
    ///                security issue. Used when the initial reviewer is not the resource owner, and needs
    ///                intervention from the resource owner.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RESOLVED</code> - The finding was reviewed and remediated and is now
    ///                considered resolved.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SUPPRESSED</code> - The finding will not be reviewed again and will not be
    ///                acted upon.</p>
    ///             </li>
    ///          </ul>
    public let status: WorkflowStatus?

    public init (
        status: WorkflowStatus? = nil
    )
    {
        self.status = status
    }
}
