// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension AwsCertificateManagerCertificateDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case createdAt = "CreatedAt"
        case domainName = "DomainName"
        case domainValidationOptions = "DomainValidationOptions"
        case extendedKeyUsages = "ExtendedKeyUsages"
        case failureReason = "FailureReason"
        case importedAt = "ImportedAt"
        case inUseBy = "InUseBy"
        case issuedAt = "IssuedAt"
        case issuer = "Issuer"
        case keyAlgorithm = "KeyAlgorithm"
        case keyUsages = "KeyUsages"
        case notAfter = "NotAfter"
        case notBefore = "NotBefore"
        case options = "Options"
        case renewalEligibility = "RenewalEligibility"
        case renewalSummary = "RenewalSummary"
        case serial = "Serial"
        case signatureAlgorithm = "SignatureAlgorithm"
        case status = "Status"
        case subject = "Subject"
        case subjectAlternativeNames = "SubjectAlternativeNames"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainValidationOptions = domainValidationOptions {
            var domainValidationOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainValidationOptions)
            for awscertificatemanagercertificatedomainvalidationoptions0 in domainValidationOptions {
                try domainValidationOptionsContainer.encode(awscertificatemanagercertificatedomainvalidationoptions0)
            }
        }
        if let extendedKeyUsages = extendedKeyUsages {
            var extendedKeyUsagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .extendedKeyUsages)
            for awscertificatemanagercertificateextendedkeyusages0 in extendedKeyUsages {
                try extendedKeyUsagesContainer.encode(awscertificatemanagercertificateextendedkeyusages0)
            }
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let importedAt = importedAt {
            try encodeContainer.encode(importedAt, forKey: .importedAt)
        }
        if let inUseBy = inUseBy {
            var inUseByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inUseBy)
            for stringlist0 in inUseBy {
                try inUseByContainer.encode(stringlist0)
            }
        }
        if let issuedAt = issuedAt {
            try encodeContainer.encode(issuedAt, forKey: .issuedAt)
        }
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let keyAlgorithm = keyAlgorithm {
            try encodeContainer.encode(keyAlgorithm, forKey: .keyAlgorithm)
        }
        if let keyUsages = keyUsages {
            var keyUsagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keyUsages)
            for awscertificatemanagercertificatekeyusages0 in keyUsages {
                try keyUsagesContainer.encode(awscertificatemanagercertificatekeyusages0)
            }
        }
        if let notAfter = notAfter {
            try encodeContainer.encode(notAfter, forKey: .notAfter)
        }
        if let notBefore = notBefore {
            try encodeContainer.encode(notBefore, forKey: .notBefore)
        }
        if let options = options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let renewalEligibility = renewalEligibility {
            try encodeContainer.encode(renewalEligibility, forKey: .renewalEligibility)
        }
        if let renewalSummary = renewalSummary {
            try encodeContainer.encode(renewalSummary, forKey: .renewalSummary)
        }
        if let serial = serial {
            try encodeContainer.encode(serial, forKey: .serial)
        }
        if let signatureAlgorithm = signatureAlgorithm {
            try encodeContainer.encode(signatureAlgorithm, forKey: .signatureAlgorithm)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let subjectAlternativeNames = subjectAlternativeNames {
            var subjectAlternativeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subjectAlternativeNames)
            for stringlist0 in subjectAlternativeNames {
                try subjectAlternativeNamesContainer.encode(stringlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainValidationOptionsContainer = try containerValues.decodeIfPresent([AwsCertificateManagerCertificateDomainValidationOption].self, forKey: .domainValidationOptions)
        var domainValidationOptionsDecoded0:[AwsCertificateManagerCertificateDomainValidationOption]? = nil
        if let domainValidationOptionsContainer = domainValidationOptionsContainer {
            domainValidationOptionsDecoded0 = [AwsCertificateManagerCertificateDomainValidationOption]()
            for structure0 in domainValidationOptionsContainer {
                domainValidationOptionsDecoded0?.append(structure0)
            }
        }
        domainValidationOptions = domainValidationOptionsDecoded0
        let extendedKeyUsagesContainer = try containerValues.decodeIfPresent([AwsCertificateManagerCertificateExtendedKeyUsage].self, forKey: .extendedKeyUsages)
        var extendedKeyUsagesDecoded0:[AwsCertificateManagerCertificateExtendedKeyUsage]? = nil
        if let extendedKeyUsagesContainer = extendedKeyUsagesContainer {
            extendedKeyUsagesDecoded0 = [AwsCertificateManagerCertificateExtendedKeyUsage]()
            for structure0 in extendedKeyUsagesContainer {
                extendedKeyUsagesDecoded0?.append(structure0)
            }
        }
        extendedKeyUsages = extendedKeyUsagesDecoded0
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let importedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importedAt)
        importedAt = importedAtDecoded
        let inUseByContainer = try containerValues.decodeIfPresent([String].self, forKey: .inUseBy)
        var inUseByDecoded0:[String]? = nil
        if let inUseByContainer = inUseByContainer {
            inUseByDecoded0 = [String]()
            for string0 in inUseByContainer {
                inUseByDecoded0?.append(string0)
            }
        }
        inUseBy = inUseByDecoded0
        let issuedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .issuedAt)
        issuedAt = issuedAtDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .issuer)
        issuer = issuerDecoded
        let keyAlgorithmDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyAlgorithm)
        keyAlgorithm = keyAlgorithmDecoded
        let keyUsagesContainer = try containerValues.decodeIfPresent([AwsCertificateManagerCertificateKeyUsage].self, forKey: .keyUsages)
        var keyUsagesDecoded0:[AwsCertificateManagerCertificateKeyUsage]? = nil
        if let keyUsagesContainer = keyUsagesContainer {
            keyUsagesDecoded0 = [AwsCertificateManagerCertificateKeyUsage]()
            for structure0 in keyUsagesContainer {
                keyUsagesDecoded0?.append(structure0)
            }
        }
        keyUsages = keyUsagesDecoded0
        let notAfterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notAfter)
        notAfter = notAfterDecoded
        let notBeforeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notBefore)
        notBefore = notBeforeDecoded
        let optionsDecoded = try containerValues.decodeIfPresent(AwsCertificateManagerCertificateOptions.self, forKey: .options)
        options = optionsDecoded
        let renewalEligibilityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .renewalEligibility)
        renewalEligibility = renewalEligibilityDecoded
        let renewalSummaryDecoded = try containerValues.decodeIfPresent(AwsCertificateManagerCertificateRenewalSummary.self, forKey: .renewalSummary)
        renewalSummary = renewalSummaryDecoded
        let serialDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serial)
        serial = serialDecoded
        let signatureAlgorithmDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signatureAlgorithm)
        signatureAlgorithm = signatureAlgorithmDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let subjectAlternativeNamesContainer = try containerValues.decodeIfPresent([String].self, forKey: .subjectAlternativeNames)
        var subjectAlternativeNamesDecoded0:[String]? = nil
        if let subjectAlternativeNamesContainer = subjectAlternativeNamesContainer {
            subjectAlternativeNamesDecoded0 = [String]()
            for string0 in subjectAlternativeNamesContainer {
                subjectAlternativeNamesDecoded0?.append(string0)
            }
        }
        subjectAlternativeNames = subjectAlternativeNamesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}
