// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension AwsApiGatewayMethodSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cacheDataEncrypted = "CacheDataEncrypted"
        case cacheTtlInSeconds = "CacheTtlInSeconds"
        case cachingEnabled = "CachingEnabled"
        case dataTraceEnabled = "DataTraceEnabled"
        case httpMethod = "HttpMethod"
        case loggingLevel = "LoggingLevel"
        case metricsEnabled = "MetricsEnabled"
        case requireAuthorizationForCacheControl = "RequireAuthorizationForCacheControl"
        case resourcePath = "ResourcePath"
        case throttlingBurstLimit = "ThrottlingBurstLimit"
        case throttlingRateLimit = "ThrottlingRateLimit"
        case unauthorizedCacheControlHeaderStrategy = "UnauthorizedCacheControlHeaderStrategy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cacheDataEncrypted != false {
            try encodeContainer.encode(cacheDataEncrypted, forKey: .cacheDataEncrypted)
        }
        if cacheTtlInSeconds != 0 {
            try encodeContainer.encode(cacheTtlInSeconds, forKey: .cacheTtlInSeconds)
        }
        if cachingEnabled != false {
            try encodeContainer.encode(cachingEnabled, forKey: .cachingEnabled)
        }
        if dataTraceEnabled != false {
            try encodeContainer.encode(dataTraceEnabled, forKey: .dataTraceEnabled)
        }
        if let httpMethod = httpMethod {
            try encodeContainer.encode(httpMethod, forKey: .httpMethod)
        }
        if let loggingLevel = loggingLevel {
            try encodeContainer.encode(loggingLevel, forKey: .loggingLevel)
        }
        if metricsEnabled != false {
            try encodeContainer.encode(metricsEnabled, forKey: .metricsEnabled)
        }
        if requireAuthorizationForCacheControl != false {
            try encodeContainer.encode(requireAuthorizationForCacheControl, forKey: .requireAuthorizationForCacheControl)
        }
        if let resourcePath = resourcePath {
            try encodeContainer.encode(resourcePath, forKey: .resourcePath)
        }
        if throttlingBurstLimit != 0 {
            try encodeContainer.encode(throttlingBurstLimit, forKey: .throttlingBurstLimit)
        }
        if throttlingRateLimit != 0.0 {
            try encodeContainer.encode(throttlingRateLimit, forKey: .throttlingRateLimit)
        }
        if let unauthorizedCacheControlHeaderStrategy = unauthorizedCacheControlHeaderStrategy {
            try encodeContainer.encode(unauthorizedCacheControlHeaderStrategy, forKey: .unauthorizedCacheControlHeaderStrategy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricsEnabledDecoded = try containerValues.decode(Bool.self, forKey: .metricsEnabled)
        metricsEnabled = metricsEnabledDecoded
        let loggingLevelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loggingLevel)
        loggingLevel = loggingLevelDecoded
        let dataTraceEnabledDecoded = try containerValues.decode(Bool.self, forKey: .dataTraceEnabled)
        dataTraceEnabled = dataTraceEnabledDecoded
        let throttlingBurstLimitDecoded = try containerValues.decode(Int.self, forKey: .throttlingBurstLimit)
        throttlingBurstLimit = throttlingBurstLimitDecoded
        let throttlingRateLimitDecoded = try containerValues.decode(Double.self, forKey: .throttlingRateLimit)
        throttlingRateLimit = throttlingRateLimitDecoded
        let cachingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .cachingEnabled)
        cachingEnabled = cachingEnabledDecoded
        let cacheTtlInSecondsDecoded = try containerValues.decode(Int.self, forKey: .cacheTtlInSeconds)
        cacheTtlInSeconds = cacheTtlInSecondsDecoded
        let cacheDataEncryptedDecoded = try containerValues.decode(Bool.self, forKey: .cacheDataEncrypted)
        cacheDataEncrypted = cacheDataEncryptedDecoded
        let requireAuthorizationForCacheControlDecoded = try containerValues.decode(Bool.self, forKey: .requireAuthorizationForCacheControl)
        requireAuthorizationForCacheControl = requireAuthorizationForCacheControlDecoded
        let unauthorizedCacheControlHeaderStrategyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unauthorizedCacheControlHeaderStrategy)
        unauthorizedCacheControlHeaderStrategy = unauthorizedCacheControlHeaderStrategyDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let resourcePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourcePath)
        resourcePath = resourcePathDecoded
    }
}
