// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension AwsSecurityFinding: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case awsAccountId = "AwsAccountId"
        case compliance = "Compliance"
        case confidence = "Confidence"
        case createdAt = "CreatedAt"
        case criticality = "Criticality"
        case description = "Description"
        case findingProviderFields = "FindingProviderFields"
        case firstObservedAt = "FirstObservedAt"
        case generatorId = "GeneratorId"
        case id = "Id"
        case lastObservedAt = "LastObservedAt"
        case malware = "Malware"
        case network = "Network"
        case networkPath = "NetworkPath"
        case note = "Note"
        case patchSummary = "PatchSummary"
        case process = "Process"
        case productArn = "ProductArn"
        case productFields = "ProductFields"
        case recordState = "RecordState"
        case relatedFindings = "RelatedFindings"
        case remediation = "Remediation"
        case resources = "Resources"
        case schemaVersion = "SchemaVersion"
        case severity = "Severity"
        case sourceUrl = "SourceUrl"
        case threatIntelIndicators = "ThreatIntelIndicators"
        case title = "Title"
        case types = "Types"
        case updatedAt = "UpdatedAt"
        case userDefinedFields = "UserDefinedFields"
        case verificationState = "VerificationState"
        case vulnerabilities = "Vulnerabilities"
        case workflow = "Workflow"
        case workflowState = "WorkflowState"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let awsAccountId = awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let compliance = compliance {
            try encodeContainer.encode(compliance, forKey: .compliance)
        }
        if confidence != 0 {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if criticality != 0 {
            try encodeContainer.encode(criticality, forKey: .criticality)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let findingProviderFields = findingProviderFields {
            try encodeContainer.encode(findingProviderFields, forKey: .findingProviderFields)
        }
        if let firstObservedAt = firstObservedAt {
            try encodeContainer.encode(firstObservedAt, forKey: .firstObservedAt)
        }
        if let generatorId = generatorId {
            try encodeContainer.encode(generatorId, forKey: .generatorId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastObservedAt = lastObservedAt {
            try encodeContainer.encode(lastObservedAt, forKey: .lastObservedAt)
        }
        if let malware = malware {
            var malwareContainer = encodeContainer.nestedUnkeyedContainer(forKey: .malware)
            for malwarelist0 in malware {
                try malwareContainer.encode(malwarelist0)
            }
        }
        if let network = network {
            try encodeContainer.encode(network, forKey: .network)
        }
        if let networkPath = networkPath {
            var networkPathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkPath)
            for networkpathlist0 in networkPath {
                try networkPathContainer.encode(networkpathlist0)
            }
        }
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let patchSummary = patchSummary {
            try encodeContainer.encode(patchSummary, forKey: .patchSummary)
        }
        if let process = process {
            try encodeContainer.encode(process, forKey: .process)
        }
        if let productArn = productArn {
            try encodeContainer.encode(productArn, forKey: .productArn)
        }
        if let productFields = productFields {
            var productFieldsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .productFields)
            for (dictKey0, fieldmap0) in productFields {
                try productFieldsContainer.encode(fieldmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let recordState = recordState {
            try encodeContainer.encode(recordState.rawValue, forKey: .recordState)
        }
        if let relatedFindings = relatedFindings {
            var relatedFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedFindings)
            for relatedfindinglist0 in relatedFindings {
                try relatedFindingsContainer.encode(relatedfindinglist0)
            }
        }
        if let remediation = remediation {
            try encodeContainer.encode(remediation, forKey: .remediation)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resourcelist0 in resources {
                try resourcesContainer.encode(resourcelist0)
            }
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let sourceUrl = sourceUrl {
            try encodeContainer.encode(sourceUrl, forKey: .sourceUrl)
        }
        if let threatIntelIndicators = threatIntelIndicators {
            var threatIntelIndicatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatIntelIndicators)
            for threatintelindicatorlist0 in threatIntelIndicators {
                try threatIntelIndicatorsContainer.encode(threatintelindicatorlist0)
            }
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let types = types {
            var typesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .types)
            for typelist0 in types {
                try typesContainer.encode(typelist0)
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt, forKey: .updatedAt)
        }
        if let userDefinedFields = userDefinedFields {
            var userDefinedFieldsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .userDefinedFields)
            for (dictKey0, fieldmap0) in userDefinedFields {
                try userDefinedFieldsContainer.encode(fieldmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let verificationState = verificationState {
            try encodeContainer.encode(verificationState.rawValue, forKey: .verificationState)
        }
        if let vulnerabilities = vulnerabilities {
            var vulnerabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vulnerabilities)
            for vulnerabilitylist0 in vulnerabilities {
                try vulnerabilitiesContainer.encode(vulnerabilitylist0)
            }
        }
        if let workflow = workflow {
            try encodeContainer.encode(workflow, forKey: .workflow)
        }
        if let workflowState = workflowState {
            try encodeContainer.encode(workflowState.rawValue, forKey: .workflowState)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let productArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productArn)
        productArn = productArnDecoded
        let generatorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .generatorId)
        generatorId = generatorIdDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let typesContainer = try containerValues.decodeIfPresent([String].self, forKey: .types)
        var typesDecoded0:[String]? = nil
        if let typesContainer = typesContainer {
            typesDecoded0 = [String]()
            for string0 in typesContainer {
                typesDecoded0?.append(string0)
            }
        }
        types = typesDecoded0
        let firstObservedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firstObservedAt)
        firstObservedAt = firstObservedAtDecoded
        let lastObservedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastObservedAt)
        lastObservedAt = lastObservedAtDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Severity.self, forKey: .severity)
        severity = severityDecoded
        let confidenceDecoded = try containerValues.decode(Int.self, forKey: .confidence)
        confidence = confidenceDecoded
        let criticalityDecoded = try containerValues.decode(Int.self, forKey: .criticality)
        criticality = criticalityDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let remediationDecoded = try containerValues.decodeIfPresent(Remediation.self, forKey: .remediation)
        remediation = remediationDecoded
        let sourceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceUrl)
        sourceUrl = sourceUrlDecoded
        let productFieldsContainer = try containerValues.decodeIfPresent([String:String].self, forKey: .productFields)
        var productFieldsDecoded0: [String:String]? = nil
        if let productFieldsContainer = productFieldsContainer {
            productFieldsDecoded0 = [String:String]()
            for (key0, nonemptystring0) in productFieldsContainer {
                productFieldsDecoded0?[key0] = nonemptystring0
            }
        }
        productFields = productFieldsDecoded0
        let userDefinedFieldsContainer = try containerValues.decodeIfPresent([String:String].self, forKey: .userDefinedFields)
        var userDefinedFieldsDecoded0: [String:String]? = nil
        if let userDefinedFieldsContainer = userDefinedFieldsContainer {
            userDefinedFieldsDecoded0 = [String:String]()
            for (key0, nonemptystring0) in userDefinedFieldsContainer {
                userDefinedFieldsDecoded0?[key0] = nonemptystring0
            }
        }
        userDefinedFields = userDefinedFieldsDecoded0
        let malwareContainer = try containerValues.decodeIfPresent([Malware].self, forKey: .malware)
        var malwareDecoded0:[Malware]? = nil
        if let malwareContainer = malwareContainer {
            malwareDecoded0 = [Malware]()
            for structure0 in malwareContainer {
                malwareDecoded0?.append(structure0)
            }
        }
        malware = malwareDecoded0
        let networkDecoded = try containerValues.decodeIfPresent(Network.self, forKey: .network)
        network = networkDecoded
        let networkPathContainer = try containerValues.decodeIfPresent([NetworkPathComponent].self, forKey: .networkPath)
        var networkPathDecoded0:[NetworkPathComponent]? = nil
        if let networkPathContainer = networkPathContainer {
            networkPathDecoded0 = [NetworkPathComponent]()
            for structure0 in networkPathContainer {
                networkPathDecoded0?.append(structure0)
            }
        }
        networkPath = networkPathDecoded0
        let processDecoded = try containerValues.decodeIfPresent(ProcessDetails.self, forKey: .process)
        process = processDecoded
        let threatIntelIndicatorsContainer = try containerValues.decodeIfPresent([ThreatIntelIndicator].self, forKey: .threatIntelIndicators)
        var threatIntelIndicatorsDecoded0:[ThreatIntelIndicator]? = nil
        if let threatIntelIndicatorsContainer = threatIntelIndicatorsContainer {
            threatIntelIndicatorsDecoded0 = [ThreatIntelIndicator]()
            for structure0 in threatIntelIndicatorsContainer {
                threatIntelIndicatorsDecoded0?.append(structure0)
            }
        }
        threatIntelIndicators = threatIntelIndicatorsDecoded0
        let resourcesContainer = try containerValues.decodeIfPresent([Resource].self, forKey: .resources)
        var resourcesDecoded0:[Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Resource]()
            for structure0 in resourcesContainer {
                resourcesDecoded0?.append(structure0)
            }
        }
        resources = resourcesDecoded0
        let complianceDecoded = try containerValues.decodeIfPresent(Compliance.self, forKey: .compliance)
        compliance = complianceDecoded
        let verificationStateDecoded = try containerValues.decodeIfPresent(VerificationState.self, forKey: .verificationState)
        verificationState = verificationStateDecoded
        let workflowStateDecoded = try containerValues.decodeIfPresent(WorkflowState.self, forKey: .workflowState)
        workflowState = workflowStateDecoded
        let workflowDecoded = try containerValues.decodeIfPresent(Workflow.self, forKey: .workflow)
        workflow = workflowDecoded
        let recordStateDecoded = try containerValues.decodeIfPresent(RecordState.self, forKey: .recordState)
        recordState = recordStateDecoded
        let relatedFindingsContainer = try containerValues.decodeIfPresent([RelatedFinding].self, forKey: .relatedFindings)
        var relatedFindingsDecoded0:[RelatedFinding]? = nil
        if let relatedFindingsContainer = relatedFindingsContainer {
            relatedFindingsDecoded0 = [RelatedFinding]()
            for structure0 in relatedFindingsContainer {
                relatedFindingsDecoded0?.append(structure0)
            }
        }
        relatedFindings = relatedFindingsDecoded0
        let noteDecoded = try containerValues.decodeIfPresent(Note.self, forKey: .note)
        note = noteDecoded
        let vulnerabilitiesContainer = try containerValues.decodeIfPresent([Vulnerability].self, forKey: .vulnerabilities)
        var vulnerabilitiesDecoded0:[Vulnerability]? = nil
        if let vulnerabilitiesContainer = vulnerabilitiesContainer {
            vulnerabilitiesDecoded0 = [Vulnerability]()
            for structure0 in vulnerabilitiesContainer {
                vulnerabilitiesDecoded0?.append(structure0)
            }
        }
        vulnerabilities = vulnerabilitiesDecoded0
        let patchSummaryDecoded = try containerValues.decodeIfPresent(PatchSummary.self, forKey: .patchSummary)
        patchSummary = patchSummaryDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
        let findingProviderFieldsDecoded = try containerValues.decodeIfPresent(FindingProviderFields.self, forKey: .findingProviderFields)
        findingProviderFields = findingProviderFieldsDecoded
    }
}
