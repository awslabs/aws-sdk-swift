// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension DeviceFarmClientTypes.AccountSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountNumber
        case defaultJobTimeoutMinutes
        case maxJobTimeoutMinutes
        case maxSlots
        case skipAppResign
        case trialMinutes
        case unmeteredDevices
        case unmeteredRemoteAccessDevices
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountNumber = self.awsAccountNumber {
            try encodeContainer.encode(awsAccountNumber, forKey: .awsAccountNumber)
        }
        if let defaultJobTimeoutMinutes = self.defaultJobTimeoutMinutes {
            try encodeContainer.encode(defaultJobTimeoutMinutes, forKey: .defaultJobTimeoutMinutes)
        }
        if let maxJobTimeoutMinutes = self.maxJobTimeoutMinutes {
            try encodeContainer.encode(maxJobTimeoutMinutes, forKey: .maxJobTimeoutMinutes)
        }
        if let maxSlots = maxSlots {
            var maxSlotsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .maxSlots)
            for (dictKey0, maxSlotMap0) in maxSlots {
                try maxSlotsContainer.encode(maxSlotMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let skipAppResign = self.skipAppResign {
            try encodeContainer.encode(skipAppResign, forKey: .skipAppResign)
        }
        if let trialMinutes = self.trialMinutes {
            try encodeContainer.encode(trialMinutes, forKey: .trialMinutes)
        }
        if let unmeteredDevices = unmeteredDevices {
            var unmeteredDevicesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .unmeteredDevices)
            for (dictKey0, purchasedDevicesMap0) in unmeteredDevices {
                try unmeteredDevicesContainer.encode(purchasedDevicesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let unmeteredRemoteAccessDevices = unmeteredRemoteAccessDevices {
            var unmeteredRemoteAccessDevicesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .unmeteredRemoteAccessDevices)
            for (dictKey0, purchasedDevicesMap0) in unmeteredRemoteAccessDevices {
                try unmeteredRemoteAccessDevicesContainer.encode(purchasedDevicesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountNumber)
        awsAccountNumber = awsAccountNumberDecoded
        let unmeteredDevicesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .unmeteredDevices)
        var unmeteredDevicesDecoded0: [Swift.String:Swift.Int]? = nil
        if let unmeteredDevicesContainer = unmeteredDevicesContainer {
            unmeteredDevicesDecoded0 = [Swift.String:Swift.Int]()
            for (key0, integer0) in unmeteredDevicesContainer {
                if let integer0 = integer0 {
                    unmeteredDevicesDecoded0?[key0] = integer0
                }
            }
        }
        unmeteredDevices = unmeteredDevicesDecoded0
        let unmeteredRemoteAccessDevicesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .unmeteredRemoteAccessDevices)
        var unmeteredRemoteAccessDevicesDecoded0: [Swift.String:Swift.Int]? = nil
        if let unmeteredRemoteAccessDevicesContainer = unmeteredRemoteAccessDevicesContainer {
            unmeteredRemoteAccessDevicesDecoded0 = [Swift.String:Swift.Int]()
            for (key0, integer0) in unmeteredRemoteAccessDevicesContainer {
                if let integer0 = integer0 {
                    unmeteredRemoteAccessDevicesDecoded0?[key0] = integer0
                }
            }
        }
        unmeteredRemoteAccessDevices = unmeteredRemoteAccessDevicesDecoded0
        let maxJobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxJobTimeoutMinutes)
        maxJobTimeoutMinutes = maxJobTimeoutMinutesDecoded
        let trialMinutesDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TrialMinutes.self, forKey: .trialMinutes)
        trialMinutes = trialMinutesDecoded
        let maxSlotsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .maxSlots)
        var maxSlotsDecoded0: [Swift.String:Swift.Int]? = nil
        if let maxSlotsContainer = maxSlotsContainer {
            maxSlotsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, integer0) in maxSlotsContainer {
                if let integer0 = integer0 {
                    maxSlotsDecoded0?[key0] = integer0
                }
            }
        }
        maxSlots = maxSlotsDecoded0
        let defaultJobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultJobTimeoutMinutes)
        defaultJobTimeoutMinutes = defaultJobTimeoutMinutesDecoded
        let skipAppResignDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .skipAppResign)
        skipAppResign = skipAppResignDecoded
    }
}

extension DeviceFarmClientTypes {
    /// A container for account-level settings in AWS Device Farm.
    public struct AccountSettings: Swift.Equatable {
        /// The AWS account number specified in the AccountSettings container.
        public var awsAccountNumber: Swift.String?
        /// The default number of minutes (at the account level) a test run executes before it times out. The default value is 150 minutes.
        public var defaultJobTimeoutMinutes: Swift.Int?
        /// The maximum number of minutes a test run executes before it times out.
        public var maxJobTimeoutMinutes: Swift.Int?
        /// The maximum number of device slots that the AWS account can purchase. Each maximum is expressed as an offering-id:number pair, where the offering-id represents one of the IDs returned by the ListOfferings command.
        public var maxSlots: [Swift.String:Swift.Int]?
        /// When set to true, for private devices, Device Farm does not sign your app again. For public devices, Device Farm always signs your apps again. For more information about how Device Farm re-signs your apps, see [Do you modify my app?](http://aws.amazon.com/device-farm/faqs/) in the AWS Device Farm FAQs.
        public var skipAppResign: Swift.Bool?
        /// Information about an AWS account's usage of free trial device minutes.
        public var trialMinutes: DeviceFarmClientTypes.TrialMinutes?
        /// Returns the unmetered devices you have purchased or want to purchase.
        public var unmeteredDevices: [Swift.String:Swift.Int]?
        /// Returns the unmetered remote access devices you have purchased or want to purchase.
        public var unmeteredRemoteAccessDevices: [Swift.String:Swift.Int]?

        public init (
            awsAccountNumber: Swift.String? = nil,
            defaultJobTimeoutMinutes: Swift.Int? = nil,
            maxJobTimeoutMinutes: Swift.Int? = nil,
            maxSlots: [Swift.String:Swift.Int]? = nil,
            skipAppResign: Swift.Bool? = nil,
            trialMinutes: DeviceFarmClientTypes.TrialMinutes? = nil,
            unmeteredDevices: [Swift.String:Swift.Int]? = nil,
            unmeteredRemoteAccessDevices: [Swift.String:Swift.Int]? = nil
        )
        {
            self.awsAccountNumber = awsAccountNumber
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.maxJobTimeoutMinutes = maxJobTimeoutMinutes
            self.maxSlots = maxSlots
            self.skipAppResign = skipAppResign
            self.trialMinutes = trialMinutes
            self.unmeteredDevices = unmeteredDevices
            self.unmeteredRemoteAccessDevices = unmeteredRemoteAccessDevices
        }
    }

}

extension ArgumentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An invalid argument was specified.
public struct ArgumentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any additional information about the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ArgumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeviceFarmClientTypes.Artifact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case `extension` = "extension"
        case name
        case type
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let `extension` = self.`extension` {
            try encodeContainer.encode(`extension`, forKey: .`extension`)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ArtifactType.self, forKey: .type)
        type = typeDecoded
        let extensionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extension)
        `extension` = extensionDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents the output of a test. Examples of artifacts include logs and screenshots.
    public struct Artifact: Swift.Equatable {
        /// The artifact's ARN.
        public var arn: Swift.String?
        /// The artifact's file extension.
        public var `extension`: Swift.String?
        /// The artifact's name.
        public var name: Swift.String?
        /// The artifact's type. Allowed values include the following:
        ///
        /// * UNKNOWN
        ///
        /// * SCREENSHOT
        ///
        /// * DEVICE_LOG
        ///
        /// * MESSAGE_LOG
        ///
        /// * VIDEO_LOG
        ///
        /// * RESULT_LOG
        ///
        /// * SERVICE_LOG
        ///
        /// * WEBKIT_LOG
        ///
        /// * INSTRUMENTATION_OUTPUT
        ///
        /// * EXERCISER_MONKEY_OUTPUT: the artifact (log) generated by an Android fuzz test.
        ///
        /// * CALABASH_JSON_OUTPUT
        ///
        /// * CALABASH_PRETTY_OUTPUT
        ///
        /// * CALABASH_STANDARD_OUTPUT
        ///
        /// * CALABASH_JAVA_XML_OUTPUT
        ///
        /// * AUTOMATION_OUTPUT
        ///
        /// * APPIUM_SERVER_OUTPUT
        ///
        /// * APPIUM_JAVA_OUTPUT
        ///
        /// * APPIUM_JAVA_XML_OUTPUT
        ///
        /// * APPIUM_PYTHON_OUTPUT
        ///
        /// * APPIUM_PYTHON_XML_OUTPUT
        ///
        /// * EXPLORER_EVENT_LOG
        ///
        /// * EXPLORER_SUMMARY_LOG
        ///
        /// * APPLICATION_CRASH_REPORT
        ///
        /// * XCTEST_LOG
        ///
        /// * VIDEO
        ///
        /// * CUSTOMER_ARTIFACT
        ///
        /// * CUSTOMER_ARTIFACT_LOG
        ///
        /// * TESTSPEC_OUTPUT
        public var type: DeviceFarmClientTypes.ArtifactType?
        /// The presigned Amazon S3 URL that can be used with a GET request to download the artifact's file.
        public var url: Swift.String?

        public init (
            arn: Swift.String? = nil,
            `extension`: Swift.String? = nil,
            name: Swift.String? = nil,
            type: DeviceFarmClientTypes.ArtifactType? = nil,
            url: Swift.String? = nil
        )
        {
            self.arn = arn
            self.`extension` = `extension`
            self.name = name
            self.type = type
            self.url = url
        }
    }

}

extension DeviceFarmClientTypes {
    public enum ArtifactCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case file
        case log
        case screenshot
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactCategory] {
            return [
                .file,
                .log,
                .screenshot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .file: return "FILE"
            case .log: return "LOG"
            case .screenshot: return "SCREENSHOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArtifactCategory(rawValue: rawValue) ?? ArtifactCategory.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum ArtifactType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appiumJavaOutput
        case appiumJavaXmlOutput
        case appiumPythonOutput
        case appiumPythonXmlOutput
        case appiumServerOutput
        case applicationCrashReport
        case automationOutput
        case calabashJavaXmlOutput
        case calabashJsonOutput
        case calabashPrettyOutput
        case calabashStandardOutput
        case customerArtifact
        case customerArtifactLog
        case deviceLog
        case exerciserMonkeyOutput
        case explorerEventLog
        case explorerSummaryLog
        case instrumentationOutput
        case messageLog
        case resultLog
        case screenshot
        case serviceLog
        case testspecOutput
        case unknown
        case video
        case videoLog
        case webkitLog
        case xctestLog
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactType] {
            return [
                .appiumJavaOutput,
                .appiumJavaXmlOutput,
                .appiumPythonOutput,
                .appiumPythonXmlOutput,
                .appiumServerOutput,
                .applicationCrashReport,
                .automationOutput,
                .calabashJavaXmlOutput,
                .calabashJsonOutput,
                .calabashPrettyOutput,
                .calabashStandardOutput,
                .customerArtifact,
                .customerArtifactLog,
                .deviceLog,
                .exerciserMonkeyOutput,
                .explorerEventLog,
                .explorerSummaryLog,
                .instrumentationOutput,
                .messageLog,
                .resultLog,
                .screenshot,
                .serviceLog,
                .testspecOutput,
                .unknown,
                .video,
                .videoLog,
                .webkitLog,
                .xctestLog,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appiumJavaOutput: return "APPIUM_JAVA_OUTPUT"
            case .appiumJavaXmlOutput: return "APPIUM_JAVA_XML_OUTPUT"
            case .appiumPythonOutput: return "APPIUM_PYTHON_OUTPUT"
            case .appiumPythonXmlOutput: return "APPIUM_PYTHON_XML_OUTPUT"
            case .appiumServerOutput: return "APPIUM_SERVER_OUTPUT"
            case .applicationCrashReport: return "APPLICATION_CRASH_REPORT"
            case .automationOutput: return "AUTOMATION_OUTPUT"
            case .calabashJavaXmlOutput: return "CALABASH_JAVA_XML_OUTPUT"
            case .calabashJsonOutput: return "CALABASH_JSON_OUTPUT"
            case .calabashPrettyOutput: return "CALABASH_PRETTY_OUTPUT"
            case .calabashStandardOutput: return "CALABASH_STANDARD_OUTPUT"
            case .customerArtifact: return "CUSTOMER_ARTIFACT"
            case .customerArtifactLog: return "CUSTOMER_ARTIFACT_LOG"
            case .deviceLog: return "DEVICE_LOG"
            case .exerciserMonkeyOutput: return "EXERCISER_MONKEY_OUTPUT"
            case .explorerEventLog: return "EXPLORER_EVENT_LOG"
            case .explorerSummaryLog: return "EXPLORER_SUMMARY_LOG"
            case .instrumentationOutput: return "INSTRUMENTATION_OUTPUT"
            case .messageLog: return "MESSAGE_LOG"
            case .resultLog: return "RESULT_LOG"
            case .screenshot: return "SCREENSHOT"
            case .serviceLog: return "SERVICE_LOG"
            case .testspecOutput: return "TESTSPEC_OUTPUT"
            case .unknown: return "UNKNOWN"
            case .video: return "VIDEO"
            case .videoLog: return "VIDEO_LOG"
            case .webkitLog: return "WEBKIT_LOG"
            case .xctestLog: return "XCTEST_LOG"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArtifactType(rawValue: rawValue) ?? ArtifactType.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum BillingMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case metered
        case unmetered
        case sdkUnknown(Swift.String)

        public static var allCases: [BillingMethod] {
            return [
                .metered,
                .unmetered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .metered: return "METERED"
            case .unmetered: return "UNMETERED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BillingMethod(rawValue: rawValue) ?? BillingMethod.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.CPU: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case clock
        case frequency
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture, forKey: .architecture)
        }
        if let clock = self.clock {
            try encodeContainer.encode(clock, forKey: .clock)
        }
        if let frequency = self.frequency {
            try encodeContainer.encode(frequency, forKey: .frequency)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frequency)
        frequency = frequencyDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecture)
        architecture = architectureDecoded
        let clockDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .clock)
        clock = clockDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents the amount of CPU that an app is using on a physical device. Does not represent system-wide CPU usage.
    public struct CPU: Swift.Equatable {
        /// The CPU's architecture (for example, x86 or ARM).
        public var architecture: Swift.String?
        /// The clock speed of the device's CPU, expressed in hertz (Hz). For example, a 1.2 GHz CPU is expressed as 1200000000.
        public var clock: Swift.Double?
        /// The CPU's frequency.
        public var frequency: Swift.String?

        public init (
            architecture: Swift.String? = nil,
            clock: Swift.Double? = nil,
            frequency: Swift.String? = nil
        )
        {
            self.architecture = architecture
            self.clock = clock
            self.frequency = frequency
        }
    }

}

extension CannotDeleteException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CannotDeleteExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested object could not be deleted.
public struct CannotDeleteException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CannotDeleteExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CannotDeleteExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeviceFarmClientTypes.Counters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errored
        case failed
        case passed
        case skipped
        case stopped
        case total
        case warned
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errored = self.errored {
            try encodeContainer.encode(errored, forKey: .errored)
        }
        if let failed = self.failed {
            try encodeContainer.encode(failed, forKey: .failed)
        }
        if let passed = self.passed {
            try encodeContainer.encode(passed, forKey: .passed)
        }
        if let skipped = self.skipped {
            try encodeContainer.encode(skipped, forKey: .skipped)
        }
        if let stopped = self.stopped {
            try encodeContainer.encode(stopped, forKey: .stopped)
        }
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
        if let warned = self.warned {
            try encodeContainer.encode(warned, forKey: .warned)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .total)
        total = totalDecoded
        let passedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .passed)
        passed = passedDecoded
        let failedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failed)
        failed = failedDecoded
        let warnedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .warned)
        warned = warnedDecoded
        let erroredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errored)
        errored = erroredDecoded
        let stoppedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stopped)
        stopped = stoppedDecoded
        let skippedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .skipped)
        skipped = skippedDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents entity counters.
    public struct Counters: Swift.Equatable {
        /// The number of errored entities.
        public var errored: Swift.Int?
        /// The number of failed entities.
        public var failed: Swift.Int?
        /// The number of passed entities.
        public var passed: Swift.Int?
        /// The number of skipped entities.
        public var skipped: Swift.Int?
        /// The number of stopped entities.
        public var stopped: Swift.Int?
        /// The total number of entities.
        public var total: Swift.Int?
        /// The number of warned entities.
        public var warned: Swift.Int?

        public init (
            errored: Swift.Int? = nil,
            failed: Swift.Int? = nil,
            passed: Swift.Int? = nil,
            skipped: Swift.Int? = nil,
            stopped: Swift.Int? = nil,
            total: Swift.Int? = nil,
            warned: Swift.Int? = nil
        )
        {
            self.errored = errored
            self.failed = failed
            self.passed = passed
            self.skipped = skipped
            self.stopped = stopped
            self.total = total
            self.warned = warned
        }
    }

}

extension CreateDevicePoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case maxDevices
        case name
        case projectArn
        case rules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let maxDevices = self.maxDevices {
            try encodeContainer.encode(maxDevices, forKey: .maxDevices)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectArn = self.projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rule0 in rules {
                try rulesContainer.encode(rule0)
            }
        }
    }
}

extension CreateDevicePoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the create device pool operation.
public struct CreateDevicePoolInput: Swift.Equatable {
    /// The device pool's description.
    public var description: Swift.String?
    /// The number of devices that Device Farm can add to your device pool. Device Farm adds devices that are available and meet the criteria that you assign for the rules parameter. Depending on how many devices meet these constraints, your device pool might contain fewer devices than the value for this parameter. By specifying the maximum number of devices, you can control the costs that you incur by running tests.
    public var maxDevices: Swift.Int?
    /// The device pool's name.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the project for the device pool.
    /// This member is required.
    public var projectArn: Swift.String?
    /// The device pool's rules.
    /// This member is required.
    public var rules: [DeviceFarmClientTypes.Rule]?

    public init (
        description: Swift.String? = nil,
        maxDevices: Swift.Int? = nil,
        name: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        rules: [DeviceFarmClientTypes.Rule]? = nil
    )
    {
        self.description = description
        self.maxDevices = maxDevices
        self.name = name
        self.projectArn = projectArn
        self.rules = rules
    }
}

struct CreateDevicePoolInputBody: Swift.Equatable {
    let projectArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let rules: [DeviceFarmClientTypes.Rule]?
    let maxDevices: Swift.Int?
}

extension CreateDevicePoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case maxDevices
        case name
        case projectArn
        case rules
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[DeviceFarmClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [DeviceFarmClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let maxDevicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDevices)
        maxDevices = maxDevicesDecoded
    }
}

extension CreateDevicePoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDevicePoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDevicePoolOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDevicePoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDevicePoolOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devicePool = output.devicePool
        } else {
            self.devicePool = nil
        }
    }
}

/// Represents the result of a create device pool request.
public struct CreateDevicePoolOutputResponse: Swift.Equatable {
    /// The newly created device pool.
    public var devicePool: DeviceFarmClientTypes.DevicePool?

    public init (
        devicePool: DeviceFarmClientTypes.DevicePool? = nil
    )
    {
        self.devicePool = devicePool
    }
}

struct CreateDevicePoolOutputResponseBody: Swift.Equatable {
    let devicePool: DeviceFarmClientTypes.DevicePool?
}

extension CreateDevicePoolOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePool
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePoolDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DevicePool.self, forKey: .devicePool)
        devicePool = devicePoolDecoded
    }
}

extension CreateInstanceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case excludeAppPackagesFromCleanup
        case name
        case packageCleanup
        case rebootAfterUse
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup {
            var excludeAppPackagesFromCleanupContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeAppPackagesFromCleanup)
            for string0 in excludeAppPackagesFromCleanup {
                try excludeAppPackagesFromCleanupContainer.encode(string0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packageCleanup = self.packageCleanup {
            try encodeContainer.encode(packageCleanup, forKey: .packageCleanup)
        }
        if let rebootAfterUse = self.rebootAfterUse {
            try encodeContainer.encode(rebootAfterUse, forKey: .rebootAfterUse)
        }
    }
}

extension CreateInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateInstanceProfileInput: Swift.Equatable {
    /// The description of your instance profile.
    public var description: Swift.String?
    /// An array of strings that specifies the list of app packages that should not be cleaned up from the device after a test run. The list of packages is considered only if you set packageCleanup to true.
    public var excludeAppPackagesFromCleanup: [Swift.String]?
    /// The name of your instance profile.
    /// This member is required.
    public var name: Swift.String?
    /// When set to true, Device Farm removes app packages after a test run. The default value is false for private devices.
    public var packageCleanup: Swift.Bool?
    /// When set to true, Device Farm reboots the instance after a test run. The default value is true.
    public var rebootAfterUse: Swift.Bool?

    public init (
        description: Swift.String? = nil,
        excludeAppPackagesFromCleanup: [Swift.String]? = nil,
        name: Swift.String? = nil,
        packageCleanup: Swift.Bool? = nil,
        rebootAfterUse: Swift.Bool? = nil
    )
    {
        self.description = description
        self.excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup
        self.name = name
        self.packageCleanup = packageCleanup
        self.rebootAfterUse = rebootAfterUse
    }
}

struct CreateInstanceProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let packageCleanup: Swift.Bool?
    let excludeAppPackagesFromCleanup: [Swift.String]?
    let rebootAfterUse: Swift.Bool?
}

extension CreateInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case excludeAppPackagesFromCleanup
        case name
        case packageCleanup
        case rebootAfterUse
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let packageCleanupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .packageCleanup)
        packageCleanup = packageCleanupDecoded
        let excludeAppPackagesFromCleanupContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludeAppPackagesFromCleanup)
        var excludeAppPackagesFromCleanupDecoded0:[Swift.String]? = nil
        if let excludeAppPackagesFromCleanupContainer = excludeAppPackagesFromCleanupContainer {
            excludeAppPackagesFromCleanupDecoded0 = [Swift.String]()
            for string0 in excludeAppPackagesFromCleanupContainer {
                if let string0 = string0 {
                    excludeAppPackagesFromCleanupDecoded0?.append(string0)
                }
            }
        }
        excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanupDecoded0
        let rebootAfterUseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rebootAfterUse)
        rebootAfterUse = rebootAfterUseDecoded
    }
}

extension CreateInstanceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInstanceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateInstanceProfileOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInstanceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateInstanceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceProfile = output.instanceProfile
        } else {
            self.instanceProfile = nil
        }
    }
}

public struct CreateInstanceProfileOutputResponse: Swift.Equatable {
    /// An object that contains information about your instance profile.
    public var instanceProfile: DeviceFarmClientTypes.InstanceProfile?

    public init (
        instanceProfile: DeviceFarmClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

struct CreateInstanceProfileOutputResponseBody: Swift.Equatable {
    let instanceProfile: DeviceFarmClientTypes.InstanceProfile?
}

extension CreateInstanceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

extension CreateNetworkProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case downlinkBandwidthBits
        case downlinkDelayMs
        case downlinkJitterMs
        case downlinkLossPercent
        case name
        case projectArn
        case type
        case uplinkBandwidthBits
        case uplinkDelayMs
        case uplinkJitterMs
        case uplinkLossPercent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let downlinkBandwidthBits = self.downlinkBandwidthBits {
            try encodeContainer.encode(downlinkBandwidthBits, forKey: .downlinkBandwidthBits)
        }
        if let downlinkDelayMs = self.downlinkDelayMs {
            try encodeContainer.encode(downlinkDelayMs, forKey: .downlinkDelayMs)
        }
        if let downlinkJitterMs = self.downlinkJitterMs {
            try encodeContainer.encode(downlinkJitterMs, forKey: .downlinkJitterMs)
        }
        if downlinkLossPercent != 0 {
            try encodeContainer.encode(downlinkLossPercent, forKey: .downlinkLossPercent)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectArn = self.projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uplinkBandwidthBits = self.uplinkBandwidthBits {
            try encodeContainer.encode(uplinkBandwidthBits, forKey: .uplinkBandwidthBits)
        }
        if let uplinkDelayMs = self.uplinkDelayMs {
            try encodeContainer.encode(uplinkDelayMs, forKey: .uplinkDelayMs)
        }
        if let uplinkJitterMs = self.uplinkJitterMs {
            try encodeContainer.encode(uplinkJitterMs, forKey: .uplinkJitterMs)
        }
        if uplinkLossPercent != 0 {
            try encodeContainer.encode(uplinkLossPercent, forKey: .uplinkLossPercent)
        }
    }
}

extension CreateNetworkProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateNetworkProfileInput: Swift.Equatable {
    /// The description of the network profile.
    public var description: Swift.String?
    /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
    public var downlinkBandwidthBits: Swift.Int?
    /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
    public var downlinkDelayMs: Swift.Int?
    /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
    public var downlinkJitterMs: Swift.Int?
    /// Proportion of received packets that fail to arrive from 0 to 100 percent.
    public var downlinkLossPercent: Swift.Int
    /// The name for the new network profile.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the project for which you want to create a network profile.
    /// This member is required.
    public var projectArn: Swift.String?
    /// The type of network profile to create. Valid values are listed here.
    public var type: DeviceFarmClientTypes.NetworkProfileType?
    /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
    public var uplinkBandwidthBits: Swift.Int?
    /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
    public var uplinkDelayMs: Swift.Int?
    /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
    public var uplinkJitterMs: Swift.Int?
    /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
    public var uplinkLossPercent: Swift.Int

    public init (
        description: Swift.String? = nil,
        downlinkBandwidthBits: Swift.Int? = nil,
        downlinkDelayMs: Swift.Int? = nil,
        downlinkJitterMs: Swift.Int? = nil,
        downlinkLossPercent: Swift.Int = 0,
        name: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        type: DeviceFarmClientTypes.NetworkProfileType? = nil,
        uplinkBandwidthBits: Swift.Int? = nil,
        uplinkDelayMs: Swift.Int? = nil,
        uplinkJitterMs: Swift.Int? = nil,
        uplinkLossPercent: Swift.Int = 0
    )
    {
        self.description = description
        self.downlinkBandwidthBits = downlinkBandwidthBits
        self.downlinkDelayMs = downlinkDelayMs
        self.downlinkJitterMs = downlinkJitterMs
        self.downlinkLossPercent = downlinkLossPercent
        self.name = name
        self.projectArn = projectArn
        self.type = type
        self.uplinkBandwidthBits = uplinkBandwidthBits
        self.uplinkDelayMs = uplinkDelayMs
        self.uplinkJitterMs = uplinkJitterMs
        self.uplinkLossPercent = uplinkLossPercent
    }
}

struct CreateNetworkProfileInputBody: Swift.Equatable {
    let projectArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let type: DeviceFarmClientTypes.NetworkProfileType?
    let uplinkBandwidthBits: Swift.Int?
    let downlinkBandwidthBits: Swift.Int?
    let uplinkDelayMs: Swift.Int?
    let downlinkDelayMs: Swift.Int?
    let uplinkJitterMs: Swift.Int?
    let downlinkJitterMs: Swift.Int?
    let uplinkLossPercent: Swift.Int
    let downlinkLossPercent: Swift.Int
}

extension CreateNetworkProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case downlinkBandwidthBits
        case downlinkDelayMs
        case downlinkJitterMs
        case downlinkLossPercent
        case name
        case projectArn
        case type
        case uplinkBandwidthBits
        case uplinkDelayMs
        case uplinkJitterMs
        case uplinkLossPercent
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.NetworkProfileType.self, forKey: .type)
        type = typeDecoded
        let uplinkBandwidthBitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkBandwidthBits)
        uplinkBandwidthBits = uplinkBandwidthBitsDecoded
        let downlinkBandwidthBitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkBandwidthBits)
        downlinkBandwidthBits = downlinkBandwidthBitsDecoded
        let uplinkDelayMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkDelayMs)
        uplinkDelayMs = uplinkDelayMsDecoded
        let downlinkDelayMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkDelayMs)
        downlinkDelayMs = downlinkDelayMsDecoded
        let uplinkJitterMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkJitterMs)
        uplinkJitterMs = uplinkJitterMsDecoded
        let downlinkJitterMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkJitterMs)
        downlinkJitterMs = downlinkJitterMsDecoded
        let uplinkLossPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkLossPercent) ?? 0
        uplinkLossPercent = uplinkLossPercentDecoded
        let downlinkLossPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkLossPercent) ?? 0
        downlinkLossPercent = downlinkLossPercentDecoded
    }
}

extension CreateNetworkProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNetworkProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateNetworkProfileOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNetworkProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateNetworkProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkProfile = output.networkProfile
        } else {
            self.networkProfile = nil
        }
    }
}

public struct CreateNetworkProfileOutputResponse: Swift.Equatable {
    /// The network profile that is returned by the create network profile request.
    public var networkProfile: DeviceFarmClientTypes.NetworkProfile?

    public init (
        networkProfile: DeviceFarmClientTypes.NetworkProfile? = nil
    )
    {
        self.networkProfile = networkProfile
    }
}

struct CreateNetworkProfileOutputResponseBody: Swift.Equatable {
    let networkProfile: DeviceFarmClientTypes.NetworkProfile?
}

extension CreateNetworkProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.NetworkProfile.self, forKey: .networkProfile)
        networkProfile = networkProfileDecoded
    }
}

extension CreateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultJobTimeoutMinutes
        case name
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultJobTimeoutMinutes = self.defaultJobTimeoutMinutes {
            try encodeContainer.encode(defaultJobTimeoutMinutes, forKey: .defaultJobTimeoutMinutes)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension CreateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the create project operation.
public struct CreateProjectInput: Swift.Equatable {
    /// Sets the execution timeout value (in minutes) for a project. All test runs in this project use the specified execution timeout value unless overridden when scheduling a run.
    public var defaultJobTimeoutMinutes: Swift.Int?
    /// The project's name.
    /// This member is required.
    public var name: Swift.String?
    /// The VPC security groups and subnets that are attached to a project.
    public var vpcConfig: DeviceFarmClientTypes.VpcConfig?

    public init (
        defaultJobTimeoutMinutes: Swift.Int? = nil,
        name: Swift.String? = nil,
        vpcConfig: DeviceFarmClientTypes.VpcConfig? = nil
    )
    {
        self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
        self.name = name
        self.vpcConfig = vpcConfig
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    let name: Swift.String?
    let defaultJobTimeoutMinutes: Swift.Int?
    let vpcConfig: DeviceFarmClientTypes.VpcConfig?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultJobTimeoutMinutes
        case name
        case vpcConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultJobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultJobTimeoutMinutes)
        defaultJobTimeoutMinutes = defaultJobTimeoutMinutesDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension CreateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOperationException" : self = .tagOperationException(try TagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateProjectOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case tagOperationException(TagOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

/// Represents the result of a create project request.
public struct CreateProjectOutputResponse: Swift.Equatable {
    /// The newly created project.
    public var project: DeviceFarmClientTypes.Project?

    public init (
        project: DeviceFarmClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

struct CreateProjectOutputResponseBody: Swift.Equatable {
    let project: DeviceFarmClientTypes.Project?
}

extension CreateProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case project
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Project.self, forKey: .project)
        project = projectDecoded
    }
}

extension DeviceFarmClientTypes.CreateRemoteAccessSessionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingMethod
        case vpceConfigurationArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingMethod = self.billingMethod {
            try encodeContainer.encode(billingMethod.rawValue, forKey: .billingMethod)
        }
        if let vpceConfigurationArns = vpceConfigurationArns {
            var vpceConfigurationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpceConfigurationArns)
            for amazonresourcename0 in vpceConfigurationArns {
                try vpceConfigurationArnsContainer.encode(amazonresourcename0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingMethodDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.BillingMethod.self, forKey: .billingMethod)
        billingMethod = billingMethodDecoded
        let vpceConfigurationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpceConfigurationArns)
        var vpceConfigurationArnsDecoded0:[Swift.String]? = nil
        if let vpceConfigurationArnsContainer = vpceConfigurationArnsContainer {
            vpceConfigurationArnsDecoded0 = [Swift.String]()
            for string0 in vpceConfigurationArnsContainer {
                if let string0 = string0 {
                    vpceConfigurationArnsDecoded0?.append(string0)
                }
            }
        }
        vpceConfigurationArns = vpceConfigurationArnsDecoded0
    }
}

extension DeviceFarmClientTypes {
    /// Configuration settings for a remote access session, including billing method.
    public struct CreateRemoteAccessSessionConfiguration: Swift.Equatable {
        /// The billing method for the remote access session.
        public var billingMethod: DeviceFarmClientTypes.BillingMethod?
        /// An array of ARNs included in the VPC endpoint configuration.
        public var vpceConfigurationArns: [Swift.String]?

        public init (
            billingMethod: DeviceFarmClientTypes.BillingMethod? = nil,
            vpceConfigurationArns: [Swift.String]? = nil
        )
        {
            self.billingMethod = billingMethod
            self.vpceConfigurationArns = vpceConfigurationArns
        }
    }

}

extension CreateRemoteAccessSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case configuration
        case deviceArn
        case instanceArn
        case interactionMode
        case name
        case projectArn
        case remoteDebugEnabled
        case remoteRecordAppArn
        case remoteRecordEnabled
        case skipAppResign
        case sshPublicKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let deviceArn = self.deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let interactionMode = self.interactionMode {
            try encodeContainer.encode(interactionMode.rawValue, forKey: .interactionMode)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectArn = self.projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let remoteDebugEnabled = self.remoteDebugEnabled {
            try encodeContainer.encode(remoteDebugEnabled, forKey: .remoteDebugEnabled)
        }
        if let remoteRecordAppArn = self.remoteRecordAppArn {
            try encodeContainer.encode(remoteRecordAppArn, forKey: .remoteRecordAppArn)
        }
        if let remoteRecordEnabled = self.remoteRecordEnabled {
            try encodeContainer.encode(remoteRecordEnabled, forKey: .remoteRecordEnabled)
        }
        if let skipAppResign = self.skipAppResign {
            try encodeContainer.encode(skipAppResign, forKey: .skipAppResign)
        }
        if let sshPublicKey = self.sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
    }
}

extension CreateRemoteAccessSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Creates and submits a request to start a remote access session.
public struct CreateRemoteAccessSessionInput: Swift.Equatable {
    /// Unique identifier for the client. If you want access to multiple devices on the same client, you should pass the same clientId value in each call to CreateRemoteAccessSession. This identifier is required only if remoteDebugEnabled is set to true. Remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html).
    public var clientId: Swift.String?
    /// The configuration information for the remote access session request.
    public var configuration: DeviceFarmClientTypes.CreateRemoteAccessSessionConfiguration?
    /// The ARN of the device for which you want to create a remote access session.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the device instance for which you want to create a remote access session.
    public var instanceArn: Swift.String?
    /// The interaction mode of the remote access session. Valid values are:
    ///
    /// * INTERACTIVE: You can interact with the iOS device by viewing, touching, and rotating the screen. You cannot run XCUITest framework-based tests in this mode.
    ///
    /// * NO_VIDEO: You are connected to the device, but cannot interact with it or view the screen. This mode has the fastest test execution speed. You can run XCUITest framework-based tests in this mode.
    ///
    /// * VIDEO_ONLY: You can view the screen, but cannot touch or rotate it. You can run XCUITest framework-based tests and watch the screen in this mode.
    public var interactionMode: DeviceFarmClientTypes.InteractionMode?
    /// The name of the remote access session to create.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the project for which you want to create a remote access session.
    /// This member is required.
    public var projectArn: Swift.String?
    /// Set to true if you want to access devices remotely for debugging in your remote access session. Remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html).
    public var remoteDebugEnabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) for the app to be recorded in the remote access session.
    public var remoteRecordAppArn: Swift.String?
    /// Set to true to enable remote recording for the remote access session.
    public var remoteRecordEnabled: Swift.Bool?
    /// When set to true, for private devices, Device Farm does not sign your app again. For public devices, Device Farm always signs your apps again. For more information on how Device Farm modifies your uploads during tests, see [Do you modify my app?](http://aws.amazon.com/device-farm/faqs/)
    public var skipAppResign: Swift.Bool?
    /// Ignored. The public key of the ssh key pair you want to use for connecting to remote devices in your remote debugging session. This key is required only if remoteDebugEnabled is set to true. Remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html).
    public var sshPublicKey: Swift.String?

    public init (
        clientId: Swift.String? = nil,
        configuration: DeviceFarmClientTypes.CreateRemoteAccessSessionConfiguration? = nil,
        deviceArn: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        interactionMode: DeviceFarmClientTypes.InteractionMode? = nil,
        name: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        remoteDebugEnabled: Swift.Bool? = nil,
        remoteRecordAppArn: Swift.String? = nil,
        remoteRecordEnabled: Swift.Bool? = nil,
        skipAppResign: Swift.Bool? = nil,
        sshPublicKey: Swift.String? = nil
    )
    {
        self.clientId = clientId
        self.configuration = configuration
        self.deviceArn = deviceArn
        self.instanceArn = instanceArn
        self.interactionMode = interactionMode
        self.name = name
        self.projectArn = projectArn
        self.remoteDebugEnabled = remoteDebugEnabled
        self.remoteRecordAppArn = remoteRecordAppArn
        self.remoteRecordEnabled = remoteRecordEnabled
        self.skipAppResign = skipAppResign
        self.sshPublicKey = sshPublicKey
    }
}

struct CreateRemoteAccessSessionInputBody: Swift.Equatable {
    let projectArn: Swift.String?
    let deviceArn: Swift.String?
    let instanceArn: Swift.String?
    let sshPublicKey: Swift.String?
    let remoteDebugEnabled: Swift.Bool?
    let remoteRecordEnabled: Swift.Bool?
    let remoteRecordAppArn: Swift.String?
    let name: Swift.String?
    let clientId: Swift.String?
    let configuration: DeviceFarmClientTypes.CreateRemoteAccessSessionConfiguration?
    let interactionMode: DeviceFarmClientTypes.InteractionMode?
    let skipAppResign: Swift.Bool?
}

extension CreateRemoteAccessSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case configuration
        case deviceArn
        case instanceArn
        case interactionMode
        case name
        case projectArn
        case remoteDebugEnabled
        case remoteRecordAppArn
        case remoteRecordEnabled
        case skipAppResign
        case sshPublicKey
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let remoteDebugEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remoteDebugEnabled)
        remoteDebugEnabled = remoteDebugEnabledDecoded
        let remoteRecordEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remoteRecordEnabled)
        remoteRecordEnabled = remoteRecordEnabledDecoded
        let remoteRecordAppArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteRecordAppArn)
        remoteRecordAppArn = remoteRecordAppArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.CreateRemoteAccessSessionConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let interactionModeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.InteractionMode.self, forKey: .interactionMode)
        interactionMode = interactionModeDecoded
        let skipAppResignDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .skipAppResign)
        skipAppResign = skipAppResignDecoded
    }
}

extension CreateRemoteAccessSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRemoteAccessSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateRemoteAccessSessionOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRemoteAccessSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateRemoteAccessSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.remoteAccessSession = output.remoteAccessSession
        } else {
            self.remoteAccessSession = nil
        }
    }
}

/// Represents the server response from a request to create a remote access session.
public struct CreateRemoteAccessSessionOutputResponse: Swift.Equatable {
    /// A container that describes the remote access session when the request to create a remote access session is sent.
    public var remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession?

    public init (
        remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession? = nil
    )
    {
        self.remoteAccessSession = remoteAccessSession
    }
}

struct CreateRemoteAccessSessionOutputResponseBody: Swift.Equatable {
    let remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession?
}

extension CreateRemoteAccessSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case remoteAccessSession
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remoteAccessSessionDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.RemoteAccessSession.self, forKey: .remoteAccessSession)
        remoteAccessSession = remoteAccessSessionDecoded
    }
}

extension CreateTestGridProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension CreateTestGridProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateTestGridProjectInput: Swift.Equatable {
    /// Human-readable description of the project.
    public var description: Swift.String?
    /// Human-readable name of the Selenium testing project.
    /// This member is required.
    public var name: Swift.String?
    /// The VPC security groups and subnets that are attached to a project.
    public var vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig? = nil
    )
    {
        self.description = description
        self.name = name
        self.vpcConfig = vpcConfig
    }
}

struct CreateTestGridProjectInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig?
}

extension CreateTestGridProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case vpcConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridVpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension CreateTestGridProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTestGridProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTestGridProjectOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTestGridProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateTestGridProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.testGridProject = output.testGridProject
        } else {
            self.testGridProject = nil
        }
    }
}

public struct CreateTestGridProjectOutputResponse: Swift.Equatable {
    /// ARN of the Selenium testing project that was created.
    public var testGridProject: DeviceFarmClientTypes.TestGridProject?

    public init (
        testGridProject: DeviceFarmClientTypes.TestGridProject? = nil
    )
    {
        self.testGridProject = testGridProject
    }
}

struct CreateTestGridProjectOutputResponseBody: Swift.Equatable {
    let testGridProject: DeviceFarmClientTypes.TestGridProject?
}

extension CreateTestGridProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case testGridProject
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testGridProjectDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridProject.self, forKey: .testGridProject)
        testGridProject = testGridProjectDecoded
    }
}

extension CreateTestGridUrlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiresInSeconds
        case projectArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expiresInSeconds = self.expiresInSeconds {
            try encodeContainer.encode(expiresInSeconds, forKey: .expiresInSeconds)
        }
        if let projectArn = self.projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
    }
}

extension CreateTestGridUrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateTestGridUrlInput: Swift.Equatable {
    /// Lifetime, in seconds, of the URL.
    /// This member is required.
    public var expiresInSeconds: Swift.Int?
    /// ARN (from [CreateTestGridProject] or [ListTestGridProjects]) to associate with the short-term URL.
    /// This member is required.
    public var projectArn: Swift.String?

    public init (
        expiresInSeconds: Swift.Int? = nil,
        projectArn: Swift.String? = nil
    )
    {
        self.expiresInSeconds = expiresInSeconds
        self.projectArn = projectArn
    }
}

struct CreateTestGridUrlInputBody: Swift.Equatable {
    let projectArn: Swift.String?
    let expiresInSeconds: Swift.Int?
}

extension CreateTestGridUrlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiresInSeconds
        case projectArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let expiresInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiresInSeconds)
        expiresInSeconds = expiresInSecondsDecoded
    }
}

extension CreateTestGridUrlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTestGridUrlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTestGridUrlOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTestGridUrlOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTestGridUrlOutputResponse(expires: \(Swift.String(describing: expires)), url: \"CONTENT_REDACTED\")"}
}

extension CreateTestGridUrlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateTestGridUrlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.expires = output.expires
            self.url = output.url
        } else {
            self.expires = nil
            self.url = nil
        }
    }
}

public struct CreateTestGridUrlOutputResponse: Swift.Equatable {
    /// The number of seconds the URL from [CreateTestGridUrlResult$url] stays active.
    public var expires: ClientRuntime.Date?
    /// A signed URL, expiring in [CreateTestGridUrlRequest$expiresInSeconds] seconds, to be passed to a RemoteWebDriver.
    public var url: Swift.String?

    public init (
        expires: ClientRuntime.Date? = nil,
        url: Swift.String? = nil
    )
    {
        self.expires = expires
        self.url = url
    }
}

struct CreateTestGridUrlOutputResponseBody: Swift.Equatable {
    let url: Swift.String?
    let expires: ClientRuntime.Date?
}

extension CreateTestGridUrlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expires
        case url
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let expiresDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expires)
        expires = expiresDecoded
    }
}

extension CreateUploadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case name
        case projectArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectArn = self.projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the create upload operation.
public struct CreateUploadInput: Swift.Equatable {
    /// The upload's content type (for example, application/octet-stream).
    public var contentType: Swift.String?
    /// The upload's file name. The name should not contain any forward slashes (/). If you are uploading an iOS app, the file name must end with the .ipa extension. If you are uploading an Android app, the file name must end with the .apk extension. For all others, the file name must end with the .zip file extension.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the project for the upload.
    /// This member is required.
    public var projectArn: Swift.String?
    /// The upload's upload type. Must be one of the following values:
    ///
    /// * ANDROID_APP
    ///
    /// * IOS_APP
    ///
    /// * WEB_APP
    ///
    /// * EXTERNAL_DATA
    ///
    /// * APPIUM_JAVA_JUNIT_TEST_PACKAGE
    ///
    /// * APPIUM_JAVA_TESTNG_TEST_PACKAGE
    ///
    /// * APPIUM_PYTHON_TEST_PACKAGE
    ///
    /// * APPIUM_NODE_TEST_PACKAGE
    ///
    /// * APPIUM_RUBY_TEST_PACKAGE
    ///
    /// * APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE
    ///
    /// * APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE
    ///
    /// * APPIUM_WEB_PYTHON_TEST_PACKAGE
    ///
    /// * APPIUM_WEB_NODE_TEST_PACKAGE
    ///
    /// * APPIUM_WEB_RUBY_TEST_PACKAGE
    ///
    /// * CALABASH_TEST_PACKAGE
    ///
    /// * INSTRUMENTATION_TEST_PACKAGE
    ///
    /// * UIAUTOMATION_TEST_PACKAGE
    ///
    /// * UIAUTOMATOR_TEST_PACKAGE
    ///
    /// * XCTEST_TEST_PACKAGE
    ///
    /// * XCTEST_UI_TEST_PACKAGE
    ///
    /// * APPIUM_JAVA_JUNIT_TEST_SPEC
    ///
    /// * APPIUM_JAVA_TESTNG_TEST_SPEC
    ///
    /// * APPIUM_PYTHON_TEST_SPEC
    ///
    /// * APPIUM_NODE_TEST_SPEC
    ///
    /// * APPIUM_RUBY_TEST_SPEC
    ///
    /// * APPIUM_WEB_JAVA_JUNIT_TEST_SPEC
    ///
    /// * APPIUM_WEB_JAVA_TESTNG_TEST_SPEC
    ///
    /// * APPIUM_WEB_PYTHON_TEST_SPEC
    ///
    /// * APPIUM_WEB_NODE_TEST_SPEC
    ///
    /// * APPIUM_WEB_RUBY_TEST_SPEC
    ///
    /// * INSTRUMENTATION_TEST_SPEC
    ///
    /// * XCTEST_UI_TEST_SPEC
    ///
    ///
    /// If you call CreateUpload with WEB_APP specified, AWS Device Farm throws an ArgumentException error.
    /// This member is required.
    public var type: DeviceFarmClientTypes.UploadType?

    public init (
        contentType: Swift.String? = nil,
        name: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        type: DeviceFarmClientTypes.UploadType? = nil
    )
    {
        self.contentType = contentType
        self.name = name
        self.projectArn = projectArn
        self.type = type
    }
}

struct CreateUploadInputBody: Swift.Equatable {
    let projectArn: Swift.String?
    let name: Swift.String?
    let type: DeviceFarmClientTypes.UploadType?
    let contentType: Swift.String?
}

extension CreateUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case name
        case projectArn
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.UploadType.self, forKey: .type)
        type = typeDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension CreateUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateUploadOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateUploadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.upload = output.upload
        } else {
            self.upload = nil
        }
    }
}

/// Represents the result of a create upload request.
public struct CreateUploadOutputResponse: Swift.Equatable {
    /// The newly created upload.
    public var upload: DeviceFarmClientTypes.Upload?

    public init (
        upload: DeviceFarmClientTypes.Upload? = nil
    )
    {
        self.upload = upload
    }
}

struct CreateUploadOutputResponseBody: Swift.Equatable {
    let upload: DeviceFarmClientTypes.Upload?
}

extension CreateUploadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case upload
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Upload.self, forKey: .upload)
        upload = uploadDecoded
    }
}

extension CreateVPCEConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceDnsName
        case vpceConfigurationDescription
        case vpceConfigurationName
        case vpceServiceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceDnsName = self.serviceDnsName {
            try encodeContainer.encode(serviceDnsName, forKey: .serviceDnsName)
        }
        if let vpceConfigurationDescription = self.vpceConfigurationDescription {
            try encodeContainer.encode(vpceConfigurationDescription, forKey: .vpceConfigurationDescription)
        }
        if let vpceConfigurationName = self.vpceConfigurationName {
            try encodeContainer.encode(vpceConfigurationName, forKey: .vpceConfigurationName)
        }
        if let vpceServiceName = self.vpceServiceName {
            try encodeContainer.encode(vpceServiceName, forKey: .vpceServiceName)
        }
    }
}

extension CreateVPCEConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateVPCEConfigurationInput: Swift.Equatable {
    /// The DNS name of the service running in your VPC that you want Device Farm to test.
    /// This member is required.
    public var serviceDnsName: Swift.String?
    /// An optional description that provides details about your VPC endpoint configuration.
    public var vpceConfigurationDescription: Swift.String?
    /// The friendly name you give to your VPC endpoint configuration, to manage your configurations more easily.
    /// This member is required.
    public var vpceConfigurationName: Swift.String?
    /// The name of the VPC endpoint service running in your AWS account that you want Device Farm to test.
    /// This member is required.
    public var vpceServiceName: Swift.String?

    public init (
        serviceDnsName: Swift.String? = nil,
        vpceConfigurationDescription: Swift.String? = nil,
        vpceConfigurationName: Swift.String? = nil,
        vpceServiceName: Swift.String? = nil
    )
    {
        self.serviceDnsName = serviceDnsName
        self.vpceConfigurationDescription = vpceConfigurationDescription
        self.vpceConfigurationName = vpceConfigurationName
        self.vpceServiceName = vpceServiceName
    }
}

struct CreateVPCEConfigurationInputBody: Swift.Equatable {
    let vpceConfigurationName: Swift.String?
    let vpceServiceName: Swift.String?
    let serviceDnsName: Swift.String?
    let vpceConfigurationDescription: Swift.String?
}

extension CreateVPCEConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceDnsName
        case vpceConfigurationDescription
        case vpceConfigurationName
        case vpceServiceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpceConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceConfigurationName)
        vpceConfigurationName = vpceConfigurationNameDecoded
        let vpceServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceServiceName)
        vpceServiceName = vpceServiceNameDecoded
        let serviceDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceDnsName)
        serviceDnsName = serviceDnsNameDecoded
        let vpceConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceConfigurationDescription)
        vpceConfigurationDescription = vpceConfigurationDescriptionDecoded
    }
}

extension CreateVPCEConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVPCEConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateVPCEConfigurationOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVPCEConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateVPCEConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vpceConfiguration = output.vpceConfiguration
        } else {
            self.vpceConfiguration = nil
        }
    }
}

public struct CreateVPCEConfigurationOutputResponse: Swift.Equatable {
    /// An object that contains information about your VPC endpoint configuration.
    public var vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration?

    public init (
        vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration? = nil
    )
    {
        self.vpceConfiguration = vpceConfiguration
    }
}

struct CreateVPCEConfigurationOutputResponseBody: Swift.Equatable {
    let vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration?
}

extension CreateVPCEConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpceConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpceConfigurationDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.VPCEConfiguration.self, forKey: .vpceConfiguration)
        vpceConfiguration = vpceConfigurationDecoded
    }
}

extension DeviceFarmClientTypes {
    public enum CurrencyCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case usd
        case sdkUnknown(Swift.String)

        public static var allCases: [CurrencyCode] {
            return [
                .usd,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .usd: return "USD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CurrencyCode(rawValue: rawValue) ?? CurrencyCode.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.CustomerArtifactPaths: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case androidPaths
        case deviceHostPaths
        case iosPaths
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let androidPaths = androidPaths {
            var androidPathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .androidPaths)
            for string0 in androidPaths {
                try androidPathsContainer.encode(string0)
            }
        }
        if let deviceHostPaths = deviceHostPaths {
            var deviceHostPathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceHostPaths)
            for string0 in deviceHostPaths {
                try deviceHostPathsContainer.encode(string0)
            }
        }
        if let iosPaths = iosPaths {
            var iosPathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .iosPaths)
            for string0 in iosPaths {
                try iosPathsContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iosPathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .iosPaths)
        var iosPathsDecoded0:[Swift.String]? = nil
        if let iosPathsContainer = iosPathsContainer {
            iosPathsDecoded0 = [Swift.String]()
            for string0 in iosPathsContainer {
                if let string0 = string0 {
                    iosPathsDecoded0?.append(string0)
                }
            }
        }
        iosPaths = iosPathsDecoded0
        let androidPathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .androidPaths)
        var androidPathsDecoded0:[Swift.String]? = nil
        if let androidPathsContainer = androidPathsContainer {
            androidPathsDecoded0 = [Swift.String]()
            for string0 in androidPathsContainer {
                if let string0 = string0 {
                    androidPathsDecoded0?.append(string0)
                }
            }
        }
        androidPaths = androidPathsDecoded0
        let deviceHostPathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceHostPaths)
        var deviceHostPathsDecoded0:[Swift.String]? = nil
        if let deviceHostPathsContainer = deviceHostPathsContainer {
            deviceHostPathsDecoded0 = [Swift.String]()
            for string0 in deviceHostPathsContainer {
                if let string0 = string0 {
                    deviceHostPathsDecoded0?.append(string0)
                }
            }
        }
        deviceHostPaths = deviceHostPathsDecoded0
    }
}

extension DeviceFarmClientTypes {
    /// A JSON object that specifies the paths where the artifacts generated by the customer's tests, on the device or in the test environment, are pulled from. Specify deviceHostPaths and optionally specify either iosPaths or androidPaths. For web app tests, you can specify both iosPaths and androidPaths.
    public struct CustomerArtifactPaths: Swift.Equatable {
        /// Comma-separated list of paths on the Android device where the artifacts generated by the customer's tests are pulled from.
        public var androidPaths: [Swift.String]?
        /// Comma-separated list of paths in the test execution environment where the artifacts generated by the customer's tests are pulled from.
        public var deviceHostPaths: [Swift.String]?
        /// Comma-separated list of paths on the iOS device where the artifacts generated by the customer's tests are pulled from.
        public var iosPaths: [Swift.String]?

        public init (
            androidPaths: [Swift.String]? = nil,
            deviceHostPaths: [Swift.String]? = nil,
            iosPaths: [Swift.String]? = nil
        )
        {
            self.androidPaths = androidPaths
            self.deviceHostPaths = deviceHostPaths
            self.iosPaths = iosPaths
        }
    }

}

extension DeleteDevicePoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteDevicePoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the delete device pool operation.
public struct DeleteDevicePoolInput: Swift.Equatable {
    /// Represents the Amazon Resource Name (ARN) of the Device Farm device pool to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteDevicePoolInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteDevicePoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteDevicePoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDevicePoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDevicePoolOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDevicePoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Represents the result of a delete device pool request.
public struct DeleteDevicePoolOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteInstanceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteInstanceProfileInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the instance profile you are requesting to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteInstanceProfileInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteInstanceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInstanceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteInstanceProfileOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInstanceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteInstanceProfileOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteNetworkProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteNetworkProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteNetworkProfileInput: Swift.Equatable {
    /// The ARN of the network profile to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteNetworkProfileInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteNetworkProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteNetworkProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNetworkProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteNetworkProfileOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNetworkProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteNetworkProfileOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the delete project operation.
public struct DeleteProjectInput: Swift.Equatable {
    /// Represents the Amazon Resource Name (ARN) of the Device Farm project to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteProjectOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Represents the result of a delete project request.
public struct DeleteProjectOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRemoteAccessSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteRemoteAccessSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the request to delete the specified remote access session.
public struct DeleteRemoteAccessSessionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the session for which you want to delete remote access.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteRemoteAccessSessionInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteRemoteAccessSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteRemoteAccessSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRemoteAccessSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRemoteAccessSessionOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRemoteAccessSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// The response from the server when a request is made to delete the remote access session.
public struct DeleteRemoteAccessSessionOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the delete run operation.
public struct DeleteRunInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the run to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteRunInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRunOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Represents the result of a delete run request.
public struct DeleteRunOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteTestGridProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectArn = self.projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
    }
}

extension DeleteTestGridProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteTestGridProjectInput: Swift.Equatable {
    /// The ARN of the project to delete, from [CreateTestGridProject] or [ListTestGridProjects].
    /// This member is required.
    public var projectArn: Swift.String?

    public init (
        projectArn: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
    }
}

struct DeleteTestGridProjectInputBody: Swift.Equatable {
    let projectArn: Swift.String?
}

extension DeleteTestGridProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

extension DeleteTestGridProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTestGridProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CannotDeleteException" : self = .cannotDeleteException(try CannotDeleteException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteTestGridProjectOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case cannotDeleteException(CannotDeleteException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTestGridProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTestGridProjectOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteUploadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the delete upload operation.
public struct DeleteUploadInput: Swift.Equatable {
    /// Represents the Amazon Resource Name (ARN) of the Device Farm upload to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteUploadInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteUploadOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Represents the result of a delete upload request.
public struct DeleteUploadOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteVPCEConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteVPCEConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteVPCEConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteVPCEConfigurationInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteVPCEConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteVPCEConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVPCEConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVPCEConfigurationOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case invalidOperationException(InvalidOperationException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVPCEConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVPCEConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeviceFarmClientTypes.Device: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case availability
        case carrier
        case cpu
        case fleetName
        case fleetType
        case formFactor
        case heapSize
        case image
        case instances
        case manufacturer
        case memory
        case model
        case modelId
        case name
        case os
        case platform
        case radio
        case remoteAccessEnabled
        case remoteDebugEnabled
        case resolution
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let availability = self.availability {
            try encodeContainer.encode(availability.rawValue, forKey: .availability)
        }
        if let carrier = self.carrier {
            try encodeContainer.encode(carrier, forKey: .carrier)
        }
        if let cpu = self.cpu {
            try encodeContainer.encode(cpu, forKey: .cpu)
        }
        if let fleetName = self.fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let fleetType = self.fleetType {
            try encodeContainer.encode(fleetType, forKey: .fleetType)
        }
        if let formFactor = self.formFactor {
            try encodeContainer.encode(formFactor.rawValue, forKey: .formFactor)
        }
        if let heapSize = self.heapSize {
            try encodeContainer.encode(heapSize, forKey: .heapSize)
        }
        if let image = self.image {
            try encodeContainer.encode(image, forKey: .image)
        }
        if let instances = instances {
            var instancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instances)
            for deviceinstance0 in instances {
                try instancesContainer.encode(deviceinstance0)
            }
        }
        if let manufacturer = self.manufacturer {
            try encodeContainer.encode(manufacturer, forKey: .manufacturer)
        }
        if let memory = self.memory {
            try encodeContainer.encode(memory, forKey: .memory)
        }
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let modelId = self.modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let os = self.os {
            try encodeContainer.encode(os, forKey: .os)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let radio = self.radio {
            try encodeContainer.encode(radio, forKey: .radio)
        }
        if let remoteAccessEnabled = self.remoteAccessEnabled {
            try encodeContainer.encode(remoteAccessEnabled, forKey: .remoteAccessEnabled)
        }
        if let remoteDebugEnabled = self.remoteDebugEnabled {
            try encodeContainer.encode(remoteDebugEnabled, forKey: .remoteDebugEnabled)
        }
        if let resolution = self.resolution {
            try encodeContainer.encode(resolution, forKey: .resolution)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let manufacturerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manufacturer)
        manufacturer = manufacturerDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let formFactorDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceFormFactor.self, forKey: .formFactor)
        formFactor = formFactorDecoded
        let platformDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DevicePlatform.self, forKey: .platform)
        platform = platformDecoded
        let osDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .os)
        os = osDecoded
        let cpuDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.CPU.self, forKey: .cpu)
        cpu = cpuDecoded
        let resolutionDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Resolution.self, forKey: .resolution)
        resolution = resolutionDecoded
        let heapSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .heapSize)
        heapSize = heapSizeDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memory)
        memory = memoryDecoded
        let imageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .image)
        image = imageDecoded
        let carrierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .carrier)
        carrier = carrierDecoded
        let radioDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .radio)
        radio = radioDecoded
        let remoteAccessEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remoteAccessEnabled)
        remoteAccessEnabled = remoteAccessEnabledDecoded
        let remoteDebugEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remoteDebugEnabled)
        remoteDebugEnabled = remoteDebugEnabledDecoded
        let fleetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetType)
        fleetType = fleetTypeDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let instancesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.DeviceInstance?].self, forKey: .instances)
        var instancesDecoded0:[DeviceFarmClientTypes.DeviceInstance]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [DeviceFarmClientTypes.DeviceInstance]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
        let availabilityDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceAvailability.self, forKey: .availability)
        availability = availabilityDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents a device type that an app is tested against.
    public struct Device: Swift.Equatable {
        /// The device's ARN.
        public var arn: Swift.String?
        /// Indicates how likely a device is available for a test run. Currently available in the [ListDevices] and GetDevice API methods.
        public var availability: DeviceFarmClientTypes.DeviceAvailability?
        /// The device's carrier.
        public var carrier: Swift.String?
        /// Information about the device's CPU.
        public var cpu: DeviceFarmClientTypes.CPU?
        /// The name of the fleet to which this device belongs.
        public var fleetName: Swift.String?
        /// The type of fleet to which this device belongs. Possible values are PRIVATE and PUBLIC.
        public var fleetType: Swift.String?
        /// The device's form factor. Allowed values include:
        ///
        /// * PHONE
        ///
        /// * TABLET
        public var formFactor: DeviceFarmClientTypes.DeviceFormFactor?
        /// The device's heap size, expressed in bytes.
        public var heapSize: Swift.Int?
        /// The device's image name.
        public var image: Swift.String?
        /// The instances that belong to this device.
        public var instances: [DeviceFarmClientTypes.DeviceInstance]?
        /// The device's manufacturer name.
        public var manufacturer: Swift.String?
        /// The device's total memory size, expressed in bytes.
        public var memory: Swift.Int?
        /// The device's model name.
        public var model: Swift.String?
        /// The device's model ID.
        public var modelId: Swift.String?
        /// The device's display name.
        public var name: Swift.String?
        /// The device's operating system type.
        public var os: Swift.String?
        /// The device's platform. Allowed values include:
        ///
        /// * ANDROID
        ///
        /// * IOS
        public var platform: DeviceFarmClientTypes.DevicePlatform?
        /// The device's radio.
        public var radio: Swift.String?
        /// Specifies whether remote access has been enabled for the specified device.
        public var remoteAccessEnabled: Swift.Bool?
        /// This flag is set to true if remote debugging is enabled for the device. Remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html).
        public var remoteDebugEnabled: Swift.Bool?
        /// The resolution of the device.
        public var resolution: DeviceFarmClientTypes.Resolution?

        public init (
            arn: Swift.String? = nil,
            availability: DeviceFarmClientTypes.DeviceAvailability? = nil,
            carrier: Swift.String? = nil,
            cpu: DeviceFarmClientTypes.CPU? = nil,
            fleetName: Swift.String? = nil,
            fleetType: Swift.String? = nil,
            formFactor: DeviceFarmClientTypes.DeviceFormFactor? = nil,
            heapSize: Swift.Int? = nil,
            image: Swift.String? = nil,
            instances: [DeviceFarmClientTypes.DeviceInstance]? = nil,
            manufacturer: Swift.String? = nil,
            memory: Swift.Int? = nil,
            model: Swift.String? = nil,
            modelId: Swift.String? = nil,
            name: Swift.String? = nil,
            os: Swift.String? = nil,
            platform: DeviceFarmClientTypes.DevicePlatform? = nil,
            radio: Swift.String? = nil,
            remoteAccessEnabled: Swift.Bool? = nil,
            remoteDebugEnabled: Swift.Bool? = nil,
            resolution: DeviceFarmClientTypes.Resolution? = nil
        )
        {
            self.arn = arn
            self.availability = availability
            self.carrier = carrier
            self.cpu = cpu
            self.fleetName = fleetName
            self.fleetType = fleetType
            self.formFactor = formFactor
            self.heapSize = heapSize
            self.image = image
            self.instances = instances
            self.manufacturer = manufacturer
            self.memory = memory
            self.model = model
            self.modelId = modelId
            self.name = name
            self.os = os
            self.platform = platform
            self.radio = radio
            self.remoteAccessEnabled = remoteAccessEnabled
            self.remoteDebugEnabled = remoteDebugEnabled
            self.resolution = resolution
        }
    }

}

extension DeviceFarmClientTypes {
    public enum DeviceAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appiumVersion
        case arn
        case availability
        case fleetType
        case formFactor
        case instanceArn
        case instanceLabels
        case manufacturer
        case model
        case osVersion
        case platform
        case remoteAccessEnabled
        case remoteDebugEnabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceAttribute] {
            return [
                .appiumVersion,
                .arn,
                .availability,
                .fleetType,
                .formFactor,
                .instanceArn,
                .instanceLabels,
                .manufacturer,
                .model,
                .osVersion,
                .platform,
                .remoteAccessEnabled,
                .remoteDebugEnabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appiumVersion: return "APPIUM_VERSION"
            case .arn: return "ARN"
            case .availability: return "AVAILABILITY"
            case .fleetType: return "FLEET_TYPE"
            case .formFactor: return "FORM_FACTOR"
            case .instanceArn: return "INSTANCE_ARN"
            case .instanceLabels: return "INSTANCE_LABELS"
            case .manufacturer: return "MANUFACTURER"
            case .model: return "MODEL"
            case .osVersion: return "OS_VERSION"
            case .platform: return "PLATFORM"
            case .remoteAccessEnabled: return "REMOTE_ACCESS_ENABLED"
            case .remoteDebugEnabled: return "REMOTE_DEBUG_ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceAttribute(rawValue: rawValue) ?? DeviceAttribute.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum DeviceAvailability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case busy
        case highlyAvailable
        case temporaryNotAvailable
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceAvailability] {
            return [
                .available,
                .busy,
                .highlyAvailable,
                .temporaryNotAvailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .busy: return "BUSY"
            case .highlyAvailable: return "HIGHLY_AVAILABLE"
            case .temporaryNotAvailable: return "TEMPORARY_NOT_AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceAvailability(rawValue: rawValue) ?? DeviceAvailability.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.DeviceFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string0 in values {
                try valuesContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceFilterAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.RuleOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension DeviceFarmClientTypes {
    /// Represents a device filter used to select a set of devices to be included in a test run. This data structure is passed in as the deviceSelectionConfiguration parameter to ScheduleRun. For an example of the JSON request syntax, see [ScheduleRun]. It is also passed in as the filters parameter to ListDevices. For an example of the JSON request syntax, see [ListDevices].
    public struct DeviceFilter: Swift.Equatable {
        /// The aspect of a device such as platform or model used as the selection criteria in a device filter. The supported operators for each attribute are provided in the following list. ARN The Amazon Resource Name (ARN) of the device (for example, arn:aws:devicefarm:us-west-2::device:12345Example). Supported operators: EQUALS, IN, NOT_IN PLATFORM The device platform. Valid values are ANDROID or IOS. Supported operators: EQUALS OS_VERSION The operating system version (for example, 10.3.2). Supported operators: EQUALS, GREATER_THAN, GREATER_THAN_OR_EQUALS, IN, LESS_THAN, LESS_THAN_OR_EQUALS, NOT_IN MODEL The device model (for example, iPad 5th Gen). Supported operators: CONTAINS, EQUALS, IN, NOT_IN AVAILABILITY The current availability of the device. Valid values are AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE. Supported operators: EQUALS FORM_FACTOR The device form factor. Valid values are PHONE or TABLET. Supported operators: EQUALS MANUFACTURER The device manufacturer (for example, Apple). Supported operators: EQUALS, IN, NOT_IN REMOTE_ACCESS_ENABLED Whether the device is enabled for remote access. Valid values are TRUE or FALSE. Supported operators: EQUALS REMOTE_DEBUG_ENABLED Whether the device is enabled for remote debugging. Valid values are TRUE or FALSE. Supported operators: EQUALS Because remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html), this filter is ignored. INSTANCE_ARN The Amazon Resource Name (ARN) of the device instance. Supported operators: EQUALS, IN, NOT_IN INSTANCE_LABELS The label of the device instance. Supported operators: CONTAINS FLEET_TYPE The fleet type. Valid values are PUBLIC or PRIVATE. Supported operators: EQUALS
        /// This member is required.
        public var attribute: DeviceFarmClientTypes.DeviceFilterAttribute?
        /// Specifies how Device Farm compares the filter's attribute to the value. See the attribute descriptions.
        /// This member is required.
        public var `operator`: DeviceFarmClientTypes.RuleOperator?
        /// An array of one or more filter values used in a device filter. Operator Values
        ///
        /// * The IN and NOT_IN operators can take a values array that has more than one element.
        ///
        /// * The other operators require an array with a single element.
        ///
        ///
        /// Attribute Values
        ///
        /// * The PLATFORM attribute can be set to ANDROID or IOS.
        ///
        /// * The AVAILABILITY attribute can be set to AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.
        ///
        /// * The FORM_FACTOR attribute can be set to PHONE or TABLET.
        ///
        /// * The FLEET_TYPE attribute can be set to PUBLIC or PRIVATE.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            attribute: DeviceFarmClientTypes.DeviceFilterAttribute? = nil,
            `operator`: DeviceFarmClientTypes.RuleOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.attribute = attribute
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension DeviceFarmClientTypes {
    public enum DeviceFilterAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arn
        case availability
        case fleetType
        case formFactor
        case instanceArn
        case instanceLabels
        case manufacturer
        case model
        case osVersion
        case platform
        case remoteAccessEnabled
        case remoteDebugEnabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceFilterAttribute] {
            return [
                .arn,
                .availability,
                .fleetType,
                .formFactor,
                .instanceArn,
                .instanceLabels,
                .manufacturer,
                .model,
                .osVersion,
                .platform,
                .remoteAccessEnabled,
                .remoteDebugEnabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arn: return "ARN"
            case .availability: return "AVAILABILITY"
            case .fleetType: return "FLEET_TYPE"
            case .formFactor: return "FORM_FACTOR"
            case .instanceArn: return "INSTANCE_ARN"
            case .instanceLabels: return "INSTANCE_LABELS"
            case .manufacturer: return "MANUFACTURER"
            case .model: return "MODEL"
            case .osVersion: return "OS_VERSION"
            case .platform: return "PLATFORM"
            case .remoteAccessEnabled: return "REMOTE_ACCESS_ENABLED"
            case .remoteDebugEnabled: return "REMOTE_DEBUG_ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceFilterAttribute(rawValue: rawValue) ?? DeviceFilterAttribute.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum DeviceFormFactor: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case phone
        case tablet
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceFormFactor] {
            return [
                .phone,
                .tablet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .phone: return "PHONE"
            case .tablet: return "TABLET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceFormFactor(rawValue: rawValue) ?? DeviceFormFactor.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.DeviceInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case deviceArn
        case instanceProfile
        case labels
        case status
        case udid
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let deviceArn = self.deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let instanceProfile = self.instanceProfile {
            try encodeContainer.encode(instanceProfile, forKey: .instanceProfile)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for string0 in labels {
                try labelsContainer.encode(string0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let udid = self.udid {
            try encodeContainer.encode(udid, forKey: .udid)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.InstanceStatus.self, forKey: .status)
        status = statusDecoded
        let udidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .udid)
        udid = udidDecoded
        let instanceProfileDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents the device instance.
    public struct DeviceInstance: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the device instance.
        public var arn: Swift.String?
        /// The ARN of the device.
        public var deviceArn: Swift.String?
        /// A object that contains information about the instance profile.
        public var instanceProfile: DeviceFarmClientTypes.InstanceProfile?
        /// An array of strings that describe the device instance.
        public var labels: [Swift.String]?
        /// The status of the device instance. Valid values are listed here.
        public var status: DeviceFarmClientTypes.InstanceStatus?
        /// Unique device identifier for the device instance.
        public var udid: Swift.String?

        public init (
            arn: Swift.String? = nil,
            deviceArn: Swift.String? = nil,
            instanceProfile: DeviceFarmClientTypes.InstanceProfile? = nil,
            labels: [Swift.String]? = nil,
            status: DeviceFarmClientTypes.InstanceStatus? = nil,
            udid: Swift.String? = nil
        )
        {
            self.arn = arn
            self.deviceArn = deviceArn
            self.instanceProfile = instanceProfile
            self.labels = labels
            self.status = status
            self.udid = udid
        }
    }

}

extension DeviceFarmClientTypes.DeviceMinutes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metered
        case total
        case unmetered
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metered = self.metered {
            try encodeContainer.encode(metered, forKey: .metered)
        }
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
        if let unmetered = self.unmetered {
            try encodeContainer.encode(unmetered, forKey: .unmetered)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .total)
        total = totalDecoded
        let meteredDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .metered)
        metered = meteredDecoded
        let unmeteredDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .unmetered)
        unmetered = unmeteredDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents the total (metered or unmetered) minutes used by the resource to run tests. Contains the sum of minutes consumed by all children.
    public struct DeviceMinutes: Swift.Equatable {
        /// When specified, represents only the sum of metered minutes used by the resource to run tests.
        public var metered: Swift.Double?
        /// When specified, represents the total minutes used by the resource to run tests.
        public var total: Swift.Double?
        /// When specified, represents only the sum of unmetered minutes used by the resource to run tests.
        public var unmetered: Swift.Double?

        public init (
            metered: Swift.Double? = nil,
            total: Swift.Double? = nil,
            unmetered: Swift.Double? = nil
        )
        {
            self.metered = metered
            self.total = total
            self.unmetered = unmetered
        }
    }

}

extension DeviceFarmClientTypes {
    public enum DevicePlatform: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case android
        case ios
        case sdkUnknown(Swift.String)

        public static var allCases: [DevicePlatform] {
            return [
                .android,
                .ios,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .android: return "ANDROID"
            case .ios: return "IOS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DevicePlatform(rawValue: rawValue) ?? DevicePlatform.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.DevicePool: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case maxDevices
        case name
        case rules
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let maxDevices = self.maxDevices {
            try encodeContainer.encode(maxDevices, forKey: .maxDevices)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rule0 in rules {
                try rulesContainer.encode(rule0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DevicePoolType.self, forKey: .type)
        type = typeDecoded
        let rulesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[DeviceFarmClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [DeviceFarmClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let maxDevicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDevices)
        maxDevices = maxDevicesDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents a collection of device types.
    public struct DevicePool: Swift.Equatable {
        /// The device pool's ARN.
        public var arn: Swift.String?
        /// The device pool's description.
        public var description: Swift.String?
        /// The number of devices that Device Farm can add to your device pool. Device Farm adds devices that are available and meet the criteria that you assign for the rules parameter. Depending on how many devices meet these constraints, your device pool might contain fewer devices than the value for this parameter. By specifying the maximum number of devices, you can control the costs that you incur by running tests.
        public var maxDevices: Swift.Int?
        /// The device pool's name.
        public var name: Swift.String?
        /// Information about the device pool's rules.
        public var rules: [DeviceFarmClientTypes.Rule]?
        /// The device pool's type. Allowed values include:
        ///
        /// * CURATED: A device pool that is created and managed by AWS Device Farm.
        ///
        /// * PRIVATE: A device pool that is created and managed by the device pool developer.
        public var type: DeviceFarmClientTypes.DevicePoolType?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            maxDevices: Swift.Int? = nil,
            name: Swift.String? = nil,
            rules: [DeviceFarmClientTypes.Rule]? = nil,
            type: DeviceFarmClientTypes.DevicePoolType? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.maxDevices = maxDevices
            self.name = name
            self.rules = rules
            self.type = type
        }
    }

}

extension DeviceFarmClientTypes.DevicePoolCompatibilityResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatible
        case device
        case incompatibilityMessages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatible = self.compatible {
            try encodeContainer.encode(compatible, forKey: .compatible)
        }
        if let device = self.device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let incompatibilityMessages = incompatibilityMessages {
            var incompatibilityMessagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .incompatibilityMessages)
            for incompatibilitymessage0 in incompatibilityMessages {
                try incompatibilityMessagesContainer.encode(incompatibilitymessage0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
        let compatibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .compatible)
        compatible = compatibleDecoded
        let incompatibilityMessagesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.IncompatibilityMessage?].self, forKey: .incompatibilityMessages)
        var incompatibilityMessagesDecoded0:[DeviceFarmClientTypes.IncompatibilityMessage]? = nil
        if let incompatibilityMessagesContainer = incompatibilityMessagesContainer {
            incompatibilityMessagesDecoded0 = [DeviceFarmClientTypes.IncompatibilityMessage]()
            for structure0 in incompatibilityMessagesContainer {
                if let structure0 = structure0 {
                    incompatibilityMessagesDecoded0?.append(structure0)
                }
            }
        }
        incompatibilityMessages = incompatibilityMessagesDecoded0
    }
}

extension DeviceFarmClientTypes {
    /// Represents a device pool compatibility result.
    public struct DevicePoolCompatibilityResult: Swift.Equatable {
        /// Whether the result was compatible with the device pool.
        public var compatible: Swift.Bool?
        /// The device (phone or tablet) to return information about.
        public var device: DeviceFarmClientTypes.Device?
        /// Information about the compatibility.
        public var incompatibilityMessages: [DeviceFarmClientTypes.IncompatibilityMessage]?

        public init (
            compatible: Swift.Bool? = nil,
            device: DeviceFarmClientTypes.Device? = nil,
            incompatibilityMessages: [DeviceFarmClientTypes.IncompatibilityMessage]? = nil
        )
        {
            self.compatible = compatible
            self.device = device
            self.incompatibilityMessages = incompatibilityMessages
        }
    }

}

extension DeviceFarmClientTypes {
    public enum DevicePoolType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case curated
        case `private`
        case sdkUnknown(Swift.String)

        public static var allCases: [DevicePoolType] {
            return [
                .curated,
                .private,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .curated: return "CURATED"
            case .private: return "PRIVATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DevicePoolType(rawValue: rawValue) ?? DevicePoolType.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.DeviceSelectionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxDevices
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for devicefilter0 in filters {
                try filtersContainer.encode(devicefilter0)
            }
        }
        if let maxDevices = self.maxDevices {
            try encodeContainer.encode(maxDevices, forKey: .maxDevices)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.DeviceFilter?].self, forKey: .filters)
        var filtersDecoded0:[DeviceFarmClientTypes.DeviceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DeviceFarmClientTypes.DeviceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxDevicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDevices)
        maxDevices = maxDevicesDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents the device filters used in a test run and the maximum number of devices to be included in the run. It is passed in as the deviceSelectionConfiguration request parameter in [ScheduleRun].
    public struct DeviceSelectionConfiguration: Swift.Equatable {
        /// Used to dynamically select a set of devices for a test run. A filter is made up of an attribute, an operator, and one or more values.
        ///
        /// * Attribute The aspect of a device such as platform or model used as the selection criteria in a device filter. Allowed values include:
        ///
        /// * ARN: The Amazon Resource Name (ARN) of the device (for example, arn:aws:devicefarm:us-west-2::device:12345Example).
        ///
        /// * PLATFORM: The device platform. Valid values are ANDROID or IOS.
        ///
        /// * OS_VERSION: The operating system version (for example, 10.3.2).
        ///
        /// * MODEL: The device model (for example, iPad 5th Gen).
        ///
        /// * AVAILABILITY: The current availability of the device. Valid values are AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.
        ///
        /// * FORM_FACTOR: The device form factor. Valid values are PHONE or TABLET.
        ///
        /// * MANUFACTURER: The device manufacturer (for example, Apple).
        ///
        /// * REMOTE_ACCESS_ENABLED: Whether the device is enabled for remote access. Valid values are TRUE or FALSE.
        ///
        /// * REMOTE_DEBUG_ENABLED: Whether the device is enabled for remote debugging. Valid values are TRUE or FALSE. Because remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html), this filter is ignored.
        ///
        /// * INSTANCE_ARN: The Amazon Resource Name (ARN) of the device instance.
        ///
        /// * INSTANCE_LABELS: The label of the device instance.
        ///
        /// * FLEET_TYPE: The fleet type. Valid values are PUBLIC or PRIVATE.
        ///
        ///
        ///
        ///
        /// * Operator The filter operator.
        ///
        /// * The EQUALS operator is available for every attribute except INSTANCE_LABELS.
        ///
        /// * The CONTAINS operator is available for the INSTANCE_LABELS and MODEL attributes.
        ///
        /// * The IN and NOT_IN operators are available for the ARN, OS_VERSION, MODEL, MANUFACTURER, and INSTANCE_ARN attributes.
        ///
        /// * The LESS_THAN, GREATER_THAN, LESS_THAN_OR_EQUALS, and GREATER_THAN_OR_EQUALS operators are also available for the OS_VERSION attribute.
        ///
        ///
        ///
        ///
        /// * Values An array of one or more filter values. Operator Values
        ///
        /// * The IN and NOT_IN operators can take a values array that has more than one element.
        ///
        /// * The other operators require an array with a single element.
        ///
        ///
        /// Attribute Values
        ///
        /// * The PLATFORM attribute can be set to ANDROID or IOS.
        ///
        /// * The AVAILABILITY attribute can be set to AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.
        ///
        /// * The FORM_FACTOR attribute can be set to PHONE or TABLET.
        ///
        /// * The FLEET_TYPE attribute can be set to PUBLIC or PRIVATE.
        /// This member is required.
        public var filters: [DeviceFarmClientTypes.DeviceFilter]?
        /// The maximum number of devices to be included in a test run.
        /// This member is required.
        public var maxDevices: Swift.Int?

        public init (
            filters: [DeviceFarmClientTypes.DeviceFilter]? = nil,
            maxDevices: Swift.Int? = nil
        )
        {
            self.filters = filters
            self.maxDevices = maxDevices
        }
    }

}

extension DeviceFarmClientTypes.DeviceSelectionResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case matchedDevicesCount
        case maxDevices
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for devicefilter0 in filters {
                try filtersContainer.encode(devicefilter0)
            }
        }
        if let matchedDevicesCount = self.matchedDevicesCount {
            try encodeContainer.encode(matchedDevicesCount, forKey: .matchedDevicesCount)
        }
        if let maxDevices = self.maxDevices {
            try encodeContainer.encode(maxDevices, forKey: .maxDevices)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.DeviceFilter?].self, forKey: .filters)
        var filtersDecoded0:[DeviceFarmClientTypes.DeviceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DeviceFarmClientTypes.DeviceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let matchedDevicesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .matchedDevicesCount)
        matchedDevicesCount = matchedDevicesCountDecoded
        let maxDevicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDevices)
        maxDevices = maxDevicesDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Contains the run results requested by the device selection configuration and how many devices were returned. For an example of the JSON response syntax, see [ScheduleRun].
    public struct DeviceSelectionResult: Swift.Equatable {
        /// The filters in a device selection result.
        public var filters: [DeviceFarmClientTypes.DeviceFilter]?
        /// The number of devices that matched the device filter selection criteria.
        public var matchedDevicesCount: Swift.Int?
        /// The maximum number of devices to be selected by a device filter and included in a test run.
        public var maxDevices: Swift.Int?

        public init (
            filters: [DeviceFarmClientTypes.DeviceFilter]? = nil,
            matchedDevicesCount: Swift.Int? = nil,
            maxDevices: Swift.Int? = nil
        )
        {
            self.filters = filters
            self.matchedDevicesCount = matchedDevicesCount
            self.maxDevices = maxDevices
        }
    }

}

extension DeviceFarmClientTypes.ExecutionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountsCleanup
        case appPackagesCleanup
        case jobTimeoutMinutes
        case skipAppResign
        case videoCapture
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountsCleanup = self.accountsCleanup {
            try encodeContainer.encode(accountsCleanup, forKey: .accountsCleanup)
        }
        if let appPackagesCleanup = self.appPackagesCleanup {
            try encodeContainer.encode(appPackagesCleanup, forKey: .appPackagesCleanup)
        }
        if let jobTimeoutMinutes = self.jobTimeoutMinutes {
            try encodeContainer.encode(jobTimeoutMinutes, forKey: .jobTimeoutMinutes)
        }
        if let skipAppResign = self.skipAppResign {
            try encodeContainer.encode(skipAppResign, forKey: .skipAppResign)
        }
        if let videoCapture = self.videoCapture {
            try encodeContainer.encode(videoCapture, forKey: .videoCapture)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .jobTimeoutMinutes)
        jobTimeoutMinutes = jobTimeoutMinutesDecoded
        let accountsCleanupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .accountsCleanup)
        accountsCleanup = accountsCleanupDecoded
        let appPackagesCleanupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .appPackagesCleanup)
        appPackagesCleanup = appPackagesCleanupDecoded
        let videoCaptureDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .videoCapture)
        videoCapture = videoCaptureDecoded
        let skipAppResignDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .skipAppResign)
        skipAppResign = skipAppResignDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents configuration information about a test run, such as the execution timeout (in minutes).
    public struct ExecutionConfiguration: Swift.Equatable {
        /// True if account cleanup is enabled at the beginning of the test. Otherwise, false.
        public var accountsCleanup: Swift.Bool?
        /// True if app package cleanup is enabled at the beginning of the test. Otherwise, false.
        public var appPackagesCleanup: Swift.Bool?
        /// The number of minutes a test run executes before it times out.
        public var jobTimeoutMinutes: Swift.Int?
        /// When set to true, for private devices, Device Farm does not sign your app again. For public devices, Device Farm always signs your apps again. For more information about how Device Farm re-signs your apps, see [Do you modify my app?](http://aws.amazon.com/device-farm/faqs/) in the AWS Device Farm FAQs.
        public var skipAppResign: Swift.Bool?
        /// Set to true to enable video capture. Otherwise, set to false. The default is true.
        public var videoCapture: Swift.Bool?

        public init (
            accountsCleanup: Swift.Bool? = nil,
            appPackagesCleanup: Swift.Bool? = nil,
            jobTimeoutMinutes: Swift.Int? = nil,
            skipAppResign: Swift.Bool? = nil,
            videoCapture: Swift.Bool? = nil
        )
        {
            self.accountsCleanup = accountsCleanup
            self.appPackagesCleanup = appPackagesCleanup
            self.jobTimeoutMinutes = jobTimeoutMinutes
            self.skipAppResign = skipAppResign
            self.videoCapture = videoCapture
        }
    }

}

extension DeviceFarmClientTypes {
    public enum ExecutionResult: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case errored
        case failed
        case passed
        case pending
        case skipped
        case stopped
        case warned
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionResult] {
            return [
                .errored,
                .failed,
                .passed,
                .pending,
                .skipped,
                .stopped,
                .warned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .errored: return "ERRORED"
            case .failed: return "FAILED"
            case .passed: return "PASSED"
            case .pending: return "PENDING"
            case .skipped: return "SKIPPED"
            case .stopped: return "STOPPED"
            case .warned: return "WARNED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionResult(rawValue: rawValue) ?? ExecutionResult.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum ExecutionResultCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case parsingFailed
        case vpcEndpointSetupFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionResultCode] {
            return [
                .parsingFailed,
                .vpcEndpointSetupFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .parsingFailed: return "PARSING_FAILED"
            case .vpcEndpointSetupFailed: return "VPC_ENDPOINT_SETUP_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionResultCode(rawValue: rawValue) ?? ExecutionResultCode.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum ExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case pending
        case pendingConcurrnecy
        case pendingDevice
        case preparing
        case processing
        case running
        case scheduling
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatus] {
            return [
                .completed,
                .pending,
                .pendingConcurrnecy,
                .pendingDevice,
                .preparing,
                .processing,
                .running,
                .scheduling,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .pending: return "PENDING"
            case .pendingConcurrnecy: return "PENDING_CONCURRENCY"
            case .pendingDevice: return "PENDING_DEVICE"
            case .preparing: return "PREPARING"
            case .processing: return "PROCESSING"
            case .running: return "RUNNING"
            case .scheduling: return "SCHEDULING"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionStatus(rawValue: rawValue) ?? ExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension GetAccountSettingsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetAccountSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the request sent to retrieve the account settings.
public struct GetAccountSettingsInput: Swift.Equatable {

    public init () { }
}

struct GetAccountSettingsInputBody: Swift.Equatable {
}

extension GetAccountSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccountSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAccountSettingsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAccountSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountSettings = output.accountSettings
        } else {
            self.accountSettings = nil
        }
    }
}

/// Represents the account settings return values from the GetAccountSettings request.
public struct GetAccountSettingsOutputResponse: Swift.Equatable {
    /// The account settings.
    public var accountSettings: DeviceFarmClientTypes.AccountSettings?

    public init (
        accountSettings: DeviceFarmClientTypes.AccountSettings? = nil
    )
    {
        self.accountSettings = accountSettings
    }
}

struct GetAccountSettingsOutputResponseBody: Swift.Equatable {
    let accountSettings: DeviceFarmClientTypes.AccountSettings?
}

extension GetAccountSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSettingsDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.AccountSettings.self, forKey: .accountSettings)
        accountSettings = accountSettingsDecoded
    }
}

extension GetDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the get device request.
public struct GetDeviceInput: Swift.Equatable {
    /// The device type's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetDeviceInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetDeviceInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetDeviceInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDeviceInstanceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the instance you're requesting information about.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetDeviceInstanceInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetDeviceInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetDeviceInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDeviceInstanceOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDeviceInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceInstance = output.deviceInstance
        } else {
            self.deviceInstance = nil
        }
    }
}

public struct GetDeviceInstanceOutputResponse: Swift.Equatable {
    /// An object that contains information about your device instance.
    public var deviceInstance: DeviceFarmClientTypes.DeviceInstance?

    public init (
        deviceInstance: DeviceFarmClientTypes.DeviceInstance? = nil
    )
    {
        self.deviceInstance = deviceInstance
    }
}

struct GetDeviceInstanceOutputResponseBody: Swift.Equatable {
    let deviceInstance: DeviceFarmClientTypes.DeviceInstance?
}

extension GetDeviceInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceInstance
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceInstanceDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceInstance.self, forKey: .deviceInstance)
        deviceInstance = deviceInstanceDecoded
    }
}

extension GetDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDeviceOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

/// Represents the result of a get device request.
public struct GetDeviceOutputResponse: Swift.Equatable {
    /// An object that contains information about the requested device.
    public var device: DeviceFarmClientTypes.Device?

    public init (
        device: DeviceFarmClientTypes.Device? = nil
    )
    {
        self.device = device
    }
}

struct GetDeviceOutputResponseBody: Swift.Equatable {
    let device: DeviceFarmClientTypes.Device?
}

extension GetDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case device
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
    }
}

extension GetDevicePoolCompatibilityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case configuration
        case devicePoolArn
        case test
        case testType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let devicePoolArn = self.devicePoolArn {
            try encodeContainer.encode(devicePoolArn, forKey: .devicePoolArn)
        }
        if let test = self.test {
            try encodeContainer.encode(test, forKey: .test)
        }
        if let testType = self.testType {
            try encodeContainer.encode(testType.rawValue, forKey: .testType)
        }
    }
}

extension GetDevicePoolCompatibilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the get device pool compatibility operation.
public struct GetDevicePoolCompatibilityInput: Swift.Equatable {
    /// The ARN of the app that is associated with the specified device pool.
    public var appArn: Swift.String?
    /// An object that contains information about the settings for a run.
    public var configuration: DeviceFarmClientTypes.ScheduleRunConfiguration?
    /// The device pool's ARN.
    /// This member is required.
    public var devicePoolArn: Swift.String?
    /// Information about the uploaded test to be run against the device pool.
    public var test: DeviceFarmClientTypes.ScheduleRunTest?
    /// The test type for the specified device pool. Allowed values include the following:
    ///
    /// * BUILTIN_FUZZ.
    ///
    /// * BUILTIN_EXPLORER. For Android, an app explorer that traverses an Android app, interacting with it and capturing screenshots at the same time.
    ///
    /// * APPIUM_JAVA_JUNIT.
    ///
    /// * APPIUM_JAVA_TESTNG.
    ///
    /// * APPIUM_PYTHON.
    ///
    /// * APPIUM_NODE.
    ///
    /// * APPIUM_RUBY.
    ///
    /// * APPIUM_WEB_JAVA_JUNIT.
    ///
    /// * APPIUM_WEB_JAVA_TESTNG.
    ///
    /// * APPIUM_WEB_PYTHON.
    ///
    /// * APPIUM_WEB_NODE.
    ///
    /// * APPIUM_WEB_RUBY.
    ///
    /// * CALABASH.
    ///
    /// * INSTRUMENTATION.
    ///
    /// * UIAUTOMATION.
    ///
    /// * UIAUTOMATOR.
    ///
    /// * XCTEST.
    ///
    /// * XCTEST_UI.
    public var testType: DeviceFarmClientTypes.TestType?

    public init (
        appArn: Swift.String? = nil,
        configuration: DeviceFarmClientTypes.ScheduleRunConfiguration? = nil,
        devicePoolArn: Swift.String? = nil,
        test: DeviceFarmClientTypes.ScheduleRunTest? = nil,
        testType: DeviceFarmClientTypes.TestType? = nil
    )
    {
        self.appArn = appArn
        self.configuration = configuration
        self.devicePoolArn = devicePoolArn
        self.test = test
        self.testType = testType
    }
}

struct GetDevicePoolCompatibilityInputBody: Swift.Equatable {
    let devicePoolArn: Swift.String?
    let appArn: Swift.String?
    let testType: DeviceFarmClientTypes.TestType?
    let test: DeviceFarmClientTypes.ScheduleRunTest?
    let configuration: DeviceFarmClientTypes.ScheduleRunConfiguration?
}

extension GetDevicePoolCompatibilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case configuration
        case devicePoolArn
        case test
        case testType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePoolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devicePoolArn)
        devicePoolArn = devicePoolArnDecoded
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let testTypeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestType.self, forKey: .testType)
        testType = testTypeDecoded
        let testDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ScheduleRunTest.self, forKey: .test)
        test = testDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ScheduleRunConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension GetDevicePoolCompatibilityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDevicePoolCompatibilityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDevicePoolCompatibilityOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDevicePoolCompatibilityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDevicePoolCompatibilityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.compatibleDevices = output.compatibleDevices
            self.incompatibleDevices = output.incompatibleDevices
        } else {
            self.compatibleDevices = nil
            self.incompatibleDevices = nil
        }
    }
}

/// Represents the result of describe device pool compatibility request.
public struct GetDevicePoolCompatibilityOutputResponse: Swift.Equatable {
    /// Information about compatible devices.
    public var compatibleDevices: [DeviceFarmClientTypes.DevicePoolCompatibilityResult]?
    /// Information about incompatible devices.
    public var incompatibleDevices: [DeviceFarmClientTypes.DevicePoolCompatibilityResult]?

    public init (
        compatibleDevices: [DeviceFarmClientTypes.DevicePoolCompatibilityResult]? = nil,
        incompatibleDevices: [DeviceFarmClientTypes.DevicePoolCompatibilityResult]? = nil
    )
    {
        self.compatibleDevices = compatibleDevices
        self.incompatibleDevices = incompatibleDevices
    }
}

struct GetDevicePoolCompatibilityOutputResponseBody: Swift.Equatable {
    let compatibleDevices: [DeviceFarmClientTypes.DevicePoolCompatibilityResult]?
    let incompatibleDevices: [DeviceFarmClientTypes.DevicePoolCompatibilityResult]?
}

extension GetDevicePoolCompatibilityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleDevices
        case incompatibleDevices
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compatibleDevicesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.DevicePoolCompatibilityResult?].self, forKey: .compatibleDevices)
        var compatibleDevicesDecoded0:[DeviceFarmClientTypes.DevicePoolCompatibilityResult]? = nil
        if let compatibleDevicesContainer = compatibleDevicesContainer {
            compatibleDevicesDecoded0 = [DeviceFarmClientTypes.DevicePoolCompatibilityResult]()
            for structure0 in compatibleDevicesContainer {
                if let structure0 = structure0 {
                    compatibleDevicesDecoded0?.append(structure0)
                }
            }
        }
        compatibleDevices = compatibleDevicesDecoded0
        let incompatibleDevicesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.DevicePoolCompatibilityResult?].self, forKey: .incompatibleDevices)
        var incompatibleDevicesDecoded0:[DeviceFarmClientTypes.DevicePoolCompatibilityResult]? = nil
        if let incompatibleDevicesContainer = incompatibleDevicesContainer {
            incompatibleDevicesDecoded0 = [DeviceFarmClientTypes.DevicePoolCompatibilityResult]()
            for structure0 in incompatibleDevicesContainer {
                if let structure0 = structure0 {
                    incompatibleDevicesDecoded0?.append(structure0)
                }
            }
        }
        incompatibleDevices = incompatibleDevicesDecoded0
    }
}

extension GetDevicePoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetDevicePoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the get device pool operation.
public struct GetDevicePoolInput: Swift.Equatable {
    /// The device pool's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetDevicePoolInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetDevicePoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetDevicePoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDevicePoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDevicePoolOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDevicePoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDevicePoolOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devicePool = output.devicePool
        } else {
            self.devicePool = nil
        }
    }
}

/// Represents the result of a get device pool request.
public struct GetDevicePoolOutputResponse: Swift.Equatable {
    /// An object that contains information about the requested device pool.
    public var devicePool: DeviceFarmClientTypes.DevicePool?

    public init (
        devicePool: DeviceFarmClientTypes.DevicePool? = nil
    )
    {
        self.devicePool = devicePool
    }
}

struct GetDevicePoolOutputResponseBody: Swift.Equatable {
    let devicePool: DeviceFarmClientTypes.DevicePool?
}

extension GetDevicePoolOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePool
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePoolDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DevicePool.self, forKey: .devicePool)
        devicePool = devicePoolDecoded
    }
}

extension GetInstanceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetInstanceProfileInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of an instance profile.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetInstanceProfileInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetInstanceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInstanceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetInstanceProfileOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInstanceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetInstanceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceProfile = output.instanceProfile
        } else {
            self.instanceProfile = nil
        }
    }
}

public struct GetInstanceProfileOutputResponse: Swift.Equatable {
    /// An object that contains information about an instance profile.
    public var instanceProfile: DeviceFarmClientTypes.InstanceProfile?

    public init (
        instanceProfile: DeviceFarmClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

struct GetInstanceProfileOutputResponseBody: Swift.Equatable {
    let instanceProfile: DeviceFarmClientTypes.InstanceProfile?
}

extension GetInstanceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

extension GetJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the get job operation.
public struct GetJobInput: Swift.Equatable {
    /// The job's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetJobInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetJobOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

/// Represents the result of a get job request.
public struct GetJobOutputResponse: Swift.Equatable {
    /// An object that contains information about the requested job.
    public var job: DeviceFarmClientTypes.Job?

    public init (
        job: DeviceFarmClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct GetJobOutputResponseBody: Swift.Equatable {
    let job: DeviceFarmClientTypes.Job?
}

extension GetJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

extension GetNetworkProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetNetworkProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetNetworkProfileInput: Swift.Equatable {
    /// The ARN of the network profile to return information about.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetNetworkProfileInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetNetworkProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetNetworkProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetNetworkProfileOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetNetworkProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkProfile = output.networkProfile
        } else {
            self.networkProfile = nil
        }
    }
}

public struct GetNetworkProfileOutputResponse: Swift.Equatable {
    /// The network profile.
    public var networkProfile: DeviceFarmClientTypes.NetworkProfile?

    public init (
        networkProfile: DeviceFarmClientTypes.NetworkProfile? = nil
    )
    {
        self.networkProfile = networkProfile
    }
}

struct GetNetworkProfileOutputResponseBody: Swift.Equatable {
    let networkProfile: DeviceFarmClientTypes.NetworkProfile?
}

extension GetNetworkProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.NetworkProfile.self, forKey: .networkProfile)
        networkProfile = networkProfileDecoded
    }
}

extension GetOfferingStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetOfferingStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the request to retrieve the offering status for the specified customer or account.
public struct GetOfferingStatusInput: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct GetOfferingStatusInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension GetOfferingStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetOfferingStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOfferingStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotEligibleException" : self = .notEligibleException(try NotEligibleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetOfferingStatusOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notEligibleException(NotEligibleException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOfferingStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetOfferingStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.current = output.current
            self.nextPeriod = output.nextPeriod
            self.nextToken = output.nextToken
        } else {
            self.current = nil
            self.nextPeriod = nil
            self.nextToken = nil
        }
    }
}

/// Returns the status result for a device offering.
public struct GetOfferingStatusOutputResponse: Swift.Equatable {
    /// When specified, gets the offering status for the current period.
    public var current: [Swift.String:DeviceFarmClientTypes.OfferingStatus]?
    /// When specified, gets the offering status for the next period.
    public var nextPeriod: [Swift.String:DeviceFarmClientTypes.OfferingStatus]?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        current: [Swift.String:DeviceFarmClientTypes.OfferingStatus]? = nil,
        nextPeriod: [Swift.String:DeviceFarmClientTypes.OfferingStatus]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.current = current
        self.nextPeriod = nextPeriod
        self.nextToken = nextToken
    }
}

struct GetOfferingStatusOutputResponseBody: Swift.Equatable {
    let current: [Swift.String:DeviceFarmClientTypes.OfferingStatus]?
    let nextPeriod: [Swift.String:DeviceFarmClientTypes.OfferingStatus]?
    let nextToken: Swift.String?
}

extension GetOfferingStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case current
        case nextPeriod
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentContainer = try containerValues.decodeIfPresent([Swift.String: DeviceFarmClientTypes.OfferingStatus?].self, forKey: .current)
        var currentDecoded0: [Swift.String:DeviceFarmClientTypes.OfferingStatus]? = nil
        if let currentContainer = currentContainer {
            currentDecoded0 = [Swift.String:DeviceFarmClientTypes.OfferingStatus]()
            for (key0, offeringstatus0) in currentContainer {
                if let offeringstatus0 = offeringstatus0 {
                    currentDecoded0?[key0] = offeringstatus0
                }
            }
        }
        current = currentDecoded0
        let nextPeriodContainer = try containerValues.decodeIfPresent([Swift.String: DeviceFarmClientTypes.OfferingStatus?].self, forKey: .nextPeriod)
        var nextPeriodDecoded0: [Swift.String:DeviceFarmClientTypes.OfferingStatus]? = nil
        if let nextPeriodContainer = nextPeriodContainer {
            nextPeriodDecoded0 = [Swift.String:DeviceFarmClientTypes.OfferingStatus]()
            for (key0, offeringstatus0) in nextPeriodContainer {
                if let offeringstatus0 = offeringstatus0 {
                    nextPeriodDecoded0?[key0] = offeringstatus0
                }
            }
        }
        nextPeriod = nextPeriodDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the get project operation.
public struct GetProjectInput: Swift.Equatable {
    /// The project's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetProjectInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetProjectOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

/// Represents the result of a get project request.
public struct GetProjectOutputResponse: Swift.Equatable {
    /// The project to get information about.
    public var project: DeviceFarmClientTypes.Project?

    public init (
        project: DeviceFarmClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

struct GetProjectOutputResponseBody: Swift.Equatable {
    let project: DeviceFarmClientTypes.Project?
}

extension GetProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case project
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Project.self, forKey: .project)
        project = projectDecoded
    }
}

extension GetRemoteAccessSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetRemoteAccessSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the request to get information about the specified remote access session.
public struct GetRemoteAccessSessionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the remote access session about which you want to get session information.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetRemoteAccessSessionInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetRemoteAccessSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetRemoteAccessSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRemoteAccessSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRemoteAccessSessionOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRemoteAccessSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRemoteAccessSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.remoteAccessSession = output.remoteAccessSession
        } else {
            self.remoteAccessSession = nil
        }
    }
}

/// Represents the response from the server that lists detailed information about the remote access session.
public struct GetRemoteAccessSessionOutputResponse: Swift.Equatable {
    /// A container that lists detailed information about the remote access session.
    public var remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession?

    public init (
        remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession? = nil
    )
    {
        self.remoteAccessSession = remoteAccessSession
    }
}

struct GetRemoteAccessSessionOutputResponseBody: Swift.Equatable {
    let remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession?
}

extension GetRemoteAccessSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case remoteAccessSession
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remoteAccessSessionDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.RemoteAccessSession.self, forKey: .remoteAccessSession)
        remoteAccessSession = remoteAccessSessionDecoded
    }
}

extension GetRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the get run operation.
public struct GetRunInput: Swift.Equatable {
    /// The run's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetRunInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRunOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.run = output.run
        } else {
            self.run = nil
        }
    }
}

/// Represents the result of a get run request.
public struct GetRunOutputResponse: Swift.Equatable {
    /// The run to get results from.
    public var run: DeviceFarmClientTypes.Run?

    public init (
        run: DeviceFarmClientTypes.Run? = nil
    )
    {
        self.run = run
    }
}

struct GetRunOutputResponseBody: Swift.Equatable {
    let run: DeviceFarmClientTypes.Run?
}

extension GetRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case run
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Run.self, forKey: .run)
        run = runDecoded
    }
}

extension GetSuiteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetSuiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the get suite operation.
public struct GetSuiteInput: Swift.Equatable {
    /// The suite's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetSuiteInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetSuiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetSuiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSuiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSuiteOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSuiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSuiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.suite = output.suite
        } else {
            self.suite = nil
        }
    }
}

/// Represents the result of a get suite request.
public struct GetSuiteOutputResponse: Swift.Equatable {
    /// A collection of one or more tests.
    public var suite: DeviceFarmClientTypes.Suite?

    public init (
        suite: DeviceFarmClientTypes.Suite? = nil
    )
    {
        self.suite = suite
    }
}

struct GetSuiteOutputResponseBody: Swift.Equatable {
    let suite: DeviceFarmClientTypes.Suite?
}

extension GetSuiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suite
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Suite.self, forKey: .suite)
        suite = suiteDecoded
    }
}

extension GetTestGridProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectArn = self.projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
    }
}

extension GetTestGridProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetTestGridProjectInput: Swift.Equatable {
    /// The ARN of the Selenium testing project, from either [CreateTestGridProject] or [ListTestGridProjects].
    /// This member is required.
    public var projectArn: Swift.String?

    public init (
        projectArn: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
    }
}

struct GetTestGridProjectInputBody: Swift.Equatable {
    let projectArn: Swift.String?
}

extension GetTestGridProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

extension GetTestGridProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTestGridProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTestGridProjectOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTestGridProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTestGridProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.testGridProject = output.testGridProject
        } else {
            self.testGridProject = nil
        }
    }
}

public struct GetTestGridProjectOutputResponse: Swift.Equatable {
    /// A [TestGridProject].
    public var testGridProject: DeviceFarmClientTypes.TestGridProject?

    public init (
        testGridProject: DeviceFarmClientTypes.TestGridProject? = nil
    )
    {
        self.testGridProject = testGridProject
    }
}

struct GetTestGridProjectOutputResponseBody: Swift.Equatable {
    let testGridProject: DeviceFarmClientTypes.TestGridProject?
}

extension GetTestGridProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case testGridProject
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testGridProjectDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridProject.self, forKey: .testGridProject)
        testGridProject = testGridProjectDecoded
    }
}

extension GetTestGridSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
        case sessionArn
        case sessionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectArn = self.projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let sessionArn = self.sessionArn {
            try encodeContainer.encode(sessionArn, forKey: .sessionArn)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

extension GetTestGridSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetTestGridSessionInput: Swift.Equatable {
    /// The ARN for the project that this session belongs to. See [CreateTestGridProject] and [ListTestGridProjects].
    public var projectArn: Swift.String?
    /// An ARN that uniquely identifies a [TestGridSession].
    public var sessionArn: Swift.String?
    /// An ID associated with this session.
    public var sessionId: Swift.String?

    public init (
        projectArn: Swift.String? = nil,
        sessionArn: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
        self.sessionArn = sessionArn
        self.sessionId = sessionId
    }
}

struct GetTestGridSessionInputBody: Swift.Equatable {
    let projectArn: Swift.String?
    let sessionId: Swift.String?
    let sessionArn: Swift.String?
}

extension GetTestGridSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
        case sessionArn
        case sessionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let sessionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionArn)
        sessionArn = sessionArnDecoded
    }
}

extension GetTestGridSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTestGridSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTestGridSessionOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTestGridSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTestGridSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.testGridSession = output.testGridSession
        } else {
            self.testGridSession = nil
        }
    }
}

public struct GetTestGridSessionOutputResponse: Swift.Equatable {
    /// The [TestGridSession] that was requested.
    public var testGridSession: DeviceFarmClientTypes.TestGridSession?

    public init (
        testGridSession: DeviceFarmClientTypes.TestGridSession? = nil
    )
    {
        self.testGridSession = testGridSession
    }
}

struct GetTestGridSessionOutputResponseBody: Swift.Equatable {
    let testGridSession: DeviceFarmClientTypes.TestGridSession?
}

extension GetTestGridSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case testGridSession
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testGridSessionDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridSession.self, forKey: .testGridSession)
        testGridSession = testGridSessionDecoded
    }
}

extension GetTestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetTestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the get test operation.
public struct GetTestInput: Swift.Equatable {
    /// The test's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetTestInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetTestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetTestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTestOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.test = output.test
        } else {
            self.test = nil
        }
    }
}

/// Represents the result of a get test request.
public struct GetTestOutputResponse: Swift.Equatable {
    /// A test condition that is evaluated.
    public var test: DeviceFarmClientTypes.Test?

    public init (
        test: DeviceFarmClientTypes.Test? = nil
    )
    {
        self.test = test
    }
}

struct GetTestOutputResponseBody: Swift.Equatable {
    let test: DeviceFarmClientTypes.Test?
}

extension GetTestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case test
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Test.self, forKey: .test)
        test = testDecoded
    }
}

extension GetUploadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the get upload operation.
public struct GetUploadInput: Swift.Equatable {
    /// The upload's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetUploadInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetUploadOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetUploadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.upload = output.upload
        } else {
            self.upload = nil
        }
    }
}

/// Represents the result of a get upload request.
public struct GetUploadOutputResponse: Swift.Equatable {
    /// An app or a set of one or more tests to upload or that have been uploaded.
    public var upload: DeviceFarmClientTypes.Upload?

    public init (
        upload: DeviceFarmClientTypes.Upload? = nil
    )
    {
        self.upload = upload
    }
}

struct GetUploadOutputResponseBody: Swift.Equatable {
    let upload: DeviceFarmClientTypes.Upload?
}

extension GetUploadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case upload
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Upload.self, forKey: .upload)
        upload = uploadDecoded
    }
}

extension GetVPCEConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetVPCEConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetVPCEConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to describe.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetVPCEConfigurationInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetVPCEConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetVPCEConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVPCEConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetVPCEConfigurationOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVPCEConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetVPCEConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vpceConfiguration = output.vpceConfiguration
        } else {
            self.vpceConfiguration = nil
        }
    }
}

public struct GetVPCEConfigurationOutputResponse: Swift.Equatable {
    /// An object that contains information about your VPC endpoint configuration.
    public var vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration?

    public init (
        vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration? = nil
    )
    {
        self.vpceConfiguration = vpceConfiguration
    }
}

struct GetVPCEConfigurationOutputResponseBody: Swift.Equatable {
    let vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration?
}

extension GetVPCEConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpceConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpceConfigurationDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.VPCEConfiguration.self, forKey: .vpceConfiguration)
        vpceConfiguration = vpceConfigurationDecoded
    }
}

extension IdempotencyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: IdempotencyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An entity with the same name already exists.
public struct IdempotencyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any additional information about the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotencyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IdempotencyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeviceFarmClientTypes.IncompatibilityMessage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceAttribute.self, forKey: .type)
        type = typeDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents information about incompatibility.
    public struct IncompatibilityMessage: Swift.Equatable {
        /// A message about the incompatibility.
        public var message: Swift.String?
        /// The type of incompatibility. Allowed values include:
        ///
        /// * ARN
        ///
        /// * FORM_FACTOR (for example, phone or tablet)
        ///
        /// * MANUFACTURER
        ///
        /// * PLATFORM (for example, Android or iOS)
        ///
        /// * REMOTE_ACCESS_ENABLED
        ///
        /// * APPIUM_VERSION
        public var type: DeviceFarmClientTypes.DeviceAttribute?

        public init (
            message: Swift.String? = nil,
            type: DeviceFarmClientTypes.DeviceAttribute? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension InstallToRemoteAccessSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case remoteAccessSessionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let remoteAccessSessionArn = self.remoteAccessSessionArn {
            try encodeContainer.encode(remoteAccessSessionArn, forKey: .remoteAccessSessionArn)
        }
    }
}

extension InstallToRemoteAccessSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the request to install an Android application (in .apk format) or an iOS application (in .ipa format) as part of a remote access session.
public struct InstallToRemoteAccessSessionInput: Swift.Equatable {
    /// The ARN of the app about which you are requesting information.
    /// This member is required.
    public var appArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the remote access session about which you are requesting information.
    /// This member is required.
    public var remoteAccessSessionArn: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        remoteAccessSessionArn: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.remoteAccessSessionArn = remoteAccessSessionArn
    }
}

struct InstallToRemoteAccessSessionInputBody: Swift.Equatable {
    let remoteAccessSessionArn: Swift.String?
    let appArn: Swift.String?
}

extension InstallToRemoteAccessSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case remoteAccessSessionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remoteAccessSessionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteAccessSessionArn)
        remoteAccessSessionArn = remoteAccessSessionArnDecoded
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
    }
}

extension InstallToRemoteAccessSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InstallToRemoteAccessSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum InstallToRemoteAccessSessionOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InstallToRemoteAccessSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InstallToRemoteAccessSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appUpload = output.appUpload
        } else {
            self.appUpload = nil
        }
    }
}

/// Represents the response from the server after AWS Device Farm makes a request to install to a remote access session.
public struct InstallToRemoteAccessSessionOutputResponse: Swift.Equatable {
    /// An app to upload or that has been uploaded.
    public var appUpload: DeviceFarmClientTypes.Upload?

    public init (
        appUpload: DeviceFarmClientTypes.Upload? = nil
    )
    {
        self.appUpload = appUpload
    }
}

struct InstallToRemoteAccessSessionOutputResponseBody: Swift.Equatable {
    let appUpload: DeviceFarmClientTypes.Upload?
}

extension InstallToRemoteAccessSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appUpload
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appUploadDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Upload.self, forKey: .appUpload)
        appUpload = appUploadDecoded
    }
}

extension DeviceFarmClientTypes.InstanceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case excludeAppPackagesFromCleanup
        case name
        case packageCleanup
        case rebootAfterUse
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup {
            var excludeAppPackagesFromCleanupContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeAppPackagesFromCleanup)
            for string0 in excludeAppPackagesFromCleanup {
                try excludeAppPackagesFromCleanupContainer.encode(string0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packageCleanup = self.packageCleanup {
            try encodeContainer.encode(packageCleanup, forKey: .packageCleanup)
        }
        if let rebootAfterUse = self.rebootAfterUse {
            try encodeContainer.encode(rebootAfterUse, forKey: .rebootAfterUse)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let packageCleanupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .packageCleanup)
        packageCleanup = packageCleanupDecoded
        let excludeAppPackagesFromCleanupContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludeAppPackagesFromCleanup)
        var excludeAppPackagesFromCleanupDecoded0:[Swift.String]? = nil
        if let excludeAppPackagesFromCleanupContainer = excludeAppPackagesFromCleanupContainer {
            excludeAppPackagesFromCleanupDecoded0 = [Swift.String]()
            for string0 in excludeAppPackagesFromCleanupContainer {
                if let string0 = string0 {
                    excludeAppPackagesFromCleanupDecoded0?.append(string0)
                }
            }
        }
        excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanupDecoded0
        let rebootAfterUseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rebootAfterUse)
        rebootAfterUse = rebootAfterUseDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents the instance profile.
    public struct InstanceProfile: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the instance profile.
        public var arn: Swift.String?
        /// The description of the instance profile.
        public var description: Swift.String?
        /// An array of strings containing the list of app packages that should not be cleaned up from the device after a test run completes. The list of packages is considered only if you set packageCleanup to true.
        public var excludeAppPackagesFromCleanup: [Swift.String]?
        /// The name of the instance profile.
        public var name: Swift.String?
        /// When set to true, Device Farm removes app packages after a test run. The default value is false for private devices.
        public var packageCleanup: Swift.Bool?
        /// When set to true, Device Farm reboots the instance after a test run. The default value is true.
        public var rebootAfterUse: Swift.Bool?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            excludeAppPackagesFromCleanup: [Swift.String]? = nil,
            name: Swift.String? = nil,
            packageCleanup: Swift.Bool? = nil,
            rebootAfterUse: Swift.Bool? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup
            self.name = name
            self.packageCleanup = packageCleanup
            self.rebootAfterUse = rebootAfterUse
        }
    }

}

extension DeviceFarmClientTypes {
    public enum InstanceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case inUse
        case notAvailable
        case preparing
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceStatus] {
            return [
                .available,
                .inUse,
                .notAvailable,
                .preparing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .inUse: return "IN_USE"
            case .notAvailable: return "NOT_AVAILABLE"
            case .preparing: return "PREPARING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceStatus(rawValue: rawValue) ?? InstanceStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum InteractionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case interactive
        case noVideo
        case videoOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [InteractionMode] {
            return [
                .interactive,
                .noVideo,
                .videoOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .interactive: return "INTERACTIVE"
            case .noVideo: return "NO_VIDEO"
            case .videoOnly: return "VIDEO_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InteractionMode(rawValue: rawValue) ?? InteractionMode.sdkUnknown(rawValue)
        }
    }
}

extension InternalServiceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal exception was raised in the service. Contact [aws-devicefarm-support@amazon.com](mailto:aws-devicefarm-support@amazon.com) if you see this error.
public struct InternalServiceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was an error with the update request, or you do not have sufficient permissions to update this VPC endpoint configuration.
public struct InvalidOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeviceFarmClientTypes.Job: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case counters
        case created
        case device
        case deviceMinutes
        case instanceArn
        case message
        case name
        case result
        case started
        case status
        case stopped
        case type
        case videoCapture
        case videoEndpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let counters = self.counters {
            try encodeContainer.encode(counters, forKey: .counters)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let device = self.device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let deviceMinutes = self.deviceMinutes {
            try encodeContainer.encode(deviceMinutes, forKey: .deviceMinutes)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let result = self.result {
            try encodeContainer.encode(result.rawValue, forKey: .result)
        }
        if let started = self.started {
            try encodeContainer.encodeTimestamp(started, format: .epochSeconds, forKey: .started)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopped = self.stopped {
            try encodeContainer.encodeTimestamp(stopped, format: .epochSeconds, forKey: .stopped)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let videoCapture = self.videoCapture {
            try encodeContainer.encode(videoCapture, forKey: .videoCapture)
        }
        if let videoEndpoint = self.videoEndpoint {
            try encodeContainer.encode(videoEndpoint, forKey: .videoEndpoint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestType.self, forKey: .type)
        type = typeDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let resultDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionResult.self, forKey: .result)
        result = resultDecoded
        let startedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .started)
        started = startedDecoded
        let stoppedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stopped)
        stopped = stoppedDecoded
        let countersDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Counters.self, forKey: .counters)
        counters = countersDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let deviceDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let deviceMinutesDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceMinutes.self, forKey: .deviceMinutes)
        deviceMinutes = deviceMinutesDecoded
        let videoEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .videoEndpoint)
        videoEndpoint = videoEndpointDecoded
        let videoCaptureDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .videoCapture)
        videoCapture = videoCaptureDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents a device.
    public struct Job: Swift.Equatable {
        /// The job's ARN.
        public var arn: Swift.String?
        /// The job's result counters.
        public var counters: DeviceFarmClientTypes.Counters?
        /// When the job was created.
        public var created: ClientRuntime.Date?
        /// The device (phone or tablet).
        public var device: DeviceFarmClientTypes.Device?
        /// Represents the total (metered or unmetered) minutes used by the job.
        public var deviceMinutes: DeviceFarmClientTypes.DeviceMinutes?
        /// The ARN of the instance.
        public var instanceArn: Swift.String?
        /// A message about the job's result.
        public var message: Swift.String?
        /// The job's name.
        public var name: Swift.String?
        /// The job's result. Allowed values include:
        ///
        /// * PENDING
        ///
        /// * PASSED
        ///
        /// * WARNED
        ///
        /// * FAILED
        ///
        /// * SKIPPED
        ///
        /// * ERRORED
        ///
        /// * STOPPED
        public var result: DeviceFarmClientTypes.ExecutionResult?
        /// The job's start time.
        public var started: ClientRuntime.Date?
        /// The job's status. Allowed values include:
        ///
        /// * PENDING
        ///
        /// * PENDING_CONCURRENCY
        ///
        /// * PENDING_DEVICE
        ///
        /// * PROCESSING
        ///
        /// * SCHEDULING
        ///
        /// * PREPARING
        ///
        /// * RUNNING
        ///
        /// * COMPLETED
        ///
        /// * STOPPING
        public var status: DeviceFarmClientTypes.ExecutionStatus?
        /// The job's stop time.
        public var stopped: ClientRuntime.Date?
        /// The job's type. Allowed values include the following:
        ///
        /// * BUILTIN_FUZZ
        ///
        /// * BUILTIN_EXPLORER. For Android, an app explorer that traverses an Android app, interacting with it and capturing screenshots at the same time.
        ///
        /// * APPIUM_JAVA_JUNIT
        ///
        /// * APPIUM_JAVA_TESTNG
        ///
        /// * APPIUM_PYTHON
        ///
        /// * APPIUM_NODE
        ///
        /// * APPIUM_RUBY
        ///
        /// * APPIUM_WEB_JAVA_JUNIT
        ///
        /// * APPIUM_WEB_JAVA_TESTNG
        ///
        /// * APPIUM_WEB_PYTHON
        ///
        /// * APPIUM_WEB_NODE
        ///
        /// * APPIUM_WEB_RUBY
        ///
        /// * CALABASH
        ///
        /// * INSTRUMENTATION
        ///
        /// * UIAUTOMATION
        ///
        /// * UIAUTOMATOR
        ///
        /// * XCTEST
        ///
        /// * XCTEST_UI
        public var type: DeviceFarmClientTypes.TestType?
        /// This value is set to true if video capture is enabled. Otherwise, it is set to false.
        public var videoCapture: Swift.Bool?
        /// The endpoint for streaming device video.
        public var videoEndpoint: Swift.String?

        public init (
            arn: Swift.String? = nil,
            counters: DeviceFarmClientTypes.Counters? = nil,
            created: ClientRuntime.Date? = nil,
            device: DeviceFarmClientTypes.Device? = nil,
            deviceMinutes: DeviceFarmClientTypes.DeviceMinutes? = nil,
            instanceArn: Swift.String? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            result: DeviceFarmClientTypes.ExecutionResult? = nil,
            started: ClientRuntime.Date? = nil,
            status: DeviceFarmClientTypes.ExecutionStatus? = nil,
            stopped: ClientRuntime.Date? = nil,
            type: DeviceFarmClientTypes.TestType? = nil,
            videoCapture: Swift.Bool? = nil,
            videoEndpoint: Swift.String? = nil
        )
        {
            self.arn = arn
            self.counters = counters
            self.created = created
            self.device = device
            self.deviceMinutes = deviceMinutes
            self.instanceArn = instanceArn
            self.message = message
            self.name = name
            self.result = result
            self.started = started
            self.status = status
            self.stopped = stopped
            self.type = type
            self.videoCapture = videoCapture
            self.videoEndpoint = videoEndpoint
        }
    }

}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A limit was exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any additional information about the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListArtifactsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension ListArtifactsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the list artifacts operation.
public struct ListArtifactsInput: Swift.Equatable {
    /// The run, job, suite, or test ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The artifacts' type. Allowed values include:
    ///
    /// * FILE
    ///
    /// * LOG
    ///
    /// * SCREENSHOT
    /// This member is required.
    public var type: DeviceFarmClientTypes.ArtifactCategory?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        type: DeviceFarmClientTypes.ArtifactCategory? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListArtifactsInputBody: Swift.Equatable {
    let arn: Swift.String?
    let type: DeviceFarmClientTypes.ArtifactCategory?
    let nextToken: Swift.String?
}

extension ListArtifactsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ArtifactCategory.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListArtifactsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListArtifactsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListArtifactsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListArtifactsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListArtifactsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.artifacts = output.artifacts
            self.nextToken = output.nextToken
        } else {
            self.artifacts = nil
            self.nextToken = nil
        }
    }
}

/// Represents the result of a list artifacts operation.
public struct ListArtifactsOutputResponse: Swift.Equatable {
    /// Information about the artifacts.
    public var artifacts: [DeviceFarmClientTypes.Artifact]?
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        artifacts: [DeviceFarmClientTypes.Artifact]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.artifacts = artifacts
        self.nextToken = nextToken
    }
}

struct ListArtifactsOutputResponseBody: Swift.Equatable {
    let artifacts: [DeviceFarmClientTypes.Artifact]?
    let nextToken: Swift.String?
}

extension ListArtifactsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifacts
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Artifact?].self, forKey: .artifacts)
        var artifactsDecoded0:[DeviceFarmClientTypes.Artifact]? = nil
        if let artifactsContainer = artifactsContainer {
            artifactsDecoded0 = [DeviceFarmClientTypes.Artifact]()
            for structure0 in artifactsContainer {
                if let structure0 = structure0 {
                    artifactsDecoded0?.append(structure0)
                }
            }
        }
        artifacts = artifactsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeviceInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDeviceInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDeviceInstancesInput: Swift.Equatable {
    /// An integer that specifies the maximum number of items you want to return in the API response.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeviceInstancesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListDeviceInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeviceInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeviceInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDeviceInstancesOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeviceInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDeviceInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceInstances = output.deviceInstances
            self.nextToken = output.nextToken
        } else {
            self.deviceInstances = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeviceInstancesOutputResponse: Swift.Equatable {
    /// An object that contains information about your device instances.
    public var deviceInstances: [DeviceFarmClientTypes.DeviceInstance]?
    /// An identifier that can be used in the next call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        deviceInstances: [DeviceFarmClientTypes.DeviceInstance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceInstances = deviceInstances
        self.nextToken = nextToken
    }
}

struct ListDeviceInstancesOutputResponseBody: Swift.Equatable {
    let deviceInstances: [DeviceFarmClientTypes.DeviceInstance]?
    let nextToken: Swift.String?
}

extension ListDeviceInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceInstances
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceInstancesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.DeviceInstance?].self, forKey: .deviceInstances)
        var deviceInstancesDecoded0:[DeviceFarmClientTypes.DeviceInstance]? = nil
        if let deviceInstancesContainer = deviceInstancesContainer {
            deviceInstancesDecoded0 = [DeviceFarmClientTypes.DeviceInstance]()
            for structure0 in deviceInstancesContainer {
                if let structure0 = structure0 {
                    deviceInstancesDecoded0?.append(structure0)
                }
            }
        }
        deviceInstances = deviceInstancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDevicePoolsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension ListDevicePoolsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the result of a list device pools request.
public struct ListDevicePoolsInput: Swift.Equatable {
    /// The project ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The device pools' type. Allowed values include:
    ///
    /// * CURATED: A device pool that is created and managed by AWS Device Farm.
    ///
    /// * PRIVATE: A device pool that is created and managed by the device pool developer.
    public var type: DeviceFarmClientTypes.DevicePoolType?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        type: DeviceFarmClientTypes.DevicePoolType? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListDevicePoolsInputBody: Swift.Equatable {
    let arn: Swift.String?
    let type: DeviceFarmClientTypes.DevicePoolType?
    let nextToken: Swift.String?
}

extension ListDevicePoolsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DevicePoolType.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDevicePoolsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDevicePoolsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDevicePoolsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDevicePoolsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDevicePoolsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devicePools = output.devicePools
            self.nextToken = output.nextToken
        } else {
            self.devicePools = nil
            self.nextToken = nil
        }
    }
}

/// Represents the result of a list device pools request.
public struct ListDevicePoolsOutputResponse: Swift.Equatable {
    /// Information about the device pools.
    public var devicePools: [DeviceFarmClientTypes.DevicePool]?
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        devicePools: [DeviceFarmClientTypes.DevicePool]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devicePools = devicePools
        self.nextToken = nextToken
    }
}

struct ListDevicePoolsOutputResponseBody: Swift.Equatable {
    let devicePools: [DeviceFarmClientTypes.DevicePool]?
    let nextToken: Swift.String?
}

extension ListDevicePoolsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePools
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePoolsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.DevicePool?].self, forKey: .devicePools)
        var devicePoolsDecoded0:[DeviceFarmClientTypes.DevicePool]? = nil
        if let devicePoolsContainer = devicePoolsContainer {
            devicePoolsDecoded0 = [DeviceFarmClientTypes.DevicePool]()
            for structure0 in devicePoolsContainer {
                if let structure0 = structure0 {
                    devicePoolsDecoded0?.append(structure0)
                }
            }
        }
        devicePools = devicePoolsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDevicesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case filters
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for devicefilter0 in filters {
                try filtersContainer.encode(devicefilter0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the result of a list devices request.
public struct ListDevicesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the project.
    public var arn: Swift.String?
    /// Used to select a set of devices. A filter is made up of an attribute, an operator, and one or more values.
    ///
    /// * Attribute: The aspect of a device such as platform or model used as the selection criteria in a device filter. Allowed values include:
    ///
    /// * ARN: The Amazon Resource Name (ARN) of the device (for example, arn:aws:devicefarm:us-west-2::device:12345Example).
    ///
    /// * PLATFORM: The device platform. Valid values are ANDROID or IOS.
    ///
    /// * OS_VERSION: The operating system version (for example, 10.3.2).
    ///
    /// * MODEL: The device model (for example, iPad 5th Gen).
    ///
    /// * AVAILABILITY: The current availability of the device. Valid values are AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.
    ///
    /// * FORM_FACTOR: The device form factor. Valid values are PHONE or TABLET.
    ///
    /// * MANUFACTURER: The device manufacturer (for example, Apple).
    ///
    /// * REMOTE_ACCESS_ENABLED: Whether the device is enabled for remote access. Valid values are TRUE or FALSE.
    ///
    /// * REMOTE_DEBUG_ENABLED: Whether the device is enabled for remote debugging. Valid values are TRUE or FALSE. Because remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html), this attribute is ignored.
    ///
    /// * INSTANCE_ARN: The Amazon Resource Name (ARN) of the device instance.
    ///
    /// * INSTANCE_LABELS: The label of the device instance.
    ///
    /// * FLEET_TYPE: The fleet type. Valid values are PUBLIC or PRIVATE.
    ///
    ///
    ///
    ///
    /// * Operator: The filter operator.
    ///
    /// * The EQUALS operator is available for every attribute except INSTANCE_LABELS.
    ///
    /// * The CONTAINS operator is available for the INSTANCE_LABELS and MODEL attributes.
    ///
    /// * The IN and NOT_IN operators are available for the ARN, OS_VERSION, MODEL, MANUFACTURER, and INSTANCE_ARN attributes.
    ///
    /// * The LESS_THAN, GREATER_THAN, LESS_THAN_OR_EQUALS, and GREATER_THAN_OR_EQUALS operators are also available for the OS_VERSION attribute.
    ///
    ///
    ///
    ///
    /// * Values: An array of one or more filter values.
    ///
    /// * The IN and NOT_IN operators take a values array that has one or more elements.
    ///
    /// * The other operators require an array with a single element.
    ///
    /// * In a request, the AVAILABILITY attribute takes the following values: AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.
    public var filters: [DeviceFarmClientTypes.DeviceFilter]?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        filters: [DeviceFarmClientTypes.DeviceFilter]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.filters = filters
        self.nextToken = nextToken
    }
}

struct ListDevicesInputBody: Swift.Equatable {
    let arn: Swift.String?
    let nextToken: Swift.String?
    let filters: [DeviceFarmClientTypes.DeviceFilter]?
}

extension ListDevicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case filters
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.DeviceFilter?].self, forKey: .filters)
        var filtersDecoded0:[DeviceFarmClientTypes.DeviceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DeviceFarmClientTypes.DeviceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListDevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDevicesOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devices = output.devices
            self.nextToken = output.nextToken
        } else {
            self.devices = nil
            self.nextToken = nil
        }
    }
}

/// Represents the result of a list devices operation.
public struct ListDevicesOutputResponse: Swift.Equatable {
    /// Information about the devices.
    public var devices: [DeviceFarmClientTypes.Device]?
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        devices: [DeviceFarmClientTypes.Device]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

struct ListDevicesOutputResponseBody: Swift.Equatable {
    let devices: [DeviceFarmClientTypes.Device]?
    let nextToken: Swift.String?
}

extension ListDevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Device?].self, forKey: .devices)
        var devicesDecoded0:[DeviceFarmClientTypes.Device]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [DeviceFarmClientTypes.Device]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInstanceProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListInstanceProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListInstanceProfilesInput: Swift.Equatable {
    /// An integer that specifies the maximum number of items you want to return in the API response.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInstanceProfilesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListInstanceProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInstanceProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInstanceProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListInstanceProfilesOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstanceProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListInstanceProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceProfiles = output.instanceProfiles
            self.nextToken = output.nextToken
        } else {
            self.instanceProfiles = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstanceProfilesOutputResponse: Swift.Equatable {
    /// An object that contains information about your instance profiles.
    public var instanceProfiles: [DeviceFarmClientTypes.InstanceProfile]?
    /// An identifier that can be used in the next call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        instanceProfiles: [DeviceFarmClientTypes.InstanceProfile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceProfiles = instanceProfiles
        self.nextToken = nextToken
    }
}

struct ListInstanceProfilesOutputResponseBody: Swift.Equatable {
    let instanceProfiles: [DeviceFarmClientTypes.InstanceProfile]?
    let nextToken: Swift.String?
}

extension ListInstanceProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfiles
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfilesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.InstanceProfile?].self, forKey: .instanceProfiles)
        var instanceProfilesDecoded0:[DeviceFarmClientTypes.InstanceProfile]? = nil
        if let instanceProfilesContainer = instanceProfilesContainer {
            instanceProfilesDecoded0 = [DeviceFarmClientTypes.InstanceProfile]()
            for structure0 in instanceProfilesContainer {
                if let structure0 = structure0 {
                    instanceProfilesDecoded0?.append(structure0)
                }
            }
        }
        instanceProfiles = instanceProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the list jobs operation.
public struct ListJobsInput: Swift.Equatable {
    /// The run's Amazon Resource Name (ARN).
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListJobsInputBody: Swift.Equatable {
    let arn: Swift.String?
    let nextToken: Swift.String?
}

extension ListJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListJobsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

/// Represents the result of a list jobs request.
public struct ListJobsOutputResponse: Swift.Equatable {
    /// Information about the jobs.
    public var jobs: [DeviceFarmClientTypes.Job]?
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        jobs: [DeviceFarmClientTypes.Job]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListJobsOutputResponseBody: Swift.Equatable {
    let jobs: [DeviceFarmClientTypes.Job]?
    let nextToken: Swift.String?
}

extension ListJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Job?].self, forKey: .jobs)
        var jobsDecoded0:[DeviceFarmClientTypes.Job]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [DeviceFarmClientTypes.Job]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNetworkProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension ListNetworkProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListNetworkProfilesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the project for which you want to list network profiles.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The type of network profile to return information about. Valid values are listed here.
    public var type: DeviceFarmClientTypes.NetworkProfileType?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        type: DeviceFarmClientTypes.NetworkProfileType? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListNetworkProfilesInputBody: Swift.Equatable {
    let arn: Swift.String?
    let type: DeviceFarmClientTypes.NetworkProfileType?
    let nextToken: Swift.String?
}

extension ListNetworkProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.NetworkProfileType.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNetworkProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNetworkProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListNetworkProfilesOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNetworkProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListNetworkProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkProfiles = output.networkProfiles
            self.nextToken = output.nextToken
        } else {
            self.networkProfiles = nil
            self.nextToken = nil
        }
    }
}

public struct ListNetworkProfilesOutputResponse: Swift.Equatable {
    /// A list of the available network profiles.
    public var networkProfiles: [DeviceFarmClientTypes.NetworkProfile]?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        networkProfiles: [DeviceFarmClientTypes.NetworkProfile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkProfiles = networkProfiles
        self.nextToken = nextToken
    }
}

struct ListNetworkProfilesOutputResponseBody: Swift.Equatable {
    let networkProfiles: [DeviceFarmClientTypes.NetworkProfile]?
    let nextToken: Swift.String?
}

extension ListNetworkProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfiles
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfilesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.NetworkProfile?].self, forKey: .networkProfiles)
        var networkProfilesDecoded0:[DeviceFarmClientTypes.NetworkProfile]? = nil
        if let networkProfilesContainer = networkProfilesContainer {
            networkProfilesDecoded0 = [DeviceFarmClientTypes.NetworkProfile]()
            for structure0 in networkProfilesContainer {
                if let structure0 = structure0 {
                    networkProfilesDecoded0?.append(structure0)
                }
            }
        }
        networkProfiles = networkProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOfferingPromotionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListOfferingPromotionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListOfferingPromotionsInput: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListOfferingPromotionsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListOfferingPromotionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOfferingPromotionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOfferingPromotionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotEligibleException" : self = .notEligibleException(try NotEligibleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListOfferingPromotionsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notEligibleException(NotEligibleException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOfferingPromotionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListOfferingPromotionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.offeringPromotions = output.offeringPromotions
        } else {
            self.nextToken = nil
            self.offeringPromotions = nil
        }
    }
}

public struct ListOfferingPromotionsOutputResponse: Swift.Equatable {
    /// An identifier to be used in the next call to this operation, to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// Information about the offering promotions.
    public var offeringPromotions: [DeviceFarmClientTypes.OfferingPromotion]?

    public init (
        nextToken: Swift.String? = nil,
        offeringPromotions: [DeviceFarmClientTypes.OfferingPromotion]? = nil
    )
    {
        self.nextToken = nextToken
        self.offeringPromotions = offeringPromotions
    }
}

struct ListOfferingPromotionsOutputResponseBody: Swift.Equatable {
    let offeringPromotions: [DeviceFarmClientTypes.OfferingPromotion]?
    let nextToken: Swift.String?
}

extension ListOfferingPromotionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case offeringPromotions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringPromotionsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.OfferingPromotion?].self, forKey: .offeringPromotions)
        var offeringPromotionsDecoded0:[DeviceFarmClientTypes.OfferingPromotion]? = nil
        if let offeringPromotionsContainer = offeringPromotionsContainer {
            offeringPromotionsDecoded0 = [DeviceFarmClientTypes.OfferingPromotion]()
            for structure0 in offeringPromotionsContainer {
                if let structure0 = structure0 {
                    offeringPromotionsDecoded0?.append(structure0)
                }
            }
        }
        offeringPromotions = offeringPromotionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOfferingTransactionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListOfferingTransactionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the request to list the offering transaction history.
public struct ListOfferingTransactionsInput: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListOfferingTransactionsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListOfferingTransactionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOfferingTransactionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOfferingTransactionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotEligibleException" : self = .notEligibleException(try NotEligibleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListOfferingTransactionsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notEligibleException(NotEligibleException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOfferingTransactionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListOfferingTransactionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.offeringTransactions = output.offeringTransactions
        } else {
            self.nextToken = nil
            self.offeringTransactions = nil
        }
    }
}

/// Returns the transaction log of the specified offerings.
public struct ListOfferingTransactionsOutputResponse: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The audit log of subscriptions you have purchased and modified through AWS Device Farm.
    public var offeringTransactions: [DeviceFarmClientTypes.OfferingTransaction]?

    public init (
        nextToken: Swift.String? = nil,
        offeringTransactions: [DeviceFarmClientTypes.OfferingTransaction]? = nil
    )
    {
        self.nextToken = nextToken
        self.offeringTransactions = offeringTransactions
    }
}

struct ListOfferingTransactionsOutputResponseBody: Swift.Equatable {
    let offeringTransactions: [DeviceFarmClientTypes.OfferingTransaction]?
    let nextToken: Swift.String?
}

extension ListOfferingTransactionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case offeringTransactions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringTransactionsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.OfferingTransaction?].self, forKey: .offeringTransactions)
        var offeringTransactionsDecoded0:[DeviceFarmClientTypes.OfferingTransaction]? = nil
        if let offeringTransactionsContainer = offeringTransactionsContainer {
            offeringTransactionsDecoded0 = [DeviceFarmClientTypes.OfferingTransaction]()
            for structure0 in offeringTransactionsContainer {
                if let structure0 = structure0 {
                    offeringTransactionsDecoded0?.append(structure0)
                }
            }
        }
        offeringTransactions = offeringTransactionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOfferingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListOfferingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the request to list all offerings.
public struct ListOfferingsInput: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListOfferingsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListOfferingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOfferingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOfferingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotEligibleException" : self = .notEligibleException(try NotEligibleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListOfferingsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notEligibleException(NotEligibleException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOfferingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListOfferingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.offerings = output.offerings
        } else {
            self.nextToken = nil
            self.offerings = nil
        }
    }
}

/// Represents the return values of the list of offerings.
public struct ListOfferingsOutputResponse: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// A value that represents the list offering results.
    public var offerings: [DeviceFarmClientTypes.Offering]?

    public init (
        nextToken: Swift.String? = nil,
        offerings: [DeviceFarmClientTypes.Offering]? = nil
    )
    {
        self.nextToken = nextToken
        self.offerings = offerings
    }
}

struct ListOfferingsOutputResponseBody: Swift.Equatable {
    let offerings: [DeviceFarmClientTypes.Offering]?
    let nextToken: Swift.String?
}

extension ListOfferingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case offerings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Offering?].self, forKey: .offerings)
        var offeringsDecoded0:[DeviceFarmClientTypes.Offering]? = nil
        if let offeringsContainer = offeringsContainer {
            offeringsDecoded0 = [DeviceFarmClientTypes.Offering]()
            for structure0 in offeringsContainer {
                if let structure0 = structure0 {
                    offeringsDecoded0?.append(structure0)
                }
            }
        }
        offerings = offeringsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListProjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the list projects operation.
public struct ListProjectsInput: Swift.Equatable {
    /// Optional. If no Amazon Resource Name (ARN) is specified, then AWS Device Farm returns a list of all projects for the AWS account. You can also specify a project ARN.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Swift.Equatable {
    let arn: Swift.String?
    let nextToken: Swift.String?
}

extension ListProjectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListProjectsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

/// Represents the result of a list projects request.
public struct ListProjectsOutputResponse: Swift.Equatable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// Information about the projects.
    public var projects: [DeviceFarmClientTypes.Project]?

    public init (
        nextToken: Swift.String? = nil,
        projects: [DeviceFarmClientTypes.Project]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputResponseBody: Swift.Equatable {
    let projects: [DeviceFarmClientTypes.Project]?
    let nextToken: Swift.String?
}

extension ListProjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case projects
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Project?].self, forKey: .projects)
        var projectsDecoded0:[DeviceFarmClientTypes.Project]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [DeviceFarmClientTypes.Project]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRemoteAccessSessionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRemoteAccessSessionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the request to return information about the remote access session.
public struct ListRemoteAccessSessionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the project about which you are requesting information.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListRemoteAccessSessionsInputBody: Swift.Equatable {
    let arn: Swift.String?
    let nextToken: Swift.String?
}

extension ListRemoteAccessSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRemoteAccessSessionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRemoteAccessSessionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRemoteAccessSessionsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRemoteAccessSessionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRemoteAccessSessionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.remoteAccessSessions = output.remoteAccessSessions
        } else {
            self.nextToken = nil
            self.remoteAccessSessions = nil
        }
    }
}

/// Represents the response from the server after AWS Device Farm makes a request to return information about the remote access session.
public struct ListRemoteAccessSessionsOutputResponse: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// A container that represents the metadata from the service about each remote access session you are requesting.
    public var remoteAccessSessions: [DeviceFarmClientTypes.RemoteAccessSession]?

    public init (
        nextToken: Swift.String? = nil,
        remoteAccessSessions: [DeviceFarmClientTypes.RemoteAccessSession]? = nil
    )
    {
        self.nextToken = nextToken
        self.remoteAccessSessions = remoteAccessSessions
    }
}

struct ListRemoteAccessSessionsOutputResponseBody: Swift.Equatable {
    let remoteAccessSessions: [DeviceFarmClientTypes.RemoteAccessSession]?
    let nextToken: Swift.String?
}

extension ListRemoteAccessSessionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case remoteAccessSessions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remoteAccessSessionsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.RemoteAccessSession?].self, forKey: .remoteAccessSessions)
        var remoteAccessSessionsDecoded0:[DeviceFarmClientTypes.RemoteAccessSession]? = nil
        if let remoteAccessSessionsContainer = remoteAccessSessionsContainer {
            remoteAccessSessionsDecoded0 = [DeviceFarmClientTypes.RemoteAccessSession]()
            for structure0 in remoteAccessSessionsContainer {
                if let structure0 = structure0 {
                    remoteAccessSessionsDecoded0?.append(structure0)
                }
            }
        }
        remoteAccessSessions = remoteAccessSessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRunsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRunsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the list runs operation.
public struct ListRunsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the project for which you want to list runs.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListRunsInputBody: Swift.Equatable {
    let arn: Swift.String?
    let nextToken: Swift.String?
}

extension ListRunsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRunsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRunsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRunsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRunsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRunsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.runs = output.runs
        } else {
            self.nextToken = nil
            self.runs = nil
        }
    }
}

/// Represents the result of a list runs request.
public struct ListRunsOutputResponse: Swift.Equatable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// Information about the runs.
    public var runs: [DeviceFarmClientTypes.Run]?

    public init (
        nextToken: Swift.String? = nil,
        runs: [DeviceFarmClientTypes.Run]? = nil
    )
    {
        self.nextToken = nextToken
        self.runs = runs
    }
}

struct ListRunsOutputResponseBody: Swift.Equatable {
    let runs: [DeviceFarmClientTypes.Run]?
    let nextToken: Swift.String?
}

extension ListRunsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case runs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Run?].self, forKey: .runs)
        var runsDecoded0:[DeviceFarmClientTypes.Run]? = nil
        if let runsContainer = runsContainer {
            runsDecoded0 = [DeviceFarmClientTypes.Run]()
            for structure0 in runsContainer {
                if let structure0 = structure0 {
                    runsDecoded0?.append(structure0)
                }
            }
        }
        runs = runsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSamplesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSamplesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the list samples operation.
public struct ListSamplesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the job used to list samples.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListSamplesInputBody: Swift.Equatable {
    let arn: Swift.String?
    let nextToken: Swift.String?
}

extension ListSamplesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSamplesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSamplesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSamplesOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSamplesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSamplesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.samples = output.samples
        } else {
            self.nextToken = nil
            self.samples = nil
        }
    }
}

/// Represents the result of a list samples request.
public struct ListSamplesOutputResponse: Swift.Equatable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// Information about the samples.
    public var samples: [DeviceFarmClientTypes.Sample]?

    public init (
        nextToken: Swift.String? = nil,
        samples: [DeviceFarmClientTypes.Sample]? = nil
    )
    {
        self.nextToken = nextToken
        self.samples = samples
    }
}

struct ListSamplesOutputResponseBody: Swift.Equatable {
    let samples: [DeviceFarmClientTypes.Sample]?
    let nextToken: Swift.String?
}

extension ListSamplesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case samples
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Sample?].self, forKey: .samples)
        var samplesDecoded0:[DeviceFarmClientTypes.Sample]? = nil
        if let samplesContainer = samplesContainer {
            samplesDecoded0 = [DeviceFarmClientTypes.Sample]()
            for structure0 in samplesContainer {
                if let structure0 = structure0 {
                    samplesDecoded0?.append(structure0)
                }
            }
        }
        samples = samplesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSuitesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSuitesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the list suites operation.
public struct ListSuitesInput: Swift.Equatable {
    /// The job's Amazon Resource Name (ARN).
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListSuitesInputBody: Swift.Equatable {
    let arn: Swift.String?
    let nextToken: Swift.String?
}

extension ListSuitesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSuitesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSuitesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSuitesOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSuitesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSuitesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.suites = output.suites
        } else {
            self.nextToken = nil
            self.suites = nil
        }
    }
}

/// Represents the result of a list suites request.
public struct ListSuitesOutputResponse: Swift.Equatable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// Information about the suites.
    public var suites: [DeviceFarmClientTypes.Suite]?

    public init (
        nextToken: Swift.String? = nil,
        suites: [DeviceFarmClientTypes.Suite]? = nil
    )
    {
        self.nextToken = nextToken
        self.suites = suites
    }
}

struct ListSuitesOutputResponseBody: Swift.Equatable {
    let suites: [DeviceFarmClientTypes.Suite]?
    let nextToken: Swift.String?
}

extension ListSuitesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case suites
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suitesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Suite?].self, forKey: .suites)
        var suitesDecoded0:[DeviceFarmClientTypes.Suite]? = nil
        if let suitesContainer = suitesContainer {
            suitesDecoded0 = [DeviceFarmClientTypes.Suite]()
            for structure0 in suitesContainer {
                if let structure0 = structure0 {
                    suitesDecoded0?.append(structure0)
                }
            }
        }
        suites = suitesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource or resources for which to list tags. You can associate tags with the following Device Farm resources: PROJECT, RUN, NETWORK_PROFILE, INSTANCE_PROFILE, DEVICE_INSTANCE, SESSION, DEVICE_POOL, DEVICE, and VPCE_CONFIGURATION.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOperationException" : self = .tagOperationException(try TagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case notFoundException(NotFoundException)
    case tagOperationException(TagOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters. Tag values can have a maximum length of 256 characters.
    public var tags: [DeviceFarmClientTypes.Tag]?

    public init (
        tags: [DeviceFarmClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [DeviceFarmClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DeviceFarmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DeviceFarmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTestGridProjectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResult
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResult = self.maxResult {
            try encodeContainer.encode(maxResult, forKey: .maxResult)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTestGridProjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTestGridProjectsInput: Swift.Equatable {
    /// Return no more than this number of results.
    public var maxResult: Swift.Int?
    /// From a response, used to continue a paginated listing.
    public var nextToken: Swift.String?

    public init (
        maxResult: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResult = maxResult
        self.nextToken = nextToken
    }
}

struct ListTestGridProjectsInputBody: Swift.Equatable {
    let maxResult: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTestGridProjectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResult
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResult)
        maxResult = maxResultDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestGridProjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTestGridProjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTestGridProjectsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTestGridProjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTestGridProjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.testGridProjects = output.testGridProjects
        } else {
            self.nextToken = nil
            self.testGridProjects = nil
        }
    }
}

public struct ListTestGridProjectsOutputResponse: Swift.Equatable {
    /// Used for pagination. Pass into [ListTestGridProjects] to get more results in a paginated request.
    public var nextToken: Swift.String?
    /// The list of TestGridProjects, based on a [ListTestGridProjectsRequest].
    public var testGridProjects: [DeviceFarmClientTypes.TestGridProject]?

    public init (
        nextToken: Swift.String? = nil,
        testGridProjects: [DeviceFarmClientTypes.TestGridProject]? = nil
    )
    {
        self.nextToken = nextToken
        self.testGridProjects = testGridProjects
    }
}

struct ListTestGridProjectsOutputResponseBody: Swift.Equatable {
    let testGridProjects: [DeviceFarmClientTypes.TestGridProject]?
    let nextToken: Swift.String?
}

extension ListTestGridProjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case testGridProjects
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testGridProjectsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.TestGridProject?].self, forKey: .testGridProjects)
        var testGridProjectsDecoded0:[DeviceFarmClientTypes.TestGridProject]? = nil
        if let testGridProjectsContainer = testGridProjectsContainer {
            testGridProjectsDecoded0 = [DeviceFarmClientTypes.TestGridProject]()
            for structure0 in testGridProjectsContainer {
                if let structure0 = structure0 {
                    testGridProjectsDecoded0?.append(structure0)
                }
            }
        }
        testGridProjects = testGridProjectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestGridSessionActionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResult
        case nextToken
        case sessionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResult = self.maxResult {
            try encodeContainer.encode(maxResult, forKey: .maxResult)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sessionArn = self.sessionArn {
            try encodeContainer.encode(sessionArn, forKey: .sessionArn)
        }
    }
}

extension ListTestGridSessionActionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTestGridSessionActionsInput: Swift.Equatable {
    /// The maximum number of sessions to return per response.
    public var maxResult: Swift.Int?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The ARN of the session to retrieve.
    /// This member is required.
    public var sessionArn: Swift.String?

    public init (
        maxResult: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sessionArn: Swift.String? = nil
    )
    {
        self.maxResult = maxResult
        self.nextToken = nextToken
        self.sessionArn = sessionArn
    }
}

struct ListTestGridSessionActionsInputBody: Swift.Equatable {
    let sessionArn: Swift.String?
    let maxResult: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTestGridSessionActionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResult
        case nextToken
        case sessionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionArn)
        sessionArn = sessionArnDecoded
        let maxResultDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResult)
        maxResult = maxResultDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestGridSessionActionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTestGridSessionActionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTestGridSessionActionsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTestGridSessionActionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTestGridSessionActionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actions = output.actions
            self.nextToken = output.nextToken
        } else {
            self.actions = nil
            self.nextToken = nil
        }
    }
}

public struct ListTestGridSessionActionsOutputResponse: Swift.Equatable {
    /// The action taken by the session.
    public var actions: [DeviceFarmClientTypes.TestGridSessionAction]?
    /// Pagination token.
    public var nextToken: Swift.String?

    public init (
        actions: [DeviceFarmClientTypes.TestGridSessionAction]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actions = actions
        self.nextToken = nextToken
    }
}

struct ListTestGridSessionActionsOutputResponseBody: Swift.Equatable {
    let actions: [DeviceFarmClientTypes.TestGridSessionAction]?
    let nextToken: Swift.String?
}

extension ListTestGridSessionActionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.TestGridSessionAction?].self, forKey: .actions)
        var actionsDecoded0:[DeviceFarmClientTypes.TestGridSessionAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [DeviceFarmClientTypes.TestGridSessionAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestGridSessionArtifactsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResult
        case nextToken
        case sessionArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResult = self.maxResult {
            try encodeContainer.encode(maxResult, forKey: .maxResult)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sessionArn = self.sessionArn {
            try encodeContainer.encode(sessionArn, forKey: .sessionArn)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension ListTestGridSessionArtifactsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTestGridSessionArtifactsInput: Swift.Equatable {
    /// The maximum number of results to be returned by a request.
    public var maxResult: Swift.Int?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The ARN of a [TestGridSession].
    /// This member is required.
    public var sessionArn: Swift.String?
    /// Limit results to a specified type of artifact.
    public var type: DeviceFarmClientTypes.TestGridSessionArtifactCategory?

    public init (
        maxResult: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sessionArn: Swift.String? = nil,
        type: DeviceFarmClientTypes.TestGridSessionArtifactCategory? = nil
    )
    {
        self.maxResult = maxResult
        self.nextToken = nextToken
        self.sessionArn = sessionArn
        self.type = type
    }
}

struct ListTestGridSessionArtifactsInputBody: Swift.Equatable {
    let sessionArn: Swift.String?
    let type: DeviceFarmClientTypes.TestGridSessionArtifactCategory?
    let maxResult: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTestGridSessionArtifactsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResult
        case nextToken
        case sessionArn
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionArn)
        sessionArn = sessionArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridSessionArtifactCategory.self, forKey: .type)
        type = typeDecoded
        let maxResultDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResult)
        maxResult = maxResultDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestGridSessionArtifactsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTestGridSessionArtifactsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTestGridSessionArtifactsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTestGridSessionArtifactsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTestGridSessionArtifactsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.artifacts = output.artifacts
            self.nextToken = output.nextToken
        } else {
            self.artifacts = nil
            self.nextToken = nil
        }
    }
}

public struct ListTestGridSessionArtifactsOutputResponse: Swift.Equatable {
    /// A list of test grid session artifacts for a [TestGridSession].
    public var artifacts: [DeviceFarmClientTypes.TestGridSessionArtifact]?
    /// Pagination token.
    public var nextToken: Swift.String?

    public init (
        artifacts: [DeviceFarmClientTypes.TestGridSessionArtifact]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.artifacts = artifacts
        self.nextToken = nextToken
    }
}

struct ListTestGridSessionArtifactsOutputResponseBody: Swift.Equatable {
    let artifacts: [DeviceFarmClientTypes.TestGridSessionArtifact]?
    let nextToken: Swift.String?
}

extension ListTestGridSessionArtifactsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifacts
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.TestGridSessionArtifact?].self, forKey: .artifacts)
        var artifactsDecoded0:[DeviceFarmClientTypes.TestGridSessionArtifact]? = nil
        if let artifactsContainer = artifactsContainer {
            artifactsDecoded0 = [DeviceFarmClientTypes.TestGridSessionArtifact]()
            for structure0 in artifactsContainer {
                if let structure0 = structure0 {
                    artifactsDecoded0?.append(structure0)
                }
            }
        }
        artifacts = artifactsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestGridSessionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimeAfter
        case creationTimeBefore
        case endTimeAfter
        case endTimeBefore
        case maxResult
        case nextToken
        case projectArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimeAfter = self.creationTimeAfter {
            try encodeContainer.encodeTimestamp(creationTimeAfter, format: .epochSeconds, forKey: .creationTimeAfter)
        }
        if let creationTimeBefore = self.creationTimeBefore {
            try encodeContainer.encodeTimestamp(creationTimeBefore, format: .epochSeconds, forKey: .creationTimeBefore)
        }
        if let endTimeAfter = self.endTimeAfter {
            try encodeContainer.encodeTimestamp(endTimeAfter, format: .epochSeconds, forKey: .endTimeAfter)
        }
        if let endTimeBefore = self.endTimeBefore {
            try encodeContainer.encodeTimestamp(endTimeBefore, format: .epochSeconds, forKey: .endTimeBefore)
        }
        if let maxResult = self.maxResult {
            try encodeContainer.encode(maxResult, forKey: .maxResult)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let projectArn = self.projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension ListTestGridSessionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTestGridSessionsInput: Swift.Equatable {
    /// Return only sessions created after this time.
    public var creationTimeAfter: ClientRuntime.Date?
    /// Return only sessions created before this time.
    public var creationTimeBefore: ClientRuntime.Date?
    /// Return only sessions that ended after this time.
    public var endTimeAfter: ClientRuntime.Date?
    /// Return only sessions that ended before this time.
    public var endTimeBefore: ClientRuntime.Date?
    /// Return only this many results at a time.
    public var maxResult: Swift.Int?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// ARN of a [TestGridProject].
    /// This member is required.
    public var projectArn: Swift.String?
    /// Return only sessions in this state.
    public var status: DeviceFarmClientTypes.TestGridSessionStatus?

    public init (
        creationTimeAfter: ClientRuntime.Date? = nil,
        creationTimeBefore: ClientRuntime.Date? = nil,
        endTimeAfter: ClientRuntime.Date? = nil,
        endTimeBefore: ClientRuntime.Date? = nil,
        maxResult: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        status: DeviceFarmClientTypes.TestGridSessionStatus? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.endTimeAfter = endTimeAfter
        self.endTimeBefore = endTimeBefore
        self.maxResult = maxResult
        self.nextToken = nextToken
        self.projectArn = projectArn
        self.status = status
    }
}

struct ListTestGridSessionsInputBody: Swift.Equatable {
    let projectArn: Swift.String?
    let status: DeviceFarmClientTypes.TestGridSessionStatus?
    let creationTimeAfter: ClientRuntime.Date?
    let creationTimeBefore: ClientRuntime.Date?
    let endTimeAfter: ClientRuntime.Date?
    let endTimeBefore: ClientRuntime.Date?
    let maxResult: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTestGridSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimeAfter
        case creationTimeBefore
        case endTimeAfter
        case endTimeBefore
        case maxResult
        case nextToken
        case projectArn
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridSessionStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeAfterDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimeAfter)
        creationTimeAfter = creationTimeAfterDecoded
        let creationTimeBeforeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimeBefore)
        creationTimeBefore = creationTimeBeforeDecoded
        let endTimeAfterDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTimeAfter)
        endTimeAfter = endTimeAfterDecoded
        let endTimeBeforeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTimeBefore)
        endTimeBefore = endTimeBeforeDecoded
        let maxResultDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResult)
        maxResult = maxResultDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestGridSessionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTestGridSessionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTestGridSessionsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTestGridSessionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTestGridSessionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.testGridSessions = output.testGridSessions
        } else {
            self.nextToken = nil
            self.testGridSessions = nil
        }
    }
}

public struct ListTestGridSessionsOutputResponse: Swift.Equatable {
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The sessions that match the criteria in a [ListTestGridSessionsRequest].
    public var testGridSessions: [DeviceFarmClientTypes.TestGridSession]?

    public init (
        nextToken: Swift.String? = nil,
        testGridSessions: [DeviceFarmClientTypes.TestGridSession]? = nil
    )
    {
        self.nextToken = nextToken
        self.testGridSessions = testGridSessions
    }
}

struct ListTestGridSessionsOutputResponseBody: Swift.Equatable {
    let testGridSessions: [DeviceFarmClientTypes.TestGridSession]?
    let nextToken: Swift.String?
}

extension ListTestGridSessionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case testGridSessions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testGridSessionsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.TestGridSession?].self, forKey: .testGridSessions)
        var testGridSessionsDecoded0:[DeviceFarmClientTypes.TestGridSession]? = nil
        if let testGridSessionsContainer = testGridSessionsContainer {
            testGridSessionsDecoded0 = [DeviceFarmClientTypes.TestGridSession]()
            for structure0 in testGridSessionsContainer {
                if let structure0 = structure0 {
                    testGridSessionsDecoded0?.append(structure0)
                }
            }
        }
        testGridSessions = testGridSessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTestsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the list tests operation.
public struct ListTestsInput: Swift.Equatable {
    /// The test suite's Amazon Resource Name (ARN).
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListTestsInputBody: Swift.Equatable {
    let arn: Swift.String?
    let nextToken: Swift.String?
}

extension ListTestsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTestsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTestsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTestsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTestsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tests = output.tests
        } else {
            self.nextToken = nil
            self.tests = nil
        }
    }
}

/// Represents the result of a list tests request.
public struct ListTestsOutputResponse: Swift.Equatable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// Information about the tests.
    public var tests: [DeviceFarmClientTypes.Test]?

    public init (
        nextToken: Swift.String? = nil,
        tests: [DeviceFarmClientTypes.Test]? = nil
    )
    {
        self.nextToken = nextToken
        self.tests = tests
    }
}

struct ListTestsOutputResponseBody: Swift.Equatable {
    let tests: [DeviceFarmClientTypes.Test]?
    let nextToken: Swift.String?
}

extension ListTestsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tests
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Test?].self, forKey: .tests)
        var testsDecoded0:[DeviceFarmClientTypes.Test]? = nil
        if let testsContainer = testsContainer {
            testsDecoded0 = [DeviceFarmClientTypes.Test]()
            for structure0 in testsContainer {
                if let structure0 = structure0 {
                    testsDecoded0?.append(structure0)
                }
            }
        }
        tests = testsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUniqueProblemsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListUniqueProblemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the list unique problems operation.
public struct ListUniqueProblemsInput: Swift.Equatable {
    /// The unique problems' ARNs.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListUniqueProblemsInputBody: Swift.Equatable {
    let arn: Swift.String?
    let nextToken: Swift.String?
}

extension ListUniqueProblemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUniqueProblemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUniqueProblemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListUniqueProblemsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUniqueProblemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListUniqueProblemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.uniqueProblems = output.uniqueProblems
        } else {
            self.nextToken = nil
            self.uniqueProblems = nil
        }
    }
}

/// Represents the result of a list unique problems request.
public struct ListUniqueProblemsOutputResponse: Swift.Equatable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// Information about the unique problems. Allowed values include:
    ///
    /// * PENDING
    ///
    /// * PASSED
    ///
    /// * WARNED
    ///
    /// * FAILED
    ///
    /// * SKIPPED
    ///
    /// * ERRORED
    ///
    /// * STOPPED
    public var uniqueProblems: [Swift.String:[DeviceFarmClientTypes.UniqueProblem]]?

    public init (
        nextToken: Swift.String? = nil,
        uniqueProblems: [Swift.String:[DeviceFarmClientTypes.UniqueProblem]]? = nil
    )
    {
        self.nextToken = nextToken
        self.uniqueProblems = uniqueProblems
    }
}

struct ListUniqueProblemsOutputResponseBody: Swift.Equatable {
    let uniqueProblems: [Swift.String:[DeviceFarmClientTypes.UniqueProblem]]?
    let nextToken: Swift.String?
}

extension ListUniqueProblemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case uniqueProblems
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uniqueProblemsContainer = try containerValues.decodeIfPresent([Swift.String: [DeviceFarmClientTypes.UniqueProblem?]?].self, forKey: .uniqueProblems)
        var uniqueProblemsDecoded0: [Swift.String:[DeviceFarmClientTypes.UniqueProblem]]? = nil
        if let uniqueProblemsContainer = uniqueProblemsContainer {
            uniqueProblemsDecoded0 = [Swift.String:[DeviceFarmClientTypes.UniqueProblem]]()
            for (key0, uniqueproblems0) in uniqueProblemsContainer {
                var uniqueproblems0Decoded0: [DeviceFarmClientTypes.UniqueProblem]? = nil
                if let uniqueproblems0 = uniqueproblems0 {
                    uniqueproblems0Decoded0 = [DeviceFarmClientTypes.UniqueProblem]()
                    for structure1 in uniqueproblems0 {
                        if let structure1 = structure1 {
                            uniqueproblems0Decoded0?.append(structure1)
                        }
                    }
                }
                uniqueProblemsDecoded0?[key0] = uniqueproblems0Decoded0
            }
        }
        uniqueProblems = uniqueProblemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUploadsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension ListUploadsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the list uploads operation.
public struct ListUploadsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the project for which you want to list uploads.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The type of upload. Must be one of the following values:
    ///
    /// * ANDROID_APP
    ///
    /// * IOS_APP
    ///
    /// * WEB_APP
    ///
    /// * EXTERNAL_DATA
    ///
    /// * APPIUM_JAVA_JUNIT_TEST_PACKAGE
    ///
    /// * APPIUM_JAVA_TESTNG_TEST_PACKAGE
    ///
    /// * APPIUM_PYTHON_TEST_PACKAGE
    ///
    /// * APPIUM_NODE_TEST_PACKAGE
    ///
    /// * APPIUM_RUBY_TEST_PACKAGE
    ///
    /// * APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE
    ///
    /// * APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE
    ///
    /// * APPIUM_WEB_PYTHON_TEST_PACKAGE
    ///
    /// * APPIUM_WEB_NODE_TEST_PACKAGE
    ///
    /// * APPIUM_WEB_RUBY_TEST_PACKAGE
    ///
    /// * CALABASH_TEST_PACKAGE
    ///
    /// * INSTRUMENTATION_TEST_PACKAGE
    ///
    /// * UIAUTOMATION_TEST_PACKAGE
    ///
    /// * UIAUTOMATOR_TEST_PACKAGE
    ///
    /// * XCTEST_TEST_PACKAGE
    ///
    /// * XCTEST_UI_TEST_PACKAGE
    ///
    /// * APPIUM_JAVA_JUNIT_TEST_SPEC
    ///
    /// * APPIUM_JAVA_TESTNG_TEST_SPEC
    ///
    /// * APPIUM_PYTHON_TEST_SPEC
    ///
    /// * APPIUM_NODE_TEST_SPEC
    ///
    /// * APPIUM_RUBY_TEST_SPEC
    ///
    /// * APPIUM_WEB_JAVA_JUNIT_TEST_SPEC
    ///
    /// * APPIUM_WEB_JAVA_TESTNG_TEST_SPEC
    ///
    /// * APPIUM_WEB_PYTHON_TEST_SPEC
    ///
    /// * APPIUM_WEB_NODE_TEST_SPEC
    ///
    /// * APPIUM_WEB_RUBY_TEST_SPEC
    ///
    /// * INSTRUMENTATION_TEST_SPEC
    ///
    /// * XCTEST_UI_TEST_SPEC
    public var type: DeviceFarmClientTypes.UploadType?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        type: DeviceFarmClientTypes.UploadType? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListUploadsInputBody: Swift.Equatable {
    let arn: Swift.String?
    let type: DeviceFarmClientTypes.UploadType?
    let nextToken: Swift.String?
}

extension ListUploadsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.UploadType.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUploadsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUploadsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListUploadsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUploadsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListUploadsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.uploads = output.uploads
        } else {
            self.nextToken = nil
            self.uploads = nil
        }
    }
}

/// Represents the result of a list uploads request.
public struct ListUploadsOutputResponse: Swift.Equatable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// Information about the uploads.
    public var uploads: [DeviceFarmClientTypes.Upload]?

    public init (
        nextToken: Swift.String? = nil,
        uploads: [DeviceFarmClientTypes.Upload]? = nil
    )
    {
        self.nextToken = nextToken
        self.uploads = uploads
    }
}

struct ListUploadsOutputResponseBody: Swift.Equatable {
    let uploads: [DeviceFarmClientTypes.Upload]?
    let nextToken: Swift.String?
}

extension ListUploadsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case uploads
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Upload?].self, forKey: .uploads)
        var uploadsDecoded0:[DeviceFarmClientTypes.Upload]? = nil
        if let uploadsContainer = uploadsContainer {
            uploadsDecoded0 = [DeviceFarmClientTypes.Upload]()
            for structure0 in uploadsContainer {
                if let structure0 = structure0 {
                    uploadsDecoded0?.append(structure0)
                }
            }
        }
        uploads = uploadsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVPCEConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListVPCEConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListVPCEConfigurationsInput: Swift.Equatable {
    /// An integer that specifies the maximum number of items you want to return in the API response.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVPCEConfigurationsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListVPCEConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVPCEConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVPCEConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVPCEConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVPCEConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVPCEConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.vpceConfigurations = output.vpceConfigurations
        } else {
            self.nextToken = nil
            self.vpceConfigurations = nil
        }
    }
}

public struct ListVPCEConfigurationsOutputResponse: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// An array of VPCEConfiguration objects that contain information about your VPC endpoint configuration.
    public var vpceConfigurations: [DeviceFarmClientTypes.VPCEConfiguration]?

    public init (
        nextToken: Swift.String? = nil,
        vpceConfigurations: [DeviceFarmClientTypes.VPCEConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.vpceConfigurations = vpceConfigurations
    }
}

struct ListVPCEConfigurationsOutputResponseBody: Swift.Equatable {
    let vpceConfigurations: [DeviceFarmClientTypes.VPCEConfiguration]?
    let nextToken: Swift.String?
}

extension ListVPCEConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case vpceConfigurations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpceConfigurationsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.VPCEConfiguration?].self, forKey: .vpceConfigurations)
        var vpceConfigurationsDecoded0:[DeviceFarmClientTypes.VPCEConfiguration]? = nil
        if let vpceConfigurationsContainer = vpceConfigurationsContainer {
            vpceConfigurationsDecoded0 = [DeviceFarmClientTypes.VPCEConfiguration]()
            for structure0 in vpceConfigurationsContainer {
                if let structure0 = structure0 {
                    vpceConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        vpceConfigurations = vpceConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DeviceFarmClientTypes.Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case latitude
        case longitude
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let latitude = self.latitude {
            try encodeContainer.encode(latitude, forKey: .latitude)
        }
        if let longitude = self.longitude {
            try encodeContainer.encode(longitude, forKey: .longitude)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latitudeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .latitude)
        latitude = latitudeDecoded
        let longitudeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .longitude)
        longitude = longitudeDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents a latitude and longitude pair, expressed in geographic coordinate system degrees (for example, 47.6204, -122.3491). Elevation is currently not supported.
    public struct Location: Swift.Equatable {
        /// The latitude.
        /// This member is required.
        public var latitude: Swift.Double?
        /// The longitude.
        /// This member is required.
        public var longitude: Swift.Double?

        public init (
            latitude: Swift.Double? = nil,
            longitude: Swift.Double? = nil
        )
        {
            self.latitude = latitude
            self.longitude = longitude
        }
    }

}

extension DeviceFarmClientTypes.MonetaryAmount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount
        case currencyCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = self.amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode.rawValue, forKey: .currencyCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amountDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .amount)
        amount = amountDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.CurrencyCode.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
    }
}

extension DeviceFarmClientTypes {
    /// A number that represents the monetary amount for an offering or transaction.
    public struct MonetaryAmount: Swift.Equatable {
        /// The numerical amount of an offering or transaction.
        public var amount: Swift.Double?
        /// The currency code of a monetary amount. For example, USD means U.S. dollars.
        public var currencyCode: DeviceFarmClientTypes.CurrencyCode?

        public init (
            amount: Swift.Double? = nil,
            currencyCode: DeviceFarmClientTypes.CurrencyCode? = nil
        )
        {
            self.amount = amount
            self.currencyCode = currencyCode
        }
    }

}

extension DeviceFarmClientTypes.NetworkProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case downlinkBandwidthBits
        case downlinkDelayMs
        case downlinkJitterMs
        case downlinkLossPercent
        case name
        case type
        case uplinkBandwidthBits
        case uplinkDelayMs
        case uplinkJitterMs
        case uplinkLossPercent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let downlinkBandwidthBits = self.downlinkBandwidthBits {
            try encodeContainer.encode(downlinkBandwidthBits, forKey: .downlinkBandwidthBits)
        }
        if let downlinkDelayMs = self.downlinkDelayMs {
            try encodeContainer.encode(downlinkDelayMs, forKey: .downlinkDelayMs)
        }
        if let downlinkJitterMs = self.downlinkJitterMs {
            try encodeContainer.encode(downlinkJitterMs, forKey: .downlinkJitterMs)
        }
        if downlinkLossPercent != 0 {
            try encodeContainer.encode(downlinkLossPercent, forKey: .downlinkLossPercent)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uplinkBandwidthBits = self.uplinkBandwidthBits {
            try encodeContainer.encode(uplinkBandwidthBits, forKey: .uplinkBandwidthBits)
        }
        if let uplinkDelayMs = self.uplinkDelayMs {
            try encodeContainer.encode(uplinkDelayMs, forKey: .uplinkDelayMs)
        }
        if let uplinkJitterMs = self.uplinkJitterMs {
            try encodeContainer.encode(uplinkJitterMs, forKey: .uplinkJitterMs)
        }
        if uplinkLossPercent != 0 {
            try encodeContainer.encode(uplinkLossPercent, forKey: .uplinkLossPercent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.NetworkProfileType.self, forKey: .type)
        type = typeDecoded
        let uplinkBandwidthBitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkBandwidthBits)
        uplinkBandwidthBits = uplinkBandwidthBitsDecoded
        let downlinkBandwidthBitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkBandwidthBits)
        downlinkBandwidthBits = downlinkBandwidthBitsDecoded
        let uplinkDelayMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkDelayMs)
        uplinkDelayMs = uplinkDelayMsDecoded
        let downlinkDelayMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkDelayMs)
        downlinkDelayMs = downlinkDelayMsDecoded
        let uplinkJitterMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkJitterMs)
        uplinkJitterMs = uplinkJitterMsDecoded
        let downlinkJitterMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkJitterMs)
        downlinkJitterMs = downlinkJitterMsDecoded
        let uplinkLossPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkLossPercent) ?? 0
        uplinkLossPercent = uplinkLossPercentDecoded
        let downlinkLossPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkLossPercent) ?? 0
        downlinkLossPercent = downlinkLossPercentDecoded
    }
}

extension DeviceFarmClientTypes {
    /// An array of settings that describes characteristics of a network profile.
    public struct NetworkProfile: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the network profile.
        public var arn: Swift.String?
        /// The description of the network profile.
        public var description: Swift.String?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public var downlinkBandwidthBits: Swift.Int?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public var downlinkDelayMs: Swift.Int?
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public var downlinkJitterMs: Swift.Int?
        /// Proportion of received packets that fail to arrive from 0 to 100 percent.
        public var downlinkLossPercent: Swift.Int
        /// The name of the network profile.
        public var name: Swift.String?
        /// The type of network profile. Valid values are listed here.
        public var type: DeviceFarmClientTypes.NetworkProfileType?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public var uplinkBandwidthBits: Swift.Int?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public var uplinkDelayMs: Swift.Int?
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public var uplinkJitterMs: Swift.Int?
        /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
        public var uplinkLossPercent: Swift.Int

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            downlinkBandwidthBits: Swift.Int? = nil,
            downlinkDelayMs: Swift.Int? = nil,
            downlinkJitterMs: Swift.Int? = nil,
            downlinkLossPercent: Swift.Int = 0,
            name: Swift.String? = nil,
            type: DeviceFarmClientTypes.NetworkProfileType? = nil,
            uplinkBandwidthBits: Swift.Int? = nil,
            uplinkDelayMs: Swift.Int? = nil,
            uplinkJitterMs: Swift.Int? = nil,
            uplinkLossPercent: Swift.Int = 0
        )
        {
            self.arn = arn
            self.description = description
            self.downlinkBandwidthBits = downlinkBandwidthBits
            self.downlinkDelayMs = downlinkDelayMs
            self.downlinkJitterMs = downlinkJitterMs
            self.downlinkLossPercent = downlinkLossPercent
            self.name = name
            self.type = type
            self.uplinkBandwidthBits = uplinkBandwidthBits
            self.uplinkDelayMs = uplinkDelayMs
            self.uplinkJitterMs = uplinkJitterMs
            self.uplinkLossPercent = uplinkLossPercent
        }
    }

}

extension DeviceFarmClientTypes {
    public enum NetworkProfileType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case curated
        case `private`
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkProfileType] {
            return [
                .curated,
                .private,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .curated: return "CURATED"
            case .private: return "PRIVATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkProfileType(rawValue: rawValue) ?? NetworkProfileType.sdkUnknown(rawValue)
        }
    }
}

extension NotEligibleException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotEligibleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception gets thrown when a user is not eligible to perform the specified transaction.
public struct NotEligibleException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The HTTP response code of a Not Eligible exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotEligibleExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotEligibleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified entity was not found.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any additional information about the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeviceFarmClientTypes.Offering: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case platform
        case recurringCharges
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let recurringCharges = recurringCharges {
            var recurringChargesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recurringCharges)
            for recurringcharge0 in recurringCharges {
                try recurringChargesContainer.encode(recurringcharge0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.OfferingType.self, forKey: .type)
        type = typeDecoded
        let platformDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DevicePlatform.self, forKey: .platform)
        platform = platformDecoded
        let recurringChargesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.RecurringCharge?].self, forKey: .recurringCharges)
        var recurringChargesDecoded0:[DeviceFarmClientTypes.RecurringCharge]? = nil
        if let recurringChargesContainer = recurringChargesContainer {
            recurringChargesDecoded0 = [DeviceFarmClientTypes.RecurringCharge]()
            for structure0 in recurringChargesContainer {
                if let structure0 = structure0 {
                    recurringChargesDecoded0?.append(structure0)
                }
            }
        }
        recurringCharges = recurringChargesDecoded0
    }
}

extension DeviceFarmClientTypes {
    /// Represents the metadata of a device offering.
    public struct Offering: Swift.Equatable {
        /// A string that describes the offering.
        public var description: Swift.String?
        /// The ID that corresponds to a device offering.
        public var id: Swift.String?
        /// The platform of the device (for example, ANDROID or IOS).
        public var platform: DeviceFarmClientTypes.DevicePlatform?
        /// Specifies whether there are recurring charges for the offering.
        public var recurringCharges: [DeviceFarmClientTypes.RecurringCharge]?
        /// The type of offering (for example, RECURRING) for a device.
        public var type: DeviceFarmClientTypes.OfferingType?

        public init (
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            platform: DeviceFarmClientTypes.DevicePlatform? = nil,
            recurringCharges: [DeviceFarmClientTypes.RecurringCharge]? = nil,
            type: DeviceFarmClientTypes.OfferingType? = nil
        )
        {
            self.description = description
            self.id = id
            self.platform = platform
            self.recurringCharges = recurringCharges
            self.type = type
        }
    }

}

extension DeviceFarmClientTypes.OfferingPromotion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents information about an offering promotion.
    public struct OfferingPromotion: Swift.Equatable {
        /// A string that describes the offering promotion.
        public var description: Swift.String?
        /// The ID of the offering promotion.
        public var id: Swift.String?

        public init (
            description: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.description = description
            self.id = id
        }
    }

}

extension DeviceFarmClientTypes.OfferingStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectiveOn
        case offering
        case quantity
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let effectiveOn = self.effectiveOn {
            try encodeContainer.encodeTimestamp(effectiveOn, format: .epochSeconds, forKey: .effectiveOn)
        }
        if let offering = self.offering {
            try encodeContainer.encode(offering, forKey: .offering)
        }
        if let quantity = self.quantity {
            try encodeContainer.encode(quantity, forKey: .quantity)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.OfferingTransactionType.self, forKey: .type)
        type = typeDecoded
        let offeringDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Offering.self, forKey: .offering)
        offering = offeringDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        let effectiveOnDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .effectiveOn)
        effectiveOn = effectiveOnDecoded
    }
}

extension DeviceFarmClientTypes {
    /// The status of the offering.
    public struct OfferingStatus: Swift.Equatable {
        /// The date on which the offering is effective.
        public var effectiveOn: ClientRuntime.Date?
        /// Represents the metadata of an offering status.
        public var offering: DeviceFarmClientTypes.Offering?
        /// The number of available devices in the offering.
        public var quantity: Swift.Int?
        /// The type specified for the offering status.
        public var type: DeviceFarmClientTypes.OfferingTransactionType?

        public init (
            effectiveOn: ClientRuntime.Date? = nil,
            offering: DeviceFarmClientTypes.Offering? = nil,
            quantity: Swift.Int? = nil,
            type: DeviceFarmClientTypes.OfferingTransactionType? = nil
        )
        {
            self.effectiveOn = effectiveOn
            self.offering = offering
            self.quantity = quantity
            self.type = type
        }
    }

}

extension DeviceFarmClientTypes.OfferingTransaction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cost
        case createdOn
        case offeringPromotionId
        case offeringStatus
        case transactionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cost = self.cost {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if let createdOn = self.createdOn {
            try encodeContainer.encodeTimestamp(createdOn, format: .epochSeconds, forKey: .createdOn)
        }
        if let offeringPromotionId = self.offeringPromotionId {
            try encodeContainer.encode(offeringPromotionId, forKey: .offeringPromotionId)
        }
        if let offeringStatus = self.offeringStatus {
            try encodeContainer.encode(offeringStatus, forKey: .offeringStatus)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringStatusDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.OfferingStatus.self, forKey: .offeringStatus)
        offeringStatus = offeringStatusDecoded
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let offeringPromotionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringPromotionId)
        offeringPromotionId = offeringPromotionIdDecoded
        let createdOnDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdOn)
        createdOn = createdOnDecoded
        let costDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.MonetaryAmount.self, forKey: .cost)
        cost = costDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents the metadata of an offering transaction.
    public struct OfferingTransaction: Swift.Equatable {
        /// The cost of an offering transaction.
        public var cost: DeviceFarmClientTypes.MonetaryAmount?
        /// The date on which an offering transaction was created.
        public var createdOn: ClientRuntime.Date?
        /// The ID that corresponds to a device offering promotion.
        public var offeringPromotionId: Swift.String?
        /// The status of an offering transaction.
        public var offeringStatus: DeviceFarmClientTypes.OfferingStatus?
        /// The transaction ID of the offering transaction.
        public var transactionId: Swift.String?

        public init (
            cost: DeviceFarmClientTypes.MonetaryAmount? = nil,
            createdOn: ClientRuntime.Date? = nil,
            offeringPromotionId: Swift.String? = nil,
            offeringStatus: DeviceFarmClientTypes.OfferingStatus? = nil,
            transactionId: Swift.String? = nil
        )
        {
            self.cost = cost
            self.createdOn = createdOn
            self.offeringPromotionId = offeringPromotionId
            self.offeringStatus = offeringStatus
            self.transactionId = transactionId
        }
    }

}

extension DeviceFarmClientTypes {
    public enum OfferingTransactionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case purchase
        case renew
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [OfferingTransactionType] {
            return [
                .purchase,
                .renew,
                .system,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .purchase: return "PURCHASE"
            case .renew: return "RENEW"
            case .system: return "SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OfferingTransactionType(rawValue: rawValue) ?? OfferingTransactionType.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum OfferingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case recurring
        case sdkUnknown(Swift.String)

        public static var allCases: [OfferingType] {
            return [
                .recurring,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .recurring: return "RECURRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OfferingType(rawValue: rawValue) ?? OfferingType.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.Problem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case device
        case job
        case message
        case result
        case run
        case suite
        case test
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let device = self.device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let job = self.job {
            try encodeContainer.encode(job, forKey: .job)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let result = self.result {
            try encodeContainer.encode(result.rawValue, forKey: .result)
        }
        if let run = self.run {
            try encodeContainer.encode(run, forKey: .run)
        }
        if let suite = self.suite {
            try encodeContainer.encode(suite, forKey: .suite)
        }
        if let test = self.test {
            try encodeContainer.encode(test, forKey: .test)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ProblemDetail.self, forKey: .run)
        run = runDecoded
        let jobDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ProblemDetail.self, forKey: .job)
        job = jobDecoded
        let suiteDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ProblemDetail.self, forKey: .suite)
        suite = suiteDecoded
        let testDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ProblemDetail.self, forKey: .test)
        test = testDecoded
        let deviceDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
        let resultDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionResult.self, forKey: .result)
        result = resultDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents a specific warning or failure.
    public struct Problem: Swift.Equatable {
        /// Information about the associated device.
        public var device: DeviceFarmClientTypes.Device?
        /// Information about the associated job.
        public var job: DeviceFarmClientTypes.ProblemDetail?
        /// A message about the problem's result.
        public var message: Swift.String?
        /// The problem's result. Allowed values include:
        ///
        /// * PENDING
        ///
        /// * PASSED
        ///
        /// * WARNED
        ///
        /// * FAILED
        ///
        /// * SKIPPED
        ///
        /// * ERRORED
        ///
        /// * STOPPED
        public var result: DeviceFarmClientTypes.ExecutionResult?
        /// Information about the associated run.
        public var run: DeviceFarmClientTypes.ProblemDetail?
        /// Information about the associated suite.
        public var suite: DeviceFarmClientTypes.ProblemDetail?
        /// Information about the associated test.
        public var test: DeviceFarmClientTypes.ProblemDetail?

        public init (
            device: DeviceFarmClientTypes.Device? = nil,
            job: DeviceFarmClientTypes.ProblemDetail? = nil,
            message: Swift.String? = nil,
            result: DeviceFarmClientTypes.ExecutionResult? = nil,
            run: DeviceFarmClientTypes.ProblemDetail? = nil,
            suite: DeviceFarmClientTypes.ProblemDetail? = nil,
            test: DeviceFarmClientTypes.ProblemDetail? = nil
        )
        {
            self.device = device
            self.job = job
            self.message = message
            self.result = result
            self.run = run
            self.suite = suite
            self.test = test
        }
    }

}

extension DeviceFarmClientTypes.ProblemDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Information about a problem detail.
    public struct ProblemDetail: Swift.Equatable {
        /// The problem detail's ARN.
        public var arn: Swift.String?
        /// The problem detail's name.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension DeviceFarmClientTypes.Project: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case created
        case defaultJobTimeoutMinutes
        case name
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let defaultJobTimeoutMinutes = self.defaultJobTimeoutMinutes {
            try encodeContainer.encode(defaultJobTimeoutMinutes, forKey: .defaultJobTimeoutMinutes)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultJobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultJobTimeoutMinutes)
        defaultJobTimeoutMinutes = defaultJobTimeoutMinutesDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents an operating-system neutral workspace for running and managing tests.
    public struct Project: Swift.Equatable {
        /// The project's ARN.
        public var arn: Swift.String?
        /// When the project was created.
        public var created: ClientRuntime.Date?
        /// The default number of minutes (at the project level) a test run executes before it times out. The default value is 150 minutes.
        public var defaultJobTimeoutMinutes: Swift.Int?
        /// The project's name.
        public var name: Swift.String?
        /// The VPC security groups and subnets that are attached to a project.
        public var vpcConfig: DeviceFarmClientTypes.VpcConfig?

        public init (
            arn: Swift.String? = nil,
            created: ClientRuntime.Date? = nil,
            defaultJobTimeoutMinutes: Swift.Int? = nil,
            name: Swift.String? = nil,
            vpcConfig: DeviceFarmClientTypes.VpcConfig? = nil
        )
        {
            self.arn = arn
            self.created = created
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.name = name
            self.vpcConfig = vpcConfig
        }
    }

}

extension PurchaseOfferingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offeringId
        case offeringPromotionId
        case quantity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offeringId = self.offeringId {
            try encodeContainer.encode(offeringId, forKey: .offeringId)
        }
        if let offeringPromotionId = self.offeringPromotionId {
            try encodeContainer.encode(offeringPromotionId, forKey: .offeringPromotionId)
        }
        if let quantity = self.quantity {
            try encodeContainer.encode(quantity, forKey: .quantity)
        }
    }
}

extension PurchaseOfferingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request for a purchase offering.
public struct PurchaseOfferingInput: Swift.Equatable {
    /// The ID of the offering.
    /// This member is required.
    public var offeringId: Swift.String?
    /// The ID of the offering promotion to be applied to the purchase.
    public var offeringPromotionId: Swift.String?
    /// The number of device slots to purchase in an offering request.
    /// This member is required.
    public var quantity: Swift.Int?

    public init (
        offeringId: Swift.String? = nil,
        offeringPromotionId: Swift.String? = nil,
        quantity: Swift.Int? = nil
    )
    {
        self.offeringId = offeringId
        self.offeringPromotionId = offeringPromotionId
        self.quantity = quantity
    }
}

struct PurchaseOfferingInputBody: Swift.Equatable {
    let offeringId: Swift.String?
    let quantity: Swift.Int?
    let offeringPromotionId: Swift.String?
}

extension PurchaseOfferingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offeringId
        case offeringPromotionId
        case quantity
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringId)
        offeringId = offeringIdDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        let offeringPromotionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringPromotionId)
        offeringPromotionId = offeringPromotionIdDecoded
    }
}

extension PurchaseOfferingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PurchaseOfferingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotEligibleException" : self = .notEligibleException(try NotEligibleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PurchaseOfferingOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notEligibleException(NotEligibleException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PurchaseOfferingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PurchaseOfferingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.offeringTransaction = output.offeringTransaction
        } else {
            self.offeringTransaction = nil
        }
    }
}

/// The result of the purchase offering (for example, success or failure).
public struct PurchaseOfferingOutputResponse: Swift.Equatable {
    /// Represents the offering transaction for the purchase result.
    public var offeringTransaction: DeviceFarmClientTypes.OfferingTransaction?

    public init (
        offeringTransaction: DeviceFarmClientTypes.OfferingTransaction? = nil
    )
    {
        self.offeringTransaction = offeringTransaction
    }
}

struct PurchaseOfferingOutputResponseBody: Swift.Equatable {
    let offeringTransaction: DeviceFarmClientTypes.OfferingTransaction?
}

extension PurchaseOfferingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offeringTransaction
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringTransactionDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.OfferingTransaction.self, forKey: .offeringTransaction)
        offeringTransaction = offeringTransactionDecoded
    }
}

extension DeviceFarmClientTypes.Radios: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bluetooth
        case gps
        case nfc
        case wifi
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bluetooth = self.bluetooth {
            try encodeContainer.encode(bluetooth, forKey: .bluetooth)
        }
        if let gps = self.gps {
            try encodeContainer.encode(gps, forKey: .gps)
        }
        if let nfc = self.nfc {
            try encodeContainer.encode(nfc, forKey: .nfc)
        }
        if let wifi = self.wifi {
            try encodeContainer.encode(wifi, forKey: .wifi)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wifiDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .wifi)
        wifi = wifiDecoded
        let bluetoothDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bluetooth)
        bluetooth = bluetoothDecoded
        let nfcDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .nfc)
        nfc = nfcDecoded
        let gpsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .gps)
        gps = gpsDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents the set of radios and their states on a device. Examples of radios include Wi-Fi, GPS, Bluetooth, and NFC.
    public struct Radios: Swift.Equatable {
        /// True if Bluetooth is enabled at the beginning of the test. Otherwise, false.
        public var bluetooth: Swift.Bool?
        /// True if GPS is enabled at the beginning of the test. Otherwise, false.
        public var gps: Swift.Bool?
        /// True if NFC is enabled at the beginning of the test. Otherwise, false.
        public var nfc: Swift.Bool?
        /// True if Wi-Fi is enabled at the beginning of the test. Otherwise, false.
        public var wifi: Swift.Bool?

        public init (
            bluetooth: Swift.Bool? = nil,
            gps: Swift.Bool? = nil,
            nfc: Swift.Bool? = nil,
            wifi: Swift.Bool? = nil
        )
        {
            self.bluetooth = bluetooth
            self.gps = gps
            self.nfc = nfc
            self.wifi = wifi
        }
    }

}

extension DeviceFarmClientTypes.RecurringCharge: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cost
        case frequency
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cost = self.cost {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if let frequency = self.frequency {
            try encodeContainer.encode(frequency.rawValue, forKey: .frequency)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.MonetaryAmount.self, forKey: .cost)
        cost = costDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.RecurringChargeFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Specifies whether charges for devices are recurring.
    public struct RecurringCharge: Swift.Equatable {
        /// The cost of the recurring charge.
        public var cost: DeviceFarmClientTypes.MonetaryAmount?
        /// The frequency in which charges recur.
        public var frequency: DeviceFarmClientTypes.RecurringChargeFrequency?

        public init (
            cost: DeviceFarmClientTypes.MonetaryAmount? = nil,
            frequency: DeviceFarmClientTypes.RecurringChargeFrequency? = nil
        )
        {
            self.cost = cost
            self.frequency = frequency
        }
    }

}

extension DeviceFarmClientTypes {
    public enum RecurringChargeFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case monthly
        case sdkUnknown(Swift.String)

        public static var allCases: [RecurringChargeFrequency] {
            return [
                .monthly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .monthly: return "MONTHLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecurringChargeFrequency(rawValue: rawValue) ?? RecurringChargeFrequency.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.RemoteAccessSession: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case billingMethod
        case clientId
        case created
        case device
        case deviceMinutes
        case deviceUdid
        case endpoint
        case hostAddress
        case instanceArn
        case interactionMode
        case message
        case name
        case remoteDebugEnabled
        case remoteRecordAppArn
        case remoteRecordEnabled
        case result
        case skipAppResign
        case started
        case status
        case stopped
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let billingMethod = self.billingMethod {
            try encodeContainer.encode(billingMethod.rawValue, forKey: .billingMethod)
        }
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let device = self.device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let deviceMinutes = self.deviceMinutes {
            try encodeContainer.encode(deviceMinutes, forKey: .deviceMinutes)
        }
        if let deviceUdid = self.deviceUdid {
            try encodeContainer.encode(deviceUdid, forKey: .deviceUdid)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let hostAddress = self.hostAddress {
            try encodeContainer.encode(hostAddress, forKey: .hostAddress)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let interactionMode = self.interactionMode {
            try encodeContainer.encode(interactionMode.rawValue, forKey: .interactionMode)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let remoteDebugEnabled = self.remoteDebugEnabled {
            try encodeContainer.encode(remoteDebugEnabled, forKey: .remoteDebugEnabled)
        }
        if let remoteRecordAppArn = self.remoteRecordAppArn {
            try encodeContainer.encode(remoteRecordAppArn, forKey: .remoteRecordAppArn)
        }
        if let remoteRecordEnabled = self.remoteRecordEnabled {
            try encodeContainer.encode(remoteRecordEnabled, forKey: .remoteRecordEnabled)
        }
        if let result = self.result {
            try encodeContainer.encode(result.rawValue, forKey: .result)
        }
        if let skipAppResign = self.skipAppResign {
            try encodeContainer.encode(skipAppResign, forKey: .skipAppResign)
        }
        if let started = self.started {
            try encodeContainer.encodeTimestamp(started, format: .epochSeconds, forKey: .started)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopped = self.stopped {
            try encodeContainer.encodeTimestamp(stopped, format: .epochSeconds, forKey: .stopped)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let resultDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionResult.self, forKey: .result)
        result = resultDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let startedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .started)
        started = startedDecoded
        let stoppedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stopped)
        stopped = stoppedDecoded
        let deviceDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let remoteDebugEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remoteDebugEnabled)
        remoteDebugEnabled = remoteDebugEnabledDecoded
        let remoteRecordEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remoteRecordEnabled)
        remoteRecordEnabled = remoteRecordEnabledDecoded
        let remoteRecordAppArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteRecordAppArn)
        remoteRecordAppArn = remoteRecordAppArnDecoded
        let hostAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostAddress)
        hostAddress = hostAddressDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let billingMethodDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.BillingMethod.self, forKey: .billingMethod)
        billingMethod = billingMethodDecoded
        let deviceMinutesDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceMinutes.self, forKey: .deviceMinutes)
        deviceMinutes = deviceMinutesDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let deviceUdidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceUdid)
        deviceUdid = deviceUdidDecoded
        let interactionModeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.InteractionMode.self, forKey: .interactionMode)
        interactionMode = interactionModeDecoded
        let skipAppResignDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .skipAppResign)
        skipAppResign = skipAppResignDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents information about the remote access session.
    public struct RemoteAccessSession: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the remote access session.
        public var arn: Swift.String?
        /// The billing method of the remote access session. Possible values include METERED or UNMETERED. For more information about metered devices, see [AWS Device Farm terminology](https://docs.aws.amazon.com/devicefarm/latest/developerguide/welcome.html#welcome-terminology).
        public var billingMethod: DeviceFarmClientTypes.BillingMethod?
        /// Unique identifier of your client for the remote access session. Only returned if remote debugging is enabled for the remote access session. Remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html).
        public var clientId: Swift.String?
        /// The date and time the remote access session was created.
        public var created: ClientRuntime.Date?
        /// The device (phone or tablet) used in the remote access session.
        public var device: DeviceFarmClientTypes.Device?
        /// The number of minutes a device is used in a remote access session (including setup and teardown minutes).
        public var deviceMinutes: DeviceFarmClientTypes.DeviceMinutes?
        /// Unique device identifier for the remote device. Only returned if remote debugging is enabled for the remote access session. Remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html).
        public var deviceUdid: Swift.String?
        /// The endpoint for the remote access sesssion.
        public var endpoint: Swift.String?
        /// IP address of the EC2 host where you need to connect to remotely debug devices. Only returned if remote debugging is enabled for the remote access session. Remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html).
        public var hostAddress: Swift.String?
        /// The ARN of the instance.
        public var instanceArn: Swift.String?
        /// The interaction mode of the remote access session. Valid values are:
        ///
        /// * INTERACTIVE: You can interact with the iOS device by viewing, touching, and rotating the screen. You cannot run XCUITest framework-based tests in this mode.
        ///
        /// * NO_VIDEO: You are connected to the device, but cannot interact with it or view the screen. This mode has the fastest test execution speed. You can run XCUITest framework-based tests in this mode.
        ///
        /// * VIDEO_ONLY: You can view the screen, but cannot touch or rotate it. You can run XCUITest framework-based tests and watch the screen in this mode.
        public var interactionMode: DeviceFarmClientTypes.InteractionMode?
        /// A message about the remote access session.
        public var message: Swift.String?
        /// The name of the remote access session.
        public var name: Swift.String?
        /// This flag is set to true if remote debugging is enabled for the remote access session. Remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html).
        public var remoteDebugEnabled: Swift.Bool?
        /// The ARN for the app to be recorded in the remote access session.
        public var remoteRecordAppArn: Swift.String?
        /// This flag is set to true if remote recording is enabled for the remote access session.
        public var remoteRecordEnabled: Swift.Bool?
        /// The result of the remote access session. Can be any of the following:
        ///
        /// * PENDING.
        ///
        /// * PASSED.
        ///
        /// * WARNED.
        ///
        /// * FAILED.
        ///
        /// * SKIPPED.
        ///
        /// * ERRORED.
        ///
        /// * STOPPED.
        public var result: DeviceFarmClientTypes.ExecutionResult?
        /// When set to true, for private devices, Device Farm does not sign your app again. For public devices, Device Farm always signs your apps again. For more information about how Device Farm re-signs your apps, see [Do you modify my app?](http://aws.amazon.com/device-farm/faqs/) in the AWS Device Farm FAQs.
        public var skipAppResign: Swift.Bool?
        /// The date and time the remote access session was started.
        public var started: ClientRuntime.Date?
        /// The status of the remote access session. Can be any of the following:
        ///
        /// * PENDING.
        ///
        /// * PENDING_CONCURRENCY.
        ///
        /// * PENDING_DEVICE.
        ///
        /// * PROCESSING.
        ///
        /// * SCHEDULING.
        ///
        /// * PREPARING.
        ///
        /// * RUNNING.
        ///
        /// * COMPLETED.
        ///
        /// * STOPPING.
        public var status: DeviceFarmClientTypes.ExecutionStatus?
        /// The date and time the remote access session was stopped.
        public var stopped: ClientRuntime.Date?
        /// The VPC security groups and subnets that are attached to a project.
        public var vpcConfig: DeviceFarmClientTypes.VpcConfig?

        public init (
            arn: Swift.String? = nil,
            billingMethod: DeviceFarmClientTypes.BillingMethod? = nil,
            clientId: Swift.String? = nil,
            created: ClientRuntime.Date? = nil,
            device: DeviceFarmClientTypes.Device? = nil,
            deviceMinutes: DeviceFarmClientTypes.DeviceMinutes? = nil,
            deviceUdid: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            hostAddress: Swift.String? = nil,
            instanceArn: Swift.String? = nil,
            interactionMode: DeviceFarmClientTypes.InteractionMode? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            remoteDebugEnabled: Swift.Bool? = nil,
            remoteRecordAppArn: Swift.String? = nil,
            remoteRecordEnabled: Swift.Bool? = nil,
            result: DeviceFarmClientTypes.ExecutionResult? = nil,
            skipAppResign: Swift.Bool? = nil,
            started: ClientRuntime.Date? = nil,
            status: DeviceFarmClientTypes.ExecutionStatus? = nil,
            stopped: ClientRuntime.Date? = nil,
            vpcConfig: DeviceFarmClientTypes.VpcConfig? = nil
        )
        {
            self.arn = arn
            self.billingMethod = billingMethod
            self.clientId = clientId
            self.created = created
            self.device = device
            self.deviceMinutes = deviceMinutes
            self.deviceUdid = deviceUdid
            self.endpoint = endpoint
            self.hostAddress = hostAddress
            self.instanceArn = instanceArn
            self.interactionMode = interactionMode
            self.message = message
            self.name = name
            self.remoteDebugEnabled = remoteDebugEnabled
            self.remoteRecordAppArn = remoteRecordAppArn
            self.remoteRecordEnabled = remoteRecordEnabled
            self.result = result
            self.skipAppResign = skipAppResign
            self.started = started
            self.status = status
            self.stopped = stopped
            self.vpcConfig = vpcConfig
        }
    }

}

extension RenewOfferingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offeringId
        case quantity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offeringId = self.offeringId {
            try encodeContainer.encode(offeringId, forKey: .offeringId)
        }
        if let quantity = self.quantity {
            try encodeContainer.encode(quantity, forKey: .quantity)
        }
    }
}

extension RenewOfferingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A request that represents an offering renewal.
public struct RenewOfferingInput: Swift.Equatable {
    /// The ID of a request to renew an offering.
    /// This member is required.
    public var offeringId: Swift.String?
    /// The quantity requested in an offering renewal.
    /// This member is required.
    public var quantity: Swift.Int?

    public init (
        offeringId: Swift.String? = nil,
        quantity: Swift.Int? = nil
    )
    {
        self.offeringId = offeringId
        self.quantity = quantity
    }
}

struct RenewOfferingInputBody: Swift.Equatable {
    let offeringId: Swift.String?
    let quantity: Swift.Int?
}

extension RenewOfferingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offeringId
        case quantity
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringId)
        offeringId = offeringIdDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
    }
}

extension RenewOfferingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RenewOfferingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotEligibleException" : self = .notEligibleException(try NotEligibleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RenewOfferingOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notEligibleException(NotEligibleException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RenewOfferingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RenewOfferingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.offeringTransaction = output.offeringTransaction
        } else {
            self.offeringTransaction = nil
        }
    }
}

/// The result of a renewal offering.
public struct RenewOfferingOutputResponse: Swift.Equatable {
    /// Represents the status of the offering transaction for the renewal.
    public var offeringTransaction: DeviceFarmClientTypes.OfferingTransaction?

    public init (
        offeringTransaction: DeviceFarmClientTypes.OfferingTransaction? = nil
    )
    {
        self.offeringTransaction = offeringTransaction
    }
}

struct RenewOfferingOutputResponseBody: Swift.Equatable {
    let offeringTransaction: DeviceFarmClientTypes.OfferingTransaction?
}

extension RenewOfferingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offeringTransaction
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringTransactionDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.OfferingTransaction.self, forKey: .offeringTransaction)
        offeringTransaction = offeringTransactionDecoded
    }
}

extension DeviceFarmClientTypes.Resolution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case height
        case width
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let height = self.height {
            try encodeContainer.encode(height, forKey: .height)
        }
        if let width = self.width {
            try encodeContainer.encode(width, forKey: .width)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let widthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .width)
        width = widthDecoded
        let heightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .height)
        height = heightDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents the screen resolution of a device in height and width, expressed in pixels.
    public struct Resolution: Swift.Equatable {
        /// The screen resolution's height, expressed in pixels.
        public var height: Swift.Int?
        /// The screen resolution's width, expressed in pixels.
        public var width: Swift.Int?

        public init (
            height: Swift.Int? = nil,
            width: Swift.Int? = nil
        )
        {
            self.height = height
            self.width = width
        }
    }

}

extension DeviceFarmClientTypes.Rule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case `operator` = "operator"
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.RuleOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents a condition for a device pool.
    public struct Rule: Swift.Equatable {
        /// The rule's stringified attribute. For example, specify the value as "\"abc\"". The supported operators for each attribute are provided in the following list. APPIUM_VERSION The Appium version for the test. Supported operators: CONTAINS ARN The Amazon Resource Name (ARN) of the device (for example, arn:aws:devicefarm:us-west-2::device:12345Example. Supported operators: EQUALS, IN, NOT_IN AVAILABILITY The current availability of the device. Valid values are AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE. Supported operators: EQUALS FLEET_TYPE The fleet type. Valid values are PUBLIC or PRIVATE. Supported operators: EQUALS FORM_FACTOR The device form factor. Valid values are PHONE or TABLET. Supported operators: EQUALS, IN, NOT_IN INSTANCE_ARN The Amazon Resource Name (ARN) of the device instance. Supported operators: IN, NOT_IN INSTANCE_LABELS The label of the device instance. Supported operators: CONTAINS MANUFACTURER The device manufacturer (for example, Apple). Supported operators: EQUALS, IN, NOT_IN MODEL The device model, such as Apple iPad Air 2 or Google Pixel. Supported operators: CONTAINS, EQUALS, IN, NOT_IN OS_VERSION The operating system version (for example, 10.3.2). Supported operators: EQUALS, GREATER_THAN, GREATER_THAN_OR_EQUALS, IN, LESS_THAN, LESS_THAN_OR_EQUALS, NOT_IN PLATFORM The device platform. Valid values are ANDROID or IOS. Supported operators: EQUALS, IN, NOT_IN REMOTE_ACCESS_ENABLED Whether the device is enabled for remote access. Valid values are TRUE or FALSE. Supported operators: EQUALS REMOTE_DEBUG_ENABLED Whether the device is enabled for remote debugging. Valid values are TRUE or FALSE. Supported operators: EQUALS Because remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html), this filter is ignored.
        public var attribute: DeviceFarmClientTypes.DeviceAttribute?
        /// Specifies how Device Farm compares the rule's attribute to the value. For the operators that are supported by each attribute, see the attribute descriptions.
        public var `operator`: DeviceFarmClientTypes.RuleOperator?
        /// The rule's value.
        public var value: Swift.String?

        public init (
            attribute: DeviceFarmClientTypes.DeviceAttribute? = nil,
            `operator`: DeviceFarmClientTypes.RuleOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.attribute = attribute
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension DeviceFarmClientTypes {
    public enum RuleOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case equals
        case greaterThan
        case greaterThanOrEquals
        case `in`
        case lessThan
        case lessThanOrEquals
        case notIn
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleOperator] {
            return [
                .contains,
                .equals,
                .greaterThan,
                .greaterThanOrEquals,
                .in,
                .lessThan,
                .lessThanOrEquals,
                .notIn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .equals: return "EQUALS"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEquals: return "GREATER_THAN_OR_EQUALS"
            case .in: return "IN"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEquals: return "LESS_THAN_OR_EQUALS"
            case .notIn: return "NOT_IN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuleOperator(rawValue: rawValue) ?? RuleOperator.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.Run: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appUpload
        case arn
        case billingMethod
        case completedJobs
        case counters
        case created
        case customerArtifactPaths
        case deviceMinutes
        case devicePoolArn
        case deviceSelectionResult
        case eventCount
        case jobTimeoutMinutes
        case locale
        case location
        case message
        case name
        case networkProfile
        case parsingResultUrl
        case platform
        case radios
        case result
        case resultCode
        case seed
        case skipAppResign
        case started
        case status
        case stopped
        case testSpecArn
        case totalJobs
        case type
        case vpcConfig
        case webUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appUpload = self.appUpload {
            try encodeContainer.encode(appUpload, forKey: .appUpload)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let billingMethod = self.billingMethod {
            try encodeContainer.encode(billingMethod.rawValue, forKey: .billingMethod)
        }
        if let completedJobs = self.completedJobs {
            try encodeContainer.encode(completedJobs, forKey: .completedJobs)
        }
        if let counters = self.counters {
            try encodeContainer.encode(counters, forKey: .counters)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let customerArtifactPaths = self.customerArtifactPaths {
            try encodeContainer.encode(customerArtifactPaths, forKey: .customerArtifactPaths)
        }
        if let deviceMinutes = self.deviceMinutes {
            try encodeContainer.encode(deviceMinutes, forKey: .deviceMinutes)
        }
        if let devicePoolArn = self.devicePoolArn {
            try encodeContainer.encode(devicePoolArn, forKey: .devicePoolArn)
        }
        if let deviceSelectionResult = self.deviceSelectionResult {
            try encodeContainer.encode(deviceSelectionResult, forKey: .deviceSelectionResult)
        }
        if let eventCount = self.eventCount {
            try encodeContainer.encode(eventCount, forKey: .eventCount)
        }
        if let jobTimeoutMinutes = self.jobTimeoutMinutes {
            try encodeContainer.encode(jobTimeoutMinutes, forKey: .jobTimeoutMinutes)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkProfile = self.networkProfile {
            try encodeContainer.encode(networkProfile, forKey: .networkProfile)
        }
        if let parsingResultUrl = self.parsingResultUrl {
            try encodeContainer.encode(parsingResultUrl, forKey: .parsingResultUrl)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let radios = self.radios {
            try encodeContainer.encode(radios, forKey: .radios)
        }
        if let result = self.result {
            try encodeContainer.encode(result.rawValue, forKey: .result)
        }
        if let resultCode = self.resultCode {
            try encodeContainer.encode(resultCode.rawValue, forKey: .resultCode)
        }
        if let seed = self.seed {
            try encodeContainer.encode(seed, forKey: .seed)
        }
        if let skipAppResign = self.skipAppResign {
            try encodeContainer.encode(skipAppResign, forKey: .skipAppResign)
        }
        if let started = self.started {
            try encodeContainer.encodeTimestamp(started, format: .epochSeconds, forKey: .started)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopped = self.stopped {
            try encodeContainer.encodeTimestamp(stopped, format: .epochSeconds, forKey: .stopped)
        }
        if let testSpecArn = self.testSpecArn {
            try encodeContainer.encode(testSpecArn, forKey: .testSpecArn)
        }
        if let totalJobs = self.totalJobs {
            try encodeContainer.encode(totalJobs, forKey: .totalJobs)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
        if let webUrl = self.webUrl {
            try encodeContainer.encode(webUrl, forKey: .webUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestType.self, forKey: .type)
        type = typeDecoded
        let platformDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DevicePlatform.self, forKey: .platform)
        platform = platformDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let resultDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionResult.self, forKey: .result)
        result = resultDecoded
        let startedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .started)
        started = startedDecoded
        let stoppedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stopped)
        stopped = stoppedDecoded
        let countersDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Counters.self, forKey: .counters)
        counters = countersDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let totalJobsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalJobs)
        totalJobs = totalJobsDecoded
        let completedJobsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .completedJobs)
        completedJobs = completedJobsDecoded
        let billingMethodDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.BillingMethod.self, forKey: .billingMethod)
        billingMethod = billingMethodDecoded
        let deviceMinutesDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceMinutes.self, forKey: .deviceMinutes)
        deviceMinutes = deviceMinutesDecoded
        let networkProfileDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.NetworkProfile.self, forKey: .networkProfile)
        networkProfile = networkProfileDecoded
        let parsingResultUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parsingResultUrl)
        parsingResultUrl = parsingResultUrlDecoded
        let resultCodeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionResultCode.self, forKey: .resultCode)
        resultCode = resultCodeDecoded
        let seedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .seed)
        seed = seedDecoded
        let appUploadDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appUpload)
        appUpload = appUploadDecoded
        let eventCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .eventCount)
        eventCount = eventCountDecoded
        let jobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .jobTimeoutMinutes)
        jobTimeoutMinutes = jobTimeoutMinutesDecoded
        let devicePoolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devicePoolArn)
        devicePoolArn = devicePoolArnDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let radiosDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Radios.self, forKey: .radios)
        radios = radiosDecoded
        let locationDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let customerArtifactPathsDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.CustomerArtifactPaths.self, forKey: .customerArtifactPaths)
        customerArtifactPaths = customerArtifactPathsDecoded
        let webUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webUrl)
        webUrl = webUrlDecoded
        let skipAppResignDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .skipAppResign)
        skipAppResign = skipAppResignDecoded
        let testSpecArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSpecArn)
        testSpecArn = testSpecArnDecoded
        let deviceSelectionResultDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceSelectionResult.self, forKey: .deviceSelectionResult)
        deviceSelectionResult = deviceSelectionResultDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents a test run on a set of devices with a given app package, test parameters, and so on.
    public struct Run: Swift.Equatable {
        /// An app to upload or that has been uploaded.
        public var appUpload: Swift.String?
        /// The run's ARN.
        public var arn: Swift.String?
        /// Specifies the billing method for a test run: metered or unmetered. If the parameter is not specified, the default value is metered. If you have unmetered device slots, you must set this to unmetered to use them. Otherwise, the run is counted toward metered device minutes.
        public var billingMethod: DeviceFarmClientTypes.BillingMethod?
        /// The total number of completed jobs.
        public var completedJobs: Swift.Int?
        /// The run's result counters.
        public var counters: DeviceFarmClientTypes.Counters?
        /// When the run was created.
        public var created: ClientRuntime.Date?
        /// Output CustomerArtifactPaths object for the test run.
        public var customerArtifactPaths: DeviceFarmClientTypes.CustomerArtifactPaths?
        /// Represents the total (metered or unmetered) minutes used by the test run.
        public var deviceMinutes: DeviceFarmClientTypes.DeviceMinutes?
        /// The ARN of the device pool for the run.
        public var devicePoolArn: Swift.String?
        /// The results of a device filter used to select the devices for a test run.
        public var deviceSelectionResult: DeviceFarmClientTypes.DeviceSelectionResult?
        /// For fuzz tests, this is the number of events, between 1 and 10000, that the UI fuzz test should perform.
        public var eventCount: Swift.Int?
        /// The number of minutes the job executes before it times out.
        public var jobTimeoutMinutes: Swift.Int?
        /// Information about the locale that is used for the run.
        public var locale: Swift.String?
        /// Information about the location that is used for the run.
        public var location: DeviceFarmClientTypes.Location?
        /// A message about the run's result.
        public var message: Swift.String?
        /// The run's name.
        public var name: Swift.String?
        /// The network profile being used for a test run.
        public var networkProfile: DeviceFarmClientTypes.NetworkProfile?
        /// Read-only URL for an object in an S3 bucket where you can get the parsing results of the test package. If the test package doesn't parse, the reason why it doesn't parse appears in the file that this URL points to.
        public var parsingResultUrl: Swift.String?
        /// The run's platform. Allowed values include:
        ///
        /// * ANDROID
        ///
        /// * IOS
        public var platform: DeviceFarmClientTypes.DevicePlatform?
        /// Information about the radio states for the run.
        public var radios: DeviceFarmClientTypes.Radios?
        /// The run's result. Allowed values include:
        ///
        /// * PENDING
        ///
        /// * PASSED
        ///
        /// * WARNED
        ///
        /// * FAILED
        ///
        /// * SKIPPED
        ///
        /// * ERRORED
        ///
        /// * STOPPED
        public var result: DeviceFarmClientTypes.ExecutionResult?
        /// Supporting field for the result field. Set only if result is SKIPPED. PARSING_FAILED if the result is skipped because of test package parsing failure.
        public var resultCode: DeviceFarmClientTypes.ExecutionResultCode?
        /// For fuzz tests, this is a seed to use for randomizing the UI fuzz test. Using the same seed value between tests ensures identical event sequences.
        public var seed: Swift.Int?
        /// When set to true, for private devices, Device Farm does not sign your app again. For public devices, Device Farm always signs your apps again. For more information about how Device Farm re-signs your apps, see [Do you modify my app?](http://aws.amazon.com/device-farm/faqs/) in the AWS Device Farm FAQs.
        public var skipAppResign: Swift.Bool?
        /// The run's start time.
        public var started: ClientRuntime.Date?
        /// The run's status. Allowed values include:
        ///
        /// * PENDING
        ///
        /// * PENDING_CONCURRENCY
        ///
        /// * PENDING_DEVICE
        ///
        /// * PROCESSING
        ///
        /// * SCHEDULING
        ///
        /// * PREPARING
        ///
        /// * RUNNING
        ///
        /// * COMPLETED
        ///
        /// * STOPPING
        public var status: DeviceFarmClientTypes.ExecutionStatus?
        /// The run's stop time.
        public var stopped: ClientRuntime.Date?
        /// The ARN of the YAML-formatted test specification for the run.
        public var testSpecArn: Swift.String?
        /// The total number of jobs for the run.
        public var totalJobs: Swift.Int?
        /// The run's type. Must be one of the following values:
        ///
        /// * BUILTIN_FUZZ
        ///
        /// * BUILTIN_EXPLORER For Android, an app explorer that traverses an Android app, interacting with it and capturing screenshots at the same time.
        ///
        /// * APPIUM_JAVA_JUNIT
        ///
        /// * APPIUM_JAVA_TESTNG
        ///
        /// * APPIUM_PYTHON
        ///
        /// * APPIUM_NODE
        ///
        /// * APPIUM_RUBY
        ///
        /// * APPIUM_WEB_JAVA_JUNIT
        ///
        /// * APPIUM_WEB_JAVA_TESTNG
        ///
        /// * APPIUM_WEB_PYTHON
        ///
        /// * APPIUM_WEB_NODE
        ///
        /// * APPIUM_WEB_RUBY
        ///
        /// * CALABASH
        ///
        /// * INSTRUMENTATION
        ///
        /// * UIAUTOMATION
        ///
        /// * UIAUTOMATOR
        ///
        /// * XCTEST
        ///
        /// * XCTEST_UI
        public var type: DeviceFarmClientTypes.TestType?
        /// The VPC security groups and subnets that are attached to a project.
        public var vpcConfig: DeviceFarmClientTypes.VpcConfig?
        /// The Device Farm console URL for the recording of the run.
        public var webUrl: Swift.String?

        public init (
            appUpload: Swift.String? = nil,
            arn: Swift.String? = nil,
            billingMethod: DeviceFarmClientTypes.BillingMethod? = nil,
            completedJobs: Swift.Int? = nil,
            counters: DeviceFarmClientTypes.Counters? = nil,
            created: ClientRuntime.Date? = nil,
            customerArtifactPaths: DeviceFarmClientTypes.CustomerArtifactPaths? = nil,
            deviceMinutes: DeviceFarmClientTypes.DeviceMinutes? = nil,
            devicePoolArn: Swift.String? = nil,
            deviceSelectionResult: DeviceFarmClientTypes.DeviceSelectionResult? = nil,
            eventCount: Swift.Int? = nil,
            jobTimeoutMinutes: Swift.Int? = nil,
            locale: Swift.String? = nil,
            location: DeviceFarmClientTypes.Location? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            networkProfile: DeviceFarmClientTypes.NetworkProfile? = nil,
            parsingResultUrl: Swift.String? = nil,
            platform: DeviceFarmClientTypes.DevicePlatform? = nil,
            radios: DeviceFarmClientTypes.Radios? = nil,
            result: DeviceFarmClientTypes.ExecutionResult? = nil,
            resultCode: DeviceFarmClientTypes.ExecutionResultCode? = nil,
            seed: Swift.Int? = nil,
            skipAppResign: Swift.Bool? = nil,
            started: ClientRuntime.Date? = nil,
            status: DeviceFarmClientTypes.ExecutionStatus? = nil,
            stopped: ClientRuntime.Date? = nil,
            testSpecArn: Swift.String? = nil,
            totalJobs: Swift.Int? = nil,
            type: DeviceFarmClientTypes.TestType? = nil,
            vpcConfig: DeviceFarmClientTypes.VpcConfig? = nil,
            webUrl: Swift.String? = nil
        )
        {
            self.appUpload = appUpload
            self.arn = arn
            self.billingMethod = billingMethod
            self.completedJobs = completedJobs
            self.counters = counters
            self.created = created
            self.customerArtifactPaths = customerArtifactPaths
            self.deviceMinutes = deviceMinutes
            self.devicePoolArn = devicePoolArn
            self.deviceSelectionResult = deviceSelectionResult
            self.eventCount = eventCount
            self.jobTimeoutMinutes = jobTimeoutMinutes
            self.locale = locale
            self.location = location
            self.message = message
            self.name = name
            self.networkProfile = networkProfile
            self.parsingResultUrl = parsingResultUrl
            self.platform = platform
            self.radios = radios
            self.result = result
            self.resultCode = resultCode
            self.seed = seed
            self.skipAppResign = skipAppResign
            self.started = started
            self.status = status
            self.stopped = stopped
            self.testSpecArn = testSpecArn
            self.totalJobs = totalJobs
            self.type = type
            self.vpcConfig = vpcConfig
            self.webUrl = webUrl
        }
    }

}

extension DeviceFarmClientTypes.Sample: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case type
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.SampleType.self, forKey: .type)
        type = typeDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents a sample of performance data.
    public struct Sample: Swift.Equatable {
        /// The sample's ARN.
        public var arn: Swift.String?
        /// The sample's type. Must be one of the following values:
        ///
        /// * CPU: A CPU sample type. This is expressed as the app processing CPU time (including child processes) as reported by process, as a percentage.
        ///
        /// * MEMORY: A memory usage sample type. This is expressed as the total proportional set size of an app process, in kilobytes.
        ///
        /// * NATIVE_AVG_DRAWTIME
        ///
        /// * NATIVE_FPS
        ///
        /// * NATIVE_FRAMES
        ///
        /// * NATIVE_MAX_DRAWTIME
        ///
        /// * NATIVE_MIN_DRAWTIME
        ///
        /// * OPENGL_AVG_DRAWTIME
        ///
        /// * OPENGL_FPS
        ///
        /// * OPENGL_FRAMES
        ///
        /// * OPENGL_MAX_DRAWTIME
        ///
        /// * OPENGL_MIN_DRAWTIME
        ///
        /// * RX
        ///
        /// * RX_RATE: The total number of bytes per second (TCP and UDP) that are sent, by app process.
        ///
        /// * THREADS: A threads sample type. This is expressed as the total number of threads per app process.
        ///
        /// * TX
        ///
        /// * TX_RATE: The total number of bytes per second (TCP and UDP) that are received, by app process.
        public var type: DeviceFarmClientTypes.SampleType?
        /// The presigned Amazon S3 URL that can be used with a GET request to download the sample's file.
        public var url: Swift.String?

        public init (
            arn: Swift.String? = nil,
            type: DeviceFarmClientTypes.SampleType? = nil,
            url: Swift.String? = nil
        )
        {
            self.arn = arn
            self.type = type
            self.url = url
        }
    }

}

extension DeviceFarmClientTypes {
    public enum SampleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cpu
        case memory
        case nativeAvgDrawtime
        case nativeFps
        case nativeFrames
        case nativeMaxDrawtime
        case nativeMinDrawtime
        case openglAvgDrawtime
        case openglFps
        case openglFrames
        case openglMaxDrawtime
        case openglMinDrawtime
        case rx
        case rxRate
        case threads
        case tx
        case txRate
        case sdkUnknown(Swift.String)

        public static var allCases: [SampleType] {
            return [
                .cpu,
                .memory,
                .nativeAvgDrawtime,
                .nativeFps,
                .nativeFrames,
                .nativeMaxDrawtime,
                .nativeMinDrawtime,
                .openglAvgDrawtime,
                .openglFps,
                .openglFrames,
                .openglMaxDrawtime,
                .openglMinDrawtime,
                .rx,
                .rxRate,
                .threads,
                .tx,
                .txRate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cpu: return "CPU"
            case .memory: return "MEMORY"
            case .nativeAvgDrawtime: return "NATIVE_AVG_DRAWTIME"
            case .nativeFps: return "NATIVE_FPS"
            case .nativeFrames: return "NATIVE_FRAMES"
            case .nativeMaxDrawtime: return "NATIVE_MAX_DRAWTIME"
            case .nativeMinDrawtime: return "NATIVE_MIN_DRAWTIME"
            case .openglAvgDrawtime: return "OPENGL_AVG_DRAWTIME"
            case .openglFps: return "OPENGL_FPS"
            case .openglFrames: return "OPENGL_FRAMES"
            case .openglMaxDrawtime: return "OPENGL_MAX_DRAWTIME"
            case .openglMinDrawtime: return "OPENGL_MIN_DRAWTIME"
            case .rx: return "RX"
            case .rxRate: return "RX_RATE"
            case .threads: return "THREADS"
            case .tx: return "TX"
            case .txRate: return "TX_RATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SampleType(rawValue: rawValue) ?? SampleType.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.ScheduleRunConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auxiliaryApps
        case billingMethod
        case customerArtifactPaths
        case extraDataPackageArn
        case locale
        case location
        case networkProfileArn
        case radios
        case vpceConfigurationArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auxiliaryApps = auxiliaryApps {
            var auxiliaryAppsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .auxiliaryApps)
            for amazonresourcename0 in auxiliaryApps {
                try auxiliaryAppsContainer.encode(amazonresourcename0)
            }
        }
        if let billingMethod = self.billingMethod {
            try encodeContainer.encode(billingMethod.rawValue, forKey: .billingMethod)
        }
        if let customerArtifactPaths = self.customerArtifactPaths {
            try encodeContainer.encode(customerArtifactPaths, forKey: .customerArtifactPaths)
        }
        if let extraDataPackageArn = self.extraDataPackageArn {
            try encodeContainer.encode(extraDataPackageArn, forKey: .extraDataPackageArn)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let networkProfileArn = self.networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
        if let radios = self.radios {
            try encodeContainer.encode(radios, forKey: .radios)
        }
        if let vpceConfigurationArns = vpceConfigurationArns {
            var vpceConfigurationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpceConfigurationArns)
            for amazonresourcename0 in vpceConfigurationArns {
                try vpceConfigurationArnsContainer.encode(amazonresourcename0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let extraDataPackageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extraDataPackageArn)
        extraDataPackageArn = extraDataPackageArnDecoded
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let vpceConfigurationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpceConfigurationArns)
        var vpceConfigurationArnsDecoded0:[Swift.String]? = nil
        if let vpceConfigurationArnsContainer = vpceConfigurationArnsContainer {
            vpceConfigurationArnsDecoded0 = [Swift.String]()
            for string0 in vpceConfigurationArnsContainer {
                if let string0 = string0 {
                    vpceConfigurationArnsDecoded0?.append(string0)
                }
            }
        }
        vpceConfigurationArns = vpceConfigurationArnsDecoded0
        let customerArtifactPathsDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.CustomerArtifactPaths.self, forKey: .customerArtifactPaths)
        customerArtifactPaths = customerArtifactPathsDecoded
        let radiosDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Radios.self, forKey: .radios)
        radios = radiosDecoded
        let auxiliaryAppsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .auxiliaryApps)
        var auxiliaryAppsDecoded0:[Swift.String]? = nil
        if let auxiliaryAppsContainer = auxiliaryAppsContainer {
            auxiliaryAppsDecoded0 = [Swift.String]()
            for string0 in auxiliaryAppsContainer {
                if let string0 = string0 {
                    auxiliaryAppsDecoded0?.append(string0)
                }
            }
        }
        auxiliaryApps = auxiliaryAppsDecoded0
        let billingMethodDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.BillingMethod.self, forKey: .billingMethod)
        billingMethod = billingMethodDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents the settings for a run. Includes things like location, radio states, auxiliary apps, and network profiles.
    public struct ScheduleRunConfiguration: Swift.Equatable {
        /// A list of upload ARNs for app packages to be installed with your app.
        public var auxiliaryApps: [Swift.String]?
        /// Specifies the billing method for a test run: metered or unmetered. If the parameter is not specified, the default value is metered. If you have purchased unmetered device slots, you must set this parameter to unmetered to make use of them. Otherwise, your run counts against your metered time.
        public var billingMethod: DeviceFarmClientTypes.BillingMethod?
        /// Input CustomerArtifactPaths object for the scheduled run configuration.
        public var customerArtifactPaths: DeviceFarmClientTypes.CustomerArtifactPaths?
        /// The ARN of the extra data for the run. The extra data is a .zip file that AWS Device Farm extracts to external data for Android or the app's sandbox for iOS.
        public var extraDataPackageArn: Swift.String?
        /// Information about the locale that is used for the run.
        public var locale: Swift.String?
        /// Information about the location that is used for the run.
        public var location: DeviceFarmClientTypes.Location?
        /// Reserved for internal use.
        public var networkProfileArn: Swift.String?
        /// Information about the radio states for the run.
        public var radios: DeviceFarmClientTypes.Radios?
        /// An array of ARNs for your VPC endpoint configurations.
        public var vpceConfigurationArns: [Swift.String]?

        public init (
            auxiliaryApps: [Swift.String]? = nil,
            billingMethod: DeviceFarmClientTypes.BillingMethod? = nil,
            customerArtifactPaths: DeviceFarmClientTypes.CustomerArtifactPaths? = nil,
            extraDataPackageArn: Swift.String? = nil,
            locale: Swift.String? = nil,
            location: DeviceFarmClientTypes.Location? = nil,
            networkProfileArn: Swift.String? = nil,
            radios: DeviceFarmClientTypes.Radios? = nil,
            vpceConfigurationArns: [Swift.String]? = nil
        )
        {
            self.auxiliaryApps = auxiliaryApps
            self.billingMethod = billingMethod
            self.customerArtifactPaths = customerArtifactPaths
            self.extraDataPackageArn = extraDataPackageArn
            self.locale = locale
            self.location = location
            self.networkProfileArn = networkProfileArn
            self.radios = radios
            self.vpceConfigurationArns = vpceConfigurationArns
        }
    }

}

extension ScheduleRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case configuration
        case devicePoolArn
        case deviceSelectionConfiguration
        case executionConfiguration
        case name
        case projectArn
        case test
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let devicePoolArn = self.devicePoolArn {
            try encodeContainer.encode(devicePoolArn, forKey: .devicePoolArn)
        }
        if let deviceSelectionConfiguration = self.deviceSelectionConfiguration {
            try encodeContainer.encode(deviceSelectionConfiguration, forKey: .deviceSelectionConfiguration)
        }
        if let executionConfiguration = self.executionConfiguration {
            try encodeContainer.encode(executionConfiguration, forKey: .executionConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectArn = self.projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let test = self.test {
            try encodeContainer.encode(test, forKey: .test)
        }
    }
}

extension ScheduleRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the schedule run operation.
public struct ScheduleRunInput: Swift.Equatable {
    /// The ARN of an application package to run tests against, created with [CreateUpload]. See [ListUploads].
    public var appArn: Swift.String?
    /// Information about the settings for the run to be scheduled.
    public var configuration: DeviceFarmClientTypes.ScheduleRunConfiguration?
    /// The ARN of the device pool for the run to be scheduled.
    public var devicePoolArn: Swift.String?
    /// The filter criteria used to dynamically select a set of devices for a test run and the maximum number of devices to be included in the run. Either devicePoolArn or deviceSelectionConfiguration is required in a request.
    public var deviceSelectionConfiguration: DeviceFarmClientTypes.DeviceSelectionConfiguration?
    /// Specifies configuration information about a test run, such as the execution timeout (in minutes).
    public var executionConfiguration: DeviceFarmClientTypes.ExecutionConfiguration?
    /// The name for the run to be scheduled.
    public var name: Swift.String?
    /// The ARN of the project for the run to be scheduled.
    /// This member is required.
    public var projectArn: Swift.String?
    /// Information about the test for the run to be scheduled.
    /// This member is required.
    public var test: DeviceFarmClientTypes.ScheduleRunTest?

    public init (
        appArn: Swift.String? = nil,
        configuration: DeviceFarmClientTypes.ScheduleRunConfiguration? = nil,
        devicePoolArn: Swift.String? = nil,
        deviceSelectionConfiguration: DeviceFarmClientTypes.DeviceSelectionConfiguration? = nil,
        executionConfiguration: DeviceFarmClientTypes.ExecutionConfiguration? = nil,
        name: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        test: DeviceFarmClientTypes.ScheduleRunTest? = nil
    )
    {
        self.appArn = appArn
        self.configuration = configuration
        self.devicePoolArn = devicePoolArn
        self.deviceSelectionConfiguration = deviceSelectionConfiguration
        self.executionConfiguration = executionConfiguration
        self.name = name
        self.projectArn = projectArn
        self.test = test
    }
}

struct ScheduleRunInputBody: Swift.Equatable {
    let projectArn: Swift.String?
    let appArn: Swift.String?
    let devicePoolArn: Swift.String?
    let deviceSelectionConfiguration: DeviceFarmClientTypes.DeviceSelectionConfiguration?
    let name: Swift.String?
    let test: DeviceFarmClientTypes.ScheduleRunTest?
    let configuration: DeviceFarmClientTypes.ScheduleRunConfiguration?
    let executionConfiguration: DeviceFarmClientTypes.ExecutionConfiguration?
}

extension ScheduleRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case configuration
        case devicePoolArn
        case deviceSelectionConfiguration
        case executionConfiguration
        case name
        case projectArn
        case test
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let devicePoolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devicePoolArn)
        devicePoolArn = devicePoolArnDecoded
        let deviceSelectionConfigurationDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceSelectionConfiguration.self, forKey: .deviceSelectionConfiguration)
        deviceSelectionConfiguration = deviceSelectionConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let testDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ScheduleRunTest.self, forKey: .test)
        test = testDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ScheduleRunConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let executionConfigurationDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionConfiguration.self, forKey: .executionConfiguration)
        executionConfiguration = executionConfigurationDecoded
    }
}

extension ScheduleRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ScheduleRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotencyException" : self = .idempotencyException(try IdempotencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ScheduleRunOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case idempotencyException(IdempotencyException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ScheduleRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ScheduleRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.run = output.run
        } else {
            self.run = nil
        }
    }
}

/// Represents the result of a schedule run request.
public struct ScheduleRunOutputResponse: Swift.Equatable {
    /// Information about the scheduled run.
    public var run: DeviceFarmClientTypes.Run?

    public init (
        run: DeviceFarmClientTypes.Run? = nil
    )
    {
        self.run = run
    }
}

struct ScheduleRunOutputResponseBody: Swift.Equatable {
    let run: DeviceFarmClientTypes.Run?
}

extension ScheduleRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case run
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Run.self, forKey: .run)
        run = runDecoded
    }
}

extension DeviceFarmClientTypes.ScheduleRunTest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case parameters
        case testPackageArn
        case testSpecArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, testParameters0) in parameters {
                try parametersContainer.encode(testParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let testPackageArn = self.testPackageArn {
            try encodeContainer.encode(testPackageArn, forKey: .testPackageArn)
        }
        if let testSpecArn = self.testSpecArn {
            try encodeContainer.encode(testSpecArn, forKey: .testSpecArn)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestType.self, forKey: .type)
        type = typeDecoded
        let testPackageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testPackageArn)
        testPackageArn = testPackageArnDecoded
        let testSpecArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSpecArn)
        testSpecArn = testSpecArnDecoded
        let filterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filter)
        filter = filterDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in parametersContainer {
                if let string0 = string0 {
                    parametersDecoded0?[key0] = string0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension DeviceFarmClientTypes {
    /// Represents test settings. This data structure is passed in as the test parameter to ScheduleRun. For an example of the JSON request syntax, see [ScheduleRun].
    public struct ScheduleRunTest: Swift.Equatable {
        /// The test's filter.
        public var filter: Swift.String?
        /// The test's parameters, such as test framework parameters and fixture settings. Parameters are represented by name-value pairs of strings. For all tests:
        ///
        /// * app_performance_monitoring: Performance monitoring is enabled by default. Set this parameter to false to disable it.
        ///
        ///
        /// For Calabash tests:
        ///
        /// * profile: A cucumber profile (for example, my_profile_name).
        ///
        /// * tags: You can limit execution to features or scenarios that have (or don't have) certain tags (for example, @smoke or @smoke,~@wip).
        ///
        ///
        /// For Appium tests (all types):
        ///
        /// * appium_version: The Appium version. Currently supported values are 1.6.5 (and later), latest, and default.
        ///
        /// * latest runs the latest Appium version supported by Device Farm (1.9.1).
        ///
        /// * For default, Device Farm selects a compatible version of Appium for the device. The current behavior is to run 1.7.2 on Android devices and iOS 9 and earlier and 1.7.2 for iOS 10 and later.
        ///
        /// * This behavior is subject to change.
        ///
        ///
        ///
        ///
        ///
        /// For fuzz tests (Android only):
        ///
        /// * event_count: The number of events, between 1 and 10000, that the UI fuzz test should perform.
        ///
        /// * throttle: The time, in ms, between 0 and 1000, that the UI fuzz test should wait between events.
        ///
        /// * seed: A seed to use for randomizing the UI fuzz test. Using the same seed value between tests ensures identical event sequences.
        ///
        ///
        /// For Explorer tests:
        ///
        /// * username: A user name to use if the Explorer encounters a login form. If not supplied, no user name is inserted.
        ///
        /// * password: A password to use if the Explorer encounters a login form. If not supplied, no password is inserted.
        ///
        ///
        /// For Instrumentation:
        ///
        /// * filter: A test filter string. Examples:
        ///
        /// * Running a single test case: com.android.abc.Test1
        ///
        /// * Running a single test: com.android.abc.Test1#smoke
        ///
        /// * Running multiple tests: com.android.abc.Test1,com.android.abc.Test2
        ///
        ///
        ///
        ///
        ///
        /// For XCTest and XCTestUI:
        ///
        /// * filter: A test filter string. Examples:
        ///
        /// * Running a single test class: LoginTests
        ///
        /// * Running a multiple test classes: LoginTests,SmokeTests
        ///
        /// * Running a single test: LoginTests/testValid
        ///
        /// * Running multiple tests: LoginTests/testValid,LoginTests/testInvalid
        ///
        ///
        ///
        ///
        ///
        /// For UIAutomator:
        ///
        /// * filter: A test filter string. Examples:
        ///
        /// * Running a single test case: com.android.abc.Test1
        ///
        /// * Running a single test: com.android.abc.Test1#smoke
        ///
        /// * Running multiple tests: com.android.abc.Test1,com.android.abc.Test2
        public var parameters: [Swift.String:Swift.String]?
        /// The ARN of the uploaded test to be run.
        public var testPackageArn: Swift.String?
        /// The ARN of the YAML-formatted test specification.
        public var testSpecArn: Swift.String?
        /// The test's type. Must be one of the following values:
        ///
        /// * BUILTIN_FUZZ
        ///
        /// * BUILTIN_EXPLORER. For Android, an app explorer that traverses an Android app, interacting with it and capturing screenshots at the same time.
        ///
        /// * APPIUM_JAVA_JUNIT
        ///
        /// * APPIUM_JAVA_TESTNG
        ///
        /// * APPIUM_PYTHON
        ///
        /// * APPIUM_NODE
        ///
        /// * APPIUM_RUBY
        ///
        /// * APPIUM_WEB_JAVA_JUNIT
        ///
        /// * APPIUM_WEB_JAVA_TESTNG
        ///
        /// * APPIUM_WEB_PYTHON
        ///
        /// * APPIUM_WEB_NODE
        ///
        /// * APPIUM_WEB_RUBY
        ///
        /// * CALABASH
        ///
        /// * INSTRUMENTATION
        ///
        /// * UIAUTOMATION
        ///
        /// * UIAUTOMATOR
        ///
        /// * XCTEST
        ///
        /// * XCTEST_UI
        /// This member is required.
        public var type: DeviceFarmClientTypes.TestType?

        public init (
            filter: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            testPackageArn: Swift.String? = nil,
            testSpecArn: Swift.String? = nil,
            type: DeviceFarmClientTypes.TestType? = nil
        )
        {
            self.filter = filter
            self.parameters = parameters
            self.testPackageArn = testPackageArn
            self.testSpecArn = testSpecArn
            self.type = type
        }
    }

}

extension ServiceAccountException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceAccountExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was a problem with the service account.
public struct ServiceAccountException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any additional information about the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceAccountExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceAccountExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StopJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension StopJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopJobInput: Swift.Equatable {
    /// Represents the Amazon Resource Name (ARN) of the Device Farm job to stop.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct StopJobInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension StopJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StopJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopJobOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StopJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StopJobOutputResponse: Swift.Equatable {
    /// The job that was stopped.
    public var job: DeviceFarmClientTypes.Job?

    public init (
        job: DeviceFarmClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct StopJobOutputResponseBody: Swift.Equatable {
    let job: DeviceFarmClientTypes.Job?
}

extension StopJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

extension StopRemoteAccessSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension StopRemoteAccessSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the request to stop the remote access session.
public struct StopRemoteAccessSessionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the remote access session to stop.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct StopRemoteAccessSessionInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension StopRemoteAccessSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StopRemoteAccessSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopRemoteAccessSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopRemoteAccessSessionOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopRemoteAccessSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StopRemoteAccessSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.remoteAccessSession = output.remoteAccessSession
        } else {
            self.remoteAccessSession = nil
        }
    }
}

/// Represents the response from the server that describes the remote access session when AWS Device Farm stops the session.
public struct StopRemoteAccessSessionOutputResponse: Swift.Equatable {
    /// A container that represents the metadata from the service about the remote access session you are stopping.
    public var remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession?

    public init (
        remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession? = nil
    )
    {
        self.remoteAccessSession = remoteAccessSession
    }
}

struct StopRemoteAccessSessionOutputResponseBody: Swift.Equatable {
    let remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession?
}

extension StopRemoteAccessSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case remoteAccessSession
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remoteAccessSessionDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.RemoteAccessSession.self, forKey: .remoteAccessSession)
        remoteAccessSession = remoteAccessSessionDecoded
    }
}

extension StopRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension StopRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the request to stop a specific run.
public struct StopRunInput: Swift.Equatable {
    /// Represents the Amazon Resource Name (ARN) of the Device Farm run to stop.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct StopRunInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension StopRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StopRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopRunOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StopRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.run = output.run
        } else {
            self.run = nil
        }
    }
}

/// Represents the results of your stop run attempt.
public struct StopRunOutputResponse: Swift.Equatable {
    /// The run that was stopped.
    public var run: DeviceFarmClientTypes.Run?

    public init (
        run: DeviceFarmClientTypes.Run? = nil
    )
    {
        self.run = run
    }
}

struct StopRunOutputResponseBody: Swift.Equatable {
    let run: DeviceFarmClientTypes.Run?
}

extension StopRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case run
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Run.self, forKey: .run)
        run = runDecoded
    }
}

extension DeviceFarmClientTypes.Suite: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case counters
        case created
        case deviceMinutes
        case message
        case name
        case result
        case started
        case status
        case stopped
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let counters = self.counters {
            try encodeContainer.encode(counters, forKey: .counters)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let deviceMinutes = self.deviceMinutes {
            try encodeContainer.encode(deviceMinutes, forKey: .deviceMinutes)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let result = self.result {
            try encodeContainer.encode(result.rawValue, forKey: .result)
        }
        if let started = self.started {
            try encodeContainer.encodeTimestamp(started, format: .epochSeconds, forKey: .started)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopped = self.stopped {
            try encodeContainer.encodeTimestamp(stopped, format: .epochSeconds, forKey: .stopped)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestType.self, forKey: .type)
        type = typeDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let resultDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionResult.self, forKey: .result)
        result = resultDecoded
        let startedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .started)
        started = startedDecoded
        let stoppedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stopped)
        stopped = stoppedDecoded
        let countersDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Counters.self, forKey: .counters)
        counters = countersDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let deviceMinutesDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceMinutes.self, forKey: .deviceMinutes)
        deviceMinutes = deviceMinutesDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents a collection of one or more tests.
    public struct Suite: Swift.Equatable {
        /// The suite's ARN.
        public var arn: Swift.String?
        /// The suite's result counters.
        public var counters: DeviceFarmClientTypes.Counters?
        /// When the suite was created.
        public var created: ClientRuntime.Date?
        /// Represents the total (metered or unmetered) minutes used by the test suite.
        public var deviceMinutes: DeviceFarmClientTypes.DeviceMinutes?
        /// A message about the suite's result.
        public var message: Swift.String?
        /// The suite's name.
        public var name: Swift.String?
        /// The suite's result. Allowed values include:
        ///
        /// * PENDING
        ///
        /// * PASSED
        ///
        /// * WARNED
        ///
        /// * FAILED
        ///
        /// * SKIPPED
        ///
        /// * ERRORED
        ///
        /// * STOPPED
        public var result: DeviceFarmClientTypes.ExecutionResult?
        /// The suite's start time.
        public var started: ClientRuntime.Date?
        /// The suite's status. Allowed values include:
        ///
        /// * PENDING
        ///
        /// * PENDING_CONCURRENCY
        ///
        /// * PENDING_DEVICE
        ///
        /// * PROCESSING
        ///
        /// * SCHEDULING
        ///
        /// * PREPARING
        ///
        /// * RUNNING
        ///
        /// * COMPLETED
        ///
        /// * STOPPING
        public var status: DeviceFarmClientTypes.ExecutionStatus?
        /// The suite's stop time.
        public var stopped: ClientRuntime.Date?
        /// The suite's type. Must be one of the following values:
        ///
        /// * BUILTIN_FUZZ
        ///
        /// * BUILTIN_EXPLORER Only available for Android; an app explorer that traverses an Android app, interacting with it and capturing screenshots at the same time.
        ///
        /// * APPIUM_JAVA_JUNIT
        ///
        /// * APPIUM_JAVA_TESTNG
        ///
        /// * APPIUM_PYTHON
        ///
        /// * APPIUM_NODE
        ///
        /// * APPIUM_RUBY
        ///
        /// * APPIUM_WEB_JAVA_JUNIT
        ///
        /// * APPIUM_WEB_JAVA_TESTNG
        ///
        /// * APPIUM_WEB_PYTHON
        ///
        /// * APPIUM_WEB_NODE
        ///
        /// * APPIUM_WEB_RUBY
        ///
        /// * CALABASH
        ///
        /// * INSTRUMENTATION
        ///
        /// * UIAUTOMATION
        ///
        /// * UIAUTOMATOR
        ///
        /// * XCTEST
        ///
        /// * XCTEST_UI
        public var type: DeviceFarmClientTypes.TestType?

        public init (
            arn: Swift.String? = nil,
            counters: DeviceFarmClientTypes.Counters? = nil,
            created: ClientRuntime.Date? = nil,
            deviceMinutes: DeviceFarmClientTypes.DeviceMinutes? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            result: DeviceFarmClientTypes.ExecutionResult? = nil,
            started: ClientRuntime.Date? = nil,
            status: DeviceFarmClientTypes.ExecutionStatus? = nil,
            stopped: ClientRuntime.Date? = nil,
            type: DeviceFarmClientTypes.TestType? = nil
        )
        {
            self.arn = arn
            self.counters = counters
            self.created = created
            self.deviceMinutes = deviceMinutes
            self.message = message
            self.name = name
            self.result = result
            self.started = started
            self.status = status
            self.stopped = stopped
            self.type = type
        }
    }

}

extension DeviceFarmClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DeviceFarmClientTypes {
    /// The metadata that you apply to a resource to help you categorize and organize it. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters. Tag values can have a maximum length of 256 characters.
    public struct Tag: Swift.Equatable {
        /// One part of a key-value pair that makes up a tag. A key is a general label that acts like a category for more specific tag values.
        /// This member is required.
        public var key: Swift.String?
        /// The optional part of a key-value pair that makes up a tag. A value acts as a descriptor in a tag category (key).
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TagOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation was not successful. Try again.
public struct TagOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TagOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TagOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension TagPolicyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TagPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request doesn't comply with the AWS Identity and Access Management (IAM) tag policy. Correct your request and then retry it.
public struct TagPolicyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TagPolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TagPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource or resources to which to add tags. You can associate tags with the following Device Farm resources: PROJECT, RUN, NETWORK_PROFILE, INSTANCE_PROFILE, DEVICE_INSTANCE, SESSION, DEVICE_POOL, DEVICE, and VPCE_CONFIGURATION.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters. Tag values can have a maximum length of 256 characters.
    /// This member is required.
    public var tags: [DeviceFarmClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [DeviceFarmClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [DeviceFarmClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DeviceFarmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DeviceFarmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOperationException" : self = .tagOperationException(try TagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyException" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case notFoundException(NotFoundException)
    case tagOperationException(TagOperationException)
    case tagPolicyException(TagPolicyException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeviceFarmClientTypes.Test: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case counters
        case created
        case deviceMinutes
        case message
        case name
        case result
        case started
        case status
        case stopped
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let counters = self.counters {
            try encodeContainer.encode(counters, forKey: .counters)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let deviceMinutes = self.deviceMinutes {
            try encodeContainer.encode(deviceMinutes, forKey: .deviceMinutes)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let result = self.result {
            try encodeContainer.encode(result.rawValue, forKey: .result)
        }
        if let started = self.started {
            try encodeContainer.encodeTimestamp(started, format: .epochSeconds, forKey: .started)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopped = self.stopped {
            try encodeContainer.encodeTimestamp(stopped, format: .epochSeconds, forKey: .stopped)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestType.self, forKey: .type)
        type = typeDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let resultDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionResult.self, forKey: .result)
        result = resultDecoded
        let startedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .started)
        started = startedDecoded
        let stoppedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stopped)
        stopped = stoppedDecoded
        let countersDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Counters.self, forKey: .counters)
        counters = countersDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let deviceMinutesDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceMinutes.self, forKey: .deviceMinutes)
        deviceMinutes = deviceMinutesDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents a condition that is evaluated.
    public struct Test: Swift.Equatable {
        /// The test's ARN.
        public var arn: Swift.String?
        /// The test's result counters.
        public var counters: DeviceFarmClientTypes.Counters?
        /// When the test was created.
        public var created: ClientRuntime.Date?
        /// Represents the total (metered or unmetered) minutes used by the test.
        public var deviceMinutes: DeviceFarmClientTypes.DeviceMinutes?
        /// A message about the test's result.
        public var message: Swift.String?
        /// The test's name.
        public var name: Swift.String?
        /// The test's result. Allowed values include:
        ///
        /// * PENDING
        ///
        /// * PASSED
        ///
        /// * WARNED
        ///
        /// * FAILED
        ///
        /// * SKIPPED
        ///
        /// * ERRORED
        ///
        /// * STOPPED
        public var result: DeviceFarmClientTypes.ExecutionResult?
        /// The test's start time.
        public var started: ClientRuntime.Date?
        /// The test's status. Allowed values include:
        ///
        /// * PENDING
        ///
        /// * PENDING_CONCURRENCY
        ///
        /// * PENDING_DEVICE
        ///
        /// * PROCESSING
        ///
        /// * SCHEDULING
        ///
        /// * PREPARING
        ///
        /// * RUNNING
        ///
        /// * COMPLETED
        ///
        /// * STOPPING
        public var status: DeviceFarmClientTypes.ExecutionStatus?
        /// The test's stop time.
        public var stopped: ClientRuntime.Date?
        /// The test's type. Must be one of the following values:
        ///
        /// * BUILTIN_FUZZ
        ///
        /// * BUILTIN_EXPLORER For Android, an app explorer that traverses an Android app, interacting with it and capturing screenshots at the same time.
        ///
        /// * APPIUM_JAVA_JUNIT
        ///
        /// * APPIUM_JAVA_TESTNG
        ///
        /// * APPIUM_PYTHON
        ///
        /// * APPIUM_NODE
        ///
        /// * APPIUM_RUBY
        ///
        /// * APPIUM_WEB_JAVA_JUNIT
        ///
        /// * APPIUM_WEB_JAVA_TESTNG
        ///
        /// * APPIUM_WEB_PYTHON
        ///
        /// * APPIUM_WEB_NODE
        ///
        /// * APPIUM_WEB_RUBY
        ///
        /// * CALABASH
        ///
        /// * INSTRUMENTATION
        ///
        /// * UIAUTOMATION
        ///
        /// * UIAUTOMATOR
        ///
        /// * XCTEST
        ///
        /// * XCTEST_UI
        public var type: DeviceFarmClientTypes.TestType?

        public init (
            arn: Swift.String? = nil,
            counters: DeviceFarmClientTypes.Counters? = nil,
            created: ClientRuntime.Date? = nil,
            deviceMinutes: DeviceFarmClientTypes.DeviceMinutes? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            result: DeviceFarmClientTypes.ExecutionResult? = nil,
            started: ClientRuntime.Date? = nil,
            status: DeviceFarmClientTypes.ExecutionStatus? = nil,
            stopped: ClientRuntime.Date? = nil,
            type: DeviceFarmClientTypes.TestType? = nil
        )
        {
            self.arn = arn
            self.counters = counters
            self.created = created
            self.deviceMinutes = deviceMinutes
            self.message = message
            self.name = name
            self.result = result
            self.started = started
            self.status = status
            self.stopped = stopped
            self.type = type
        }
    }

}

extension DeviceFarmClientTypes.TestGridProject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case created
        case description
        case name
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridVpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
    }
}

extension DeviceFarmClientTypes {
    /// A Selenium testing project. Projects are used to collect and collate sessions.
    public struct TestGridProject: Swift.Equatable {
        /// The ARN for the project.
        public var arn: Swift.String?
        /// When the project was created.
        public var created: ClientRuntime.Date?
        /// A human-readable description for the project.
        public var description: Swift.String?
        /// A human-readable name for the project.
        public var name: Swift.String?
        /// The VPC security groups and subnets that are attached to a project.
        public var vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig?

        public init (
            arn: Swift.String? = nil,
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig? = nil
        )
        {
            self.arn = arn
            self.created = created
            self.description = description
            self.name = name
            self.vpcConfig = vpcConfig
        }
    }

}

extension DeviceFarmClientTypes.TestGridSession: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case billingMinutes
        case created
        case ended
        case seleniumProperties
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let billingMinutes = self.billingMinutes {
            try encodeContainer.encode(billingMinutes, forKey: .billingMinutes)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let ended = self.ended {
            try encodeContainer.encodeTimestamp(ended, format: .epochSeconds, forKey: .ended)
        }
        if let seleniumProperties = self.seleniumProperties {
            try encodeContainer.encode(seleniumProperties, forKey: .seleniumProperties)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridSessionStatus.self, forKey: .status)
        status = statusDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let endedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .ended)
        ended = endedDecoded
        let billingMinutesDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .billingMinutes)
        billingMinutes = billingMinutesDecoded
        let seleniumPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .seleniumProperties)
        seleniumProperties = seleniumPropertiesDecoded
    }
}

extension DeviceFarmClientTypes {
    /// A [TestGridSession] is a single instance of a browser launched from the URL provided by a call to [CreateTestGridUrl].
    public struct TestGridSession: Swift.Equatable {
        /// The ARN of the session.
        public var arn: Swift.String?
        /// The number of billed minutes that were used for this session.
        public var billingMinutes: Swift.Double?
        /// The time that the session was started.
        public var created: ClientRuntime.Date?
        /// The time the session ended.
        public var ended: ClientRuntime.Date?
        /// A JSON object of options and parameters passed to the Selenium WebDriver.
        public var seleniumProperties: Swift.String?
        /// The state of the session.
        public var status: DeviceFarmClientTypes.TestGridSessionStatus?

        public init (
            arn: Swift.String? = nil,
            billingMinutes: Swift.Double? = nil,
            created: ClientRuntime.Date? = nil,
            ended: ClientRuntime.Date? = nil,
            seleniumProperties: Swift.String? = nil,
            status: DeviceFarmClientTypes.TestGridSessionStatus? = nil
        )
        {
            self.arn = arn
            self.billingMinutes = billingMinutes
            self.created = created
            self.ended = ended
            self.seleniumProperties = seleniumProperties
            self.status = status
        }
    }

}

extension DeviceFarmClientTypes.TestGridSessionAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case duration
        case requestMethod
        case started
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let duration = self.duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let requestMethod = self.requestMethod {
            try encodeContainer.encode(requestMethod, forKey: .requestMethod)
        }
        if let started = self.started {
            try encodeContainer.encodeTimestamp(started, format: .epochSeconds, forKey: .started)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let startedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .started)
        started = startedDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let requestMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestMethod)
        requestMethod = requestMethodDecoded
    }
}

extension DeviceFarmClientTypes {
    /// An action taken by a [TestGridSession] browser instance.
    public struct TestGridSessionAction: Swift.Equatable {
        /// The action taken by the session.
        public var action: Swift.String?
        /// The time, in milliseconds, that the action took to complete in the browser.
        public var duration: Swift.Int?
        /// HTTP method that the browser used to make the request.
        public var requestMethod: Swift.String?
        /// The time that the session invoked the action.
        public var started: ClientRuntime.Date?
        /// HTTP status code returned to the browser when the action was taken.
        public var statusCode: Swift.String?

        public init (
            action: Swift.String? = nil,
            duration: Swift.Int? = nil,
            requestMethod: Swift.String? = nil,
            started: ClientRuntime.Date? = nil,
            statusCode: Swift.String? = nil
        )
        {
            self.action = action
            self.duration = duration
            self.requestMethod = requestMethod
            self.started = started
            self.statusCode = statusCode
        }
    }

}

extension DeviceFarmClientTypes.TestGridSessionArtifact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filename
        case type
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filename = self.filename {
            try encodeContainer.encode(filename, forKey: .filename)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filenameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filename)
        filename = filenameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridSessionArtifactType.self, forKey: .type)
        type = typeDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension DeviceFarmClientTypes.TestGridSessionArtifact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestGridSessionArtifact(filename: \(Swift.String(describing: filename)), type: \(Swift.String(describing: type)), url: \"CONTENT_REDACTED\")"}
}

extension DeviceFarmClientTypes {
    /// Artifacts are video and other files that are produced in the process of running a browser in an automated context. Video elements might be broken up into multiple artifacts as they grow in size during creation.
    public struct TestGridSessionArtifact: Swift.Equatable {
        /// The file name of the artifact.
        public var filename: Swift.String?
        /// The kind of artifact.
        public var type: DeviceFarmClientTypes.TestGridSessionArtifactType?
        /// A semi-stable URL to the content of the object.
        public var url: Swift.String?

        public init (
            filename: Swift.String? = nil,
            type: DeviceFarmClientTypes.TestGridSessionArtifactType? = nil,
            url: Swift.String? = nil
        )
        {
            self.filename = filename
            self.type = type
            self.url = url
        }
    }

}

extension DeviceFarmClientTypes {
    public enum TestGridSessionArtifactCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case log
        case video
        case sdkUnknown(Swift.String)

        public static var allCases: [TestGridSessionArtifactCategory] {
            return [
                .log,
                .video,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .log: return "LOG"
            case .video: return "VIDEO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestGridSessionArtifactCategory(rawValue: rawValue) ?? TestGridSessionArtifactCategory.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum TestGridSessionArtifactType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case seleniumLog
        case unknown
        case video
        case sdkUnknown(Swift.String)

        public static var allCases: [TestGridSessionArtifactType] {
            return [
                .seleniumLog,
                .unknown,
                .video,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .seleniumLog: return "SELENIUM_LOG"
            case .unknown: return "UNKNOWN"
            case .video: return "VIDEO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestGridSessionArtifactType(rawValue: rawValue) ?? TestGridSessionArtifactType.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum TestGridSessionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case closed
        case errored
        case sdkUnknown(Swift.String)

        public static var allCases: [TestGridSessionStatus] {
            return [
                .active,
                .closed,
                .errored,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .closed: return "CLOSED"
            case .errored: return "ERRORED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestGridSessionStatus(rawValue: rawValue) ?? TestGridSessionStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.TestGridVpcConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for nonemptystring0 in securityGroupIds {
                try securityGroupIdsContainer.encode(nonemptystring0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for nonemptystring0 in subnetIds {
                try subnetIdsContainer.encode(nonemptystring0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension DeviceFarmClientTypes {
    /// The VPC security groups and subnets that are attached to a project.
    public struct TestGridVpcConfig: Swift.Equatable {
        /// A list of VPC security group IDs in your Amazon VPC.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// A list of VPC subnet IDs in your Amazon VPC.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// The ID of the Amazon VPC.
        /// This member is required.
        public var vpcId: Swift.String?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension DeviceFarmClientTypes {
    public enum TestType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appiumJavaJunit
        case appiumJavaTestng
        case appiumNode
        case appiumPython
        case appiumRuby
        case appiumWebJavaJunit
        case appiumWebJavaTestng
        case appiumWebNode
        case appiumWebPython
        case appiumWebRuby
        case builtinExplorer
        case builtinFuzz
        case calabash
        case instrumentation
        case remoteAccessRecord
        case remoteAccessReplay
        case uiautomation
        case uiautomator
        case webPerformanceProfile
        case xctest
        case xctestUi
        case sdkUnknown(Swift.String)

        public static var allCases: [TestType] {
            return [
                .appiumJavaJunit,
                .appiumJavaTestng,
                .appiumNode,
                .appiumPython,
                .appiumRuby,
                .appiumWebJavaJunit,
                .appiumWebJavaTestng,
                .appiumWebNode,
                .appiumWebPython,
                .appiumWebRuby,
                .builtinExplorer,
                .builtinFuzz,
                .calabash,
                .instrumentation,
                .remoteAccessRecord,
                .remoteAccessReplay,
                .uiautomation,
                .uiautomator,
                .webPerformanceProfile,
                .xctest,
                .xctestUi,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appiumJavaJunit: return "APPIUM_JAVA_JUNIT"
            case .appiumJavaTestng: return "APPIUM_JAVA_TESTNG"
            case .appiumNode: return "APPIUM_NODE"
            case .appiumPython: return "APPIUM_PYTHON"
            case .appiumRuby: return "APPIUM_RUBY"
            case .appiumWebJavaJunit: return "APPIUM_WEB_JAVA_JUNIT"
            case .appiumWebJavaTestng: return "APPIUM_WEB_JAVA_TESTNG"
            case .appiumWebNode: return "APPIUM_WEB_NODE"
            case .appiumWebPython: return "APPIUM_WEB_PYTHON"
            case .appiumWebRuby: return "APPIUM_WEB_RUBY"
            case .builtinExplorer: return "BUILTIN_EXPLORER"
            case .builtinFuzz: return "BUILTIN_FUZZ"
            case .calabash: return "CALABASH"
            case .instrumentation: return "INSTRUMENTATION"
            case .remoteAccessRecord: return "REMOTE_ACCESS_RECORD"
            case .remoteAccessReplay: return "REMOTE_ACCESS_REPLAY"
            case .uiautomation: return "UIAUTOMATION"
            case .uiautomator: return "UIAUTOMATOR"
            case .webPerformanceProfile: return "WEB_PERFORMANCE_PROFILE"
            case .xctest: return "XCTEST"
            case .xctestUi: return "XCTEST_UI"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestType(rawValue: rawValue) ?? TestType.sdkUnknown(rawValue)
        }
    }
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The list of tags on the repository is over the limit. The maximum number of tags that can be applied to a repository is 50.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension DeviceFarmClientTypes.TrialMinutes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case remaining
        case total
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let remaining = self.remaining {
            try encodeContainer.encode(remaining, forKey: .remaining)
        }
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .total)
        total = totalDecoded
        let remainingDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .remaining)
        remaining = remainingDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents information about free trial device minutes for an AWS account.
    public struct TrialMinutes: Swift.Equatable {
        /// The number of free trial minutes remaining in the account.
        public var remaining: Swift.Double?
        /// The total number of free trial minutes that the account started with.
        public var total: Swift.Double?

        public init (
            remaining: Swift.Double? = nil,
            total: Swift.Double? = nil
        )
        {
            self.remaining = remaining
            self.total = total
        }
    }

}

extension DeviceFarmClientTypes.UniqueProblem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case problems
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let problems = problems {
            var problemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .problems)
            for problem0 in problems {
                try problemsContainer.encode(problem0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let problemsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Problem?].self, forKey: .problems)
        var problemsDecoded0:[DeviceFarmClientTypes.Problem]? = nil
        if let problemsContainer = problemsContainer {
            problemsDecoded0 = [DeviceFarmClientTypes.Problem]()
            for structure0 in problemsContainer {
                if let structure0 = structure0 {
                    problemsDecoded0?.append(structure0)
                }
            }
        }
        problems = problemsDecoded0
    }
}

extension DeviceFarmClientTypes {
    /// A collection of one or more problems, grouped by their result.
    public struct UniqueProblem: Swift.Equatable {
        /// A message about the unique problems' result.
        public var message: Swift.String?
        /// Information about the problems.
        public var problems: [DeviceFarmClientTypes.Problem]?

        public init (
            message: Swift.String? = nil,
            problems: [DeviceFarmClientTypes.Problem]? = nil
        )
        {
            self.message = message
            self.problems = problems
        }
    }

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource or resources from which to delete tags. You can associate tags with the following Device Farm resources: PROJECT, RUN, NETWORK_PROFILE, INSTANCE_PROFILE, DEVICE_INSTANCE, SESSION, DEVICE_POOL, DEVICE, and VPCE_CONFIGURATION.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOperationException" : self = .tagOperationException(try TagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case notFoundException(NotFoundException)
    case tagOperationException(TagOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateDeviceInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case labels
        case profileArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for string0 in labels {
                try labelsContainer.encode(string0)
            }
        }
        if let profileArn = self.profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
    }
}

extension UpdateDeviceInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDeviceInstanceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the device instance.
    /// This member is required.
    public var arn: Swift.String?
    /// An array of strings that you want to associate with the device instance.
    public var labels: [Swift.String]?
    /// The ARN of the profile that you want to associate with the device instance.
    public var profileArn: Swift.String?

    public init (
        arn: Swift.String? = nil,
        labels: [Swift.String]? = nil,
        profileArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.labels = labels
        self.profileArn = profileArn
    }
}

struct UpdateDeviceInstanceInputBody: Swift.Equatable {
    let arn: Swift.String?
    let profileArn: Swift.String?
    let labels: [Swift.String]?
}

extension UpdateDeviceInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case labels
        case profileArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
    }
}

extension UpdateDeviceInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeviceInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDeviceInstanceOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeviceInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDeviceInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceInstance = output.deviceInstance
        } else {
            self.deviceInstance = nil
        }
    }
}

public struct UpdateDeviceInstanceOutputResponse: Swift.Equatable {
    /// An object that contains information about your device instance.
    public var deviceInstance: DeviceFarmClientTypes.DeviceInstance?

    public init (
        deviceInstance: DeviceFarmClientTypes.DeviceInstance? = nil
    )
    {
        self.deviceInstance = deviceInstance
    }
}

struct UpdateDeviceInstanceOutputResponseBody: Swift.Equatable {
    let deviceInstance: DeviceFarmClientTypes.DeviceInstance?
}

extension UpdateDeviceInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceInstance
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceInstanceDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceInstance.self, forKey: .deviceInstance)
        deviceInstance = deviceInstanceDecoded
    }
}

extension UpdateDevicePoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clearMaxDevices
        case description
        case maxDevices
        case name
        case rules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clearMaxDevices = self.clearMaxDevices {
            try encodeContainer.encode(clearMaxDevices, forKey: .clearMaxDevices)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let maxDevices = self.maxDevices {
            try encodeContainer.encode(maxDevices, forKey: .maxDevices)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rule0 in rules {
                try rulesContainer.encode(rule0)
            }
        }
    }
}

extension UpdateDevicePoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the update device pool operation.
public struct UpdateDevicePoolInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Device Farm device pool to update.
    /// This member is required.
    public var arn: Swift.String?
    /// Sets whether the maxDevices parameter applies to your device pool. If you set this parameter to true, the maxDevices parameter does not apply, and Device Farm does not limit the number of devices that it adds to your device pool. In this case, Device Farm adds all available devices that meet the criteria specified in the rules parameter. If you use this parameter in your request, you cannot use the maxDevices parameter in the same request.
    public var clearMaxDevices: Swift.Bool?
    /// A description of the device pool to update.
    public var description: Swift.String?
    /// The number of devices that Device Farm can add to your device pool. Device Farm adds devices that are available and that meet the criteria that you assign for the rules parameter. Depending on how many devices meet these constraints, your device pool might contain fewer devices than the value for this parameter. By specifying the maximum number of devices, you can control the costs that you incur by running tests. If you use this parameter in your request, you cannot use the clearMaxDevices parameter in the same request.
    public var maxDevices: Swift.Int?
    /// A string that represents the name of the device pool to update.
    public var name: Swift.String?
    /// Represents the rules to modify for the device pool. Updating rules is optional. If you update rules for your request, the update replaces the existing rules.
    public var rules: [DeviceFarmClientTypes.Rule]?

    public init (
        arn: Swift.String? = nil,
        clearMaxDevices: Swift.Bool? = nil,
        description: Swift.String? = nil,
        maxDevices: Swift.Int? = nil,
        name: Swift.String? = nil,
        rules: [DeviceFarmClientTypes.Rule]? = nil
    )
    {
        self.arn = arn
        self.clearMaxDevices = clearMaxDevices
        self.description = description
        self.maxDevices = maxDevices
        self.name = name
        self.rules = rules
    }
}

struct UpdateDevicePoolInputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let rules: [DeviceFarmClientTypes.Rule]?
    let maxDevices: Swift.Int?
    let clearMaxDevices: Swift.Bool?
}

extension UpdateDevicePoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clearMaxDevices
        case description
        case maxDevices
        case name
        case rules
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[DeviceFarmClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [DeviceFarmClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let maxDevicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDevices)
        maxDevices = maxDevicesDecoded
        let clearMaxDevicesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .clearMaxDevices)
        clearMaxDevices = clearMaxDevicesDecoded
    }
}

extension UpdateDevicePoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDevicePoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDevicePoolOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDevicePoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDevicePoolOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devicePool = output.devicePool
        } else {
            self.devicePool = nil
        }
    }
}

/// Represents the result of an update device pool request.
public struct UpdateDevicePoolOutputResponse: Swift.Equatable {
    /// The device pool you just updated.
    public var devicePool: DeviceFarmClientTypes.DevicePool?

    public init (
        devicePool: DeviceFarmClientTypes.DevicePool? = nil
    )
    {
        self.devicePool = devicePool
    }
}

struct UpdateDevicePoolOutputResponseBody: Swift.Equatable {
    let devicePool: DeviceFarmClientTypes.DevicePool?
}

extension UpdateDevicePoolOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePool
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePoolDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DevicePool.self, forKey: .devicePool)
        devicePool = devicePoolDecoded
    }
}

extension UpdateInstanceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case excludeAppPackagesFromCleanup
        case name
        case packageCleanup
        case rebootAfterUse
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup {
            var excludeAppPackagesFromCleanupContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeAppPackagesFromCleanup)
            for string0 in excludeAppPackagesFromCleanup {
                try excludeAppPackagesFromCleanupContainer.encode(string0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packageCleanup = self.packageCleanup {
            try encodeContainer.encode(packageCleanup, forKey: .packageCleanup)
        }
        if let rebootAfterUse = self.rebootAfterUse {
            try encodeContainer.encode(rebootAfterUse, forKey: .rebootAfterUse)
        }
    }
}

extension UpdateInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateInstanceProfileInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the instance profile.
    /// This member is required.
    public var arn: Swift.String?
    /// The updated description for your instance profile.
    public var description: Swift.String?
    /// An array of strings that specifies the list of app packages that should not be cleaned up from the device after a test run is over. The list of packages is only considered if you set packageCleanup to true.
    public var excludeAppPackagesFromCleanup: [Swift.String]?
    /// The updated name for your instance profile.
    public var name: Swift.String?
    /// The updated choice for whether you want to specify package cleanup. The default value is false for private devices.
    public var packageCleanup: Swift.Bool?
    /// The updated choice for whether you want to reboot the device after use. The default value is true.
    public var rebootAfterUse: Swift.Bool?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        excludeAppPackagesFromCleanup: [Swift.String]? = nil,
        name: Swift.String? = nil,
        packageCleanup: Swift.Bool? = nil,
        rebootAfterUse: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup
        self.name = name
        self.packageCleanup = packageCleanup
        self.rebootAfterUse = rebootAfterUse
    }
}

struct UpdateInstanceProfileInputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let packageCleanup: Swift.Bool?
    let excludeAppPackagesFromCleanup: [Swift.String]?
    let rebootAfterUse: Swift.Bool?
}

extension UpdateInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case excludeAppPackagesFromCleanup
        case name
        case packageCleanup
        case rebootAfterUse
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let packageCleanupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .packageCleanup)
        packageCleanup = packageCleanupDecoded
        let excludeAppPackagesFromCleanupContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludeAppPackagesFromCleanup)
        var excludeAppPackagesFromCleanupDecoded0:[Swift.String]? = nil
        if let excludeAppPackagesFromCleanupContainer = excludeAppPackagesFromCleanupContainer {
            excludeAppPackagesFromCleanupDecoded0 = [Swift.String]()
            for string0 in excludeAppPackagesFromCleanupContainer {
                if let string0 = string0 {
                    excludeAppPackagesFromCleanupDecoded0?.append(string0)
                }
            }
        }
        excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanupDecoded0
        let rebootAfterUseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rebootAfterUse)
        rebootAfterUse = rebootAfterUseDecoded
    }
}

extension UpdateInstanceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInstanceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateInstanceProfileOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInstanceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateInstanceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceProfile = output.instanceProfile
        } else {
            self.instanceProfile = nil
        }
    }
}

public struct UpdateInstanceProfileOutputResponse: Swift.Equatable {
    /// An object that contains information about your instance profile.
    public var instanceProfile: DeviceFarmClientTypes.InstanceProfile?

    public init (
        instanceProfile: DeviceFarmClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

struct UpdateInstanceProfileOutputResponseBody: Swift.Equatable {
    let instanceProfile: DeviceFarmClientTypes.InstanceProfile?
}

extension UpdateInstanceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

extension UpdateNetworkProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case downlinkBandwidthBits
        case downlinkDelayMs
        case downlinkJitterMs
        case downlinkLossPercent
        case name
        case type
        case uplinkBandwidthBits
        case uplinkDelayMs
        case uplinkJitterMs
        case uplinkLossPercent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let downlinkBandwidthBits = self.downlinkBandwidthBits {
            try encodeContainer.encode(downlinkBandwidthBits, forKey: .downlinkBandwidthBits)
        }
        if let downlinkDelayMs = self.downlinkDelayMs {
            try encodeContainer.encode(downlinkDelayMs, forKey: .downlinkDelayMs)
        }
        if let downlinkJitterMs = self.downlinkJitterMs {
            try encodeContainer.encode(downlinkJitterMs, forKey: .downlinkJitterMs)
        }
        if downlinkLossPercent != 0 {
            try encodeContainer.encode(downlinkLossPercent, forKey: .downlinkLossPercent)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uplinkBandwidthBits = self.uplinkBandwidthBits {
            try encodeContainer.encode(uplinkBandwidthBits, forKey: .uplinkBandwidthBits)
        }
        if let uplinkDelayMs = self.uplinkDelayMs {
            try encodeContainer.encode(uplinkDelayMs, forKey: .uplinkDelayMs)
        }
        if let uplinkJitterMs = self.uplinkJitterMs {
            try encodeContainer.encode(uplinkJitterMs, forKey: .uplinkJitterMs)
        }
        if uplinkLossPercent != 0 {
            try encodeContainer.encode(uplinkLossPercent, forKey: .uplinkLossPercent)
        }
    }
}

extension UpdateNetworkProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateNetworkProfileInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the project for which you want to update network profile settings.
    /// This member is required.
    public var arn: Swift.String?
    /// The description of the network profile about which you are returning information.
    public var description: Swift.String?
    /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
    public var downlinkBandwidthBits: Swift.Int?
    /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
    public var downlinkDelayMs: Swift.Int?
    /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
    public var downlinkJitterMs: Swift.Int?
    /// Proportion of received packets that fail to arrive from 0 to 100 percent.
    public var downlinkLossPercent: Swift.Int
    /// The name of the network profile about which you are returning information.
    public var name: Swift.String?
    /// The type of network profile to return information about. Valid values are listed here.
    public var type: DeviceFarmClientTypes.NetworkProfileType?
    /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
    public var uplinkBandwidthBits: Swift.Int?
    /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
    public var uplinkDelayMs: Swift.Int?
    /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
    public var uplinkJitterMs: Swift.Int?
    /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
    public var uplinkLossPercent: Swift.Int

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        downlinkBandwidthBits: Swift.Int? = nil,
        downlinkDelayMs: Swift.Int? = nil,
        downlinkJitterMs: Swift.Int? = nil,
        downlinkLossPercent: Swift.Int = 0,
        name: Swift.String? = nil,
        type: DeviceFarmClientTypes.NetworkProfileType? = nil,
        uplinkBandwidthBits: Swift.Int? = nil,
        uplinkDelayMs: Swift.Int? = nil,
        uplinkJitterMs: Swift.Int? = nil,
        uplinkLossPercent: Swift.Int = 0
    )
    {
        self.arn = arn
        self.description = description
        self.downlinkBandwidthBits = downlinkBandwidthBits
        self.downlinkDelayMs = downlinkDelayMs
        self.downlinkJitterMs = downlinkJitterMs
        self.downlinkLossPercent = downlinkLossPercent
        self.name = name
        self.type = type
        self.uplinkBandwidthBits = uplinkBandwidthBits
        self.uplinkDelayMs = uplinkDelayMs
        self.uplinkJitterMs = uplinkJitterMs
        self.uplinkLossPercent = uplinkLossPercent
    }
}

struct UpdateNetworkProfileInputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let type: DeviceFarmClientTypes.NetworkProfileType?
    let uplinkBandwidthBits: Swift.Int?
    let downlinkBandwidthBits: Swift.Int?
    let uplinkDelayMs: Swift.Int?
    let downlinkDelayMs: Swift.Int?
    let uplinkJitterMs: Swift.Int?
    let downlinkJitterMs: Swift.Int?
    let uplinkLossPercent: Swift.Int
    let downlinkLossPercent: Swift.Int
}

extension UpdateNetworkProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case downlinkBandwidthBits
        case downlinkDelayMs
        case downlinkJitterMs
        case downlinkLossPercent
        case name
        case type
        case uplinkBandwidthBits
        case uplinkDelayMs
        case uplinkJitterMs
        case uplinkLossPercent
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.NetworkProfileType.self, forKey: .type)
        type = typeDecoded
        let uplinkBandwidthBitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkBandwidthBits)
        uplinkBandwidthBits = uplinkBandwidthBitsDecoded
        let downlinkBandwidthBitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkBandwidthBits)
        downlinkBandwidthBits = downlinkBandwidthBitsDecoded
        let uplinkDelayMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkDelayMs)
        uplinkDelayMs = uplinkDelayMsDecoded
        let downlinkDelayMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkDelayMs)
        downlinkDelayMs = downlinkDelayMsDecoded
        let uplinkJitterMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkJitterMs)
        uplinkJitterMs = uplinkJitterMsDecoded
        let downlinkJitterMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkJitterMs)
        downlinkJitterMs = downlinkJitterMsDecoded
        let uplinkLossPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkLossPercent) ?? 0
        uplinkLossPercent = uplinkLossPercentDecoded
        let downlinkLossPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkLossPercent) ?? 0
        downlinkLossPercent = downlinkLossPercentDecoded
    }
}

extension UpdateNetworkProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNetworkProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateNetworkProfileOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNetworkProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateNetworkProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkProfile = output.networkProfile
        } else {
            self.networkProfile = nil
        }
    }
}

public struct UpdateNetworkProfileOutputResponse: Swift.Equatable {
    /// A list of the available network profiles.
    public var networkProfile: DeviceFarmClientTypes.NetworkProfile?

    public init (
        networkProfile: DeviceFarmClientTypes.NetworkProfile? = nil
    )
    {
        self.networkProfile = networkProfile
    }
}

struct UpdateNetworkProfileOutputResponseBody: Swift.Equatable {
    let networkProfile: DeviceFarmClientTypes.NetworkProfile?
}

extension UpdateNetworkProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.NetworkProfile.self, forKey: .networkProfile)
        networkProfile = networkProfileDecoded
    }
}

extension UpdateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case defaultJobTimeoutMinutes
        case name
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let defaultJobTimeoutMinutes = self.defaultJobTimeoutMinutes {
            try encodeContainer.encode(defaultJobTimeoutMinutes, forKey: .defaultJobTimeoutMinutes)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension UpdateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents a request to the update project operation.
public struct UpdateProjectInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the project whose name to update.
    /// This member is required.
    public var arn: Swift.String?
    /// The number of minutes a test run in the project executes before it times out.
    public var defaultJobTimeoutMinutes: Swift.Int?
    /// A string that represents the new name of the project that you are updating.
    public var name: Swift.String?
    /// The VPC security groups and subnets that are attached to a project.
    public var vpcConfig: DeviceFarmClientTypes.VpcConfig?

    public init (
        arn: Swift.String? = nil,
        defaultJobTimeoutMinutes: Swift.Int? = nil,
        name: Swift.String? = nil,
        vpcConfig: DeviceFarmClientTypes.VpcConfig? = nil
    )
    {
        self.arn = arn
        self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
        self.name = name
        self.vpcConfig = vpcConfig
    }
}

struct UpdateProjectInputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let defaultJobTimeoutMinutes: Swift.Int?
    let vpcConfig: DeviceFarmClientTypes.VpcConfig?
}

extension UpdateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case defaultJobTimeoutMinutes
        case name
        case vpcConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultJobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultJobTimeoutMinutes)
        defaultJobTimeoutMinutes = defaultJobTimeoutMinutesDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension UpdateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateProjectOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

/// Represents the result of an update project request.
public struct UpdateProjectOutputResponse: Swift.Equatable {
    /// The project to update.
    public var project: DeviceFarmClientTypes.Project?

    public init (
        project: DeviceFarmClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

struct UpdateProjectOutputResponseBody: Swift.Equatable {
    let project: DeviceFarmClientTypes.Project?
}

extension UpdateProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case project
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Project.self, forKey: .project)
        project = projectDecoded
    }
}

extension UpdateTestGridProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case projectArn
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectArn = self.projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension UpdateTestGridProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateTestGridProjectInput: Swift.Equatable {
    /// Human-readable description for the project.
    public var description: Swift.String?
    /// Human-readable name for the project.
    public var name: Swift.String?
    /// ARN of the project to update.
    /// This member is required.
    public var projectArn: Swift.String?
    /// The VPC security groups and subnets that are attached to a project.
    public var vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig? = nil
    )
    {
        self.description = description
        self.name = name
        self.projectArn = projectArn
        self.vpcConfig = vpcConfig
    }
}

struct UpdateTestGridProjectInputBody: Swift.Equatable {
    let projectArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig?
}

extension UpdateTestGridProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case projectArn
        case vpcConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridVpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension UpdateTestGridProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTestGridProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateTestGridProjectOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTestGridProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateTestGridProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.testGridProject = output.testGridProject
        } else {
            self.testGridProject = nil
        }
    }
}

public struct UpdateTestGridProjectOutputResponse: Swift.Equatable {
    /// The project, including updated information.
    public var testGridProject: DeviceFarmClientTypes.TestGridProject?

    public init (
        testGridProject: DeviceFarmClientTypes.TestGridProject? = nil
    )
    {
        self.testGridProject = testGridProject
    }
}

struct UpdateTestGridProjectOutputResponseBody: Swift.Equatable {
    let testGridProject: DeviceFarmClientTypes.TestGridProject?
}

extension UpdateTestGridProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case testGridProject
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testGridProjectDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridProject.self, forKey: .testGridProject)
        testGridProject = testGridProjectDecoded
    }
}

extension UpdateUploadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case contentType
        case editContent
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let editContent = self.editContent {
            try encodeContainer.encode(editContent, forKey: .editContent)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateUploadInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the uploaded test spec.
    /// This member is required.
    public var arn: Swift.String?
    /// The upload's content type (for example, application/x-yaml).
    public var contentType: Swift.String?
    /// Set to true if the YAML file has changed and must be updated. Otherwise, set to false.
    public var editContent: Swift.Bool?
    /// The upload's test spec file name. The name must not contain any forward slashes (/). The test spec file name must end with the .yaml or .yml file extension.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        contentType: Swift.String? = nil,
        editContent: Swift.Bool? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.contentType = contentType
        self.editContent = editContent
        self.name = name
    }
}

struct UpdateUploadInputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let contentType: Swift.String?
    let editContent: Swift.Bool?
}

extension UpdateUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case contentType
        case editContent
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let editContentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .editContent)
        editContent = editContentDecoded
    }
}

extension UpdateUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateUploadOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateUploadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.upload = output.upload
        } else {
            self.upload = nil
        }
    }
}

public struct UpdateUploadOutputResponse: Swift.Equatable {
    /// A test spec uploaded to Device Farm.
    public var upload: DeviceFarmClientTypes.Upload?

    public init (
        upload: DeviceFarmClientTypes.Upload? = nil
    )
    {
        self.upload = upload
    }
}

struct UpdateUploadOutputResponseBody: Swift.Equatable {
    let upload: DeviceFarmClientTypes.Upload?
}

extension UpdateUploadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case upload
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Upload.self, forKey: .upload)
        upload = uploadDecoded
    }
}

extension UpdateVPCEConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case serviceDnsName
        case vpceConfigurationDescription
        case vpceConfigurationName
        case vpceServiceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let serviceDnsName = self.serviceDnsName {
            try encodeContainer.encode(serviceDnsName, forKey: .serviceDnsName)
        }
        if let vpceConfigurationDescription = self.vpceConfigurationDescription {
            try encodeContainer.encode(vpceConfigurationDescription, forKey: .vpceConfigurationDescription)
        }
        if let vpceConfigurationName = self.vpceConfigurationName {
            try encodeContainer.encode(vpceConfigurationName, forKey: .vpceConfigurationName)
        }
        if let vpceServiceName = self.vpceServiceName {
            try encodeContainer.encode(vpceServiceName, forKey: .vpceServiceName)
        }
    }
}

extension UpdateVPCEConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateVPCEConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to update.
    /// This member is required.
    public var arn: Swift.String?
    /// The DNS (domain) name used to connect to your private service in your VPC. The DNS name must not already be in use on the internet.
    public var serviceDnsName: Swift.String?
    /// An optional description that provides details about your VPC endpoint configuration.
    public var vpceConfigurationDescription: Swift.String?
    /// The friendly name you give to your VPC endpoint configuration to manage your configurations more easily.
    public var vpceConfigurationName: Swift.String?
    /// The name of the VPC endpoint service running in your AWS account that you want Device Farm to test.
    public var vpceServiceName: Swift.String?

    public init (
        arn: Swift.String? = nil,
        serviceDnsName: Swift.String? = nil,
        vpceConfigurationDescription: Swift.String? = nil,
        vpceConfigurationName: Swift.String? = nil,
        vpceServiceName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.serviceDnsName = serviceDnsName
        self.vpceConfigurationDescription = vpceConfigurationDescription
        self.vpceConfigurationName = vpceConfigurationName
        self.vpceServiceName = vpceServiceName
    }
}

struct UpdateVPCEConfigurationInputBody: Swift.Equatable {
    let arn: Swift.String?
    let vpceConfigurationName: Swift.String?
    let vpceServiceName: Swift.String?
    let serviceDnsName: Swift.String?
    let vpceConfigurationDescription: Swift.String?
}

extension UpdateVPCEConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case serviceDnsName
        case vpceConfigurationDescription
        case vpceConfigurationName
        case vpceServiceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let vpceConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceConfigurationName)
        vpceConfigurationName = vpceConfigurationNameDecoded
        let vpceServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceServiceName)
        vpceServiceName = vpceServiceNameDecoded
        let serviceDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceDnsName)
        serviceDnsName = serviceDnsNameDecoded
        let vpceConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceConfigurationDescription)
        vpceConfigurationDescription = vpceConfigurationDescriptionDecoded
    }
}

extension UpdateVPCEConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVPCEConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateVPCEConfigurationOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case invalidOperationException(InvalidOperationException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVPCEConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateVPCEConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vpceConfiguration = output.vpceConfiguration
        } else {
            self.vpceConfiguration = nil
        }
    }
}

public struct UpdateVPCEConfigurationOutputResponse: Swift.Equatable {
    /// An object that contains information about your VPC endpoint configuration.
    public var vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration?

    public init (
        vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration? = nil
    )
    {
        self.vpceConfiguration = vpceConfiguration
    }
}

struct UpdateVPCEConfigurationOutputResponseBody: Swift.Equatable {
    let vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration?
}

extension UpdateVPCEConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpceConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpceConfigurationDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.VPCEConfiguration.self, forKey: .vpceConfiguration)
        vpceConfiguration = vpceConfigurationDecoded
    }
}

extension DeviceFarmClientTypes.Upload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case category
        case contentType
        case created
        case message
        case metadata
        case name
        case status
        case type
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.UploadType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.UploadStatus.self, forKey: .status)
        status = statusDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.UploadCategory.self, forKey: .category)
        category = categoryDecoded
    }
}

extension DeviceFarmClientTypes.Upload: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Upload(arn: \(Swift.String(describing: arn)), category: \(Swift.String(describing: category)), contentType: \(Swift.String(describing: contentType)), created: \(Swift.String(describing: created)), message: \(Swift.String(describing: message)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), url: \"CONTENT_REDACTED\")"}
}

extension DeviceFarmClientTypes {
    /// An app or a set of one or more tests to upload or that have been uploaded.
    public struct Upload: Swift.Equatable {
        /// The upload's ARN.
        public var arn: Swift.String?
        /// The upload's category. Allowed values include:
        ///
        /// * CURATED: An upload managed by AWS Device Farm.
        ///
        /// * PRIVATE: An upload managed by the AWS Device Farm customer.
        public var category: DeviceFarmClientTypes.UploadCategory?
        /// The upload's content type (for example, application/octet-stream).
        public var contentType: Swift.String?
        /// When the upload was created.
        public var created: ClientRuntime.Date?
        /// A message about the upload's result.
        public var message: Swift.String?
        /// The upload's metadata. For example, for Android, this contains information that is parsed from the manifest and is displayed in the AWS Device Farm console after the associated app is uploaded.
        public var metadata: Swift.String?
        /// The upload's file name.
        public var name: Swift.String?
        /// The upload's status. Must be one of the following values:
        ///
        /// * FAILED
        ///
        /// * INITIALIZED
        ///
        /// * PROCESSING
        ///
        /// * SUCCEEDED
        public var status: DeviceFarmClientTypes.UploadStatus?
        /// The upload's type. Must be one of the following values:
        ///
        /// * ANDROID_APP
        ///
        /// * IOS_APP
        ///
        /// * WEB_APP
        ///
        /// * EXTERNAL_DATA
        ///
        /// * APPIUM_JAVA_JUNIT_TEST_PACKAGE
        ///
        /// * APPIUM_JAVA_TESTNG_TEST_PACKAGE
        ///
        /// * APPIUM_PYTHON_TEST_PACKAGE
        ///
        /// * APPIUM_NODE_TEST_PACKAGE
        ///
        /// * APPIUM_RUBY_TEST_PACKAGE
        ///
        /// * APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE
        ///
        /// * APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE
        ///
        /// * APPIUM_WEB_PYTHON_TEST_PACKAGE
        ///
        /// * APPIUM_WEB_NODE_TEST_PACKAGE
        ///
        /// * APPIUM_WEB_RUBY_TEST_PACKAGE
        ///
        /// * CALABASH_TEST_PACKAGE
        ///
        /// * INSTRUMENTATION_TEST_PACKAGE
        ///
        /// * UIAUTOMATION_TEST_PACKAGE
        ///
        /// * UIAUTOMATOR_TEST_PACKAGE
        ///
        /// * XCTEST_TEST_PACKAGE
        ///
        /// * XCTEST_UI_TEST_PACKAGE
        ///
        /// * APPIUM_JAVA_JUNIT_TEST_SPEC
        ///
        /// * APPIUM_JAVA_TESTNG_TEST_SPEC
        ///
        /// * APPIUM_PYTHON_TEST_SPEC
        ///
        /// * APPIUM_NODE_TEST_SPEC
        ///
        /// * APPIUM_RUBY_TEST_SPEC
        ///
        /// * APPIUM_WEB_JAVA_JUNIT_TEST_SPEC
        ///
        /// * APPIUM_WEB_JAVA_TESTNG_TEST_SPEC
        ///
        /// * APPIUM_WEB_PYTHON_TEST_SPEC
        ///
        /// * APPIUM_WEB_NODE_TEST_SPEC
        ///
        /// * APPIUM_WEB_RUBY_TEST_SPEC
        ///
        /// * INSTRUMENTATION_TEST_SPEC
        ///
        /// * XCTEST_UI_TEST_SPEC
        public var type: DeviceFarmClientTypes.UploadType?
        /// The presigned Amazon S3 URL that was used to store a file using a PUT request.
        public var url: Swift.String?

        public init (
            arn: Swift.String? = nil,
            category: DeviceFarmClientTypes.UploadCategory? = nil,
            contentType: Swift.String? = nil,
            created: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil,
            status: DeviceFarmClientTypes.UploadStatus? = nil,
            type: DeviceFarmClientTypes.UploadType? = nil,
            url: Swift.String? = nil
        )
        {
            self.arn = arn
            self.category = category
            self.contentType = contentType
            self.created = created
            self.message = message
            self.metadata = metadata
            self.name = name
            self.status = status
            self.type = type
            self.url = url
        }
    }

}

extension DeviceFarmClientTypes {
    public enum UploadCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case curated
        case `private`
        case sdkUnknown(Swift.String)

        public static var allCases: [UploadCategory] {
            return [
                .curated,
                .private,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .curated: return "CURATED"
            case .private: return "PRIVATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UploadCategory(rawValue: rawValue) ?? UploadCategory.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum UploadStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case initialized
        case processing
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [UploadStatus] {
            return [
                .failed,
                .initialized,
                .processing,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .initialized: return "INITIALIZED"
            case .processing: return "PROCESSING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UploadStatus(rawValue: rawValue) ?? UploadStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum UploadType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case androidApp
        case appiumJavaJunitTestPackage
        case appiumJavaJunitTestSpec
        case appiumJavaTestngTestPackage
        case appiumJavaTestngTestSpec
        case appiumNodeTestPackage
        case appiumNodeTestSpec
        case appiumPythonTestPackage
        case appiumPythonTestSpec
        case appiumRubyTestPackage
        case appiumRubyTestSpec
        case appiumWebJavaJunitTestPackage
        case appiumWebJavaJunitTestSpec
        case appiumWebJavaTestngTestPackage
        case appiumWebJavaTestngTestSpec
        case appiumWebNodeTestPackage
        case appiumWebNodeTestSpec
        case appiumWebPythonTestPackage
        case appiumWebPythonTestSpec
        case appiumWebRubyTestPackage
        case appiumWebRubyTestSpec
        case calabashTestPackage
        case externalData
        case instrumentationTestPackage
        case instrumentationTestSpec
        case iosApp
        case uiautomationTestPackage
        case uiautomatorTestPackage
        case webApp
        case xctestTestPackage
        case xctestUiTestPackage
        case xctestUiTestSpec
        case sdkUnknown(Swift.String)

        public static var allCases: [UploadType] {
            return [
                .androidApp,
                .appiumJavaJunitTestPackage,
                .appiumJavaJunitTestSpec,
                .appiumJavaTestngTestPackage,
                .appiumJavaTestngTestSpec,
                .appiumNodeTestPackage,
                .appiumNodeTestSpec,
                .appiumPythonTestPackage,
                .appiumPythonTestSpec,
                .appiumRubyTestPackage,
                .appiumRubyTestSpec,
                .appiumWebJavaJunitTestPackage,
                .appiumWebJavaJunitTestSpec,
                .appiumWebJavaTestngTestPackage,
                .appiumWebJavaTestngTestSpec,
                .appiumWebNodeTestPackage,
                .appiumWebNodeTestSpec,
                .appiumWebPythonTestPackage,
                .appiumWebPythonTestSpec,
                .appiumWebRubyTestPackage,
                .appiumWebRubyTestSpec,
                .calabashTestPackage,
                .externalData,
                .instrumentationTestPackage,
                .instrumentationTestSpec,
                .iosApp,
                .uiautomationTestPackage,
                .uiautomatorTestPackage,
                .webApp,
                .xctestTestPackage,
                .xctestUiTestPackage,
                .xctestUiTestSpec,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .androidApp: return "ANDROID_APP"
            case .appiumJavaJunitTestPackage: return "APPIUM_JAVA_JUNIT_TEST_PACKAGE"
            case .appiumJavaJunitTestSpec: return "APPIUM_JAVA_JUNIT_TEST_SPEC"
            case .appiumJavaTestngTestPackage: return "APPIUM_JAVA_TESTNG_TEST_PACKAGE"
            case .appiumJavaTestngTestSpec: return "APPIUM_JAVA_TESTNG_TEST_SPEC"
            case .appiumNodeTestPackage: return "APPIUM_NODE_TEST_PACKAGE"
            case .appiumNodeTestSpec: return "APPIUM_NODE_TEST_SPEC"
            case .appiumPythonTestPackage: return "APPIUM_PYTHON_TEST_PACKAGE"
            case .appiumPythonTestSpec: return "APPIUM_PYTHON_TEST_SPEC"
            case .appiumRubyTestPackage: return "APPIUM_RUBY_TEST_PACKAGE"
            case .appiumRubyTestSpec: return "APPIUM_RUBY_TEST_SPEC"
            case .appiumWebJavaJunitTestPackage: return "APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE"
            case .appiumWebJavaJunitTestSpec: return "APPIUM_WEB_JAVA_JUNIT_TEST_SPEC"
            case .appiumWebJavaTestngTestPackage: return "APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE"
            case .appiumWebJavaTestngTestSpec: return "APPIUM_WEB_JAVA_TESTNG_TEST_SPEC"
            case .appiumWebNodeTestPackage: return "APPIUM_WEB_NODE_TEST_PACKAGE"
            case .appiumWebNodeTestSpec: return "APPIUM_WEB_NODE_TEST_SPEC"
            case .appiumWebPythonTestPackage: return "APPIUM_WEB_PYTHON_TEST_PACKAGE"
            case .appiumWebPythonTestSpec: return "APPIUM_WEB_PYTHON_TEST_SPEC"
            case .appiumWebRubyTestPackage: return "APPIUM_WEB_RUBY_TEST_PACKAGE"
            case .appiumWebRubyTestSpec: return "APPIUM_WEB_RUBY_TEST_SPEC"
            case .calabashTestPackage: return "CALABASH_TEST_PACKAGE"
            case .externalData: return "EXTERNAL_DATA"
            case .instrumentationTestPackage: return "INSTRUMENTATION_TEST_PACKAGE"
            case .instrumentationTestSpec: return "INSTRUMENTATION_TEST_SPEC"
            case .iosApp: return "IOS_APP"
            case .uiautomationTestPackage: return "UIAUTOMATION_TEST_PACKAGE"
            case .uiautomatorTestPackage: return "UIAUTOMATOR_TEST_PACKAGE"
            case .webApp: return "WEB_APP"
            case .xctestTestPackage: return "XCTEST_TEST_PACKAGE"
            case .xctestUiTestPackage: return "XCTEST_UI_TEST_PACKAGE"
            case .xctestUiTestSpec: return "XCTEST_UI_TEST_SPEC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UploadType(rawValue: rawValue) ?? UploadType.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.VPCEConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case serviceDnsName
        case vpceConfigurationDescription
        case vpceConfigurationName
        case vpceServiceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let serviceDnsName = self.serviceDnsName {
            try encodeContainer.encode(serviceDnsName, forKey: .serviceDnsName)
        }
        if let vpceConfigurationDescription = self.vpceConfigurationDescription {
            try encodeContainer.encode(vpceConfigurationDescription, forKey: .vpceConfigurationDescription)
        }
        if let vpceConfigurationName = self.vpceConfigurationName {
            try encodeContainer.encode(vpceConfigurationName, forKey: .vpceConfigurationName)
        }
        if let vpceServiceName = self.vpceServiceName {
            try encodeContainer.encode(vpceServiceName, forKey: .vpceServiceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let vpceConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceConfigurationName)
        vpceConfigurationName = vpceConfigurationNameDecoded
        let vpceServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceServiceName)
        vpceServiceName = vpceServiceNameDecoded
        let serviceDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceDnsName)
        serviceDnsName = serviceDnsNameDecoded
        let vpceConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceConfigurationDescription)
        vpceConfigurationDescription = vpceConfigurationDescriptionDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Represents an Amazon Virtual Private Cloud (VPC) endpoint configuration.
    public struct VPCEConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the VPC endpoint configuration.
        public var arn: Swift.String?
        /// The DNS name that maps to the private IP address of the service you want to access.
        public var serviceDnsName: Swift.String?
        /// An optional description that provides details about your VPC endpoint configuration.
        public var vpceConfigurationDescription: Swift.String?
        /// The friendly name you give to your VPC endpoint configuration to manage your configurations more easily.
        public var vpceConfigurationName: Swift.String?
        /// The name of the VPC endpoint service running in your AWS account that you want Device Farm to test.
        public var vpceServiceName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            serviceDnsName: Swift.String? = nil,
            vpceConfigurationDescription: Swift.String? = nil,
            vpceConfigurationName: Swift.String? = nil,
            vpceServiceName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.serviceDnsName = serviceDnsName
            self.vpceConfigurationDescription = vpceConfigurationDescription
            self.vpceConfigurationName = vpceConfigurationName
            self.vpceServiceName = vpceServiceName
        }
    }

}

extension DeviceFarmClientTypes.VpcConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension DeviceFarmClientTypes {
    /// Contains the VPC configuration data necessary to interface with AWS Device Farm's services.
    public struct VpcConfig: Swift.Equatable {
        /// An array of one or more security groups IDs in your Amazon VPC.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// An array of one or more subnet IDs in your Amazon VPC.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// The ID of the Amazon VPC.
        /// This member is required.
        public var vpcId: Swift.String?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}
