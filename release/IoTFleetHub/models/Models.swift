// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public enum ApplicationState {
    case active
    case createFailed
    case creating
    case deleteFailed
    case deleting
    case sdkUnknown(String)
}

extension ApplicationState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ApplicationState] {
        return [
            .active,
            .createFailed,
            .creating,
            .deleteFailed,
            .deleting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .createFailed: return "CREATE_FAILED"
        case .creating: return "CREATING"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleting: return "DELETING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ApplicationState(rawValue: rawValue) ?? ApplicationState.sdkUnknown(rawValue)
    }
}

extension ApplicationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationCreationDate
        case applicationDescription
        case applicationId
        case applicationLastUpdateDate
        case applicationName
        case applicationState
        case applicationUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applicationCreationDate != 0 {
            try encodeContainer.encode(applicationCreationDate, forKey: .applicationCreationDate)
        }
        if let applicationDescription = applicationDescription {
            try encodeContainer.encode(applicationDescription, forKey: .applicationDescription)
        }
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if applicationLastUpdateDate != 0 {
            try encodeContainer.encode(applicationLastUpdateDate, forKey: .applicationLastUpdateDate)
        }
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let applicationState = applicationState {
            try encodeContainer.encode(applicationState.rawValue, forKey: .applicationState)
        }
        if let applicationUrl = applicationUrl {
            try encodeContainer.encode(applicationUrl, forKey: .applicationUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let applicationDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationDescription)
        applicationDescription = applicationDescriptionDecoded
        let applicationUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationUrl)
        applicationUrl = applicationUrlDecoded
        let applicationCreationDateDecoded = try containerValues.decode(Int.self, forKey: .applicationCreationDate)
        applicationCreationDate = applicationCreationDateDecoded
        let applicationLastUpdateDateDecoded = try containerValues.decode(Int.self, forKey: .applicationLastUpdateDate)
        applicationLastUpdateDate = applicationLastUpdateDateDecoded
        let applicationStateDecoded = try containerValues.decodeIfPresent(ApplicationState.self, forKey: .applicationState)
        applicationState = applicationStateDecoded
    }
}

extension ApplicationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationSummary(applicationCreationDate: \(String(describing: applicationCreationDate)), applicationDescription: \(String(describing: applicationDescription)), applicationId: \(String(describing: applicationId)), applicationLastUpdateDate: \(String(describing: applicationLastUpdateDate)), applicationName: \(String(describing: applicationName)), applicationState: \(String(describing: applicationState)), applicationUrl: \(String(describing: applicationUrl)))"}
}

/// <p>A summary of information about a AWS IoT Device Management web application.</p>
///          <note>
///             <p>Fleet Hub for AWS IoT Device Management is in public preview and is subject to change.</p>
///          </note>
public struct ApplicationSummary: Equatable {
    /// <p>The date (in Unix epoch time) when the web application was created.</p>
    public let applicationCreationDate: Int
    /// <p>An optional description of the web application.</p>
    public let applicationDescription: String?
    /// <p>The unique Id of the web application.</p>
    public let applicationId: String?
    /// <p>The date (in Unix epoch time) when the web application was last updated.</p>
    public let applicationLastUpdateDate: Int
    /// <p>The name of the web application.</p>
    public let applicationName: String?
    /// <p>The current state of the web application.</p>
    public let applicationState: ApplicationState?
    /// <p>The URL of the web application.</p>
    public let applicationUrl: String?

    public init (
        applicationCreationDate: Int = 0,
        applicationDescription: String? = nil,
        applicationId: String? = nil,
        applicationLastUpdateDate: Int = 0,
        applicationName: String? = nil,
        applicationState: ApplicationState? = nil,
        applicationUrl: String? = nil
    )
    {
        self.applicationCreationDate = applicationCreationDate
        self.applicationDescription = applicationDescription
        self.applicationId = applicationId
        self.applicationLastUpdateDate = applicationLastUpdateDate
        self.applicationName = applicationName
        self.applicationState = applicationState
        self.applicationUrl = applicationUrl
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request conflicts with the current state of the resource.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateApplicationInputBodyMiddleware: Middleware {
    public let id: String = "CreateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

extension CreateApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationInput(applicationDescription: \(String(describing: applicationDescription)), applicationName: \(String(describing: applicationName)), clientToken: \(String(describing: clientToken)), roleArn: \(String(describing: roleArn)), tags: \(String(describing: tags)))"}
}

extension CreateApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationDescription
        case applicationName
        case clientToken
        case roleArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationDescription = applicationDescription {
            try encodeContainer.encode(applicationDescription, forKey: .applicationDescription)
        }
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInput: Equatable {
    /// <p>An optional description of the web application.</p>
    public let applicationDescription: String?
    /// <p>The name of the web application.</p>
    public let applicationName: String?
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request.
    ///       Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?
    /// <p>The ARN of the role that the web application assumes when it interacts with AWS IoT Core.</p>
    ///          <note>
    ///             <p>The name of the role must be in the form <code>AWSIotFleetHub_<i>random_string</i>
    ///                </code>.</p>
    ///          </note>
    public let roleArn: String?
    /// <p>A set of key/value pairs that you can use to manage the web application resource.</p>
    public let tags: [String:String]?

    public init (
        applicationDescription: String? = nil,
        applicationName: String? = nil,
        clientToken: String? = nil,
        roleArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.applicationDescription = applicationDescription
        self.applicationName = applicationName
        self.clientToken = clientToken
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateApplicationInputBody: Equatable {
    public let applicationName: String?
    public let applicationDescription: String?
    public let clientToken: String?
    public let roleArn: String?
    public let tags: [String:String]?
}

extension CreateApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationDescription
        case applicationName
        case clientToken
        case roleArn
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let applicationDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationDescription)
        applicationDescription = applicationDescriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationOutputError: Swift.Error, Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationOutputResponse(applicationArn: \(String(describing: applicationArn)), applicationId: \(String(describing: applicationId)))"}
}

extension CreateApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationArn = output.applicationArn
            self.applicationId = output.applicationId
        } else {
            self.applicationArn = nil
            self.applicationId = nil
        }
    }
}

public struct CreateApplicationOutputResponse: Equatable {
    /// <p>The ARN of the web application.</p>
    public let applicationArn: String?
    /// <p>The unique Id of the web application.</p>
    public let applicationId: String?

    public init (
        applicationArn: String? = nil,
        applicationId: String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.applicationId = applicationId
    }
}

struct CreateApplicationOutputResponseBody: Equatable {
    public let applicationId: String?
    public let applicationArn: String?
}

extension CreateApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationArn
        case applicationId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

extension DeleteApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationInput(applicationId: \(String(describing: applicationId)), clientToken: \(String(describing: clientToken)))"}
}

extension DeleteApplicationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = URLQueryItem(name: "clientToken".urlPercentEncoding(), value: String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInput: Equatable {
    /// <p>The unique Id of the web application.</p>
    public let applicationId: String?
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request.
    ///       Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?

    public init (
        applicationId: String? = nil,
        clientToken: String? = nil
    )
    {
        self.applicationId = applicationId
        self.clientToken = clientToken
    }
}

struct DeleteApplicationInputBody: Equatable {
}

extension DeleteApplicationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationOutputError: Swift.Error, Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationOutputResponse()"}
}

extension DeleteApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationOutputResponse: Equatable {

    public init() {}
}

struct DeleteApplicationOutputResponseBody: Equatable {
}

extension DeleteApplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApplicationInput(applicationId: \(String(describing: applicationId)))"}
}

extension DescribeApplicationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationInput>
    public typealias MOutput = OperationOutput<DescribeApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationOutputError>
}

public struct DescribeApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationInput>
    public typealias MOutput = OperationOutput<DescribeApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationOutputError>
}

public struct DescribeApplicationInput: Equatable {
    /// <p>The unique Id of the web application.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DescribeApplicationInputBody: Equatable {
}

extension DescribeApplicationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeApplicationOutputError: Swift.Error, Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApplicationOutputResponse(applicationArn: \(String(describing: applicationArn)), applicationCreationDate: \(String(describing: applicationCreationDate)), applicationDescription: \(String(describing: applicationDescription)), applicationId: \(String(describing: applicationId)), applicationLastUpdateDate: \(String(describing: applicationLastUpdateDate)), applicationName: \(String(describing: applicationName)), applicationState: \(String(describing: applicationState)), applicationUrl: \(String(describing: applicationUrl)), errorMessage: \(String(describing: errorMessage)), roleArn: \(String(describing: roleArn)), ssoClientId: \(String(describing: ssoClientId)), tags: \(String(describing: tags)))"}
}

extension DescribeApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationArn = output.applicationArn
            self.applicationCreationDate = output.applicationCreationDate
            self.applicationDescription = output.applicationDescription
            self.applicationId = output.applicationId
            self.applicationLastUpdateDate = output.applicationLastUpdateDate
            self.applicationName = output.applicationName
            self.applicationState = output.applicationState
            self.applicationUrl = output.applicationUrl
            self.errorMessage = output.errorMessage
            self.roleArn = output.roleArn
            self.ssoClientId = output.ssoClientId
            self.tags = output.tags
        } else {
            self.applicationArn = nil
            self.applicationCreationDate = 0
            self.applicationDescription = nil
            self.applicationId = nil
            self.applicationLastUpdateDate = 0
            self.applicationName = nil
            self.applicationState = nil
            self.applicationUrl = nil
            self.errorMessage = nil
            self.roleArn = nil
            self.ssoClientId = nil
            self.tags = nil
        }
    }
}

public struct DescribeApplicationOutputResponse: Equatable {
    /// <p>The ARN of the web application.</p>
    public let applicationArn: String?
    /// <p>The date (in Unix epoch time) when the application was created.</p>
    public let applicationCreationDate: Int
    /// <p>An optional description of the web application.</p>
    public let applicationDescription: String?
    /// <p>The unique Id of the web application.</p>
    public let applicationId: String?
    /// <p>The date (in Unix epoch time) when the application was last updated.</p>
    public let applicationLastUpdateDate: Int
    /// <p>The name of the web application.</p>
    public let applicationName: String?
    /// <p>The current state of the web application.</p>
    public let applicationState: ApplicationState?
    /// <p>The URL of the web application.</p>
    public let applicationUrl: String?
    /// <p>A message indicating why the <code>DescribeApplication</code> API failed.</p>
    public let errorMessage: String?
    /// <p>The ARN of the role that the web application assumes when it interacts with AWS IoT Core.</p>
    public let roleArn: String?
    /// <p>The Id of the single sign-on client that you use to authenticate and authorize users on the web application.</p>
    public let ssoClientId: String?
    /// <p>A set of key/value pairs that you can use to manage the web application resource.</p>
    public let tags: [String:String]?

    public init (
        applicationArn: String? = nil,
        applicationCreationDate: Int = 0,
        applicationDescription: String? = nil,
        applicationId: String? = nil,
        applicationLastUpdateDate: Int = 0,
        applicationName: String? = nil,
        applicationState: ApplicationState? = nil,
        applicationUrl: String? = nil,
        errorMessage: String? = nil,
        roleArn: String? = nil,
        ssoClientId: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.applicationArn = applicationArn
        self.applicationCreationDate = applicationCreationDate
        self.applicationDescription = applicationDescription
        self.applicationId = applicationId
        self.applicationLastUpdateDate = applicationLastUpdateDate
        self.applicationName = applicationName
        self.applicationState = applicationState
        self.applicationUrl = applicationUrl
        self.errorMessage = errorMessage
        self.roleArn = roleArn
        self.ssoClientId = ssoClientId
        self.tags = tags
    }
}

struct DescribeApplicationOutputResponseBody: Equatable {
    public let applicationId: String?
    public let applicationArn: String?
    public let applicationName: String?
    public let applicationDescription: String?
    public let applicationUrl: String?
    public let applicationState: ApplicationState?
    public let applicationCreationDate: Int
    public let applicationLastUpdateDate: Int
    public let roleArn: String?
    public let ssoClientId: String?
    public let errorMessage: String?
    public let tags: [String:String]?
}

extension DescribeApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationArn
        case applicationCreationDate
        case applicationDescription
        case applicationId
        case applicationLastUpdateDate
        case applicationName
        case applicationState
        case applicationUrl
        case errorMessage
        case roleArn
        case ssoClientId
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let applicationDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationDescription)
        applicationDescription = applicationDescriptionDecoded
        let applicationUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationUrl)
        applicationUrl = applicationUrlDecoded
        let applicationStateDecoded = try containerValues.decodeIfPresent(ApplicationState.self, forKey: .applicationState)
        applicationState = applicationStateDecoded
        let applicationCreationDateDecoded = try containerValues.decode(Int.self, forKey: .applicationCreationDate)
        applicationCreationDate = applicationCreationDateDecoded
        let applicationLastUpdateDateDecoded = try containerValues.decode(Int.self, forKey: .applicationLastUpdateDate)
        applicationLastUpdateDate = applicationLastUpdateDateDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let ssoClientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ssoClientId)
        ssoClientId = ssoClientIdDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension InternalFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalFailureException(message: \(String(describing: message)))"}
}

extension InternalFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An unexpected error has occurred.</p>
public struct InternalFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Equatable {
    public let message: String?
}

extension InternalFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request is not valid.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A limit has been exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationsInput(nextToken: \(String(describing: nextToken)))"}
}

extension ListApplicationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListApplicationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListApplicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListApplicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInput: Equatable {
    /// <p>A token used to get the next set of results.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Equatable {
}

extension ListApplicationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListApplicationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationsOutputError: Swift.Error, Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationsOutputResponse(applicationSummaries: \(String(describing: applicationSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApplicationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationSummaries = output.applicationSummaries
            self.nextToken = output.nextToken
        } else {
            self.applicationSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutputResponse: Equatable {
    /// <p>An array of objects that provide summaries of information about the web applications in the list.</p>
    public let applicationSummaries: [ApplicationSummary]?
    /// <p>A token used to get the next set of results.</p>
    public let nextToken: String?

    public init (
        applicationSummaries: [ApplicationSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.applicationSummaries = applicationSummaries
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputResponseBody: Equatable {
    public let applicationSummaries: [ApplicationSummary]?
    public let nextToken: String?
}

extension ListApplicationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationSummariesContainer = try containerValues.decodeIfPresent([ApplicationSummary?].self, forKey: .applicationSummaries)
        var applicationSummariesDecoded0:[ApplicationSummary]? = nil
        if let applicationSummariesContainer = applicationSummariesContainer {
            applicationSummariesDecoded0 = [ApplicationSummary]()
            for structure0 in applicationSummariesContainer {
                if let structure0 = structure0 {
                    applicationSummariesDecoded0?.append(structure0)
                }
            }
        }
        applicationSummaries = applicationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN of the resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The list of tags assigned to the resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ARN of the resource.</p>
    public let resourceArn: String?
    /// <p>The new or modified tags for the resource.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The rate exceeds the limit.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the resource.</p>
    public let resourceArn: String?
    /// <p>A list of the keys of the tags to be removed from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateApplicationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

extension UpdateApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationInput(applicationDescription: \(String(describing: applicationDescription)), applicationId: \(String(describing: applicationId)), applicationName: \(String(describing: applicationName)), clientToken: \(String(describing: clientToken)))"}
}

extension UpdateApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationDescription
        case applicationName
        case clientToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationDescription = applicationDescription {
            try encodeContainer.encode(applicationDescription, forKey: .applicationDescription)
        }
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct UpdateApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInput: Equatable {
    /// <p>An optional description of the web application.</p>
    public let applicationDescription: String?
    /// <p>The unique Id of the web application.</p>
    public let applicationId: String?
    /// <p>The name of the web application.</p>
    public let applicationName: String?
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request.
    ///       Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?

    public init (
        applicationDescription: String? = nil,
        applicationId: String? = nil,
        applicationName: String? = nil,
        clientToken: String? = nil
    )
    {
        self.applicationDescription = applicationDescription
        self.applicationId = applicationId
        self.applicationName = applicationName
        self.clientToken = clientToken
    }
}

struct UpdateApplicationInputBody: Equatable {
    public let applicationName: String?
    public let applicationDescription: String?
    public let clientToken: String?
}

extension UpdateApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationDescription
        case applicationName
        case clientToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let applicationDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationDescription)
        applicationDescription = applicationDescriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationOutputResponse()"}
}

extension UpdateApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateApplicationOutputResponse: Equatable {

    public init() {}
}

struct UpdateApplicationOutputResponseBody: Equatable {
}

extension UpdateApplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
