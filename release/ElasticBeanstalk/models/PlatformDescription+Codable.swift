// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension PlatformDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customAmiList = "CustomAmiList"
        case dateCreated = "DateCreated"
        case dateUpdated = "DateUpdated"
        case description = "Description"
        case frameworks = "Frameworks"
        case maintainer = "Maintainer"
        case operatingSystemName = "OperatingSystemName"
        case operatingSystemVersion = "OperatingSystemVersion"
        case platformArn = "PlatformArn"
        case platformBranchLifecycleState = "PlatformBranchLifecycleState"
        case platformBranchName = "PlatformBranchName"
        case platformCategory = "PlatformCategory"
        case platformLifecycleState = "PlatformLifecycleState"
        case platformName = "PlatformName"
        case platformOwner = "PlatformOwner"
        case platformStatus = "PlatformStatus"
        case platformVersion = "PlatformVersion"
        case programmingLanguages = "ProgrammingLanguages"
        case solutionStackName = "SolutionStackName"
        case supportedAddonList = "SupportedAddonList"
        case supportedTierList = "SupportedTierList"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let customAmiList = customAmiList {
            var customAmiListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("CustomAmiList"))
            for (index0, customami0) in customAmiList.enumerated() {
                try customAmiListContainer.encode(customami0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dateCreated = dateCreated {
            try container.encode(TimestampWrapper(dateCreated, format: .dateTime), forKey: Key("dateCreated"))
        }
        if let dateUpdated = dateUpdated {
            try container.encode(TimestampWrapper(dateUpdated, format: .dateTime), forKey: Key("dateUpdated"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let frameworks = frameworks {
            var frameworksContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Frameworks"))
            for (index0, platformframework0) in frameworks.enumerated() {
                try frameworksContainer.encode(platformframework0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let maintainer = maintainer {
            try container.encode(maintainer, forKey: Key("Maintainer"))
        }
        if let operatingSystemName = operatingSystemName {
            try container.encode(operatingSystemName, forKey: Key("OperatingSystemName"))
        }
        if let operatingSystemVersion = operatingSystemVersion {
            try container.encode(operatingSystemVersion, forKey: Key("OperatingSystemVersion"))
        }
        if let platformArn = platformArn {
            try container.encode(platformArn, forKey: Key("PlatformArn"))
        }
        if let platformBranchLifecycleState = platformBranchLifecycleState {
            try container.encode(platformBranchLifecycleState, forKey: Key("PlatformBranchLifecycleState"))
        }
        if let platformBranchName = platformBranchName {
            try container.encode(platformBranchName, forKey: Key("PlatformBranchName"))
        }
        if let platformCategory = platformCategory {
            try container.encode(platformCategory, forKey: Key("PlatformCategory"))
        }
        if let platformLifecycleState = platformLifecycleState {
            try container.encode(platformLifecycleState, forKey: Key("PlatformLifecycleState"))
        }
        if let platformName = platformName {
            try container.encode(platformName, forKey: Key("PlatformName"))
        }
        if let platformOwner = platformOwner {
            try container.encode(platformOwner, forKey: Key("PlatformOwner"))
        }
        if let platformStatus = platformStatus {
            try container.encode(platformStatus, forKey: Key("PlatformStatus"))
        }
        if let platformVersion = platformVersion {
            try container.encode(platformVersion, forKey: Key("PlatformVersion"))
        }
        if let programmingLanguages = programmingLanguages {
            var programmingLanguagesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ProgrammingLanguages"))
            for (index0, platformprogramminglanguage0) in programmingLanguages.enumerated() {
                try programmingLanguagesContainer.encode(platformprogramminglanguage0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let solutionStackName = solutionStackName {
            try container.encode(solutionStackName, forKey: Key("SolutionStackName"))
        }
        if let supportedAddonList = supportedAddonList {
            var supportedAddonListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedAddonList"))
            for (index0, supportedaddon0) in supportedAddonList.enumerated() {
                try supportedAddonListContainer.encode(supportedaddon0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedTierList = supportedTierList {
            var supportedTierListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedTierList"))
            for (index0, supportedtier0) in supportedTierList.enumerated() {
                try supportedTierListContainer.encode(supportedtier0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformArn)
        platformArn = platformArnDecoded
        let platformOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformOwner)
        platformOwner = platformOwnerDecoded
        let platformNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformName)
        platformName = platformNameDecoded
        let platformVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformVersion)
        platformVersion = platformVersionDecoded
        let solutionStackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionStackName)
        solutionStackName = solutionStackNameDecoded
        let platformStatusDecoded = try containerValues.decodeIfPresent(PlatformStatus.self, forKey: .platformStatus)
        platformStatus = platformStatusDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        var dateCreatedBuffer:Date? = nil
        if let dateCreatedDecoded = dateCreatedDecoded {
            dateCreatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateCreatedDecoded, format: .dateTime)
        }
        dateCreated = dateCreatedBuffer
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateUpdated)
        var dateUpdatedBuffer:Date? = nil
        if let dateUpdatedDecoded = dateUpdatedDecoded {
            dateUpdatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateUpdatedDecoded, format: .dateTime)
        }
        dateUpdated = dateUpdatedBuffer
        let platformCategoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformCategory)
        platformCategory = platformCategoryDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let maintainerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maintainer)
        maintainer = maintainerDecoded
        let operatingSystemNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operatingSystemName)
        operatingSystemName = operatingSystemNameDecoded
        let operatingSystemVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operatingSystemVersion)
        operatingSystemVersion = operatingSystemVersionDecoded
        if containerValues.contains(.programmingLanguages) {
            struct KeyVal0{struct member{}}
            let programmingLanguagesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .programmingLanguages)
            if let programmingLanguagesWrappedContainer = programmingLanguagesWrappedContainer {
                let programmingLanguagesContainer = try programmingLanguagesWrappedContainer.decodeIfPresent([PlatformProgrammingLanguage].self, forKey: .member)
                var programmingLanguagesBuffer:[PlatformProgrammingLanguage]? = nil
                if let programmingLanguagesContainer = programmingLanguagesContainer {
                    programmingLanguagesBuffer = [PlatformProgrammingLanguage]()
                    for structureContainer0 in programmingLanguagesContainer {
                        programmingLanguagesBuffer?.append(structureContainer0)
                    }
                }
                programmingLanguages = programmingLanguagesBuffer
            } else {
                programmingLanguages = []
            }
        } else {
            programmingLanguages = nil
        }
        if containerValues.contains(.frameworks) {
            struct KeyVal0{struct member{}}
            let frameworksWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .frameworks)
            if let frameworksWrappedContainer = frameworksWrappedContainer {
                let frameworksContainer = try frameworksWrappedContainer.decodeIfPresent([PlatformFramework].self, forKey: .member)
                var frameworksBuffer:[PlatformFramework]? = nil
                if let frameworksContainer = frameworksContainer {
                    frameworksBuffer = [PlatformFramework]()
                    for structureContainer0 in frameworksContainer {
                        frameworksBuffer?.append(structureContainer0)
                    }
                }
                frameworks = frameworksBuffer
            } else {
                frameworks = []
            }
        } else {
            frameworks = nil
        }
        if containerValues.contains(.customAmiList) {
            struct KeyVal0{struct member{}}
            let customAmiListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .customAmiList)
            if let customAmiListWrappedContainer = customAmiListWrappedContainer {
                let customAmiListContainer = try customAmiListWrappedContainer.decodeIfPresent([CustomAmi].self, forKey: .member)
                var customAmiListBuffer:[CustomAmi]? = nil
                if let customAmiListContainer = customAmiListContainer {
                    customAmiListBuffer = [CustomAmi]()
                    for structureContainer0 in customAmiListContainer {
                        customAmiListBuffer?.append(structureContainer0)
                    }
                }
                customAmiList = customAmiListBuffer
            } else {
                customAmiList = []
            }
        } else {
            customAmiList = nil
        }
        if containerValues.contains(.supportedTierList) {
            struct KeyVal0{struct member{}}
            let supportedTierListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedTierList)
            if let supportedTierListWrappedContainer = supportedTierListWrappedContainer {
                let supportedTierListContainer = try supportedTierListWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var supportedTierListBuffer:[String]? = nil
                if let supportedTierListContainer = supportedTierListContainer {
                    supportedTierListBuffer = [String]()
                    for stringContainer0 in supportedTierListContainer {
                        supportedTierListBuffer?.append(stringContainer0)
                    }
                }
                supportedTierList = supportedTierListBuffer
            } else {
                supportedTierList = []
            }
        } else {
            supportedTierList = nil
        }
        if containerValues.contains(.supportedAddonList) {
            struct KeyVal0{struct member{}}
            let supportedAddonListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedAddonList)
            if let supportedAddonListWrappedContainer = supportedAddonListWrappedContainer {
                let supportedAddonListContainer = try supportedAddonListWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var supportedAddonListBuffer:[String]? = nil
                if let supportedAddonListContainer = supportedAddonListContainer {
                    supportedAddonListBuffer = [String]()
                    for stringContainer0 in supportedAddonListContainer {
                        supportedAddonListBuffer?.append(stringContainer0)
                    }
                }
                supportedAddonList = supportedAddonListBuffer
            } else {
                supportedAddonList = []
            }
        } else {
            supportedAddonList = nil
        }
        let platformLifecycleStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformLifecycleState)
        platformLifecycleState = platformLifecycleStateDecoded
        let platformBranchNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformBranchName)
        platformBranchName = platformBranchNameDecoded
        let platformBranchLifecycleStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformBranchLifecycleState)
        platformBranchLifecycleState = platformBranchLifecycleStateDecoded
    }
}
