// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AbortEnvironmentUpdateInputBodyMiddleware: Middleware {
    public let id: String = "AbortEnvironmentUpdateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AbortEnvironmentUpdateInput>,
                  next: H) -> Swift.Result<OperationOutput<AbortEnvironmentUpdateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AbortEnvironmentUpdateInput>
    public typealias MOutput = OperationOutput<AbortEnvironmentUpdateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AbortEnvironmentUpdateOutputError>
}

extension AbortEnvironmentUpdateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AbortEnvironmentUpdateInput(environmentId: \(String(describing: environmentId)), environmentName: \(String(describing: environmentName)))"}
}

extension AbortEnvironmentUpdateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let environmentId = environmentId {
            try container.encode(environmentId, forKey: Key("EnvironmentId"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        try container.encode("AbortEnvironmentUpdate", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct AbortEnvironmentUpdateInputHeadersMiddleware: Middleware {
    public let id: String = "AbortEnvironmentUpdateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AbortEnvironmentUpdateInput>,
                  next: H) -> Swift.Result<OperationOutput<AbortEnvironmentUpdateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AbortEnvironmentUpdateInput>
    public typealias MOutput = OperationOutput<AbortEnvironmentUpdateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AbortEnvironmentUpdateOutputError>
}

public struct AbortEnvironmentUpdateInputQueryItemMiddleware: Middleware {
    public let id: String = "AbortEnvironmentUpdateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AbortEnvironmentUpdateInput>,
                  next: H) -> Swift.Result<OperationOutput<AbortEnvironmentUpdateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AbortEnvironmentUpdateInput>
    public typealias MOutput = OperationOutput<AbortEnvironmentUpdateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AbortEnvironmentUpdateOutputError>
}

/// <p></p>
public struct AbortEnvironmentUpdateInput: Equatable {
    /// <p>This specifies the ID of the environment with the in-progress update that you want to
    ///       cancel.</p>
    public let environmentId: String?
    /// <p>This specifies the name of the environment with the in-progress update that you want to
    ///       cancel.</p>
    public let environmentName: String?

    public init (
        environmentId: String? = nil,
        environmentName: String? = nil
    )
    {
        self.environmentId = environmentId
        self.environmentName = environmentName
    }
}

extension AbortEnvironmentUpdateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AbortEnvironmentUpdateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AbortEnvironmentUpdateOutputError: Equatable {
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AbortEnvironmentUpdateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AbortEnvironmentUpdateOutputResponse()"}
}

extension AbortEnvironmentUpdateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AbortEnvironmentUpdateOutputResponse: Equatable {

    public init() {}
}

struct AbortEnvironmentUpdateOutputResponseBody: Equatable {
}

extension AbortEnvironmentUpdateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum ActionHistoryStatus {
    case completed
    case failed
    case unknown
    case sdkUnknown(String)
}

extension ActionHistoryStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActionHistoryStatus] {
        return [
            .completed,
            .failed,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "Completed"
        case .failed: return "Failed"
        case .unknown: return "Unknown"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActionHistoryStatus(rawValue: rawValue) ?? ActionHistoryStatus.sdkUnknown(rawValue)
    }
}

public enum ActionStatus {
    case pending
    case running
    case scheduled
    case unknown
    case sdkUnknown(String)
}

extension ActionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActionStatus] {
        return [
            .pending,
            .running,
            .scheduled,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .pending: return "Pending"
        case .running: return "Running"
        case .scheduled: return "Scheduled"
        case .unknown: return "Unknown"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActionStatus(rawValue: rawValue) ?? ActionStatus.sdkUnknown(rawValue)
    }
}

public enum ActionType {
    case instancerefresh
    case platformupdate
    case unknown
    case sdkUnknown(String)
}

extension ActionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActionType] {
        return [
            .instancerefresh,
            .platformupdate,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .instancerefresh: return "InstanceRefresh"
        case .platformupdate: return "PlatformUpdate"
        case .unknown: return "Unknown"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActionType(rawValue: rawValue) ?? ActionType.sdkUnknown(rawValue)
    }
}

extension ApplicationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationArn = "ApplicationArn"
        case applicationName = "ApplicationName"
        case configurationTemplates = "ConfigurationTemplates"
        case dateCreated = "DateCreated"
        case dateUpdated = "DateUpdated"
        case description = "Description"
        case resourceLifecycleConfig = "ResourceLifecycleConfig"
        case versions = "Versions"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationArn = applicationArn {
            try container.encode(applicationArn, forKey: Key("ApplicationArn"))
        }
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let configurationTemplates = configurationTemplates {
            var configurationTemplatesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ConfigurationTemplates"))
            for (index0, configurationtemplatename0) in configurationTemplates.enumerated() {
                try configurationTemplatesContainer.encode(configurationtemplatename0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dateCreated = dateCreated {
            try container.encode(TimestampWrapper(dateCreated, format: .dateTime), forKey: Key("dateCreated"))
        }
        if let dateUpdated = dateUpdated {
            try container.encode(TimestampWrapper(dateUpdated, format: .dateTime), forKey: Key("dateUpdated"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let resourceLifecycleConfig = resourceLifecycleConfig {
            try container.encode(resourceLifecycleConfig, forKey: Key("ResourceLifecycleConfig"))
        }
        if let versions = versions {
            var versionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Versions"))
            for (index0, versionlabel0) in versions.enumerated() {
                try versionsContainer.encode(versionlabel0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        var dateCreatedBuffer:Date? = nil
        if let dateCreatedDecoded = dateCreatedDecoded {
            dateCreatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateCreatedDecoded, format: .dateTime)
        }
        dateCreated = dateCreatedBuffer
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateUpdated)
        var dateUpdatedBuffer:Date? = nil
        if let dateUpdatedDecoded = dateUpdatedDecoded {
            dateUpdatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateUpdatedDecoded, format: .dateTime)
        }
        dateUpdated = dateUpdatedBuffer
        if containerValues.contains(.versions) {
            struct KeyVal0{struct member{}}
            let versionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .versions)
            if let versionsWrappedContainer = versionsWrappedContainer {
                let versionsContainer = try versionsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var versionsBuffer:[String]? = nil
                if let versionsContainer = versionsContainer {
                    versionsBuffer = [String]()
                    for stringContainer0 in versionsContainer {
                        versionsBuffer?.append(stringContainer0)
                    }
                }
                versions = versionsBuffer
            } else {
                versions = []
            }
        } else {
            versions = nil
        }
        if containerValues.contains(.configurationTemplates) {
            struct KeyVal0{struct member{}}
            let configurationTemplatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .configurationTemplates)
            if let configurationTemplatesWrappedContainer = configurationTemplatesWrappedContainer {
                let configurationTemplatesContainer = try configurationTemplatesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var configurationTemplatesBuffer:[String]? = nil
                if let configurationTemplatesContainer = configurationTemplatesContainer {
                    configurationTemplatesBuffer = [String]()
                    for stringContainer0 in configurationTemplatesContainer {
                        configurationTemplatesBuffer?.append(stringContainer0)
                    }
                }
                configurationTemplates = configurationTemplatesBuffer
            } else {
                configurationTemplates = []
            }
        } else {
            configurationTemplates = nil
        }
        let resourceLifecycleConfigDecoded = try containerValues.decodeIfPresent(ApplicationResourceLifecycleConfig.self, forKey: .resourceLifecycleConfig)
        resourceLifecycleConfig = resourceLifecycleConfigDecoded
    }
}

extension ApplicationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationDescription(applicationArn: \(String(describing: applicationArn)), applicationName: \(String(describing: applicationName)), configurationTemplates: \(String(describing: configurationTemplates)), dateCreated: \(String(describing: dateCreated)), dateUpdated: \(String(describing: dateUpdated)), description: \(String(describing: description)), resourceLifecycleConfig: \(String(describing: resourceLifecycleConfig)), versions: \(String(describing: versions)))"}
}

/// <p>Describes the properties of an application.</p>
public struct ApplicationDescription: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    public let applicationArn: String?
    /// <p>The name of the application.</p>
    public let applicationName: String?
    /// <p>The names of the configuration templates associated with this application.</p>
    public let configurationTemplates: [String]?
    /// <p>The date when the application was created.</p>
    public let dateCreated: Date?
    /// <p>The date when the application was last modified.</p>
    public let dateUpdated: Date?
    /// <p>User-defined description of the application.</p>
    public let description: String?
    /// <p>The lifecycle settings for the application.</p>
    public let resourceLifecycleConfig: ApplicationResourceLifecycleConfig?
    /// <p>The names of the versions for this application.</p>
    public let versions: [String]?

    public init (
        applicationArn: String? = nil,
        applicationName: String? = nil,
        configurationTemplates: [String]? = nil,
        dateCreated: Date? = nil,
        dateUpdated: Date? = nil,
        description: String? = nil,
        resourceLifecycleConfig: ApplicationResourceLifecycleConfig? = nil,
        versions: [String]? = nil
    )
    {
        self.applicationArn = applicationArn
        self.applicationName = applicationName
        self.configurationTemplates = configurationTemplates
        self.dateCreated = dateCreated
        self.dateUpdated = dateUpdated
        self.description = description
        self.resourceLifecycleConfig = resourceLifecycleConfig
        self.versions = versions
    }
}

extension ApplicationMetrics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case duration = "Duration"
        case latency = "Latency"
        case requestCount = "RequestCount"
        case statusCodes = "StatusCodes"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let duration = duration {
            try container.encode(duration, forKey: Key("Duration"))
        }
        if let latency = latency {
            try container.encode(latency, forKey: Key("Latency"))
        }
        if requestCount != 0 {
            try container.encode(requestCount, forKey: Key("RequestCount"))
        }
        if let statusCodes = statusCodes {
            try container.encode(statusCodes, forKey: Key("StatusCodes"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let durationDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .duration)
        duration = durationDecoded
        let requestCountDecoded = try containerValues.decode(Int.self, forKey: .requestCount)
        requestCount = requestCountDecoded
        let statusCodesDecoded = try containerValues.decodeIfPresent(StatusCodes.self, forKey: .statusCodes)
        statusCodes = statusCodesDecoded
        let latencyDecoded = try containerValues.decodeIfPresent(Latency.self, forKey: .latency)
        latency = latencyDecoded
    }
}

extension ApplicationMetrics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationMetrics(duration: \(String(describing: duration)), latency: \(String(describing: latency)), requestCount: \(String(describing: requestCount)), statusCodes: \(String(describing: statusCodes)))"}
}

/// <p>Application request metrics for an AWS Elastic Beanstalk environment.</p>
public struct ApplicationMetrics: Equatable {
    /// <p>The amount of time that the metrics cover (usually 10 seconds). For example, you might
    ///       have 5 requests (<code>request_count</code>) within the most recent time slice of 10 seconds
    ///         (<code>duration</code>).</p>
    public let duration: Int?
    /// <p>Represents the average latency for the slowest X percent of requests over the last 10
    ///       seconds. Latencies are in seconds with one millisecond resolution.</p>
    public let latency: Latency?
    /// <p>Average number of requests handled by the web server per second over the last 10
    ///       seconds.</p>
    public let requestCount: Int
    /// <p>Represents the percentage of requests over the last 10 seconds that resulted in each
    ///       type of status code response.</p>
    public let statusCodes: StatusCodes?

    public init (
        duration: Int? = nil,
        latency: Latency? = nil,
        requestCount: Int = 0,
        statusCodes: StatusCodes? = nil
    )
    {
        self.duration = duration
        self.latency = latency
        self.requestCount = requestCount
        self.statusCodes = statusCodes
    }
}

extension ApplicationResourceLifecycleConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serviceRole = "ServiceRole"
        case versionLifecycleConfig = "VersionLifecycleConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let serviceRole = serviceRole {
            try container.encode(serviceRole, forKey: Key("ServiceRole"))
        }
        if let versionLifecycleConfig = versionLifecycleConfig {
            try container.encode(versionLifecycleConfig, forKey: Key("VersionLifecycleConfig"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let versionLifecycleConfigDecoded = try containerValues.decodeIfPresent(ApplicationVersionLifecycleConfig.self, forKey: .versionLifecycleConfig)
        versionLifecycleConfig = versionLifecycleConfigDecoded
    }
}

extension ApplicationResourceLifecycleConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationResourceLifecycleConfig(serviceRole: \(String(describing: serviceRole)), versionLifecycleConfig: \(String(describing: versionLifecycleConfig)))"}
}

/// <p>The resource lifecycle configuration for an application. Defines lifecycle settings for
///       resources that belong to the application, and the service role that AWS Elastic Beanstalk assumes
///       in order to apply lifecycle settings. The version lifecycle configuration defines lifecycle
///       settings for application versions.</p>
public struct ApplicationResourceLifecycleConfig: Equatable {
    /// <p>The ARN of an IAM service role that Elastic Beanstalk has permission to
    ///       assume.</p>
    ///          <p>The <code>ServiceRole</code> property is required the first time that you provide a
    ///         <code>VersionLifecycleConfig</code> for the application in one of the supporting calls
    ///         (<code>CreateApplication</code> or <code>UpdateApplicationResourceLifecycle</code>). After
    ///       you provide it once, in either one of the calls, Elastic Beanstalk persists the Service Role with the
    ///       application, and you don't need to specify it again in subsequent
    ///         <code>UpdateApplicationResourceLifecycle</code> calls. You can, however, specify it in
    ///       subsequent calls to change the Service Role to another value.</p>
    public let serviceRole: String?
    /// <p>Defines lifecycle settings for application versions.</p>
    public let versionLifecycleConfig: ApplicationVersionLifecycleConfig?

    public init (
        serviceRole: String? = nil,
        versionLifecycleConfig: ApplicationVersionLifecycleConfig? = nil
    )
    {
        self.serviceRole = serviceRole
        self.versionLifecycleConfig = versionLifecycleConfig
    }
}

extension ApplicationVersionDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case applicationVersionArn = "ApplicationVersionArn"
        case buildArn = "BuildArn"
        case dateCreated = "DateCreated"
        case dateUpdated = "DateUpdated"
        case description = "Description"
        case sourceBuildInformation = "SourceBuildInformation"
        case sourceBundle = "SourceBundle"
        case status = "Status"
        case versionLabel = "VersionLabel"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let applicationVersionArn = applicationVersionArn {
            try container.encode(applicationVersionArn, forKey: Key("ApplicationVersionArn"))
        }
        if let buildArn = buildArn {
            try container.encode(buildArn, forKey: Key("BuildArn"))
        }
        if let dateCreated = dateCreated {
            try container.encode(TimestampWrapper(dateCreated, format: .dateTime), forKey: Key("dateCreated"))
        }
        if let dateUpdated = dateUpdated {
            try container.encode(TimestampWrapper(dateUpdated, format: .dateTime), forKey: Key("dateUpdated"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let sourceBuildInformation = sourceBuildInformation {
            try container.encode(sourceBuildInformation, forKey: Key("SourceBuildInformation"))
        }
        if let sourceBundle = sourceBundle {
            try container.encode(sourceBundle, forKey: Key("SourceBundle"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let versionLabel = versionLabel {
            try container.encode(versionLabel, forKey: Key("VersionLabel"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationVersionArn)
        applicationVersionArn = applicationVersionArnDecoded
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let versionLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionLabel)
        versionLabel = versionLabelDecoded
        let sourceBuildInformationDecoded = try containerValues.decodeIfPresent(SourceBuildInformation.self, forKey: .sourceBuildInformation)
        sourceBuildInformation = sourceBuildInformationDecoded
        let buildArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .buildArn)
        buildArn = buildArnDecoded
        let sourceBundleDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .sourceBundle)
        sourceBundle = sourceBundleDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        var dateCreatedBuffer:Date? = nil
        if let dateCreatedDecoded = dateCreatedDecoded {
            dateCreatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateCreatedDecoded, format: .dateTime)
        }
        dateCreated = dateCreatedBuffer
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateUpdated)
        var dateUpdatedBuffer:Date? = nil
        if let dateUpdatedDecoded = dateUpdatedDecoded {
            dateUpdatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateUpdatedDecoded, format: .dateTime)
        }
        dateUpdated = dateUpdatedBuffer
        let statusDecoded = try containerValues.decodeIfPresent(ApplicationVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ApplicationVersionDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationVersionDescription(applicationName: \(String(describing: applicationName)), applicationVersionArn: \(String(describing: applicationVersionArn)), buildArn: \(String(describing: buildArn)), dateCreated: \(String(describing: dateCreated)), dateUpdated: \(String(describing: dateUpdated)), description: \(String(describing: description)), sourceBuildInformation: \(String(describing: sourceBuildInformation)), sourceBundle: \(String(describing: sourceBundle)), status: \(String(describing: status)), versionLabel: \(String(describing: versionLabel)))"}
}

/// <p>Describes the properties of an application version.</p>
public struct ApplicationVersionDescription: Equatable {
    /// <p>The name of the application to which the application version belongs.</p>
    public let applicationName: String?
    /// <p>The Amazon Resource Name (ARN) of the application version.</p>
    public let applicationVersionArn: String?
    /// <p>Reference to the artifact from the AWS CodeBuild build.</p>
    public let buildArn: String?
    /// <p>The creation date of the application version.</p>
    public let dateCreated: Date?
    /// <p>The last modified date of the application version.</p>
    public let dateUpdated: Date?
    /// <p>The description of the application version.</p>
    public let description: String?
    /// <p>If the version's source code was retrieved from AWS CodeCommit, the location of the
    ///       source code for the application version.</p>
    public let sourceBuildInformation: SourceBuildInformation?
    /// <p>The storage location of the application version's source bundle in Amazon S3.</p>
    public let sourceBundle: S3Location?
    /// <p>The processing status of the application version. Reflects the state of the application
    ///       version during its creation. Many of the values are only applicable if you specified
    ///         <code>True</code> for the <code>Process</code> parameter of the
    ///         <code>CreateApplicationVersion</code> action. The following list describes the possible
    ///       values.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Unprocessed</code> – Application version wasn't pre-processed or validated.
    ///           Elastic Beanstalk will validate configuration files during deployment of the application version to an
    ///         environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Processing</code> – Elastic Beanstalk is currently processing the application version.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Building</code> – Application version is currently undergoing an AWS CodeBuild build.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Processed</code> – Elastic Beanstalk was successfully pre-processed and validated.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Failed</code> – Either the AWS CodeBuild build failed or configuration files didn't
    ///           pass validation. This application version isn't usable.</p>
    ///             </li>
    ///          </ul>
    public let status: ApplicationVersionStatus?
    /// <p>A unique identifier for the application version.</p>
    public let versionLabel: String?

    public init (
        applicationName: String? = nil,
        applicationVersionArn: String? = nil,
        buildArn: String? = nil,
        dateCreated: Date? = nil,
        dateUpdated: Date? = nil,
        description: String? = nil,
        sourceBuildInformation: SourceBuildInformation? = nil,
        sourceBundle: S3Location? = nil,
        status: ApplicationVersionStatus? = nil,
        versionLabel: String? = nil
    )
    {
        self.applicationName = applicationName
        self.applicationVersionArn = applicationVersionArn
        self.buildArn = buildArn
        self.dateCreated = dateCreated
        self.dateUpdated = dateUpdated
        self.description = description
        self.sourceBuildInformation = sourceBuildInformation
        self.sourceBundle = sourceBundle
        self.status = status
        self.versionLabel = versionLabel
    }
}

extension ApplicationVersionLifecycleConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxAgeRule = "MaxAgeRule"
        case maxCountRule = "MaxCountRule"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let maxAgeRule = maxAgeRule {
            try container.encode(maxAgeRule, forKey: Key("MaxAgeRule"))
        }
        if let maxCountRule = maxCountRule {
            try container.encode(maxCountRule, forKey: Key("MaxCountRule"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxCountRuleDecoded = try containerValues.decodeIfPresent(MaxCountRule.self, forKey: .maxCountRule)
        maxCountRule = maxCountRuleDecoded
        let maxAgeRuleDecoded = try containerValues.decodeIfPresent(MaxAgeRule.self, forKey: .maxAgeRule)
        maxAgeRule = maxAgeRuleDecoded
    }
}

extension ApplicationVersionLifecycleConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationVersionLifecycleConfig(maxAgeRule: \(String(describing: maxAgeRule)), maxCountRule: \(String(describing: maxCountRule)))"}
}

/// <p>The application version lifecycle settings for an application. Defines the rules that
///       Elastic Beanstalk applies to an application's versions in order to avoid hitting the
///       per-region limit for application versions.</p>
///          <p>When Elastic Beanstalk deletes an application version from its database, you can no
///       longer deploy that version to an environment. The source bundle remains in S3 unless you
///       configure the rule to delete it.</p>
public struct ApplicationVersionLifecycleConfig: Equatable {
    /// <p>Specify a max age rule to restrict the length of time that application versions are
    ///       retained for an application.</p>
    public let maxAgeRule: MaxAgeRule?
    /// <p>Specify a max count rule to restrict the number of application versions that are
    ///       retained for an application.</p>
    public let maxCountRule: MaxCountRule?

    public init (
        maxAgeRule: MaxAgeRule? = nil,
        maxCountRule: MaxCountRule? = nil
    )
    {
        self.maxAgeRule = maxAgeRule
        self.maxCountRule = maxCountRule
    }
}

public enum ApplicationVersionStatus {
    case building
    case failed
    case processed
    case processing
    case unprocessed
    case sdkUnknown(String)
}

extension ApplicationVersionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ApplicationVersionStatus] {
        return [
            .building,
            .failed,
            .processed,
            .processing,
            .unprocessed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .building: return "Building"
        case .failed: return "Failed"
        case .processed: return "Processed"
        case .processing: return "Processing"
        case .unprocessed: return "Unprocessed"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ApplicationVersionStatus(rawValue: rawValue) ?? ApplicationVersionStatus.sdkUnknown(rawValue)
    }
}

public struct ApplyEnvironmentManagedActionInputBodyMiddleware: Middleware {
    public let id: String = "ApplyEnvironmentManagedActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplyEnvironmentManagedActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplyEnvironmentManagedActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplyEnvironmentManagedActionInput>
    public typealias MOutput = OperationOutput<ApplyEnvironmentManagedActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplyEnvironmentManagedActionOutputError>
}

extension ApplyEnvironmentManagedActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplyEnvironmentManagedActionInput(actionId: \(String(describing: actionId)), environmentId: \(String(describing: environmentId)), environmentName: \(String(describing: environmentName)))"}
}

extension ApplyEnvironmentManagedActionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let actionId = actionId {
            try container.encode(actionId, forKey: Key("ActionId"))
        }
        if let environmentId = environmentId {
            try container.encode(environmentId, forKey: Key("EnvironmentId"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        try container.encode("ApplyEnvironmentManagedAction", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct ApplyEnvironmentManagedActionInputHeadersMiddleware: Middleware {
    public let id: String = "ApplyEnvironmentManagedActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplyEnvironmentManagedActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplyEnvironmentManagedActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplyEnvironmentManagedActionInput>
    public typealias MOutput = OperationOutput<ApplyEnvironmentManagedActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplyEnvironmentManagedActionOutputError>
}

public struct ApplyEnvironmentManagedActionInputQueryItemMiddleware: Middleware {
    public let id: String = "ApplyEnvironmentManagedActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplyEnvironmentManagedActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplyEnvironmentManagedActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplyEnvironmentManagedActionInput>
    public typealias MOutput = OperationOutput<ApplyEnvironmentManagedActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplyEnvironmentManagedActionOutputError>
}

/// <p>Request to execute a scheduled managed action immediately.</p>
public struct ApplyEnvironmentManagedActionInput: Equatable {
    /// <p>The action ID of the scheduled managed action to execute.</p>
    public let actionId: String?
    /// <p>The environment ID of the target environment.</p>
    public let environmentId: String?
    /// <p>The name of the target environment.</p>
    public let environmentName: String?

    public init (
        actionId: String? = nil,
        environmentId: String? = nil,
        environmentName: String? = nil
    )
    {
        self.actionId = actionId
        self.environmentId = environmentId
        self.environmentName = environmentName
    }
}

extension ApplyEnvironmentManagedActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ApplyEnvironmentManagedActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ElasticBeanstalkServiceException" : self = .elasticBeanstalkServiceException(try ElasticBeanstalkServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedActionInvalidStateException" : self = .managedActionInvalidStateException(try ManagedActionInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ApplyEnvironmentManagedActionOutputError: Equatable {
    case elasticBeanstalkServiceException(ElasticBeanstalkServiceException)
    case managedActionInvalidStateException(ManagedActionInvalidStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ApplyEnvironmentManagedActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplyEnvironmentManagedActionOutputResponse(actionDescription: \(String(describing: actionDescription)), actionId: \(String(describing: actionId)), actionType: \(String(describing: actionType)), status: \(String(describing: status)))"}
}

extension ApplyEnvironmentManagedActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ApplyEnvironmentManagedActionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.actionDescription = output.actionDescription
            self.actionId = output.actionId
            self.actionType = output.actionType
            self.status = output.status
        } else {
            self.actionDescription = nil
            self.actionId = nil
            self.actionType = nil
            self.status = nil
        }
    }
}

/// <p>The result message containing information about the managed action.</p>
public struct ApplyEnvironmentManagedActionOutputResponse: Equatable {
    /// <p>A description of the managed action.</p>
    public let actionDescription: String?
    /// <p>The action ID of the managed action.</p>
    public let actionId: String?
    /// <p>The type of managed action.</p>
    public let actionType: ActionType?
    /// <p>The status of the managed action.</p>
    public let status: String?

    public init (
        actionDescription: String? = nil,
        actionId: String? = nil,
        actionType: ActionType? = nil,
        status: String? = nil
    )
    {
        self.actionDescription = actionDescription
        self.actionId = actionId
        self.actionType = actionType
        self.status = status
    }
}

struct ApplyEnvironmentManagedActionOutputResponseBody: Equatable {
    public let actionId: String?
    public let actionDescription: String?
    public let actionType: ActionType?
    public let status: String?
}

extension ApplyEnvironmentManagedActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionDescription = "ActionDescription"
        case actionId = "ActionId"
        case actionType = "ActionType"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ApplyEnvironmentManagedActionResult"))
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let actionDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionDescription)
        actionDescription = actionDescriptionDecoded
        let actionTypeDecoded = try containerValues.decodeIfPresent(ActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct AssociateEnvironmentOperationsRoleInputBodyMiddleware: Middleware {
    public let id: String = "AssociateEnvironmentOperationsRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateEnvironmentOperationsRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateEnvironmentOperationsRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateEnvironmentOperationsRoleInput>
    public typealias MOutput = OperationOutput<AssociateEnvironmentOperationsRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateEnvironmentOperationsRoleOutputError>
}

extension AssociateEnvironmentOperationsRoleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateEnvironmentOperationsRoleInput(environmentName: \(String(describing: environmentName)), operationsRole: \(String(describing: operationsRole)))"}
}

extension AssociateEnvironmentOperationsRoleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        if let operationsRole = operationsRole {
            try container.encode(operationsRole, forKey: Key("OperationsRole"))
        }
        try container.encode("AssociateEnvironmentOperationsRole", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct AssociateEnvironmentOperationsRoleInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateEnvironmentOperationsRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateEnvironmentOperationsRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateEnvironmentOperationsRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateEnvironmentOperationsRoleInput>
    public typealias MOutput = OperationOutput<AssociateEnvironmentOperationsRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateEnvironmentOperationsRoleOutputError>
}

public struct AssociateEnvironmentOperationsRoleInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateEnvironmentOperationsRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateEnvironmentOperationsRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateEnvironmentOperationsRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateEnvironmentOperationsRoleInput>
    public typealias MOutput = OperationOutput<AssociateEnvironmentOperationsRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateEnvironmentOperationsRoleOutputError>
}

/// <p>Request to add or change the operations role used by an environment.</p>
public struct AssociateEnvironmentOperationsRoleInput: Equatable {
    /// <p>The name of the environment to which to set the operations role.</p>
    public let environmentName: String?
    /// <p>The Amazon Resource Name (ARN) of an existing IAM role to be used as the environment's
    ///       operations role.</p>
    public let operationsRole: String?

    public init (
        environmentName: String? = nil,
        operationsRole: String? = nil
    )
    {
        self.environmentName = environmentName
        self.operationsRole = operationsRole
    }
}

extension AssociateEnvironmentOperationsRoleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AssociateEnvironmentOperationsRoleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateEnvironmentOperationsRoleOutputError: Equatable {
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateEnvironmentOperationsRoleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateEnvironmentOperationsRoleOutputResponse()"}
}

extension AssociateEnvironmentOperationsRoleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateEnvironmentOperationsRoleOutputResponse: Equatable {

    public init() {}
}

struct AssociateEnvironmentOperationsRoleOutputResponseBody: Equatable {
}

extension AssociateEnvironmentOperationsRoleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AutoScalingGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AutoScalingGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutoScalingGroup(name: \(String(describing: name)))"}
}

/// <p>Describes an Auto Scaling launch configuration.</p>
public struct AutoScalingGroup: Equatable {
    /// <p>The name of the <code>AutoScalingGroup</code> . </p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension BuildConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifactName = "ArtifactName"
        case codeBuildServiceRole = "CodeBuildServiceRole"
        case computeType = "ComputeType"
        case image = "Image"
        case timeoutInMinutes = "TimeoutInMinutes"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let artifactName = artifactName {
            try container.encode(artifactName, forKey: Key("ArtifactName"))
        }
        if let codeBuildServiceRole = codeBuildServiceRole {
            try container.encode(codeBuildServiceRole, forKey: Key("CodeBuildServiceRole"))
        }
        if let computeType = computeType {
            try container.encode(computeType, forKey: Key("ComputeType"))
        }
        if let image = image {
            try container.encode(image, forKey: Key("Image"))
        }
        if let timeoutInMinutes = timeoutInMinutes {
            try container.encode(timeoutInMinutes, forKey: Key("TimeoutInMinutes"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .artifactName)
        artifactName = artifactNameDecoded
        let codeBuildServiceRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .codeBuildServiceRole)
        codeBuildServiceRole = codeBuildServiceRoleDecoded
        let computeTypeDecoded = try containerValues.decodeIfPresent(ComputeType.self, forKey: .computeType)
        computeType = computeTypeDecoded
        let imageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .image)
        image = imageDecoded
        let timeoutInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutInMinutes)
        timeoutInMinutes = timeoutInMinutesDecoded
    }
}

extension BuildConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BuildConfiguration(artifactName: \(String(describing: artifactName)), codeBuildServiceRole: \(String(describing: codeBuildServiceRole)), computeType: \(String(describing: computeType)), image: \(String(describing: image)), timeoutInMinutes: \(String(describing: timeoutInMinutes)))"}
}

/// <p>Settings for an AWS CodeBuild build.</p>
public struct BuildConfiguration: Equatable {
    /// <p>The name of the artifact of the CodeBuild build.
    ///     If provided, Elastic Beanstalk stores the build artifact in the S3 location
    ///     <i>S3-bucket</i>/resources/<i>application-name</i>/codebuild/codebuild-<i>version-label</i>-<i>artifact-name</i>.zip.
    ///     If not provided, Elastic Beanstalk stores the build artifact in the S3 location
    ///     <i>S3-bucket</i>/resources/<i>application-name</i>/codebuild/codebuild-<i>version-label</i>.zip.
    ///     </p>
    public let artifactName: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that enables AWS CodeBuild to interact with dependent AWS services on behalf of the AWS account.</p>
    public let codeBuildServiceRole: String?
    /// <p>Information about the compute resources the build project will use.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>BUILD_GENERAL1_SMALL: Use up to 3 GB memory and 2 vCPUs for builds</code>
    ///                </p>
    ///             </li>
    ///             <li>
    /// 	              <p>
    ///                   <code>BUILD_GENERAL1_MEDIUM: Use up to 7 GB memory and 4 vCPUs for builds</code>
    ///                </p>
    ///             </li>
    ///             <li>
    /// 	              <p>
    ///                   <code>BUILD_GENERAL1_LARGE: Use up to 15 GB memory and 8 vCPUs for builds</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let computeType: ComputeType?
    /// <p>The ID of the Docker image to use for this build project.</p>
    public let image: String?
    /// <p>How long in minutes, from 5 to 480 (8 hours), for AWS CodeBuild to wait until timing out any related build that does not get marked as completed. The default is 60 minutes.</p>
    public let timeoutInMinutes: Int?

    public init (
        artifactName: String? = nil,
        codeBuildServiceRole: String? = nil,
        computeType: ComputeType? = nil,
        image: String? = nil,
        timeoutInMinutes: Int? = nil
    )
    {
        self.artifactName = artifactName
        self.codeBuildServiceRole = codeBuildServiceRole
        self.computeType = computeType
        self.image = image
        self.timeoutInMinutes = timeoutInMinutes
    }
}

extension Builder: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let aRN = aRN {
            try container.encode(aRN, forKey: Key("ARN"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
    }
}

extension Builder: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Builder(aRN: \(String(describing: aRN)))"}
}

/// <p>The builder used to build the custom platform.</p>
public struct Builder: Equatable {
    /// <p>The ARN of the builder.</p>
    public let aRN: String?

    public init (
        aRN: String? = nil
    )
    {
        self.aRN = aRN
    }
}

extension CPUUtilization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iOWait = "IOWait"
        case iRQ = "IRQ"
        case idle = "Idle"
        case nice = "Nice"
        case privileged = "Privileged"
        case softIRQ = "SoftIRQ"
        case system = "System"
        case user = "User"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let iOWait = iOWait {
            try container.encode(iOWait, forKey: Key("IOWait"))
        }
        if let iRQ = iRQ {
            try container.encode(iRQ, forKey: Key("IRQ"))
        }
        if let idle = idle {
            try container.encode(idle, forKey: Key("Idle"))
        }
        if let nice = nice {
            try container.encode(nice, forKey: Key("Nice"))
        }
        if let privileged = privileged {
            try container.encode(privileged, forKey: Key("Privileged"))
        }
        if let softIRQ = softIRQ {
            try container.encode(softIRQ, forKey: Key("SoftIRQ"))
        }
        if let system = system {
            try container.encode(system, forKey: Key("System"))
        }
        if let user = user {
            try container.encode(user, forKey: Key("User"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .user)
        user = userDecoded
        let niceDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .nice)
        nice = niceDecoded
        let systemDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .system)
        system = systemDecoded
        let idleDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .idle)
        idle = idleDecoded
        let iOWaitDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .iOWait)
        iOWait = iOWaitDecoded
        let iRQDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .iRQ)
        iRQ = iRQDecoded
        let softIRQDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .softIRQ)
        softIRQ = softIRQDecoded
        let privilegedDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .privileged)
        privileged = privilegedDecoded
    }
}

extension CPUUtilization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CPUUtilization(iOWait: \(String(describing: iOWait)), iRQ: \(String(describing: iRQ)), idle: \(String(describing: idle)), nice: \(String(describing: nice)), privileged: \(String(describing: privileged)), softIRQ: \(String(describing: softIRQ)), system: \(String(describing: system)), user: \(String(describing: user)))"}
}

/// <p>CPU utilization metrics for an instance.</p>
public struct CPUUtilization: Equatable {
    /// <p>Available on Linux environments only.</p>
    ///          <p>Percentage of time that the CPU has spent in the <code>I/O Wait</code> state over the
    ///       last 10 seconds.</p>
    public let iOWait: Double?
    /// <p>Available on Linux environments only.</p>
    ///          <p>Percentage of time that the CPU has spent in the <code>IRQ</code> state over the last
    ///       10 seconds.</p>
    public let iRQ: Double?
    /// <p>Percentage of time that the CPU has spent in the <code>Idle</code> state over the last
    ///       10 seconds.</p>
    public let idle: Double?
    /// <p>Available on Linux environments only.</p>
    ///          <p>Percentage of time that the CPU has spent in the <code>Nice</code> state over the last
    ///       10 seconds.</p>
    public let nice: Double?
    /// <p>Available on Windows environments only.</p>
    ///          <p>Percentage of time that the CPU has spent in the <code>Privileged</code> state over the
    ///       last 10 seconds.</p>
    public let privileged: Double?
    /// <p>Available on Linux environments only.</p>
    ///          <p>Percentage of time that the CPU has spent in the <code>SoftIRQ</code> state over the
    ///       last 10 seconds.</p>
    public let softIRQ: Double?
    /// <p>Available on Linux environments only.</p>
    ///          <p>Percentage of time that the CPU has spent in the <code>System</code> state over the
    ///       last 10 seconds.</p>
    public let system: Double?
    /// <p>Percentage of time that the CPU has spent in the <code>User</code> state over the last
    ///       10 seconds.</p>
    public let user: Double?

    public init (
        iOWait: Double? = nil,
        iRQ: Double? = nil,
        idle: Double? = nil,
        nice: Double? = nil,
        privileged: Double? = nil,
        softIRQ: Double? = nil,
        system: Double? = nil,
        user: Double? = nil
    )
    {
        self.iOWait = iOWait
        self.iRQ = iRQ
        self.idle = idle
        self.nice = nice
        self.privileged = privileged
        self.softIRQ = softIRQ
        self.system = system
        self.user = user
    }
}

public struct CheckDNSAvailabilityInputBodyMiddleware: Middleware {
    public let id: String = "CheckDNSAvailabilityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckDNSAvailabilityInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckDNSAvailabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckDNSAvailabilityInput>
    public typealias MOutput = OperationOutput<CheckDNSAvailabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckDNSAvailabilityOutputError>
}

extension CheckDNSAvailabilityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckDNSAvailabilityInput(cNAMEPrefix: \(String(describing: cNAMEPrefix)))"}
}

extension CheckDNSAvailabilityInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let cNAMEPrefix = cNAMEPrefix {
            try container.encode(cNAMEPrefix, forKey: Key("CNAMEPrefix"))
        }
        try container.encode("CheckDNSAvailability", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct CheckDNSAvailabilityInputHeadersMiddleware: Middleware {
    public let id: String = "CheckDNSAvailabilityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckDNSAvailabilityInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckDNSAvailabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckDNSAvailabilityInput>
    public typealias MOutput = OperationOutput<CheckDNSAvailabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckDNSAvailabilityOutputError>
}

public struct CheckDNSAvailabilityInputQueryItemMiddleware: Middleware {
    public let id: String = "CheckDNSAvailabilityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckDNSAvailabilityInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckDNSAvailabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckDNSAvailabilityInput>
    public typealias MOutput = OperationOutput<CheckDNSAvailabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckDNSAvailabilityOutputError>
}

/// <p>Results message indicating whether a CNAME is available.</p>
public struct CheckDNSAvailabilityInput: Equatable {
    /// <p>The prefix used when this CNAME is reserved.</p>
    public let cNAMEPrefix: String?

    public init (
        cNAMEPrefix: String? = nil
    )
    {
        self.cNAMEPrefix = cNAMEPrefix
    }
}

extension CheckDNSAvailabilityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CheckDNSAvailabilityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CheckDNSAvailabilityOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CheckDNSAvailabilityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckDNSAvailabilityOutputResponse(available: \(String(describing: available)), fullyQualifiedCNAME: \(String(describing: fullyQualifiedCNAME)))"}
}

extension CheckDNSAvailabilityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CheckDNSAvailabilityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.available = output.available
            self.fullyQualifiedCNAME = output.fullyQualifiedCNAME
        } else {
            self.available = nil
            self.fullyQualifiedCNAME = nil
        }
    }
}

/// <p>Indicates if the specified CNAME is available.</p>
public struct CheckDNSAvailabilityOutputResponse: Equatable {
    /// <p>Indicates if the specified CNAME is available:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>true</code> : The CNAME is available.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>false</code> : The CNAME is not available.</p>
    ///             </li>
    ///          </ul>
    public let available: Bool?
    /// <p>The fully qualified CNAME to reserve when <a>CreateEnvironment</a> is called
    ///       with the provided prefix.</p>
    public let fullyQualifiedCNAME: String?

    public init (
        available: Bool? = nil,
        fullyQualifiedCNAME: String? = nil
    )
    {
        self.available = available
        self.fullyQualifiedCNAME = fullyQualifiedCNAME
    }
}

struct CheckDNSAvailabilityOutputResponseBody: Equatable {
    public let available: Bool?
    public let fullyQualifiedCNAME: String?
}

extension CheckDNSAvailabilityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case available = "Available"
        case fullyQualifiedCNAME = "FullyQualifiedCNAME"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CheckDNSAvailabilityResult"))
        let availableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .available)
        available = availableDecoded
        let fullyQualifiedCNAMEDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fullyQualifiedCNAME)
        fullyQualifiedCNAME = fullyQualifiedCNAMEDecoded
    }
}

extension CodeBuildNotInServiceRegionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeBuildNotInServiceRegionException(message: \(String(describing: message)))"}
}

extension CodeBuildNotInServiceRegionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CodeBuildNotInServiceRegionExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS CodeBuild is not available in the specified region.</p>
public struct CodeBuildNotInServiceRegionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CodeBuildNotInServiceRegionExceptionBody: Equatable {
    public let message: String?
}

extension CodeBuildNotInServiceRegionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ComposeEnvironmentsInputBodyMiddleware: Middleware {
    public let id: String = "ComposeEnvironmentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ComposeEnvironmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ComposeEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ComposeEnvironmentsInput>
    public typealias MOutput = OperationOutput<ComposeEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ComposeEnvironmentsOutputError>
}

extension ComposeEnvironmentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComposeEnvironmentsInput(applicationName: \(String(describing: applicationName)), groupName: \(String(describing: groupName)), versionLabels: \(String(describing: versionLabels)))"}
}

extension ComposeEnvironmentsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let groupName = groupName {
            try container.encode(groupName, forKey: Key("GroupName"))
        }
        if let versionLabels = versionLabels {
            var versionLabelsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VersionLabels"))
            for (index0, versionlabel0) in versionLabels.enumerated() {
                try versionLabelsContainer.encode(versionlabel0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ComposeEnvironments", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct ComposeEnvironmentsInputHeadersMiddleware: Middleware {
    public let id: String = "ComposeEnvironmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ComposeEnvironmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ComposeEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ComposeEnvironmentsInput>
    public typealias MOutput = OperationOutput<ComposeEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ComposeEnvironmentsOutputError>
}

public struct ComposeEnvironmentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ComposeEnvironmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ComposeEnvironmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ComposeEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ComposeEnvironmentsInput>
    public typealias MOutput = OperationOutput<ComposeEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ComposeEnvironmentsOutputError>
}

/// <p>Request to create or update a group of environments.</p>
public struct ComposeEnvironmentsInput: Equatable {
    /// <p>The name of the application to which the specified source bundles belong.</p>
    public let applicationName: String?
    /// <p>The name of the group to which the target environments belong. Specify a group name
    ///       only if the environment name defined in each target environment's manifest ends with a +
    ///       (plus) character. See <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/environment-cfg-manifest.html">Environment Manifest
    ///         (env.yaml)</a> for details.</p>
    public let groupName: String?
    /// <p>A list of version labels, specifying one or more application source bundles that belong
    ///       to the target application. Each source bundle must include an environment manifest that
    ///       specifies the name of the environment and the name of the solution stack to use, and
    ///       optionally can specify environment links to create.</p>
    public let versionLabels: [String]?

    public init (
        applicationName: String? = nil,
        groupName: String? = nil,
        versionLabels: [String]? = nil
    )
    {
        self.applicationName = applicationName
        self.groupName = groupName
        self.versionLabels = versionLabels
    }
}

extension ComposeEnvironmentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ComposeEnvironmentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyEnvironmentsException" : self = .tooManyEnvironmentsException(try TooManyEnvironmentsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ComposeEnvironmentsOutputError: Equatable {
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case tooManyEnvironmentsException(TooManyEnvironmentsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ComposeEnvironmentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComposeEnvironmentsOutputResponse(environments: \(String(describing: environments)), nextToken: \(String(describing: nextToken)))"}
}

extension ComposeEnvironmentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ComposeEnvironmentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.environments = output.environments
            self.nextToken = output.nextToken
        } else {
            self.environments = nil
            self.nextToken = nil
        }
    }
}

/// <p>Result message containing a list of environment descriptions.</p>
public struct ComposeEnvironmentsOutputResponse: Equatable {
    /// <p> Returns an <a>EnvironmentDescription</a> list. </p>
    public let environments: [EnvironmentDescription]?
    /// <p>In a paginated request, the token that you can pass in a subsequent request to get the
    ///       next response page.</p>
    public let nextToken: String?

    public init (
        environments: [EnvironmentDescription]? = nil,
        nextToken: String? = nil
    )
    {
        self.environments = environments
        self.nextToken = nextToken
    }
}

struct ComposeEnvironmentsOutputResponseBody: Equatable {
    public let environments: [EnvironmentDescription]?
    public let nextToken: String?
}

extension ComposeEnvironmentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case environments = "Environments"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ComposeEnvironmentsResult"))
        if containerValues.contains(.environments) {
            struct KeyVal0{struct member{}}
            let environmentsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .environments)
            if let environmentsWrappedContainer = environmentsWrappedContainer {
                let environmentsContainer = try environmentsWrappedContainer.decodeIfPresent([EnvironmentDescription].self, forKey: .member)
                var environmentsBuffer:[EnvironmentDescription]? = nil
                if let environmentsContainer = environmentsContainer {
                    environmentsBuffer = [EnvironmentDescription]()
                    for structureContainer0 in environmentsContainer {
                        environmentsBuffer?.append(structureContainer0)
                    }
                }
                environments = environmentsBuffer
            } else {
                environments = []
            }
        } else {
            environments = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public enum ComputeType {
    case buildGeneral1Large
    case buildGeneral1Medium
    case buildGeneral1Small
    case sdkUnknown(String)
}

extension ComputeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComputeType] {
        return [
            .buildGeneral1Large,
            .buildGeneral1Medium,
            .buildGeneral1Small,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .buildGeneral1Large: return "BUILD_GENERAL1_LARGE"
        case .buildGeneral1Medium: return "BUILD_GENERAL1_MEDIUM"
        case .buildGeneral1Small: return "BUILD_GENERAL1_SMALL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComputeType(rawValue: rawValue) ?? ComputeType.sdkUnknown(rawValue)
    }
}

public enum ConfigurationDeploymentStatus {
    case deployed
    case failed
    case pending
    case sdkUnknown(String)
}

extension ConfigurationDeploymentStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfigurationDeploymentStatus] {
        return [
            .deployed,
            .failed,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deployed: return "deployed"
        case .failed: return "failed"
        case .pending: return "pending"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfigurationDeploymentStatus(rawValue: rawValue) ?? ConfigurationDeploymentStatus.sdkUnknown(rawValue)
    }
}

extension ConfigurationOptionDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeSeverity = "ChangeSeverity"
        case defaultValue = "DefaultValue"
        case maxLength = "MaxLength"
        case maxValue = "MaxValue"
        case minValue = "MinValue"
        case name = "Name"
        case namespace = "Namespace"
        case regex = "Regex"
        case userDefined = "UserDefined"
        case valueOptions = "ValueOptions"
        case valueType = "ValueType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let changeSeverity = changeSeverity {
            try container.encode(changeSeverity, forKey: Key("ChangeSeverity"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: Key("DefaultValue"))
        }
        if let maxLength = maxLength {
            try container.encode(maxLength, forKey: Key("MaxLength"))
        }
        if let maxValue = maxValue {
            try container.encode(maxValue, forKey: Key("MaxValue"))
        }
        if let minValue = minValue {
            try container.encode(minValue, forKey: Key("MinValue"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let namespace = namespace {
            try container.encode(namespace, forKey: Key("Namespace"))
        }
        if let regex = regex {
            try container.encode(regex, forKey: Key("Regex"))
        }
        if let userDefined = userDefined {
            try container.encode(userDefined, forKey: Key("UserDefined"))
        }
        if let valueOptions = valueOptions {
            var valueOptionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ValueOptions"))
            for (index0, configurationoptionpossiblevalue0) in valueOptions.enumerated() {
                try valueOptionsContainer.encode(configurationoptionpossiblevalue0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let valueType = valueType {
            try container.encode(valueType, forKey: Key("ValueType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let changeSeverityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSeverity)
        changeSeverity = changeSeverityDecoded
        let userDefinedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .userDefined)
        userDefined = userDefinedDecoded
        let valueTypeDecoded = try containerValues.decodeIfPresent(ConfigurationOptionValueType.self, forKey: .valueType)
        valueType = valueTypeDecoded
        if containerValues.contains(.valueOptions) {
            struct KeyVal0{struct member{}}
            let valueOptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .valueOptions)
            if let valueOptionsWrappedContainer = valueOptionsWrappedContainer {
                let valueOptionsContainer = try valueOptionsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var valueOptionsBuffer:[String]? = nil
                if let valueOptionsContainer = valueOptionsContainer {
                    valueOptionsBuffer = [String]()
                    for stringContainer0 in valueOptionsContainer {
                        valueOptionsBuffer?.append(stringContainer0)
                    }
                }
                valueOptions = valueOptionsBuffer
            } else {
                valueOptions = []
            }
        } else {
            valueOptions = nil
        }
        let minValueDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minValue)
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let maxLengthDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxLength)
        maxLength = maxLengthDecoded
        let regexDecoded = try containerValues.decodeIfPresent(OptionRestrictionRegex.self, forKey: .regex)
        regex = regexDecoded
    }
}

extension ConfigurationOptionDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationOptionDescription(changeSeverity: \(String(describing: changeSeverity)), defaultValue: \(String(describing: defaultValue)), maxLength: \(String(describing: maxLength)), maxValue: \(String(describing: maxValue)), minValue: \(String(describing: minValue)), name: \(String(describing: name)), namespace: \(String(describing: namespace)), regex: \(String(describing: regex)), userDefined: \(String(describing: userDefined)), valueOptions: \(String(describing: valueOptions)), valueType: \(String(describing: valueType)))"}
}

/// <p>Describes the possible values for a configuration option.</p>
public struct ConfigurationOptionDescription: Equatable {
    /// <p>An indication of which action is required if the value for this configuration option
    ///       changes:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>NoInterruption</code> : There is no interruption to the environment or application
    ///           availability.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RestartEnvironment</code> : The environment is entirely restarted, all AWS resources
    ///           are deleted and recreated, and the environment is unavailable during the
    ///           process.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RestartApplicationServer</code> : The environment is available the entire time.
    ///           However, a short application outage occurs when the application servers on the running
    ///           Amazon EC2 instances are restarted.</p>
    ///             </li>
    ///          </ul>
    public let changeSeverity: String?
    /// <p>The default value for this configuration option.</p>
    public let defaultValue: String?
    /// <p>If specified, the configuration option must be a string value no longer than this
    ///       value.</p>
    public let maxLength: Int?
    /// <p>If specified, the configuration option must be a numeric value less than this
    ///       value.</p>
    public let maxValue: Int?
    /// <p>If specified, the configuration option must be a numeric value greater than this
    ///       value.</p>
    public let minValue: Int?
    /// <p>The name of the configuration option.</p>
    public let name: String?
    /// <p>A unique namespace identifying the option's associated AWS resource.</p>
    public let namespace: String?
    /// <p>If specified, the configuration option must be a string value that satisfies this
    ///       regular expression.</p>
    public let regex: OptionRestrictionRegex?
    /// <p>An indication of whether the user defined this configuration option:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>true</code> : This configuration option was defined by the user. It is a valid
    ///           choice for specifying if this as an <code>Option to Remove</code> when updating
    ///           configuration settings. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>false</code> : This configuration was not defined by the user.</p>
    ///             </li>
    ///          </ul>
    ///          <p> Constraint: You can remove only <code>UserDefined</code> options from a configuration. </p>
    ///          <p> Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let userDefined: Bool?
    /// <p>If specified, values for the configuration option are selected from this
    ///       list.</p>
    public let valueOptions: [String]?
    /// <p>An indication of which type of values this option has and whether it is allowable to
    ///       select one or more than one of the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Scalar</code> : Values for this option are a single selection from the possible
    ///           values, or an unformatted string, or numeric value governed by the
    ///           <code>MIN/MAX/Regex</code> constraints.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>List</code> : Values for this option are multiple selections from the possible
    ///           values.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Boolean</code> : Values for this option are either <code>true</code> or
    ///           <code>false</code> .</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Json</code> : Values for this option are a JSON representation of a
    ///           <code>ConfigDocument</code>.</p>
    ///             </li>
    ///          </ul>
    public let valueType: ConfigurationOptionValueType?

    public init (
        changeSeverity: String? = nil,
        defaultValue: String? = nil,
        maxLength: Int? = nil,
        maxValue: Int? = nil,
        minValue: Int? = nil,
        name: String? = nil,
        namespace: String? = nil,
        regex: OptionRestrictionRegex? = nil,
        userDefined: Bool? = nil,
        valueOptions: [String]? = nil,
        valueType: ConfigurationOptionValueType? = nil
    )
    {
        self.changeSeverity = changeSeverity
        self.defaultValue = defaultValue
        self.maxLength = maxLength
        self.maxValue = maxValue
        self.minValue = minValue
        self.name = name
        self.namespace = namespace
        self.regex = regex
        self.userDefined = userDefined
        self.valueOptions = valueOptions
        self.valueType = valueType
    }
}

extension ConfigurationOptionSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case namespace = "Namespace"
        case optionName = "OptionName"
        case resourceName = "ResourceName"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let namespace = namespace {
            try container.encode(namespace, forKey: Key("Namespace"))
        }
        if let optionName = optionName {
            try container.encode(optionName, forKey: Key("OptionName"))
        }
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: Key("ResourceName"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let optionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optionName)
        optionName = optionNameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConfigurationOptionSetting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationOptionSetting(namespace: \(String(describing: namespace)), optionName: \(String(describing: optionName)), resourceName: \(String(describing: resourceName)), value: \(String(describing: value)))"}
}

/// <p>A specification identifying an individual configuration option along with its current
///       value. For a list of possible namespaces and option values, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/command-options.html">Option Values</a> in the
///       <i>AWS Elastic Beanstalk Developer Guide</i>. </p>
public struct ConfigurationOptionSetting: Equatable {
    /// <p>A unique namespace that identifies the option's associated AWS resource.</p>
    public let namespace: String?
    /// <p>The name of the configuration option.</p>
    public let optionName: String?
    /// <p>A unique resource name for the option setting. Use it for a time–based scaling configuration option.</p>
    public let resourceName: String?
    /// <p>The current value for the configuration option.</p>
    public let value: String?

    public init (
        namespace: String? = nil,
        optionName: String? = nil,
        resourceName: String? = nil,
        value: String? = nil
    )
    {
        self.namespace = namespace
        self.optionName = optionName
        self.resourceName = resourceName
        self.value = value
    }
}

public enum ConfigurationOptionValueType {
    case list
    case scalar
    case sdkUnknown(String)
}

extension ConfigurationOptionValueType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfigurationOptionValueType] {
        return [
            .list,
            .scalar,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .list: return "List"
        case .scalar: return "Scalar"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfigurationOptionValueType(rawValue: rawValue) ?? ConfigurationOptionValueType.sdkUnknown(rawValue)
    }
}

extension ConfigurationSettingsDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case dateCreated = "DateCreated"
        case dateUpdated = "DateUpdated"
        case deploymentStatus = "DeploymentStatus"
        case description = "Description"
        case environmentName = "EnvironmentName"
        case optionSettings = "OptionSettings"
        case platformArn = "PlatformArn"
        case solutionStackName = "SolutionStackName"
        case templateName = "TemplateName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let dateCreated = dateCreated {
            try container.encode(TimestampWrapper(dateCreated, format: .dateTime), forKey: Key("dateCreated"))
        }
        if let dateUpdated = dateUpdated {
            try container.encode(TimestampWrapper(dateUpdated, format: .dateTime), forKey: Key("dateUpdated"))
        }
        if let deploymentStatus = deploymentStatus {
            try container.encode(deploymentStatus, forKey: Key("DeploymentStatus"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        if let optionSettings = optionSettings {
            var optionSettingsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionSettings"))
            for (index0, configurationoptionsetting0) in optionSettings.enumerated() {
                try optionSettingsContainer.encode(configurationoptionsetting0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let platformArn = platformArn {
            try container.encode(platformArn, forKey: Key("PlatformArn"))
        }
        if let solutionStackName = solutionStackName {
            try container.encode(solutionStackName, forKey: Key("SolutionStackName"))
        }
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionStackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionStackName)
        solutionStackName = solutionStackNameDecoded
        let platformArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformArn)
        platformArn = platformArnDecoded
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ConfigurationDeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        var dateCreatedBuffer:Date? = nil
        if let dateCreatedDecoded = dateCreatedDecoded {
            dateCreatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateCreatedDecoded, format: .dateTime)
        }
        dateCreated = dateCreatedBuffer
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateUpdated)
        var dateUpdatedBuffer:Date? = nil
        if let dateUpdatedDecoded = dateUpdatedDecoded {
            dateUpdatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateUpdatedDecoded, format: .dateTime)
        }
        dateUpdated = dateUpdatedBuffer
        if containerValues.contains(.optionSettings) {
            struct KeyVal0{struct member{}}
            let optionSettingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .optionSettings)
            if let optionSettingsWrappedContainer = optionSettingsWrappedContainer {
                let optionSettingsContainer = try optionSettingsWrappedContainer.decodeIfPresent([ConfigurationOptionSetting].self, forKey: .member)
                var optionSettingsBuffer:[ConfigurationOptionSetting]? = nil
                if let optionSettingsContainer = optionSettingsContainer {
                    optionSettingsBuffer = [ConfigurationOptionSetting]()
                    for structureContainer0 in optionSettingsContainer {
                        optionSettingsBuffer?.append(structureContainer0)
                    }
                }
                optionSettings = optionSettingsBuffer
            } else {
                optionSettings = []
            }
        } else {
            optionSettings = nil
        }
    }
}

extension ConfigurationSettingsDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationSettingsDescription(applicationName: \(String(describing: applicationName)), dateCreated: \(String(describing: dateCreated)), dateUpdated: \(String(describing: dateUpdated)), deploymentStatus: \(String(describing: deploymentStatus)), description: \(String(describing: description)), environmentName: \(String(describing: environmentName)), optionSettings: \(String(describing: optionSettings)), platformArn: \(String(describing: platformArn)), solutionStackName: \(String(describing: solutionStackName)), templateName: \(String(describing: templateName)))"}
}

/// <p>Describes the settings for a configuration set.</p>
public struct ConfigurationSettingsDescription: Equatable {
    /// <p>The name of the application associated with this configuration set.</p>
    public let applicationName: String?
    /// <p>The date (in UTC time) when this configuration set was created.</p>
    public let dateCreated: Date?
    /// <p>The date (in UTC time) when this configuration set was last modified.</p>
    public let dateUpdated: Date?
    /// <p> If this configuration set is associated with an environment, the
    ///         <code>DeploymentStatus</code> parameter indicates the deployment status of this
    ///       configuration set: </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>null</code>: This configuration is not associated with a running
    ///           environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: This is a draft configuration that is not deployed to the associated
    ///           environment but is in the process of deploying.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deployed</code>: This is the configuration that is currently deployed to the
    ///           associated running environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>failed</code>: This is a draft configuration that failed to successfully
    ///           deploy.</p>
    ///             </li>
    ///          </ul>
    public let deploymentStatus: ConfigurationDeploymentStatus?
    /// <p>Describes this configuration set.</p>
    public let description: String?
    /// <p> If not <code>null</code>, the name of the environment for this configuration set.
    ///     </p>
    public let environmentName: String?
    /// <p>A list of the configuration options and their values in this configuration
    ///       set.</p>
    public let optionSettings: [ConfigurationOptionSetting]?
    /// <p>The ARN of the platform version.</p>
    public let platformArn: String?
    /// <p>The name of the solution stack this configuration set uses.</p>
    public let solutionStackName: String?
    /// <p> If not <code>null</code>, the name of the configuration template for this
    ///       configuration set. </p>
    public let templateName: String?

    public init (
        applicationName: String? = nil,
        dateCreated: Date? = nil,
        dateUpdated: Date? = nil,
        deploymentStatus: ConfigurationDeploymentStatus? = nil,
        description: String? = nil,
        environmentName: String? = nil,
        optionSettings: [ConfigurationOptionSetting]? = nil,
        platformArn: String? = nil,
        solutionStackName: String? = nil,
        templateName: String? = nil
    )
    {
        self.applicationName = applicationName
        self.dateCreated = dateCreated
        self.dateUpdated = dateUpdated
        self.deploymentStatus = deploymentStatus
        self.description = description
        self.environmentName = environmentName
        self.optionSettings = optionSettings
        self.platformArn = platformArn
        self.solutionStackName = solutionStackName
        self.templateName = templateName
    }
}

public struct CreateApplicationInputBodyMiddleware: Middleware {
    public let id: String = "CreateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

extension CreateApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationInput(applicationName: \(String(describing: applicationName)), description: \(String(describing: description)), resourceLifecycleConfig: \(String(describing: resourceLifecycleConfig)), tags: \(String(describing: tags)))"}
}

extension CreateApplicationInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let resourceLifecycleConfig = resourceLifecycleConfig {
            try container.encode(resourceLifecycleConfig, forKey: Key("ResourceLifecycleConfig"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateApplication", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct CreateApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

/// <p>Request to create an application.</p>
public struct CreateApplicationInput: Equatable {
    /// <p>The name of the application. Must be unique within your account.</p>
    public let applicationName: String?
    /// <p>Your description of the application.</p>
    public let description: String?
    /// <p>Specifies an application resource lifecycle configuration to prevent your application
    ///       from accumulating too many versions.</p>
    public let resourceLifecycleConfig: ApplicationResourceLifecycleConfig?
    /// <p>Specifies the tags applied to the application.</p>
    ///          <p>Elastic Beanstalk applies these tags only to the application. Environments that you create in the
    ///       application don't inherit the tags.</p>
    public let tags: [Tag]?

    public init (
        applicationName: String? = nil,
        description: String? = nil,
        resourceLifecycleConfig: ApplicationResourceLifecycleConfig? = nil,
        tags: [Tag]? = nil
    )
    {
        self.applicationName = applicationName
        self.description = description
        self.resourceLifecycleConfig = resourceLifecycleConfig
        self.tags = tags
    }
}

extension CreateApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "TooManyApplicationsException" : self = .tooManyApplicationsException(try TooManyApplicationsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationOutputError: Equatable {
    case tooManyApplicationsException(TooManyApplicationsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationOutputResponse(application: \(String(describing: application)))"}
}

extension CreateApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.application = output.application
        } else {
            self.application = nil
        }
    }
}

/// <p>Result message containing a single description of an application.</p>
public struct CreateApplicationOutputResponse: Equatable {
    /// <p> The <a>ApplicationDescription</a> of the application. </p>
    public let application: ApplicationDescription?

    public init (
        application: ApplicationDescription? = nil
    )
    {
        self.application = application
    }
}

struct CreateApplicationOutputResponseBody: Equatable {
    public let application: ApplicationDescription?
}

extension CreateApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case application = "Application"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateApplicationResult"))
        let applicationDecoded = try containerValues.decodeIfPresent(ApplicationDescription.self, forKey: .application)
        application = applicationDecoded
    }
}

public struct CreateApplicationVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateApplicationVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationVersionInput>
    public typealias MOutput = OperationOutput<CreateApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationVersionOutputError>
}

extension CreateApplicationVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationVersionInput(applicationName: \(String(describing: applicationName)), autoCreateApplication: \(String(describing: autoCreateApplication)), buildConfiguration: \(String(describing: buildConfiguration)), description: \(String(describing: description)), process: \(String(describing: process)), sourceBuildInformation: \(String(describing: sourceBuildInformation)), sourceBundle: \(String(describing: sourceBundle)), tags: \(String(describing: tags)), versionLabel: \(String(describing: versionLabel)))"}
}

extension CreateApplicationVersionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let autoCreateApplication = autoCreateApplication {
            try container.encode(autoCreateApplication, forKey: Key("AutoCreateApplication"))
        }
        if let buildConfiguration = buildConfiguration {
            try container.encode(buildConfiguration, forKey: Key("BuildConfiguration"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let process = process {
            try container.encode(process, forKey: Key("Process"))
        }
        if let sourceBuildInformation = sourceBuildInformation {
            try container.encode(sourceBuildInformation, forKey: Key("SourceBuildInformation"))
        }
        if let sourceBundle = sourceBundle {
            try container.encode(sourceBundle, forKey: Key("SourceBundle"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let versionLabel = versionLabel {
            try container.encode(versionLabel, forKey: Key("VersionLabel"))
        }
        try container.encode("CreateApplicationVersion", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct CreateApplicationVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateApplicationVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationVersionInput>
    public typealias MOutput = OperationOutput<CreateApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationVersionOutputError>
}

public struct CreateApplicationVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateApplicationVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationVersionInput>
    public typealias MOutput = OperationOutput<CreateApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationVersionOutputError>
}

/// <p></p>
public struct CreateApplicationVersionInput: Equatable {
    /// <p> The name of the application. If no application is found with this name, and
    ///         <code>AutoCreateApplication</code> is <code>false</code>, returns an
    ///         <code>InvalidParameterValue</code> error. </p>
    public let applicationName: String?
    /// <p>Set to <code>true</code> to create an application with the specified name if it doesn't
    ///       already exist.</p>
    public let autoCreateApplication: Bool?
    /// <p>Settings for an AWS CodeBuild build.</p>
    public let buildConfiguration: BuildConfiguration?
    /// <p>A description of this application version.</p>
    public let description: String?
    /// <p>Pre-processes and validates the environment manifest (<code>env.yaml</code>) and
    ///       configuration files (<code>*.config</code> files in the <code>.ebextensions</code> folder) in
    ///       the source bundle. Validating configuration files can identify issues prior to deploying the
    ///       application version to an environment.</p>
    ///          <p>You must turn processing on for application versions that you create using AWS
    ///       CodeBuild or AWS CodeCommit. For application versions built from a source bundle in Amazon S3,
    ///       processing is optional.</p>
    ///          <note>
    ///             <p>The <code>Process</code> option validates Elastic Beanstalk configuration files. It
    ///       doesn't validate your application's configuration files, like proxy server or Docker
    ///       configuration.</p>
    ///          </note>
    public let process: Bool?
    /// <p>Specify a commit in an AWS CodeCommit Git repository to use as the source code for the
    ///       application version.</p>
    public let sourceBuildInformation: SourceBuildInformation?
    /// <p>The Amazon S3 bucket and key that identify the location of the source bundle for this
    ///       version.</p>
    ///          <note>
    ///             <p>The Amazon S3 bucket must be in the same region as the
    ///       environment.</p>
    ///          </note>
    ///          <p>Specify a source bundle in S3 or a commit in an AWS CodeCommit repository (with
    ///         <code>SourceBuildInformation</code>), but not both. If neither <code>SourceBundle</code> nor
    ///         <code>SourceBuildInformation</code> are provided, Elastic Beanstalk uses a sample
    ///       application.</p>
    public let sourceBundle: S3Location?
    /// <p>Specifies the tags applied to the application version.</p>
    ///          <p>Elastic Beanstalk applies these tags only to the application version. Environments that use the
    ///       application version don't inherit the tags.</p>
    public let tags: [Tag]?
    /// <p>A label identifying this version.</p>
    ///          <p>Constraint: Must be unique per application. If an application version already exists
    ///       with this label for the specified application, AWS Elastic Beanstalk returns an
    ///         <code>InvalidParameterValue</code> error. </p>
    public let versionLabel: String?

    public init (
        applicationName: String? = nil,
        autoCreateApplication: Bool? = nil,
        buildConfiguration: BuildConfiguration? = nil,
        description: String? = nil,
        process: Bool? = nil,
        sourceBuildInformation: SourceBuildInformation? = nil,
        sourceBundle: S3Location? = nil,
        tags: [Tag]? = nil,
        versionLabel: String? = nil
    )
    {
        self.applicationName = applicationName
        self.autoCreateApplication = autoCreateApplication
        self.buildConfiguration = buildConfiguration
        self.description = description
        self.process = process
        self.sourceBuildInformation = sourceBuildInformation
        self.sourceBundle = sourceBundle
        self.tags = tags
        self.versionLabel = versionLabel
    }
}

extension CreateApplicationVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateApplicationVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeBuildNotInServiceRegionException" : self = .codeBuildNotInServiceRegionException(try CodeBuildNotInServiceRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3LocationNotInServiceRegionException" : self = .s3LocationNotInServiceRegionException(try S3LocationNotInServiceRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyApplicationsException" : self = .tooManyApplicationsException(try TooManyApplicationsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyApplicationVersionsException" : self = .tooManyApplicationVersionsException(try TooManyApplicationVersionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationVersionOutputError: Equatable {
    case codeBuildNotInServiceRegionException(CodeBuildNotInServiceRegionException)
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case s3LocationNotInServiceRegionException(S3LocationNotInServiceRegionException)
    case tooManyApplicationsException(TooManyApplicationsException)
    case tooManyApplicationVersionsException(TooManyApplicationVersionsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationVersionOutputResponse(applicationVersion: \(String(describing: applicationVersion)))"}
}

extension CreateApplicationVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateApplicationVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationVersion = output.applicationVersion
        } else {
            self.applicationVersion = nil
        }
    }
}

/// <p>Result message wrapping a single description of an application version.</p>
public struct CreateApplicationVersionOutputResponse: Equatable {
    /// <p> The <a>ApplicationVersionDescription</a> of the application version.
    ///     </p>
    public let applicationVersion: ApplicationVersionDescription?

    public init (
        applicationVersion: ApplicationVersionDescription? = nil
    )
    {
        self.applicationVersion = applicationVersion
    }
}

struct CreateApplicationVersionOutputResponseBody: Equatable {
    public let applicationVersion: ApplicationVersionDescription?
}

extension CreateApplicationVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationVersion = "ApplicationVersion"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateApplicationVersionResult"))
        let applicationVersionDecoded = try containerValues.decodeIfPresent(ApplicationVersionDescription.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
    }
}

public struct CreateConfigurationTemplateInputBodyMiddleware: Middleware {
    public let id: String = "CreateConfigurationTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationTemplateInput>
    public typealias MOutput = OperationOutput<CreateConfigurationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationTemplateOutputError>
}

extension CreateConfigurationTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationTemplateInput(applicationName: \(String(describing: applicationName)), description: \(String(describing: description)), environmentId: \(String(describing: environmentId)), optionSettings: \(String(describing: optionSettings)), platformArn: \(String(describing: platformArn)), solutionStackName: \(String(describing: solutionStackName)), sourceConfiguration: \(String(describing: sourceConfiguration)), tags: \(String(describing: tags)), templateName: \(String(describing: templateName)))"}
}

extension CreateConfigurationTemplateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let environmentId = environmentId {
            try container.encode(environmentId, forKey: Key("EnvironmentId"))
        }
        if let optionSettings = optionSettings {
            var optionSettingsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionSettings"))
            for (index0, configurationoptionsetting0) in optionSettings.enumerated() {
                try optionSettingsContainer.encode(configurationoptionsetting0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let platformArn = platformArn {
            try container.encode(platformArn, forKey: Key("PlatformArn"))
        }
        if let solutionStackName = solutionStackName {
            try container.encode(solutionStackName, forKey: Key("SolutionStackName"))
        }
        if let sourceConfiguration = sourceConfiguration {
            try container.encode(sourceConfiguration, forKey: Key("SourceConfiguration"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        try container.encode("CreateConfigurationTemplate", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct CreateConfigurationTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConfigurationTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationTemplateInput>
    public typealias MOutput = OperationOutput<CreateConfigurationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationTemplateOutputError>
}

public struct CreateConfigurationTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConfigurationTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationTemplateInput>
    public typealias MOutput = OperationOutput<CreateConfigurationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationTemplateOutputError>
}

/// <p>Request to create a configuration template.</p>
public struct CreateConfigurationTemplateInput: Equatable {
    /// <p>The name of the Elastic Beanstalk application to associate with this configuration
    ///       template.</p>
    public let applicationName: String?
    /// <p>An optional description for this configuration.</p>
    public let description: String?
    /// <p>The ID of an environment whose settings you want to use to create the configuration
    ///       template. You must specify <code>EnvironmentId</code> if you don't specify
    ///         <code>PlatformArn</code>, <code>SolutionStackName</code>, or
    ///         <code>SourceConfiguration</code>.</p>
    public let environmentId: String?
    /// <p>Option values for the Elastic Beanstalk configuration, such as the instance type. If specified, these
    ///       values override the values obtained from the solution stack or the source configuration
    ///       template. For a complete list of Elastic Beanstalk configuration options, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/command-options.html">Option Values</a> in the
    ///         <i>AWS Elastic Beanstalk Developer Guide</i>.</p>
    public let optionSettings: [ConfigurationOptionSetting]?
    /// <p>The Amazon Resource Name (ARN) of the custom platform. For more information, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/custom-platforms.html"> Custom
    ///         Platforms</a> in the <i>AWS Elastic Beanstalk Developer Guide</i>.</p>
    ///          <note>
    ///
    ///             <p>If you specify <code>PlatformArn</code>, then don't specify
    ///           <code>SolutionStackName</code>.</p>
    ///          </note>
    public let platformArn: String?
    /// <p>The name of an Elastic Beanstalk solution stack (platform version) that this configuration uses. For
    ///       example, <code>64bit Amazon Linux 2013.09 running Tomcat 7 Java 7</code>. A solution stack
    ///       specifies the operating system, runtime, and application server for a configuration template.
    ///       It also determines the set of configuration options as well as the possible and default
    ///       values. For more information, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/concepts.platforms.html">Supported Platforms</a> in the
    ///         <i>AWS Elastic Beanstalk Developer Guide</i>.</p>
    ///          <p>You must specify <code>SolutionStackName</code> if you don't specify
    ///         <code>PlatformArn</code>, <code>EnvironmentId</code>, or
    ///       <code>SourceConfiguration</code>.</p>
    ///          <p>Use the <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/api/API_ListAvailableSolutionStacks.html">
    ///                <code>ListAvailableSolutionStacks</code>
    ///             </a> API to obtain a list of available
    ///       solution stacks.</p>
    public let solutionStackName: String?
    /// <p>An Elastic Beanstalk configuration template to base this one on. If specified, Elastic Beanstalk uses the configuration values from the specified
    ///       configuration template to create a new configuration.</p>
    ///          <p>Values specified in <code>OptionSettings</code> override any values obtained from the
    ///         <code>SourceConfiguration</code>.</p>
    ///          <p>You must specify <code>SourceConfiguration</code> if you don't specify
    ///         <code>PlatformArn</code>, <code>EnvironmentId</code>, or
    ///       <code>SolutionStackName</code>.</p>
    ///          <p>Constraint: If both solution stack name and source configuration are specified, the
    ///       solution stack of the source configuration template must match the specified solution stack
    ///       name.</p>
    public let sourceConfiguration: SourceConfiguration?
    /// <p>Specifies the tags applied to the configuration template.</p>
    public let tags: [Tag]?
    /// <p>The name of the configuration template.</p>
    ///          <p>Constraint: This name must be unique per application.</p>
    public let templateName: String?

    public init (
        applicationName: String? = nil,
        description: String? = nil,
        environmentId: String? = nil,
        optionSettings: [ConfigurationOptionSetting]? = nil,
        platformArn: String? = nil,
        solutionStackName: String? = nil,
        sourceConfiguration: SourceConfiguration? = nil,
        tags: [Tag]? = nil,
        templateName: String? = nil
    )
    {
        self.applicationName = applicationName
        self.description = description
        self.environmentId = environmentId
        self.optionSettings = optionSettings
        self.platformArn = platformArn
        self.solutionStackName = solutionStackName
        self.sourceConfiguration = sourceConfiguration
        self.tags = tags
        self.templateName = templateName
    }
}

extension CreateConfigurationTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateConfigurationTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyBucketsException" : self = .tooManyBucketsException(try TooManyBucketsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyConfigurationTemplatesException" : self = .tooManyConfigurationTemplatesException(try TooManyConfigurationTemplatesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationTemplateOutputError: Equatable {
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case tooManyBucketsException(TooManyBucketsException)
    case tooManyConfigurationTemplatesException(TooManyConfigurationTemplatesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationTemplateOutputResponse(applicationName: \(String(describing: applicationName)), dateCreated: \(String(describing: dateCreated)), dateUpdated: \(String(describing: dateUpdated)), deploymentStatus: \(String(describing: deploymentStatus)), description: \(String(describing: description)), environmentName: \(String(describing: environmentName)), optionSettings: \(String(describing: optionSettings)), platformArn: \(String(describing: platformArn)), solutionStackName: \(String(describing: solutionStackName)), templateName: \(String(describing: templateName)))"}
}

extension CreateConfigurationTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateConfigurationTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationName = output.applicationName
            self.dateCreated = output.dateCreated
            self.dateUpdated = output.dateUpdated
            self.deploymentStatus = output.deploymentStatus
            self.description = output.description
            self.environmentName = output.environmentName
            self.optionSettings = output.optionSettings
            self.platformArn = output.platformArn
            self.solutionStackName = output.solutionStackName
            self.templateName = output.templateName
        } else {
            self.applicationName = nil
            self.dateCreated = nil
            self.dateUpdated = nil
            self.deploymentStatus = nil
            self.description = nil
            self.environmentName = nil
            self.optionSettings = nil
            self.platformArn = nil
            self.solutionStackName = nil
            self.templateName = nil
        }
    }
}

/// <p>Describes the settings for a configuration set.</p>
public struct CreateConfigurationTemplateOutputResponse: Equatable {
    /// <p>The name of the application associated with this configuration set.</p>
    public let applicationName: String?
    /// <p>The date (in UTC time) when this configuration set was created.</p>
    public let dateCreated: Date?
    /// <p>The date (in UTC time) when this configuration set was last modified.</p>
    public let dateUpdated: Date?
    /// <p> If this configuration set is associated with an environment, the
    ///         <code>DeploymentStatus</code> parameter indicates the deployment status of this
    ///       configuration set: </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>null</code>: This configuration is not associated with a running
    ///           environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: This is a draft configuration that is not deployed to the associated
    ///           environment but is in the process of deploying.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deployed</code>: This is the configuration that is currently deployed to the
    ///           associated running environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>failed</code>: This is a draft configuration that failed to successfully
    ///           deploy.</p>
    ///             </li>
    ///          </ul>
    public let deploymentStatus: ConfigurationDeploymentStatus?
    /// <p>Describes this configuration set.</p>
    public let description: String?
    /// <p> If not <code>null</code>, the name of the environment for this configuration set.
    ///     </p>
    public let environmentName: String?
    /// <p>A list of the configuration options and their values in this configuration
    ///       set.</p>
    public let optionSettings: [ConfigurationOptionSetting]?
    /// <p>The ARN of the platform version.</p>
    public let platformArn: String?
    /// <p>The name of the solution stack this configuration set uses.</p>
    public let solutionStackName: String?
    /// <p> If not <code>null</code>, the name of the configuration template for this
    ///       configuration set. </p>
    public let templateName: String?

    public init (
        applicationName: String? = nil,
        dateCreated: Date? = nil,
        dateUpdated: Date? = nil,
        deploymentStatus: ConfigurationDeploymentStatus? = nil,
        description: String? = nil,
        environmentName: String? = nil,
        optionSettings: [ConfigurationOptionSetting]? = nil,
        platformArn: String? = nil,
        solutionStackName: String? = nil,
        templateName: String? = nil
    )
    {
        self.applicationName = applicationName
        self.dateCreated = dateCreated
        self.dateUpdated = dateUpdated
        self.deploymentStatus = deploymentStatus
        self.description = description
        self.environmentName = environmentName
        self.optionSettings = optionSettings
        self.platformArn = platformArn
        self.solutionStackName = solutionStackName
        self.templateName = templateName
    }
}

struct CreateConfigurationTemplateOutputResponseBody: Equatable {
    public let solutionStackName: String?
    public let platformArn: String?
    public let applicationName: String?
    public let templateName: String?
    public let description: String?
    public let environmentName: String?
    public let deploymentStatus: ConfigurationDeploymentStatus?
    public let dateCreated: Date?
    public let dateUpdated: Date?
    public let optionSettings: [ConfigurationOptionSetting]?
}

extension CreateConfigurationTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case dateCreated = "DateCreated"
        case dateUpdated = "DateUpdated"
        case deploymentStatus = "DeploymentStatus"
        case description = "Description"
        case environmentName = "EnvironmentName"
        case optionSettings = "OptionSettings"
        case platformArn = "PlatformArn"
        case solutionStackName = "SolutionStackName"
        case templateName = "TemplateName"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateConfigurationTemplateResult"))
        let solutionStackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionStackName)
        solutionStackName = solutionStackNameDecoded
        let platformArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformArn)
        platformArn = platformArnDecoded
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ConfigurationDeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        var dateCreatedBuffer:Date? = nil
        if let dateCreatedDecoded = dateCreatedDecoded {
            dateCreatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateCreatedDecoded, format: .dateTime)
        }
        dateCreated = dateCreatedBuffer
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateUpdated)
        var dateUpdatedBuffer:Date? = nil
        if let dateUpdatedDecoded = dateUpdatedDecoded {
            dateUpdatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateUpdatedDecoded, format: .dateTime)
        }
        dateUpdated = dateUpdatedBuffer
        if containerValues.contains(.optionSettings) {
            struct KeyVal0{struct member{}}
            let optionSettingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .optionSettings)
            if let optionSettingsWrappedContainer = optionSettingsWrappedContainer {
                let optionSettingsContainer = try optionSettingsWrappedContainer.decodeIfPresent([ConfigurationOptionSetting].self, forKey: .member)
                var optionSettingsBuffer:[ConfigurationOptionSetting]? = nil
                if let optionSettingsContainer = optionSettingsContainer {
                    optionSettingsBuffer = [ConfigurationOptionSetting]()
                    for structureContainer0 in optionSettingsContainer {
                        optionSettingsBuffer?.append(structureContainer0)
                    }
                }
                optionSettings = optionSettingsBuffer
            } else {
                optionSettings = []
            }
        } else {
            optionSettings = nil
        }
    }
}

public struct CreateEnvironmentInputBodyMiddleware: Middleware {
    public let id: String = "CreateEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEnvironmentOutputError>
}

extension CreateEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEnvironmentInput(applicationName: \(String(describing: applicationName)), cNAMEPrefix: \(String(describing: cNAMEPrefix)), description: \(String(describing: description)), environmentName: \(String(describing: environmentName)), groupName: \(String(describing: groupName)), operationsRole: \(String(describing: operationsRole)), optionSettings: \(String(describing: optionSettings)), optionsToRemove: \(String(describing: optionsToRemove)), platformArn: \(String(describing: platformArn)), solutionStackName: \(String(describing: solutionStackName)), tags: \(String(describing: tags)), templateName: \(String(describing: templateName)), tier: \(String(describing: tier)), versionLabel: \(String(describing: versionLabel)))"}
}

extension CreateEnvironmentInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let cNAMEPrefix = cNAMEPrefix {
            try container.encode(cNAMEPrefix, forKey: Key("CNAMEPrefix"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        if let groupName = groupName {
            try container.encode(groupName, forKey: Key("GroupName"))
        }
        if let operationsRole = operationsRole {
            try container.encode(operationsRole, forKey: Key("OperationsRole"))
        }
        if let optionSettings = optionSettings {
            var optionSettingsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionSettings"))
            for (index0, configurationoptionsetting0) in optionSettings.enumerated() {
                try optionSettingsContainer.encode(configurationoptionsetting0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let optionsToRemove = optionsToRemove {
            var optionsToRemoveContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionsToRemove"))
            for (index0, optionspecification0) in optionsToRemove.enumerated() {
                try optionsToRemoveContainer.encode(optionspecification0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let platformArn = platformArn {
            try container.encode(platformArn, forKey: Key("PlatformArn"))
        }
        if let solutionStackName = solutionStackName {
            try container.encode(solutionStackName, forKey: Key("SolutionStackName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        if let tier = tier {
            try container.encode(tier, forKey: Key("Tier"))
        }
        if let versionLabel = versionLabel {
            try container.encode(versionLabel, forKey: Key("VersionLabel"))
        }
        try container.encode("CreateEnvironment", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct CreateEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEnvironmentOutputError>
}

public struct CreateEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEnvironmentOutputError>
}

/// <p></p>
public struct CreateEnvironmentInput: Equatable {
    /// <p>The name of the application that is associated with this environment.</p>
    public let applicationName: String?
    /// <p>If specified, the environment attempts to use this value as the prefix for the CNAME in
    ///       your Elastic Beanstalk environment URL. If not specified, the CNAME is generated automatically by
    ///       appending a random alphanumeric string to the environment name.</p>
    public let cNAMEPrefix: String?
    /// <p>Your description for this environment.</p>
    public let description: String?
    /// <p>A unique name for the environment.</p>
    ///          <p>Constraint: Must be from 4 to 40 characters in length. The name can contain only
    ///       letters, numbers, and hyphens. It can't start or end with a hyphen. This name must be unique
    ///       within a region in your account. If the specified name already exists in the region, Elastic Beanstalk returns an
    ///         <code>InvalidParameterValue</code> error. </p>
    ///          <p>If you don't specify the <code>CNAMEPrefix</code> parameter, the environment name becomes part of
    ///       the CNAME, and therefore part of the visible URL for your application.</p>
    public let environmentName: String?
    /// <p>The name of the group to which the target environment belongs. Specify a group name
    ///       only if the environment's name is specified in an environment manifest and not with the
    ///       environment name parameter. See <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/environment-cfg-manifest.html">Environment Manifest
    ///         (env.yaml)</a> for details.</p>
    public let groupName: String?
    /// <p>The Amazon Resource Name (ARN) of an existing IAM role to be used as the environment's
    ///       operations role. If specified, Elastic Beanstalk uses the operations role for permissions to downstream
    ///       services during this call and during subsequent calls acting on this environment. To specify
    ///       an operations role, you must have the <code>iam:PassRole</code> permission for the role. For
    ///       more information, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/iam-operationsrole.html">Operations roles</a> in the
    ///         <i>AWS Elastic Beanstalk Developer Guide</i>.</p>
    public let operationsRole: String?
    /// <p>If specified, AWS Elastic Beanstalk sets the specified configuration options to the
    ///       requested value in the configuration set for the new environment. These override the values
    ///       obtained from the solution stack or the configuration template.</p>
    public let optionSettings: [ConfigurationOptionSetting]?
    /// <p>A list of custom user-defined configuration options to remove from the configuration
    ///       set for this new environment.</p>
    public let optionsToRemove: [OptionSpecification]?
    /// <p>The Amazon Resource Name (ARN) of the custom platform to use with the environment. For
    ///       more information, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/custom-platforms.html">Custom Platforms</a> in the
    ///         <i>AWS Elastic Beanstalk Developer Guide</i>.</p>
    ///          <note>
    ///
    ///             <p>If you specify <code>PlatformArn</code>, don't specify
    ///         <code>SolutionStackName</code>.</p>
    ///          </note>
    public let platformArn: String?
    /// <p>The name of an Elastic Beanstalk solution stack (platform version) to use with the environment. If
    ///       specified, Elastic Beanstalk sets the configuration values to the default values associated with the
    ///       specified solution stack. For a list of current solution stacks, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/platforms/platforms-supported.html">Elastic Beanstalk Supported Platforms</a> in the <i>AWS Elastic Beanstalk
    ///         Platforms</i> guide.</p>
    ///          <note>
    ///             <p>If you specify <code>SolutionStackName</code>, don't specify <code>PlatformArn</code> or
    ///           <code>TemplateName</code>.</p>
    ///          </note>
    public let solutionStackName: String?
    /// <p>Specifies the tags applied to resources in the environment.</p>
    public let tags: [Tag]?
    /// <p>The name of the Elastic Beanstalk configuration template to use with the environment.</p>
    ///          <note>
    ///             <p>If you specify <code>TemplateName</code>, then don't specify
    ///           <code>SolutionStackName</code>.</p>
    ///          </note>
    public let templateName: String?
    /// <p>Specifies the tier to use in creating this environment. The environment tier that you
    ///       choose determines whether Elastic Beanstalk provisions resources to support a web application that handles
    ///       HTTP(S) requests or a web application that handles background-processing tasks.</p>
    public let tier: EnvironmentTier?
    /// <p>The name of the application version to deploy.</p>
    ///          <p>Default: If not specified, Elastic Beanstalk attempts to deploy the sample application.</p>
    public let versionLabel: String?

    public init (
        applicationName: String? = nil,
        cNAMEPrefix: String? = nil,
        description: String? = nil,
        environmentName: String? = nil,
        groupName: String? = nil,
        operationsRole: String? = nil,
        optionSettings: [ConfigurationOptionSetting]? = nil,
        optionsToRemove: [OptionSpecification]? = nil,
        platformArn: String? = nil,
        solutionStackName: String? = nil,
        tags: [Tag]? = nil,
        templateName: String? = nil,
        tier: EnvironmentTier? = nil,
        versionLabel: String? = nil
    )
    {
        self.applicationName = applicationName
        self.cNAMEPrefix = cNAMEPrefix
        self.description = description
        self.environmentName = environmentName
        self.groupName = groupName
        self.operationsRole = operationsRole
        self.optionSettings = optionSettings
        self.optionsToRemove = optionsToRemove
        self.platformArn = platformArn
        self.solutionStackName = solutionStackName
        self.tags = tags
        self.templateName = templateName
        self.tier = tier
        self.versionLabel = versionLabel
    }
}

extension CreateEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyEnvironmentsException" : self = .tooManyEnvironmentsException(try TooManyEnvironmentsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEnvironmentOutputError: Equatable {
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case tooManyEnvironmentsException(TooManyEnvironmentsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEnvironmentOutputResponse(abortableOperationInProgress: \(String(describing: abortableOperationInProgress)), applicationName: \(String(describing: applicationName)), cNAME: \(String(describing: cNAME)), dateCreated: \(String(describing: dateCreated)), dateUpdated: \(String(describing: dateUpdated)), description: \(String(describing: description)), endpointURL: \(String(describing: endpointURL)), environmentArn: \(String(describing: environmentArn)), environmentId: \(String(describing: environmentId)), environmentLinks: \(String(describing: environmentLinks)), environmentName: \(String(describing: environmentName)), health: \(String(describing: health)), healthStatus: \(String(describing: healthStatus)), operationsRole: \(String(describing: operationsRole)), platformArn: \(String(describing: platformArn)), resources: \(String(describing: resources)), solutionStackName: \(String(describing: solutionStackName)), status: \(String(describing: status)), templateName: \(String(describing: templateName)), tier: \(String(describing: tier)), versionLabel: \(String(describing: versionLabel)))"}
}

extension CreateEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.abortableOperationInProgress = output.abortableOperationInProgress
            self.applicationName = output.applicationName
            self.cNAME = output.cNAME
            self.dateCreated = output.dateCreated
            self.dateUpdated = output.dateUpdated
            self.description = output.description
            self.endpointURL = output.endpointURL
            self.environmentArn = output.environmentArn
            self.environmentId = output.environmentId
            self.environmentLinks = output.environmentLinks
            self.environmentName = output.environmentName
            self.health = output.health
            self.healthStatus = output.healthStatus
            self.operationsRole = output.operationsRole
            self.platformArn = output.platformArn
            self.resources = output.resources
            self.solutionStackName = output.solutionStackName
            self.status = output.status
            self.templateName = output.templateName
            self.tier = output.tier
            self.versionLabel = output.versionLabel
        } else {
            self.abortableOperationInProgress = nil
            self.applicationName = nil
            self.cNAME = nil
            self.dateCreated = nil
            self.dateUpdated = nil
            self.description = nil
            self.endpointURL = nil
            self.environmentArn = nil
            self.environmentId = nil
            self.environmentLinks = nil
            self.environmentName = nil
            self.health = nil
            self.healthStatus = nil
            self.operationsRole = nil
            self.platformArn = nil
            self.resources = nil
            self.solutionStackName = nil
            self.status = nil
            self.templateName = nil
            self.tier = nil
            self.versionLabel = nil
        }
    }
}

/// <p>Describes the properties of an environment.</p>
public struct CreateEnvironmentOutputResponse: Equatable {
    /// <p>Indicates if there is an in-progress environment configuration update or application
    ///       version deployment that you can cancel.</p>
    ///          <p>
    ///             <code>true:</code> There is an update in progress. </p>
    ///          <p>
    ///             <code>false:</code> There are no updates currently in progress. </p>
    public let abortableOperationInProgress: Bool?
    /// <p>The name of the application associated with this environment.</p>
    public let applicationName: String?
    /// <p>The URL to the CNAME for this environment.</p>
    public let cNAME: String?
    /// <p>The creation date for this environment.</p>
    public let dateCreated: Date?
    /// <p>The last modified date for this environment.</p>
    public let dateUpdated: Date?
    /// <p>Describes this environment.</p>
    public let description: String?
    /// <p>For load-balanced, autoscaling environments, the URL to the LoadBalancer. For
    ///       single-instance environments, the IP address of the instance.</p>
    public let endpointURL: String?
    /// <p>The environment's Amazon Resource Name (ARN), which can be used in other API requests that require an ARN.</p>
    public let environmentArn: String?
    /// <p>The ID of this environment.</p>
    public let environmentId: String?
    /// <p>A list of links to other environments in the same group.</p>
    public let environmentLinks: [EnvironmentLink]?
    /// <p>The name of this environment.</p>
    public let environmentName: String?
    /// <p>Describes the health status of the environment. AWS Elastic Beanstalk indicates the
    ///       failure levels for a running environment:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Red</code>: Indicates the environment is not responsive. Occurs when three or more
    ///           consecutive failures occur for an environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Yellow</code>: Indicates that something is wrong. Occurs when two consecutive
    ///           failures occur for an environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Green</code>: Indicates the environment is healthy and fully functional.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Grey</code>: Default health for a new environment. The environment is not fully
    ///           launched and health checks have not started or health checks are suspended during an
    ///             <code>UpdateEnvironment</code> or <code>RestartEnvironment</code> request.</p>
    ///             </li>
    ///          </ul>
    ///          <p> Default: <code>Grey</code>
    ///          </p>
    public let health: EnvironmentHealth?
    /// <p>Returns the health status of the application running in your environment. For more
    ///       information, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/health-enhanced-status.html">Health Colors and
    ///         Statuses</a>.</p>
    public let healthStatus: EnvironmentHealthStatus?
    /// <p>The Amazon Resource Name (ARN) of the environment's operations role. For more information,
    ///       see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/iam-operationsrole.html">Operations roles</a> in the <i>AWS Elastic Beanstalk Developer Guide</i>.</p>
    public let operationsRole: String?
    /// <p>The ARN of the platform version.</p>
    public let platformArn: String?
    /// <p>The description of the AWS resources used by this environment.</p>
    public let resources: EnvironmentResourcesDescription?
    /// <p> The name of the <code>SolutionStack</code> deployed with this environment. </p>
    public let solutionStackName: String?
    /// <p>The current operational status of the environment:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Launching</code>: Environment is in the process of initial deployment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Updating</code>: Environment is in the process of updating its configuration
    ///           settings or application version.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Ready</code>: Environment is available to have an action performed on it, such as
    ///           update or terminate.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Terminating</code>: Environment is in the shut-down process.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Terminated</code>: Environment is not running.</p>
    ///             </li>
    ///          </ul>
    public let status: EnvironmentStatus?
    /// <p>The name of the configuration template used to originally launch this
    ///       environment.</p>
    public let templateName: String?
    /// <p>Describes the current tier of this environment.</p>
    public let tier: EnvironmentTier?
    /// <p>The application version deployed in this environment.</p>
    public let versionLabel: String?

    public init (
        abortableOperationInProgress: Bool? = nil,
        applicationName: String? = nil,
        cNAME: String? = nil,
        dateCreated: Date? = nil,
        dateUpdated: Date? = nil,
        description: String? = nil,
        endpointURL: String? = nil,
        environmentArn: String? = nil,
        environmentId: String? = nil,
        environmentLinks: [EnvironmentLink]? = nil,
        environmentName: String? = nil,
        health: EnvironmentHealth? = nil,
        healthStatus: EnvironmentHealthStatus? = nil,
        operationsRole: String? = nil,
        platformArn: String? = nil,
        resources: EnvironmentResourcesDescription? = nil,
        solutionStackName: String? = nil,
        status: EnvironmentStatus? = nil,
        templateName: String? = nil,
        tier: EnvironmentTier? = nil,
        versionLabel: String? = nil
    )
    {
        self.abortableOperationInProgress = abortableOperationInProgress
        self.applicationName = applicationName
        self.cNAME = cNAME
        self.dateCreated = dateCreated
        self.dateUpdated = dateUpdated
        self.description = description
        self.endpointURL = endpointURL
        self.environmentArn = environmentArn
        self.environmentId = environmentId
        self.environmentLinks = environmentLinks
        self.environmentName = environmentName
        self.health = health
        self.healthStatus = healthStatus
        self.operationsRole = operationsRole
        self.platformArn = platformArn
        self.resources = resources
        self.solutionStackName = solutionStackName
        self.status = status
        self.templateName = templateName
        self.tier = tier
        self.versionLabel = versionLabel
    }
}

struct CreateEnvironmentOutputResponseBody: Equatable {
    public let environmentName: String?
    public let environmentId: String?
    public let applicationName: String?
    public let versionLabel: String?
    public let solutionStackName: String?
    public let platformArn: String?
    public let templateName: String?
    public let description: String?
    public let endpointURL: String?
    public let cNAME: String?
    public let dateCreated: Date?
    public let dateUpdated: Date?
    public let status: EnvironmentStatus?
    public let abortableOperationInProgress: Bool?
    public let health: EnvironmentHealth?
    public let healthStatus: EnvironmentHealthStatus?
    public let resources: EnvironmentResourcesDescription?
    public let tier: EnvironmentTier?
    public let environmentLinks: [EnvironmentLink]?
    public let environmentArn: String?
    public let operationsRole: String?
}

extension CreateEnvironmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case abortableOperationInProgress = "AbortableOperationInProgress"
        case applicationName = "ApplicationName"
        case cNAME = "CNAME"
        case dateCreated = "DateCreated"
        case dateUpdated = "DateUpdated"
        case description = "Description"
        case endpointURL = "EndpointURL"
        case environmentArn = "EnvironmentArn"
        case environmentId = "EnvironmentId"
        case environmentLinks = "EnvironmentLinks"
        case environmentName = "EnvironmentName"
        case health = "Health"
        case healthStatus = "HealthStatus"
        case operationsRole = "OperationsRole"
        case platformArn = "PlatformArn"
        case resources = "Resources"
        case solutionStackName = "SolutionStackName"
        case status = "Status"
        case templateName = "TemplateName"
        case tier = "Tier"
        case versionLabel = "VersionLabel"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateEnvironmentResult"))
        let environmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let versionLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionLabel)
        versionLabel = versionLabelDecoded
        let solutionStackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionStackName)
        solutionStackName = solutionStackNameDecoded
        let platformArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformArn)
        platformArn = platformArnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let endpointURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointURL)
        endpointURL = endpointURLDecoded
        let cNAMEDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cNAME)
        cNAME = cNAMEDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        var dateCreatedBuffer:Date? = nil
        if let dateCreatedDecoded = dateCreatedDecoded {
            dateCreatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateCreatedDecoded, format: .dateTime)
        }
        dateCreated = dateCreatedBuffer
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateUpdated)
        var dateUpdatedBuffer:Date? = nil
        if let dateUpdatedDecoded = dateUpdatedDecoded {
            dateUpdatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateUpdatedDecoded, format: .dateTime)
        }
        dateUpdated = dateUpdatedBuffer
        let statusDecoded = try containerValues.decodeIfPresent(EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let abortableOperationInProgressDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .abortableOperationInProgress)
        abortableOperationInProgress = abortableOperationInProgressDecoded
        let healthDecoded = try containerValues.decodeIfPresent(EnvironmentHealth.self, forKey: .health)
        health = healthDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(EnvironmentHealthStatus.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(EnvironmentResourcesDescription.self, forKey: .resources)
        resources = resourcesDecoded
        let tierDecoded = try containerValues.decodeIfPresent(EnvironmentTier.self, forKey: .tier)
        tier = tierDecoded
        if containerValues.contains(.environmentLinks) {
            struct KeyVal0{struct member{}}
            let environmentLinksWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .environmentLinks)
            if let environmentLinksWrappedContainer = environmentLinksWrappedContainer {
                let environmentLinksContainer = try environmentLinksWrappedContainer.decodeIfPresent([EnvironmentLink].self, forKey: .member)
                var environmentLinksBuffer:[EnvironmentLink]? = nil
                if let environmentLinksContainer = environmentLinksContainer {
                    environmentLinksBuffer = [EnvironmentLink]()
                    for structureContainer0 in environmentLinksContainer {
                        environmentLinksBuffer?.append(structureContainer0)
                    }
                }
                environmentLinks = environmentLinksBuffer
            } else {
                environmentLinks = []
            }
        } else {
            environmentLinks = nil
        }
        let environmentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentArn)
        environmentArn = environmentArnDecoded
        let operationsRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationsRole)
        operationsRole = operationsRoleDecoded
    }
}

public struct CreatePlatformVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreatePlatformVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePlatformVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePlatformVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePlatformVersionInput>
    public typealias MOutput = OperationOutput<CreatePlatformVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePlatformVersionOutputError>
}

extension CreatePlatformVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePlatformVersionInput(environmentName: \(String(describing: environmentName)), optionSettings: \(String(describing: optionSettings)), platformDefinitionBundle: \(String(describing: platformDefinitionBundle)), platformName: \(String(describing: platformName)), platformVersion: \(String(describing: platformVersion)), tags: \(String(describing: tags)))"}
}

extension CreatePlatformVersionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        if let optionSettings = optionSettings {
            var optionSettingsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionSettings"))
            for (index0, configurationoptionsetting0) in optionSettings.enumerated() {
                try optionSettingsContainer.encode(configurationoptionsetting0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let platformDefinitionBundle = platformDefinitionBundle {
            try container.encode(platformDefinitionBundle, forKey: Key("PlatformDefinitionBundle"))
        }
        if let platformName = platformName {
            try container.encode(platformName, forKey: Key("PlatformName"))
        }
        if let platformVersion = platformVersion {
            try container.encode(platformVersion, forKey: Key("PlatformVersion"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreatePlatformVersion", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct CreatePlatformVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePlatformVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePlatformVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePlatformVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePlatformVersionInput>
    public typealias MOutput = OperationOutput<CreatePlatformVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePlatformVersionOutputError>
}

public struct CreatePlatformVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePlatformVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePlatformVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePlatformVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePlatformVersionInput>
    public typealias MOutput = OperationOutput<CreatePlatformVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePlatformVersionOutputError>
}

/// <p>Request to create a new platform version.</p>
public struct CreatePlatformVersionInput: Equatable {
    /// <p>The name of the builder environment.</p>
    public let environmentName: String?
    /// <p>The configuration option settings to apply to the builder environment.</p>
    public let optionSettings: [ConfigurationOptionSetting]?
    /// <p>The location of the platform definition archive in Amazon S3.</p>
    public let platformDefinitionBundle: S3Location?
    /// <p>The name of your custom platform.</p>
    public let platformName: String?
    /// <p>The number, such as 1.0.2, for the new platform version.</p>
    public let platformVersion: String?
    /// <p>Specifies the tags applied to the new platform version.</p>
    ///          <p>Elastic Beanstalk applies these tags only to the platform version. Environments that you create using
    ///       the platform version don't inherit the tags.</p>
    public let tags: [Tag]?

    public init (
        environmentName: String? = nil,
        optionSettings: [ConfigurationOptionSetting]? = nil,
        platformDefinitionBundle: S3Location? = nil,
        platformName: String? = nil,
        platformVersion: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.environmentName = environmentName
        self.optionSettings = optionSettings
        self.platformDefinitionBundle = platformDefinitionBundle
        self.platformName = platformName
        self.platformVersion = platformVersion
        self.tags = tags
    }
}

extension CreatePlatformVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreatePlatformVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ElasticBeanstalkServiceException" : self = .elasticBeanstalkServiceException(try ElasticBeanstalkServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyPlatformsException" : self = .tooManyPlatformsException(try TooManyPlatformsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePlatformVersionOutputError: Equatable {
    case elasticBeanstalkServiceException(ElasticBeanstalkServiceException)
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case tooManyPlatformsException(TooManyPlatformsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePlatformVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePlatformVersionOutputResponse(builder: \(String(describing: builder)), platformSummary: \(String(describing: platformSummary)))"}
}

extension CreatePlatformVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePlatformVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.builder = output.builder
            self.platformSummary = output.platformSummary
        } else {
            self.builder = nil
            self.platformSummary = nil
        }
    }
}

public struct CreatePlatformVersionOutputResponse: Equatable {
    /// <p>The builder used to create the custom platform.</p>
    public let builder: Builder?
    /// <p>Detailed information about the new version of the custom platform.</p>
    public let platformSummary: PlatformSummary?

    public init (
        builder: Builder? = nil,
        platformSummary: PlatformSummary? = nil
    )
    {
        self.builder = builder
        self.platformSummary = platformSummary
    }
}

struct CreatePlatformVersionOutputResponseBody: Equatable {
    public let platformSummary: PlatformSummary?
    public let builder: Builder?
}

extension CreatePlatformVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case builder = "Builder"
        case platformSummary = "PlatformSummary"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreatePlatformVersionResult"))
        let platformSummaryDecoded = try containerValues.decodeIfPresent(PlatformSummary.self, forKey: .platformSummary)
        platformSummary = platformSummaryDecoded
        let builderDecoded = try containerValues.decodeIfPresent(Builder.self, forKey: .builder)
        builder = builderDecoded
    }
}

public struct CreateStorageLocationInputBodyMiddleware: Middleware {
    public let id: String = "CreateStorageLocationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStorageLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStorageLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStorageLocationInput>
    public typealias MOutput = OperationOutput<CreateStorageLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStorageLocationOutputError>
}

extension CreateStorageLocationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStorageLocationInput()"}
}

extension CreateStorageLocationInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("CreateStorageLocation", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct CreateStorageLocationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStorageLocationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStorageLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStorageLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStorageLocationInput>
    public typealias MOutput = OperationOutput<CreateStorageLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStorageLocationOutputError>
}

public struct CreateStorageLocationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStorageLocationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStorageLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStorageLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStorageLocationInput>
    public typealias MOutput = OperationOutput<CreateStorageLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStorageLocationOutputError>
}

public struct CreateStorageLocationInput: Equatable {

    public init() {}
}

extension CreateStorageLocationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateStorageLocationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3SubscriptionRequiredException" : self = .s3SubscriptionRequiredException(try S3SubscriptionRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyBucketsException" : self = .tooManyBucketsException(try TooManyBucketsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStorageLocationOutputError: Equatable {
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case s3SubscriptionRequiredException(S3SubscriptionRequiredException)
    case tooManyBucketsException(TooManyBucketsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStorageLocationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStorageLocationOutputResponse(s3Bucket: \(String(describing: s3Bucket)))"}
}

extension CreateStorageLocationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateStorageLocationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.s3Bucket = output.s3Bucket
        } else {
            self.s3Bucket = nil
        }
    }
}

/// <p>Results of a <a>CreateStorageLocationResult</a> call.</p>
public struct CreateStorageLocationOutputResponse: Equatable {
    /// <p>The name of the Amazon S3 bucket created.</p>
    public let s3Bucket: String?

    public init (
        s3Bucket: String? = nil
    )
    {
        self.s3Bucket = s3Bucket
    }
}

struct CreateStorageLocationOutputResponseBody: Equatable {
    public let s3Bucket: String?
}

extension CreateStorageLocationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case s3Bucket = "S3Bucket"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateStorageLocationResult"))
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
    }
}

extension CustomAmi: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageId = "ImageId"
        case virtualizationType = "VirtualizationType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let imageId = imageId {
            try container.encode(imageId, forKey: Key("ImageId"))
        }
        if let virtualizationType = virtualizationType {
            try container.encode(virtualizationType, forKey: Key("VirtualizationType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualizationTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualizationType)
        virtualizationType = virtualizationTypeDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

extension CustomAmi: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomAmi(imageId: \(String(describing: imageId)), virtualizationType: \(String(describing: virtualizationType)))"}
}

/// <p>A custom AMI available to platforms.</p>
public struct CustomAmi: Equatable {
    /// <p>THe ID of the image used to create the custom AMI.</p>
    public let imageId: String?
    /// <p>The type of virtualization used to create the custom AMI.</p>
    public let virtualizationType: String?

    public init (
        imageId: String? = nil,
        virtualizationType: String? = nil
    )
    {
        self.imageId = imageId
        self.virtualizationType = virtualizationType
    }
}

public struct DeleteApplicationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputError>
}

extension DeleteApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationInput(applicationName: \(String(describing: applicationName)), terminateEnvByForce: \(String(describing: terminateEnvByForce)))"}
}

extension DeleteApplicationInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let terminateEnvByForce = terminateEnvByForce {
            try container.encode(terminateEnvByForce, forKey: Key("TerminateEnvByForce"))
        }
        try container.encode("DeleteApplication", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DeleteApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputError>
}

/// <p>Request to delete an application.</p>
public struct DeleteApplicationInput: Equatable {
    /// <p>The name of the application to delete.</p>
    public let applicationName: String?
    /// <p>When set to true, running environments will be terminated before deleting the
    ///       application.</p>
    public let terminateEnvByForce: Bool?

    public init (
        applicationName: String? = nil,
        terminateEnvByForce: Bool? = nil
    )
    {
        self.applicationName = applicationName
        self.terminateEnvByForce = terminateEnvByForce
    }
}

extension DeleteApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OperationInProgressException" : self = .operationInProgressException(try OperationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationOutputError: Equatable {
    case operationInProgressException(OperationInProgressException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationOutputResponse()"}
}

extension DeleteApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationOutputResponse: Equatable {

    public init() {}
}

struct DeleteApplicationOutputResponseBody: Equatable {
}

extension DeleteApplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteApplicationVersionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteApplicationVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationVersionInput>
    public typealias MOutput = OperationOutput<DeleteApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationVersionOutputError>
}

extension DeleteApplicationVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationVersionInput(applicationName: \(String(describing: applicationName)), deleteSourceBundle: \(String(describing: deleteSourceBundle)), versionLabel: \(String(describing: versionLabel)))"}
}

extension DeleteApplicationVersionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let deleteSourceBundle = deleteSourceBundle {
            try container.encode(deleteSourceBundle, forKey: Key("DeleteSourceBundle"))
        }
        if let versionLabel = versionLabel {
            try container.encode(versionLabel, forKey: Key("VersionLabel"))
        }
        try container.encode("DeleteApplicationVersion", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DeleteApplicationVersionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApplicationVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationVersionInput>
    public typealias MOutput = OperationOutput<DeleteApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationVersionOutputError>
}

public struct DeleteApplicationVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApplicationVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationVersionInput>
    public typealias MOutput = OperationOutput<DeleteApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationVersionOutputError>
}

/// <p>Request to delete an application version.</p>
public struct DeleteApplicationVersionInput: Equatable {
    /// <p>The name of the application to which the version belongs.</p>
    public let applicationName: String?
    /// <p>Set to <code>true</code> to delete the source bundle from your storage bucket.
    ///       Otherwise, the application version is deleted only from Elastic Beanstalk and the source
    ///       bundle remains in Amazon S3.</p>
    public let deleteSourceBundle: Bool?
    /// <p>The label of the version to delete.</p>
    public let versionLabel: String?

    public init (
        applicationName: String? = nil,
        deleteSourceBundle: Bool? = nil,
        versionLabel: String? = nil
    )
    {
        self.applicationName = applicationName
        self.deleteSourceBundle = deleteSourceBundle
        self.versionLabel = versionLabel
    }
}

extension DeleteApplicationVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteApplicationVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationInProgressException" : self = .operationInProgressException(try OperationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3LocationNotInServiceRegionException" : self = .s3LocationNotInServiceRegionException(try S3LocationNotInServiceRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SourceBundleDeletionException" : self = .sourceBundleDeletionException(try SourceBundleDeletionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationVersionOutputError: Equatable {
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case operationInProgressException(OperationInProgressException)
    case s3LocationNotInServiceRegionException(S3LocationNotInServiceRegionException)
    case sourceBundleDeletionException(SourceBundleDeletionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationVersionOutputResponse()"}
}

extension DeleteApplicationVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationVersionOutputResponse: Equatable {

    public init() {}
}

struct DeleteApplicationVersionOutputResponseBody: Equatable {
}

extension DeleteApplicationVersionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteConfigurationTemplateInputBodyMiddleware: Middleware {
    public let id: String = "DeleteConfigurationTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationTemplateInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationTemplateOutputError>
}

extension DeleteConfigurationTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationTemplateInput(applicationName: \(String(describing: applicationName)), templateName: \(String(describing: templateName)))"}
}

extension DeleteConfigurationTemplateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        try container.encode("DeleteConfigurationTemplate", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DeleteConfigurationTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConfigurationTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationTemplateInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationTemplateOutputError>
}

public struct DeleteConfigurationTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConfigurationTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationTemplateInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationTemplateOutputError>
}

/// <p>Request to delete a configuration template.</p>
public struct DeleteConfigurationTemplateInput: Equatable {
    /// <p>The name of the application to delete the configuration template from.</p>
    public let applicationName: String?
    /// <p>The name of the configuration template to delete.</p>
    public let templateName: String?

    public init (
        applicationName: String? = nil,
        templateName: String? = nil
    )
    {
        self.applicationName = applicationName
        self.templateName = templateName
    }
}

extension DeleteConfigurationTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteConfigurationTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OperationInProgressException" : self = .operationInProgressException(try OperationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationTemplateOutputError: Equatable {
    case operationInProgressException(OperationInProgressException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationTemplateOutputResponse()"}
}

extension DeleteConfigurationTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConfigurationTemplateOutputResponse: Equatable {

    public init() {}
}

struct DeleteConfigurationTemplateOutputResponseBody: Equatable {
}

extension DeleteConfigurationTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteEnvironmentConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteEnvironmentConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEnvironmentConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEnvironmentConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEnvironmentConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteEnvironmentConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEnvironmentConfigurationOutputError>
}

extension DeleteEnvironmentConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEnvironmentConfigurationInput(applicationName: \(String(describing: applicationName)), environmentName: \(String(describing: environmentName)))"}
}

extension DeleteEnvironmentConfigurationInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        try container.encode("DeleteEnvironmentConfiguration", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DeleteEnvironmentConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEnvironmentConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEnvironmentConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEnvironmentConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEnvironmentConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteEnvironmentConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEnvironmentConfigurationOutputError>
}

public struct DeleteEnvironmentConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEnvironmentConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEnvironmentConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEnvironmentConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEnvironmentConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteEnvironmentConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEnvironmentConfigurationOutputError>
}

/// <p>Request to delete a draft environment configuration.</p>
public struct DeleteEnvironmentConfigurationInput: Equatable {
    /// <p>The name of the application the environment is associated with.</p>
    public let applicationName: String?
    /// <p>The name of the environment to delete the draft configuration from.</p>
    public let environmentName: String?

    public init (
        applicationName: String? = nil,
        environmentName: String? = nil
    )
    {
        self.applicationName = applicationName
        self.environmentName = environmentName
    }
}

extension DeleteEnvironmentConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteEnvironmentConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEnvironmentConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEnvironmentConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEnvironmentConfigurationOutputResponse()"}
}

extension DeleteEnvironmentConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEnvironmentConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteEnvironmentConfigurationOutputResponseBody: Equatable {
}

extension DeleteEnvironmentConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePlatformVersionInputBodyMiddleware: Middleware {
    public let id: String = "DeletePlatformVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePlatformVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePlatformVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePlatformVersionInput>
    public typealias MOutput = OperationOutput<DeletePlatformVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePlatformVersionOutputError>
}

extension DeletePlatformVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePlatformVersionInput(platformArn: \(String(describing: platformArn)))"}
}

extension DeletePlatformVersionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let platformArn = platformArn {
            try container.encode(platformArn, forKey: Key("PlatformArn"))
        }
        try container.encode("DeletePlatformVersion", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DeletePlatformVersionInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePlatformVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePlatformVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePlatformVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePlatformVersionInput>
    public typealias MOutput = OperationOutput<DeletePlatformVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePlatformVersionOutputError>
}

public struct DeletePlatformVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePlatformVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePlatformVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePlatformVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePlatformVersionInput>
    public typealias MOutput = OperationOutput<DeletePlatformVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePlatformVersionOutputError>
}

public struct DeletePlatformVersionInput: Equatable {
    /// <p>The ARN of the version of the custom platform.</p>
    public let platformArn: String?

    public init (
        platformArn: String? = nil
    )
    {
        self.platformArn = platformArn
    }
}

extension DeletePlatformVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeletePlatformVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ElasticBeanstalkServiceException" : self = .elasticBeanstalkServiceException(try ElasticBeanstalkServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationInProgressException" : self = .operationInProgressException(try OperationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PlatformVersionStillReferencedException" : self = .platformVersionStillReferencedException(try PlatformVersionStillReferencedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePlatformVersionOutputError: Equatable {
    case elasticBeanstalkServiceException(ElasticBeanstalkServiceException)
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case operationInProgressException(OperationInProgressException)
    case platformVersionStillReferencedException(PlatformVersionStillReferencedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePlatformVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePlatformVersionOutputResponse(platformSummary: \(String(describing: platformSummary)))"}
}

extension DeletePlatformVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeletePlatformVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.platformSummary = output.platformSummary
        } else {
            self.platformSummary = nil
        }
    }
}

public struct DeletePlatformVersionOutputResponse: Equatable {
    /// <p>Detailed information about the version of the custom platform.</p>
    public let platformSummary: PlatformSummary?

    public init (
        platformSummary: PlatformSummary? = nil
    )
    {
        self.platformSummary = platformSummary
    }
}

struct DeletePlatformVersionOutputResponseBody: Equatable {
    public let platformSummary: PlatformSummary?
}

extension DeletePlatformVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case platformSummary = "PlatformSummary"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeletePlatformVersionResult"))
        let platformSummaryDecoded = try containerValues.decodeIfPresent(PlatformSummary.self, forKey: .platformSummary)
        platformSummary = platformSummaryDecoded
    }
}

extension Deployment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deploymentId = "DeploymentId"
        case deploymentTime = "DeploymentTime"
        case status = "Status"
        case versionLabel = "VersionLabel"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let deploymentId = deploymentId {
            try container.encode(deploymentId, forKey: Key("DeploymentId"))
        }
        if let deploymentTime = deploymentTime {
            try container.encode(TimestampWrapper(deploymentTime, format: .dateTime), forKey: Key("deploymentTime"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let versionLabel = versionLabel {
            try container.encode(versionLabel, forKey: Key("VersionLabel"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionLabel)
        versionLabel = versionLabelDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let deploymentTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentTime)
        var deploymentTimeBuffer:Date? = nil
        if let deploymentTimeDecoded = deploymentTimeDecoded {
            deploymentTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(deploymentTimeDecoded, format: .dateTime)
        }
        deploymentTime = deploymentTimeBuffer
    }
}

extension Deployment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Deployment(deploymentId: \(String(describing: deploymentId)), deploymentTime: \(String(describing: deploymentTime)), status: \(String(describing: status)), versionLabel: \(String(describing: versionLabel)))"}
}

/// <p>Information about an application version deployment.</p>
public struct Deployment: Equatable {
    /// <p>The ID of the deployment. This number increases by one each time that you deploy source
    ///       code or change instance configuration settings.</p>
    public let deploymentId: Int?
    /// <p>For in-progress deployments, the time that the deployment started.</p>
    ///          <p>For completed deployments, the time that the deployment ended.</p>
    public let deploymentTime: Date?
    /// <p>The status of the deployment:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>In Progress</code> : The deployment is in progress.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Deployed</code> : The deployment succeeded.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Failed</code> : The deployment failed.</p>
    ///             </li>
    ///          </ul>
    public let status: String?
    /// <p>The version label of the application version in the deployment.</p>
    public let versionLabel: String?

    public init (
        deploymentId: Int? = nil,
        deploymentTime: Date? = nil,
        status: String? = nil,
        versionLabel: String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.deploymentTime = deploymentTime
        self.status = status
        self.versionLabel = versionLabel
    }
}

public struct DescribeAccountAttributesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAccountAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAttributesOutputError>
}

extension DescribeAccountAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountAttributesInput()"}
}

extension DescribeAccountAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("DescribeAccountAttributes", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DescribeAccountAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccountAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAttributesOutputError>
}

public struct DescribeAccountAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccountAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAttributesOutputError>
}

public struct DescribeAccountAttributesInput: Equatable {

    public init() {}
}

extension DescribeAccountAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeAccountAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountAttributesOutputError: Equatable {
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountAttributesOutputResponse(resourceQuotas: \(String(describing: resourceQuotas)))"}
}

extension DescribeAccountAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccountAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceQuotas = output.resourceQuotas
        } else {
            self.resourceQuotas = nil
        }
    }
}

public struct DescribeAccountAttributesOutputResponse: Equatable {
    /// <p>The Elastic Beanstalk resource quotas associated with the calling AWS account.</p>
    public let resourceQuotas: ResourceQuotas?

    public init (
        resourceQuotas: ResourceQuotas? = nil
    )
    {
        self.resourceQuotas = resourceQuotas
    }
}

struct DescribeAccountAttributesOutputResponseBody: Equatable {
    public let resourceQuotas: ResourceQuotas?
}

extension DescribeAccountAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceQuotas = "ResourceQuotas"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeAccountAttributesResult"))
        let resourceQuotasDecoded = try containerValues.decodeIfPresent(ResourceQuotas.self, forKey: .resourceQuotas)
        resourceQuotas = resourceQuotasDecoded
    }
}

public struct DescribeApplicationVersionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeApplicationVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationVersionsInput>
    public typealias MOutput = OperationOutput<DescribeApplicationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationVersionsOutputError>
}

extension DescribeApplicationVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApplicationVersionsInput(applicationName: \(String(describing: applicationName)), maxRecords: \(String(describing: maxRecords)), nextToken: \(String(describing: nextToken)), versionLabels: \(String(describing: versionLabels)))"}
}

extension DescribeApplicationVersionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        if let versionLabels = versionLabels {
            var versionLabelsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VersionLabels"))
            for (index0, versionlabel0) in versionLabels.enumerated() {
                try versionLabelsContainer.encode(versionlabel0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeApplicationVersions", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DescribeApplicationVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeApplicationVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationVersionsInput>
    public typealias MOutput = OperationOutput<DescribeApplicationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationVersionsOutputError>
}

public struct DescribeApplicationVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeApplicationVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationVersionsInput>
    public typealias MOutput = OperationOutput<DescribeApplicationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationVersionsOutputError>
}

/// <p>Request to describe application versions.</p>
public struct DescribeApplicationVersionsInput: Equatable {
    /// <p>Specify an application name to show only application versions for that
    ///       application.</p>
    public let applicationName: String?
    /// <p>For a paginated request. Specify a maximum number of application versions to include in
    ///       each response.</p>
    ///          <p>If no <code>MaxRecords</code> is specified, all available application versions are
    ///       retrieved in a single response.</p>
    public let maxRecords: Int?
    /// <p>For a paginated request. Specify a token from a previous response page to retrieve the next response page. All other
    ///       parameter values must be identical to the ones specified in the initial request.</p>
    ///          <p>If no <code>NextToken</code> is specified, the first page is retrieved.</p>
    public let nextToken: String?
    /// <p>Specify a version label to show a specific application version.</p>
    public let versionLabels: [String]?

    public init (
        applicationName: String? = nil,
        maxRecords: Int? = nil,
        nextToken: String? = nil,
        versionLabels: [String]? = nil
    )
    {
        self.applicationName = applicationName
        self.maxRecords = maxRecords
        self.nextToken = nextToken
        self.versionLabels = versionLabels
    }
}

extension DescribeApplicationVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeApplicationVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeApplicationVersionsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicationVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApplicationVersionsOutputResponse(applicationVersions: \(String(describing: applicationVersions)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeApplicationVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeApplicationVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationVersions = output.applicationVersions
            self.nextToken = output.nextToken
        } else {
            self.applicationVersions = nil
            self.nextToken = nil
        }
    }
}

/// <p>Result message wrapping a list of application version descriptions.</p>
public struct DescribeApplicationVersionsOutputResponse: Equatable {
    /// <p>List of <code>ApplicationVersionDescription</code> objects sorted in order of
    ///       creation.</p>
    public let applicationVersions: [ApplicationVersionDescription]?
    /// <p>In a paginated request, the token that you can pass in a subsequent request to get the
    ///       next response page.</p>
    public let nextToken: String?

    public init (
        applicationVersions: [ApplicationVersionDescription]? = nil,
        nextToken: String? = nil
    )
    {
        self.applicationVersions = applicationVersions
        self.nextToken = nextToken
    }
}

struct DescribeApplicationVersionsOutputResponseBody: Equatable {
    public let applicationVersions: [ApplicationVersionDescription]?
    public let nextToken: String?
}

extension DescribeApplicationVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationVersions = "ApplicationVersions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeApplicationVersionsResult"))
        if containerValues.contains(.applicationVersions) {
            struct KeyVal0{struct member{}}
            let applicationVersionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .applicationVersions)
            if let applicationVersionsWrappedContainer = applicationVersionsWrappedContainer {
                let applicationVersionsContainer = try applicationVersionsWrappedContainer.decodeIfPresent([ApplicationVersionDescription].self, forKey: .member)
                var applicationVersionsBuffer:[ApplicationVersionDescription]? = nil
                if let applicationVersionsContainer = applicationVersionsContainer {
                    applicationVersionsBuffer = [ApplicationVersionDescription]()
                    for structureContainer0 in applicationVersionsContainer {
                        applicationVersionsBuffer?.append(structureContainer0)
                    }
                }
                applicationVersions = applicationVersionsBuffer
            } else {
                applicationVersions = []
            }
        } else {
            applicationVersions = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeApplicationsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeApplicationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationsInput>
    public typealias MOutput = OperationOutput<DescribeApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationsOutputError>
}

extension DescribeApplicationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApplicationsInput(applicationNames: \(String(describing: applicationNames)))"}
}

extension DescribeApplicationsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationNames = applicationNames {
            var applicationNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ApplicationNames"))
            for (index0, applicationname0) in applicationNames.enumerated() {
                try applicationNamesContainer.encode(applicationname0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeApplications", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DescribeApplicationsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeApplicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationsInput>
    public typealias MOutput = OperationOutput<DescribeApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationsOutputError>
}

public struct DescribeApplicationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeApplicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationsInput>
    public typealias MOutput = OperationOutput<DescribeApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationsOutputError>
}

/// <p>Request to describe one or more applications.</p>
public struct DescribeApplicationsInput: Equatable {
    /// <p>If specified, AWS Elastic Beanstalk restricts the returned descriptions to only include
    ///       those with the specified names.</p>
    public let applicationNames: [String]?

    public init (
        applicationNames: [String]? = nil
    )
    {
        self.applicationNames = applicationNames
    }
}

extension DescribeApplicationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeApplicationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeApplicationsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApplicationsOutputResponse(applications: \(String(describing: applications)))"}
}

extension DescribeApplicationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applications = output.applications
        } else {
            self.applications = nil
        }
    }
}

/// <p>Result message containing a list of application descriptions.</p>
public struct DescribeApplicationsOutputResponse: Equatable {
    /// <p>This parameter contains a list of <a>ApplicationDescription</a>.</p>
    public let applications: [ApplicationDescription]?

    public init (
        applications: [ApplicationDescription]? = nil
    )
    {
        self.applications = applications
    }
}

struct DescribeApplicationsOutputResponseBody: Equatable {
    public let applications: [ApplicationDescription]?
}

extension DescribeApplicationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applications = "Applications"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeApplicationsResult"))
        if containerValues.contains(.applications) {
            struct KeyVal0{struct member{}}
            let applicationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .applications)
            if let applicationsWrappedContainer = applicationsWrappedContainer {
                let applicationsContainer = try applicationsWrappedContainer.decodeIfPresent([ApplicationDescription].self, forKey: .member)
                var applicationsBuffer:[ApplicationDescription]? = nil
                if let applicationsContainer = applicationsContainer {
                    applicationsBuffer = [ApplicationDescription]()
                    for structureContainer0 in applicationsContainer {
                        applicationsBuffer?.append(structureContainer0)
                    }
                }
                applications = applicationsBuffer
            } else {
                applications = []
            }
        } else {
            applications = nil
        }
    }
}

public struct DescribeConfigurationOptionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConfigurationOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationOptionsInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationOptionsOutputError>
}

extension DescribeConfigurationOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationOptionsInput(applicationName: \(String(describing: applicationName)), environmentName: \(String(describing: environmentName)), options: \(String(describing: options)), platformArn: \(String(describing: platformArn)), solutionStackName: \(String(describing: solutionStackName)), templateName: \(String(describing: templateName)))"}
}

extension DescribeConfigurationOptionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        if let options = options {
            var optionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Options"))
            for (index0, optionspecification0) in options.enumerated() {
                try optionsContainer.encode(optionspecification0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let platformArn = platformArn {
            try container.encode(platformArn, forKey: Key("PlatformArn"))
        }
        if let solutionStackName = solutionStackName {
            try container.encode(solutionStackName, forKey: Key("SolutionStackName"))
        }
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        try container.encode("DescribeConfigurationOptions", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DescribeConfigurationOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConfigurationOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationOptionsInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationOptionsOutputError>
}

public struct DescribeConfigurationOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConfigurationOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationOptionsInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationOptionsOutputError>
}

/// <p>Result message containing a list of application version descriptions.</p>
public struct DescribeConfigurationOptionsInput: Equatable {
    /// <p>The name of the application associated with the configuration template or environment.
    ///       Only needed if you want to describe the configuration options associated with either the
    ///       configuration template or environment.</p>
    public let applicationName: String?
    /// <p>The name of the environment whose configuration options you want to describe.</p>
    public let environmentName: String?
    /// <p>If specified, restricts the descriptions to only the specified options.</p>
    public let options: [OptionSpecification]?
    /// <p>The ARN of the custom platform.</p>
    public let platformArn: String?
    /// <p>The name of the solution stack whose configuration options you want to
    ///       describe.</p>
    public let solutionStackName: String?
    /// <p>The name of the configuration template whose configuration options you want to
    ///       describe.</p>
    public let templateName: String?

    public init (
        applicationName: String? = nil,
        environmentName: String? = nil,
        options: [OptionSpecification]? = nil,
        platformArn: String? = nil,
        solutionStackName: String? = nil,
        templateName: String? = nil
    )
    {
        self.applicationName = applicationName
        self.environmentName = environmentName
        self.options = options
        self.platformArn = platformArn
        self.solutionStackName = solutionStackName
        self.templateName = templateName
    }
}

extension DescribeConfigurationOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeConfigurationOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "TooManyBucketsException" : self = .tooManyBucketsException(try TooManyBucketsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConfigurationOptionsOutputError: Equatable {
    case tooManyBucketsException(TooManyBucketsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationOptionsOutputResponse(options: \(String(describing: options)), platformArn: \(String(describing: platformArn)), solutionStackName: \(String(describing: solutionStackName)))"}
}

extension DescribeConfigurationOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConfigurationOptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.options = output.options
            self.platformArn = output.platformArn
            self.solutionStackName = output.solutionStackName
        } else {
            self.options = nil
            self.platformArn = nil
            self.solutionStackName = nil
        }
    }
}

/// <p>Describes the settings for a specified configuration set.</p>
public struct DescribeConfigurationOptionsOutputResponse: Equatable {
    /// <p> A list of <a>ConfigurationOptionDescription</a>. </p>
    public let options: [ConfigurationOptionDescription]?
    /// <p>The ARN of the platform version.</p>
    public let platformArn: String?
    /// <p>The name of the solution stack these configuration options belong to.</p>
    public let solutionStackName: String?

    public init (
        options: [ConfigurationOptionDescription]? = nil,
        platformArn: String? = nil,
        solutionStackName: String? = nil
    )
    {
        self.options = options
        self.platformArn = platformArn
        self.solutionStackName = solutionStackName
    }
}

struct DescribeConfigurationOptionsOutputResponseBody: Equatable {
    public let solutionStackName: String?
    public let platformArn: String?
    public let options: [ConfigurationOptionDescription]?
}

extension DescribeConfigurationOptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case options = "Options"
        case platformArn = "PlatformArn"
        case solutionStackName = "SolutionStackName"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeConfigurationOptionsResult"))
        let solutionStackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionStackName)
        solutionStackName = solutionStackNameDecoded
        let platformArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformArn)
        platformArn = platformArnDecoded
        if containerValues.contains(.options) {
            struct KeyVal0{struct member{}}
            let optionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .options)
            if let optionsWrappedContainer = optionsWrappedContainer {
                let optionsContainer = try optionsWrappedContainer.decodeIfPresent([ConfigurationOptionDescription].self, forKey: .member)
                var optionsBuffer:[ConfigurationOptionDescription]? = nil
                if let optionsContainer = optionsContainer {
                    optionsBuffer = [ConfigurationOptionDescription]()
                    for structureContainer0 in optionsContainer {
                        optionsBuffer?.append(structureContainer0)
                    }
                }
                options = optionsBuffer
            } else {
                options = []
            }
        } else {
            options = nil
        }
    }
}

public struct DescribeConfigurationSettingsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConfigurationSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationSettingsInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationSettingsOutputError>
}

extension DescribeConfigurationSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationSettingsInput(applicationName: \(String(describing: applicationName)), environmentName: \(String(describing: environmentName)), templateName: \(String(describing: templateName)))"}
}

extension DescribeConfigurationSettingsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        try container.encode("DescribeConfigurationSettings", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DescribeConfigurationSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConfigurationSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationSettingsInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationSettingsOutputError>
}

public struct DescribeConfigurationSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConfigurationSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationSettingsInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationSettingsOutputError>
}

/// <p>Result message containing all of the configuration settings for a specified solution
///       stack or configuration template.</p>
public struct DescribeConfigurationSettingsInput: Equatable {
    /// <p>The application for the environment or configuration template.</p>
    public let applicationName: String?
    /// <p>The name of the environment to describe.</p>
    ///          <p> Condition: You must specify either this or a TemplateName, but not both. If you
    ///       specify both, AWS Elastic Beanstalk returns an <code>InvalidParameterCombination</code> error.
    ///       If you do not specify either, AWS Elastic Beanstalk returns
    ///         <code>MissingRequiredParameter</code> error. </p>
    public let environmentName: String?
    /// <p>The name of the configuration template to describe.</p>
    ///          <p> Conditional: You must specify either this parameter or an EnvironmentName, but not
    ///       both. If you specify both, AWS Elastic Beanstalk returns an
    ///         <code>InvalidParameterCombination</code> error. If you do not specify either, AWS Elastic
    ///       Beanstalk returns a <code>MissingRequiredParameter</code> error. </p>
    public let templateName: String?

    public init (
        applicationName: String? = nil,
        environmentName: String? = nil,
        templateName: String? = nil
    )
    {
        self.applicationName = applicationName
        self.environmentName = environmentName
        self.templateName = templateName
    }
}

extension DescribeConfigurationSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeConfigurationSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "TooManyBucketsException" : self = .tooManyBucketsException(try TooManyBucketsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConfigurationSettingsOutputError: Equatable {
    case tooManyBucketsException(TooManyBucketsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationSettingsOutputResponse(configurationSettings: \(String(describing: configurationSettings)))"}
}

extension DescribeConfigurationSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConfigurationSettingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationSettings = output.configurationSettings
        } else {
            self.configurationSettings = nil
        }
    }
}

/// <p>The results from a request to change the configuration settings of an
///       environment.</p>
public struct DescribeConfigurationSettingsOutputResponse: Equatable {
    /// <p> A list of <a>ConfigurationSettingsDescription</a>. </p>
    public let configurationSettings: [ConfigurationSettingsDescription]?

    public init (
        configurationSettings: [ConfigurationSettingsDescription]? = nil
    )
    {
        self.configurationSettings = configurationSettings
    }
}

struct DescribeConfigurationSettingsOutputResponseBody: Equatable {
    public let configurationSettings: [ConfigurationSettingsDescription]?
}

extension DescribeConfigurationSettingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSettings = "ConfigurationSettings"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeConfigurationSettingsResult"))
        if containerValues.contains(.configurationSettings) {
            struct KeyVal0{struct member{}}
            let configurationSettingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .configurationSettings)
            if let configurationSettingsWrappedContainer = configurationSettingsWrappedContainer {
                let configurationSettingsContainer = try configurationSettingsWrappedContainer.decodeIfPresent([ConfigurationSettingsDescription].self, forKey: .member)
                var configurationSettingsBuffer:[ConfigurationSettingsDescription]? = nil
                if let configurationSettingsContainer = configurationSettingsContainer {
                    configurationSettingsBuffer = [ConfigurationSettingsDescription]()
                    for structureContainer0 in configurationSettingsContainer {
                        configurationSettingsBuffer?.append(structureContainer0)
                    }
                }
                configurationSettings = configurationSettingsBuffer
            } else {
                configurationSettings = []
            }
        } else {
            configurationSettings = nil
        }
    }
}

public struct DescribeEnvironmentHealthInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentHealthInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentHealthInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentHealthInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentHealthOutputError>
}

extension DescribeEnvironmentHealthInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEnvironmentHealthInput(attributeNames: \(String(describing: attributeNames)), environmentId: \(String(describing: environmentId)), environmentName: \(String(describing: environmentName)))"}
}

extension DescribeEnvironmentHealthInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributeNames = attributeNames {
            var attributeNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AttributeNames"))
            for (index0, environmenthealthattribute0) in attributeNames.enumerated() {
                try attributeNamesContainer.encode(environmenthealthattribute0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let environmentId = environmentId {
            try container.encode(environmentId, forKey: Key("EnvironmentId"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        try container.encode("DescribeEnvironmentHealth", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DescribeEnvironmentHealthInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentHealthInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentHealthInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentHealthInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentHealthOutputError>
}

public struct DescribeEnvironmentHealthInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentHealthInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentHealthInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentHealthInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentHealthOutputError>
}

/// <p>See the example below to learn how to create a request body.</p>
public struct DescribeEnvironmentHealthInput: Equatable {
    /// <p>Specify the response elements to return. To retrieve all attributes, set to
    ///         <code>All</code>. If no attribute names are specified, returns the name of the
    ///       environment.</p>
    public let attributeNames: [EnvironmentHealthAttribute]?
    /// <p>Specify the environment by ID.</p>
    ///          <p>You must specify either this or an EnvironmentName, or both.</p>
    public let environmentId: String?
    /// <p>Specify the environment by name.</p>
    ///          <p>You must specify either this or an EnvironmentName, or both.</p>
    public let environmentName: String?

    public init (
        attributeNames: [EnvironmentHealthAttribute]? = nil,
        environmentId: String? = nil,
        environmentName: String? = nil
    )
    {
        self.attributeNames = attributeNames
        self.environmentId = environmentId
        self.environmentName = environmentName
    }
}

extension DescribeEnvironmentHealthOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEnvironmentHealthOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ElasticBeanstalkServiceException" : self = .elasticBeanstalkServiceException(try ElasticBeanstalkServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEnvironmentHealthOutputError: Equatable {
    case elasticBeanstalkServiceException(ElasticBeanstalkServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEnvironmentHealthOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEnvironmentHealthOutputResponse(applicationMetrics: \(String(describing: applicationMetrics)), causes: \(String(describing: causes)), color: \(String(describing: color)), environmentName: \(String(describing: environmentName)), healthStatus: \(String(describing: healthStatus)), instancesHealth: \(String(describing: instancesHealth)), refreshedAt: \(String(describing: refreshedAt)), status: \(String(describing: status)))"}
}

extension DescribeEnvironmentHealthOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEnvironmentHealthOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationMetrics = output.applicationMetrics
            self.causes = output.causes
            self.color = output.color
            self.environmentName = output.environmentName
            self.healthStatus = output.healthStatus
            self.instancesHealth = output.instancesHealth
            self.refreshedAt = output.refreshedAt
            self.status = output.status
        } else {
            self.applicationMetrics = nil
            self.causes = nil
            self.color = nil
            self.environmentName = nil
            self.healthStatus = nil
            self.instancesHealth = nil
            self.refreshedAt = nil
            self.status = nil
        }
    }
}

/// <p>Health details for an AWS Elastic Beanstalk environment.</p>
public struct DescribeEnvironmentHealthOutputResponse: Equatable {
    /// <p>Application request metrics for the environment.</p>
    public let applicationMetrics: ApplicationMetrics?
    /// <p>Descriptions of the data that contributed to the environment's current health
    ///       status.</p>
    public let causes: [String]?
    /// <p>The <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/health-enhanced-status.html">health color</a> of the
    ///       environment.</p>
    public let color: String?
    /// <p>The environment's name.</p>
    public let environmentName: String?
    /// <p>The <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/health-enhanced-status.html">health status</a> of the
    ///       environment. For example, <code>Ok</code>.</p>
    public let healthStatus: String?
    /// <p>Summary health information for the instances in the environment.</p>
    public let instancesHealth: InstanceHealthSummary?
    /// <p>The date and time that the health information was retrieved.</p>
    public let refreshedAt: Date?
    /// <p>The environment's operational status. <code>Ready</code>, <code>Launching</code>,
    ///         <code>Updating</code>, <code>Terminating</code>, or <code>Terminated</code>.</p>
    public let status: EnvironmentHealth?

    public init (
        applicationMetrics: ApplicationMetrics? = nil,
        causes: [String]? = nil,
        color: String? = nil,
        environmentName: String? = nil,
        healthStatus: String? = nil,
        instancesHealth: InstanceHealthSummary? = nil,
        refreshedAt: Date? = nil,
        status: EnvironmentHealth? = nil
    )
    {
        self.applicationMetrics = applicationMetrics
        self.causes = causes
        self.color = color
        self.environmentName = environmentName
        self.healthStatus = healthStatus
        self.instancesHealth = instancesHealth
        self.refreshedAt = refreshedAt
        self.status = status
    }
}

struct DescribeEnvironmentHealthOutputResponseBody: Equatable {
    public let environmentName: String?
    public let healthStatus: String?
    public let status: EnvironmentHealth?
    public let color: String?
    public let causes: [String]?
    public let applicationMetrics: ApplicationMetrics?
    public let instancesHealth: InstanceHealthSummary?
    public let refreshedAt: Date?
}

extension DescribeEnvironmentHealthOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationMetrics = "ApplicationMetrics"
        case causes = "Causes"
        case color = "Color"
        case environmentName = "EnvironmentName"
        case healthStatus = "HealthStatus"
        case instancesHealth = "InstancesHealth"
        case refreshedAt = "RefreshedAt"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEnvironmentHealthResult"))
        let environmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EnvironmentHealth.self, forKey: .status)
        status = statusDecoded
        let colorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .color)
        color = colorDecoded
        if containerValues.contains(.causes) {
            struct KeyVal0{struct member{}}
            let causesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .causes)
            if let causesWrappedContainer = causesWrappedContainer {
                let causesContainer = try causesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var causesBuffer:[String]? = nil
                if let causesContainer = causesContainer {
                    causesBuffer = [String]()
                    for stringContainer0 in causesContainer {
                        causesBuffer?.append(stringContainer0)
                    }
                }
                causes = causesBuffer
            } else {
                causes = []
            }
        } else {
            causes = nil
        }
        let applicationMetricsDecoded = try containerValues.decodeIfPresent(ApplicationMetrics.self, forKey: .applicationMetrics)
        applicationMetrics = applicationMetricsDecoded
        let instancesHealthDecoded = try containerValues.decodeIfPresent(InstanceHealthSummary.self, forKey: .instancesHealth)
        instancesHealth = instancesHealthDecoded
        let refreshedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .refreshedAt)
        var refreshedAtBuffer:Date? = nil
        if let refreshedAtDecoded = refreshedAtDecoded {
            refreshedAtBuffer = try TimestampWrapperDecoder.parseDateStringValue(refreshedAtDecoded, format: .dateTime)
        }
        refreshedAt = refreshedAtBuffer
    }
}

public struct DescribeEnvironmentManagedActionHistoryInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentManagedActionHistoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentManagedActionHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentManagedActionHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentManagedActionHistoryInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentManagedActionHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentManagedActionHistoryOutputError>
}

extension DescribeEnvironmentManagedActionHistoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEnvironmentManagedActionHistoryInput(environmentId: \(String(describing: environmentId)), environmentName: \(String(describing: environmentName)), maxItems: \(String(describing: maxItems)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeEnvironmentManagedActionHistoryInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let environmentId = environmentId {
            try container.encode(environmentId, forKey: Key("EnvironmentId"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        try container.encode("DescribeEnvironmentManagedActionHistory", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DescribeEnvironmentManagedActionHistoryInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentManagedActionHistoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentManagedActionHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentManagedActionHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentManagedActionHistoryInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentManagedActionHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentManagedActionHistoryOutputError>
}

public struct DescribeEnvironmentManagedActionHistoryInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentManagedActionHistoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentManagedActionHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentManagedActionHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentManagedActionHistoryInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentManagedActionHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentManagedActionHistoryOutputError>
}

/// <p>Request to list completed and failed managed actions.</p>
public struct DescribeEnvironmentManagedActionHistoryInput: Equatable {
    /// <p>The environment ID of the target environment.</p>
    public let environmentId: String?
    /// <p>The name of the target environment.</p>
    public let environmentName: String?
    /// <p>The maximum number of items to return for a single request.</p>
    public let maxItems: Int?
    /// <p>The pagination token returned by a previous request.</p>
    public let nextToken: String?

    public init (
        environmentId: String? = nil,
        environmentName: String? = nil,
        maxItems: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.environmentId = environmentId
        self.environmentName = environmentName
        self.maxItems = maxItems
        self.nextToken = nextToken
    }
}

extension DescribeEnvironmentManagedActionHistoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEnvironmentManagedActionHistoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ElasticBeanstalkServiceException" : self = .elasticBeanstalkServiceException(try ElasticBeanstalkServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEnvironmentManagedActionHistoryOutputError: Equatable {
    case elasticBeanstalkServiceException(ElasticBeanstalkServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEnvironmentManagedActionHistoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEnvironmentManagedActionHistoryOutputResponse(managedActionHistoryItems: \(String(describing: managedActionHistoryItems)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeEnvironmentManagedActionHistoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEnvironmentManagedActionHistoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.managedActionHistoryItems = output.managedActionHistoryItems
            self.nextToken = output.nextToken
        } else {
            self.managedActionHistoryItems = nil
            self.nextToken = nil
        }
    }
}

/// <p>A result message containing a list of completed and failed managed actions.</p>
public struct DescribeEnvironmentManagedActionHistoryOutputResponse: Equatable {
    /// <p>A list of completed and failed managed actions.</p>
    public let managedActionHistoryItems: [ManagedActionHistoryItem]?
    /// <p>A pagination token that you pass to <a>DescribeEnvironmentManagedActionHistory</a> to get the next page of
    ///       results.</p>
    public let nextToken: String?

    public init (
        managedActionHistoryItems: [ManagedActionHistoryItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.managedActionHistoryItems = managedActionHistoryItems
        self.nextToken = nextToken
    }
}

struct DescribeEnvironmentManagedActionHistoryOutputResponseBody: Equatable {
    public let managedActionHistoryItems: [ManagedActionHistoryItem]?
    public let nextToken: String?
}

extension DescribeEnvironmentManagedActionHistoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case managedActionHistoryItems = "ManagedActionHistoryItems"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEnvironmentManagedActionHistoryResult"))
        if containerValues.contains(.managedActionHistoryItems) {
            struct KeyVal0{struct member{}}
            let managedActionHistoryItemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .managedActionHistoryItems)
            if let managedActionHistoryItemsWrappedContainer = managedActionHistoryItemsWrappedContainer {
                let managedActionHistoryItemsContainer = try managedActionHistoryItemsWrappedContainer.decodeIfPresent([ManagedActionHistoryItem].self, forKey: .member)
                var managedActionHistoryItemsBuffer:[ManagedActionHistoryItem]? = nil
                if let managedActionHistoryItemsContainer = managedActionHistoryItemsContainer {
                    managedActionHistoryItemsBuffer = [ManagedActionHistoryItem]()
                    for structureContainer0 in managedActionHistoryItemsContainer {
                        managedActionHistoryItemsBuffer?.append(structureContainer0)
                    }
                }
                managedActionHistoryItems = managedActionHistoryItemsBuffer
            } else {
                managedActionHistoryItems = []
            }
        } else {
            managedActionHistoryItems = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeEnvironmentManagedActionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentManagedActionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentManagedActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentManagedActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentManagedActionsInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentManagedActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentManagedActionsOutputError>
}

extension DescribeEnvironmentManagedActionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEnvironmentManagedActionsInput(environmentId: \(String(describing: environmentId)), environmentName: \(String(describing: environmentName)), status: \(String(describing: status)))"}
}

extension DescribeEnvironmentManagedActionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let environmentId = environmentId {
            try container.encode(environmentId, forKey: Key("EnvironmentId"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        try container.encode("DescribeEnvironmentManagedActions", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DescribeEnvironmentManagedActionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentManagedActionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentManagedActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentManagedActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentManagedActionsInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentManagedActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentManagedActionsOutputError>
}

public struct DescribeEnvironmentManagedActionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentManagedActionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentManagedActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentManagedActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentManagedActionsInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentManagedActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentManagedActionsOutputError>
}

/// <p>Request to list an environment's upcoming and in-progress managed actions.</p>
public struct DescribeEnvironmentManagedActionsInput: Equatable {
    /// <p>The environment ID of the target environment.</p>
    public let environmentId: String?
    /// <p>The name of the target environment.</p>
    public let environmentName: String?
    /// <p>To show only actions with a particular status, specify a status.</p>
    public let status: ActionStatus?

    public init (
        environmentId: String? = nil,
        environmentName: String? = nil,
        status: ActionStatus? = nil
    )
    {
        self.environmentId = environmentId
        self.environmentName = environmentName
        self.status = status
    }
}

extension DescribeEnvironmentManagedActionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEnvironmentManagedActionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ElasticBeanstalkServiceException" : self = .elasticBeanstalkServiceException(try ElasticBeanstalkServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEnvironmentManagedActionsOutputError: Equatable {
    case elasticBeanstalkServiceException(ElasticBeanstalkServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEnvironmentManagedActionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEnvironmentManagedActionsOutputResponse(managedActions: \(String(describing: managedActions)))"}
}

extension DescribeEnvironmentManagedActionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEnvironmentManagedActionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.managedActions = output.managedActions
        } else {
            self.managedActions = nil
        }
    }
}

/// <p>The result message containing a list of managed actions.</p>
public struct DescribeEnvironmentManagedActionsOutputResponse: Equatable {
    /// <p>A list of upcoming and in-progress managed actions.</p>
    public let managedActions: [ManagedAction]?

    public init (
        managedActions: [ManagedAction]? = nil
    )
    {
        self.managedActions = managedActions
    }
}

struct DescribeEnvironmentManagedActionsOutputResponseBody: Equatable {
    public let managedActions: [ManagedAction]?
}

extension DescribeEnvironmentManagedActionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case managedActions = "ManagedActions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEnvironmentManagedActionsResult"))
        if containerValues.contains(.managedActions) {
            struct KeyVal0{struct member{}}
            let managedActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .managedActions)
            if let managedActionsWrappedContainer = managedActionsWrappedContainer {
                let managedActionsContainer = try managedActionsWrappedContainer.decodeIfPresent([ManagedAction].self, forKey: .member)
                var managedActionsBuffer:[ManagedAction]? = nil
                if let managedActionsContainer = managedActionsContainer {
                    managedActionsBuffer = [ManagedAction]()
                    for structureContainer0 in managedActionsContainer {
                        managedActionsBuffer?.append(structureContainer0)
                    }
                }
                managedActions = managedActionsBuffer
            } else {
                managedActions = []
            }
        } else {
            managedActions = nil
        }
    }
}

public struct DescribeEnvironmentResourcesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentResourcesInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentResourcesOutputError>
}

extension DescribeEnvironmentResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEnvironmentResourcesInput(environmentId: \(String(describing: environmentId)), environmentName: \(String(describing: environmentName)))"}
}

extension DescribeEnvironmentResourcesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let environmentId = environmentId {
            try container.encode(environmentId, forKey: Key("EnvironmentId"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        try container.encode("DescribeEnvironmentResources", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DescribeEnvironmentResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentResourcesInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentResourcesOutputError>
}

public struct DescribeEnvironmentResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentResourcesInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentResourcesOutputError>
}

/// <p>Request to describe the resources in an environment.</p>
public struct DescribeEnvironmentResourcesInput: Equatable {
    /// <p>The ID of the environment to retrieve AWS resource usage data.</p>
    ///          <p> Condition: You must specify either this or an EnvironmentName, or both. If you do not
    ///       specify either, AWS Elastic Beanstalk returns <code>MissingRequiredParameter</code> error.
    ///     </p>
    public let environmentId: String?
    /// <p>The name of the environment to retrieve AWS resource usage data.</p>
    ///          <p> Condition: You must specify either this or an EnvironmentId, or both. If you do not
    ///       specify either, AWS Elastic Beanstalk returns <code>MissingRequiredParameter</code> error.
    ///     </p>
    public let environmentName: String?

    public init (
        environmentId: String? = nil,
        environmentName: String? = nil
    )
    {
        self.environmentId = environmentId
        self.environmentName = environmentName
    }
}

extension DescribeEnvironmentResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEnvironmentResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEnvironmentResourcesOutputError: Equatable {
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEnvironmentResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEnvironmentResourcesOutputResponse(environmentResources: \(String(describing: environmentResources)))"}
}

extension DescribeEnvironmentResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEnvironmentResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.environmentResources = output.environmentResources
        } else {
            self.environmentResources = nil
        }
    }
}

/// <p>Result message containing a list of environment resource descriptions.</p>
public struct DescribeEnvironmentResourcesOutputResponse: Equatable {
    /// <p> A list of <a>EnvironmentResourceDescription</a>. </p>
    public let environmentResources: EnvironmentResourceDescription?

    public init (
        environmentResources: EnvironmentResourceDescription? = nil
    )
    {
        self.environmentResources = environmentResources
    }
}

struct DescribeEnvironmentResourcesOutputResponseBody: Equatable {
    public let environmentResources: EnvironmentResourceDescription?
}

extension DescribeEnvironmentResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case environmentResources = "EnvironmentResources"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEnvironmentResourcesResult"))
        let environmentResourcesDecoded = try containerValues.decodeIfPresent(EnvironmentResourceDescription.self, forKey: .environmentResources)
        environmentResources = environmentResourcesDecoded
    }
}

public struct DescribeEnvironmentsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentsInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentsOutputError>
}

extension DescribeEnvironmentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEnvironmentsInput(applicationName: \(String(describing: applicationName)), environmentIds: \(String(describing: environmentIds)), environmentNames: \(String(describing: environmentNames)), includeDeleted: \(String(describing: includeDeleted)), includedDeletedBackTo: \(String(describing: includedDeletedBackTo)), maxRecords: \(String(describing: maxRecords)), nextToken: \(String(describing: nextToken)), versionLabel: \(String(describing: versionLabel)))"}
}

extension DescribeEnvironmentsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let environmentIds = environmentIds {
            var environmentIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnvironmentIds"))
            for (index0, environmentid0) in environmentIds.enumerated() {
                try environmentIdsContainer.encode(environmentid0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let environmentNames = environmentNames {
            var environmentNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnvironmentNames"))
            for (index0, environmentname0) in environmentNames.enumerated() {
                try environmentNamesContainer.encode(environmentname0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let includeDeleted = includeDeleted {
            try container.encode(includeDeleted, forKey: Key("IncludeDeleted"))
        }
        if let includedDeletedBackTo = includedDeletedBackTo {
            try container.encode(TimestampWrapper(includedDeletedBackTo, format: .dateTime), forKey: Key("includedDeletedBackTo"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        if let versionLabel = versionLabel {
            try container.encode(versionLabel, forKey: Key("VersionLabel"))
        }
        try container.encode("DescribeEnvironments", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DescribeEnvironmentsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentsInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentsOutputError>
}

public struct DescribeEnvironmentsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentsInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentsOutputError>
}

/// <p>Request to describe one or more environments.</p>
public struct DescribeEnvironmentsInput: Equatable {
    /// <p>If specified, AWS Elastic Beanstalk restricts the returned descriptions to include only
    ///       those that are associated with this application.</p>
    public let applicationName: String?
    /// <p>If specified, AWS Elastic Beanstalk restricts the returned descriptions to include only
    ///       those that have the specified IDs.</p>
    public let environmentIds: [String]?
    /// <p>If specified, AWS Elastic Beanstalk restricts the returned descriptions to include only
    ///       those that have the specified names.</p>
    public let environmentNames: [String]?
    /// <p>Indicates whether to include deleted environments:</p>
    ///          <p>
    ///             <code>true</code>: Environments that have been deleted after
    ///       <code>IncludedDeletedBackTo</code> are displayed.</p>
    ///          <p>
    ///             <code>false</code>: Do not include deleted environments.</p>
    public let includeDeleted: Bool?
    /// <p> If specified when <code>IncludeDeleted</code> is set to <code>true</code>, then
    ///       environments deleted after this date are displayed. </p>
    public let includedDeletedBackTo: Date?
    /// <p>For a paginated request. Specify a maximum number of environments to include in
    ///       each response.</p>
    ///          <p>If no <code>MaxRecords</code> is specified, all available environments are
    ///       retrieved in a single response.</p>
    public let maxRecords: Int?
    /// <p>For a paginated request. Specify a token from a previous response page to retrieve the next response page. All other
    ///       parameter values must be identical to the ones specified in the initial request.</p>
    ///          <p>If no <code>NextToken</code> is specified, the first page is retrieved.</p>
    public let nextToken: String?
    /// <p>If specified, AWS Elastic Beanstalk restricts the returned descriptions to include only
    ///       those that are associated with this application version.</p>
    public let versionLabel: String?

    public init (
        applicationName: String? = nil,
        environmentIds: [String]? = nil,
        environmentNames: [String]? = nil,
        includeDeleted: Bool? = nil,
        includedDeletedBackTo: Date? = nil,
        maxRecords: Int? = nil,
        nextToken: String? = nil,
        versionLabel: String? = nil
    )
    {
        self.applicationName = applicationName
        self.environmentIds = environmentIds
        self.environmentNames = environmentNames
        self.includeDeleted = includeDeleted
        self.includedDeletedBackTo = includedDeletedBackTo
        self.maxRecords = maxRecords
        self.nextToken = nextToken
        self.versionLabel = versionLabel
    }
}

extension DescribeEnvironmentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEnvironmentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEnvironmentsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEnvironmentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEnvironmentsOutputResponse(environments: \(String(describing: environments)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeEnvironmentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEnvironmentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.environments = output.environments
            self.nextToken = output.nextToken
        } else {
            self.environments = nil
            self.nextToken = nil
        }
    }
}

/// <p>Result message containing a list of environment descriptions.</p>
public struct DescribeEnvironmentsOutputResponse: Equatable {
    /// <p> Returns an <a>EnvironmentDescription</a> list. </p>
    public let environments: [EnvironmentDescription]?
    /// <p>In a paginated request, the token that you can pass in a subsequent request to get the
    ///       next response page.</p>
    public let nextToken: String?

    public init (
        environments: [EnvironmentDescription]? = nil,
        nextToken: String? = nil
    )
    {
        self.environments = environments
        self.nextToken = nextToken
    }
}

struct DescribeEnvironmentsOutputResponseBody: Equatable {
    public let environments: [EnvironmentDescription]?
    public let nextToken: String?
}

extension DescribeEnvironmentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case environments = "Environments"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEnvironmentsResult"))
        if containerValues.contains(.environments) {
            struct KeyVal0{struct member{}}
            let environmentsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .environments)
            if let environmentsWrappedContainer = environmentsWrappedContainer {
                let environmentsContainer = try environmentsWrappedContainer.decodeIfPresent([EnvironmentDescription].self, forKey: .member)
                var environmentsBuffer:[EnvironmentDescription]? = nil
                if let environmentsContainer = environmentsContainer {
                    environmentsBuffer = [EnvironmentDescription]()
                    for structureContainer0 in environmentsContainer {
                        environmentsBuffer?.append(structureContainer0)
                    }
                }
                environments = environmentsBuffer
            } else {
                environments = []
            }
        } else {
            environments = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeEventsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

extension DescribeEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventsInput(applicationName: \(String(describing: applicationName)), endTime: \(String(describing: endTime)), environmentId: \(String(describing: environmentId)), environmentName: \(String(describing: environmentName)), maxRecords: \(String(describing: maxRecords)), nextToken: \(String(describing: nextToken)), platformArn: \(String(describing: platformArn)), requestId: \(String(describing: requestId)), severity: \(String(describing: severity)), startTime: \(String(describing: startTime)), templateName: \(String(describing: templateName)), versionLabel: \(String(describing: versionLabel)))"}
}

extension DescribeEventsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let endTime = endTime {
            try container.encode(TimestampWrapper(endTime, format: .dateTime), forKey: Key("endTime"))
        }
        if let environmentId = environmentId {
            try container.encode(environmentId, forKey: Key("EnvironmentId"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        if let platformArn = platformArn {
            try container.encode(platformArn, forKey: Key("PlatformArn"))
        }
        if let requestId = requestId {
            try container.encode(requestId, forKey: Key("RequestId"))
        }
        if let severity = severity {
            try container.encode(severity, forKey: Key("Severity"))
        }
        if let startTime = startTime {
            try container.encode(TimestampWrapper(startTime, format: .dateTime), forKey: Key("startTime"))
        }
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        if let versionLabel = versionLabel {
            try container.encode(versionLabel, forKey: Key("VersionLabel"))
        }
        try container.encode("DescribeEvents", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DescribeEventsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

/// <p>Request to retrieve a list of events for an environment.</p>
public struct DescribeEventsInput: Equatable {
    /// <p>If specified, AWS Elastic Beanstalk restricts the returned descriptions to include only
    ///       those associated with this application.</p>
    public let applicationName: String?
    /// <p> If specified, AWS Elastic Beanstalk restricts the returned descriptions to those that
    ///       occur up to, but not including, the <code>EndTime</code>. </p>
    public let endTime: Date?
    /// <p>If specified, AWS Elastic Beanstalk restricts the returned descriptions to those
    ///       associated with this environment.</p>
    public let environmentId: String?
    /// <p>If specified, AWS Elastic Beanstalk restricts the returned descriptions to those
    ///       associated with this environment.</p>
    public let environmentName: String?
    /// <p>Specifies the maximum number of events that can be returned, beginning with the most
    ///       recent event.</p>
    public let maxRecords: Int?
    /// <p>Pagination token. If specified, the events return the next batch of results.</p>
    public let nextToken: String?
    /// <p>The ARN of a custom platform version. If specified, AWS Elastic Beanstalk restricts the
    ///       returned descriptions to those associated with this custom platform version.</p>
    public let platformArn: String?
    /// <p>If specified, AWS Elastic Beanstalk restricts the described events to include only
    ///       those associated with this request ID.</p>
    public let requestId: String?
    /// <p>If specified, limits the events returned from this call to include only those with the
    ///       specified severity or higher.</p>
    public let severity: EventSeverity?
    /// <p>If specified, AWS Elastic Beanstalk restricts the returned descriptions to those that
    ///       occur on or after this time.</p>
    public let startTime: Date?
    /// <p>If specified, AWS Elastic Beanstalk restricts the returned descriptions to those that
    ///       are associated with this environment configuration.</p>
    public let templateName: String?
    /// <p>If specified, AWS Elastic Beanstalk restricts the returned descriptions to those
    ///       associated with this application version.</p>
    public let versionLabel: String?

    public init (
        applicationName: String? = nil,
        endTime: Date? = nil,
        environmentId: String? = nil,
        environmentName: String? = nil,
        maxRecords: Int? = nil,
        nextToken: String? = nil,
        platformArn: String? = nil,
        requestId: String? = nil,
        severity: EventSeverity? = nil,
        startTime: Date? = nil,
        templateName: String? = nil,
        versionLabel: String? = nil
    )
    {
        self.applicationName = applicationName
        self.endTime = endTime
        self.environmentId = environmentId
        self.environmentName = environmentName
        self.maxRecords = maxRecords
        self.nextToken = nextToken
        self.platformArn = platformArn
        self.requestId = requestId
        self.severity = severity
        self.startTime = startTime
        self.templateName = templateName
        self.versionLabel = versionLabel
    }
}

extension DescribeEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventsOutputResponse(events: \(String(describing: events)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

/// <p>Result message wrapping a list of event descriptions.</p>
public struct DescribeEventsOutputResponse: Equatable {
    /// <p> A list of <a>EventDescription</a>. </p>
    public let events: [EventDescription]?
    /// <p> If returned, this indicates that there are more results to obtain. Use this token in
    ///       the next <a>DescribeEvents</a> call to get the next batch of events. </p>
    public let nextToken: String?

    public init (
        events: [EventDescription]? = nil,
        nextToken: String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct DescribeEventsOutputResponseBody: Equatable {
    public let events: [EventDescription]?
    public let nextToken: String?
}

extension DescribeEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case events = "Events"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEventsResult"))
        if containerValues.contains(.events) {
            struct KeyVal0{struct member{}}
            let eventsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .events)
            if let eventsWrappedContainer = eventsWrappedContainer {
                let eventsContainer = try eventsWrappedContainer.decodeIfPresent([EventDescription].self, forKey: .member)
                var eventsBuffer:[EventDescription]? = nil
                if let eventsContainer = eventsContainer {
                    eventsBuffer = [EventDescription]()
                    for structureContainer0 in eventsContainer {
                        eventsBuffer?.append(structureContainer0)
                    }
                }
                events = eventsBuffer
            } else {
                events = []
            }
        } else {
            events = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeInstancesHealthInputBodyMiddleware: Middleware {
    public let id: String = "DescribeInstancesHealthInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstancesHealthInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstancesHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstancesHealthInput>
    public typealias MOutput = OperationOutput<DescribeInstancesHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstancesHealthOutputError>
}

extension DescribeInstancesHealthInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstancesHealthInput(attributeNames: \(String(describing: attributeNames)), environmentId: \(String(describing: environmentId)), environmentName: \(String(describing: environmentName)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeInstancesHealthInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributeNames = attributeNames {
            var attributeNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AttributeNames"))
            for (index0, instanceshealthattribute0) in attributeNames.enumerated() {
                try attributeNamesContainer.encode(instanceshealthattribute0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let environmentId = environmentId {
            try container.encode(environmentId, forKey: Key("EnvironmentId"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        try container.encode("DescribeInstancesHealth", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DescribeInstancesHealthInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeInstancesHealthInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstancesHealthInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstancesHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstancesHealthInput>
    public typealias MOutput = OperationOutput<DescribeInstancesHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstancesHealthOutputError>
}

public struct DescribeInstancesHealthInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeInstancesHealthInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstancesHealthInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstancesHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstancesHealthInput>
    public typealias MOutput = OperationOutput<DescribeInstancesHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstancesHealthOutputError>
}

/// <p>Parameters for a call to <code>DescribeInstancesHealth</code>.</p>
public struct DescribeInstancesHealthInput: Equatable {
    /// <p>Specifies the response elements you wish to receive. To retrieve all attributes, set to
    ///         <code>All</code>. If no attribute names are specified, returns a list of
    ///       instances.</p>
    public let attributeNames: [InstancesHealthAttribute]?
    /// <p>Specify the AWS Elastic Beanstalk environment by ID.</p>
    public let environmentId: String?
    /// <p>Specify the AWS Elastic Beanstalk environment by name.</p>
    public let environmentName: String?
    /// <p>Specify the pagination token returned by a previous call.</p>
    public let nextToken: String?

    public init (
        attributeNames: [InstancesHealthAttribute]? = nil,
        environmentId: String? = nil,
        environmentName: String? = nil,
        nextToken: String? = nil
    )
    {
        self.attributeNames = attributeNames
        self.environmentId = environmentId
        self.environmentName = environmentName
        self.nextToken = nextToken
    }
}

extension DescribeInstancesHealthOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeInstancesHealthOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ElasticBeanstalkServiceException" : self = .elasticBeanstalkServiceException(try ElasticBeanstalkServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstancesHealthOutputError: Equatable {
    case elasticBeanstalkServiceException(ElasticBeanstalkServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstancesHealthOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstancesHealthOutputResponse(instanceHealthList: \(String(describing: instanceHealthList)), nextToken: \(String(describing: nextToken)), refreshedAt: \(String(describing: refreshedAt)))"}
}

extension DescribeInstancesHealthOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeInstancesHealthOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instanceHealthList = output.instanceHealthList
            self.nextToken = output.nextToken
            self.refreshedAt = output.refreshedAt
        } else {
            self.instanceHealthList = nil
            self.nextToken = nil
            self.refreshedAt = nil
        }
    }
}

/// <p>Detailed health information about the Amazon EC2 instances in an AWS Elastic Beanstalk
///       environment.</p>
public struct DescribeInstancesHealthOutputResponse: Equatable {
    /// <p>Detailed health information about each instance.</p>
    ///          <p>The output differs slightly between Linux and Windows environments. There is a difference
    ///       in the members that are supported under the <code><CPUUtilization></code> type.</p>
    public let instanceHealthList: [SingleInstanceHealth]?
    /// <p>Pagination token for the next page of results, if available.</p>
    public let nextToken: String?
    /// <p>The date and time that the health information was retrieved.</p>
    public let refreshedAt: Date?

    public init (
        instanceHealthList: [SingleInstanceHealth]? = nil,
        nextToken: String? = nil,
        refreshedAt: Date? = nil
    )
    {
        self.instanceHealthList = instanceHealthList
        self.nextToken = nextToken
        self.refreshedAt = refreshedAt
    }
}

struct DescribeInstancesHealthOutputResponseBody: Equatable {
    public let instanceHealthList: [SingleInstanceHealth]?
    public let refreshedAt: Date?
    public let nextToken: String?
}

extension DescribeInstancesHealthOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceHealthList = "InstanceHealthList"
        case nextToken = "NextToken"
        case refreshedAt = "RefreshedAt"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeInstancesHealthResult"))
        if containerValues.contains(.instanceHealthList) {
            struct KeyVal0{struct member{}}
            let instanceHealthListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instanceHealthList)
            if let instanceHealthListWrappedContainer = instanceHealthListWrappedContainer {
                let instanceHealthListContainer = try instanceHealthListWrappedContainer.decodeIfPresent([SingleInstanceHealth].self, forKey: .member)
                var instanceHealthListBuffer:[SingleInstanceHealth]? = nil
                if let instanceHealthListContainer = instanceHealthListContainer {
                    instanceHealthListBuffer = [SingleInstanceHealth]()
                    for structureContainer0 in instanceHealthListContainer {
                        instanceHealthListBuffer?.append(structureContainer0)
                    }
                }
                instanceHealthList = instanceHealthListBuffer
            } else {
                instanceHealthList = []
            }
        } else {
            instanceHealthList = nil
        }
        let refreshedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .refreshedAt)
        var refreshedAtBuffer:Date? = nil
        if let refreshedAtDecoded = refreshedAtDecoded {
            refreshedAtBuffer = try TimestampWrapperDecoder.parseDateStringValue(refreshedAtDecoded, format: .dateTime)
        }
        refreshedAt = refreshedAtBuffer
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribePlatformVersionInputBodyMiddleware: Middleware {
    public let id: String = "DescribePlatformVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePlatformVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePlatformVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePlatformVersionInput>
    public typealias MOutput = OperationOutput<DescribePlatformVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePlatformVersionOutputError>
}

extension DescribePlatformVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePlatformVersionInput(platformArn: \(String(describing: platformArn)))"}
}

extension DescribePlatformVersionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let platformArn = platformArn {
            try container.encode(platformArn, forKey: Key("PlatformArn"))
        }
        try container.encode("DescribePlatformVersion", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DescribePlatformVersionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePlatformVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePlatformVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePlatformVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePlatformVersionInput>
    public typealias MOutput = OperationOutput<DescribePlatformVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePlatformVersionOutputError>
}

public struct DescribePlatformVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePlatformVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePlatformVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePlatformVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePlatformVersionInput>
    public typealias MOutput = OperationOutput<DescribePlatformVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePlatformVersionOutputError>
}

public struct DescribePlatformVersionInput: Equatable {
    /// <p>The ARN of the platform version.</p>
    public let platformArn: String?

    public init (
        platformArn: String? = nil
    )
    {
        self.platformArn = platformArn
    }
}

extension DescribePlatformVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribePlatformVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ElasticBeanstalkServiceException" : self = .elasticBeanstalkServiceException(try ElasticBeanstalkServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePlatformVersionOutputError: Equatable {
    case elasticBeanstalkServiceException(ElasticBeanstalkServiceException)
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePlatformVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePlatformVersionOutputResponse(platformDescription: \(String(describing: platformDescription)))"}
}

extension DescribePlatformVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePlatformVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.platformDescription = output.platformDescription
        } else {
            self.platformDescription = nil
        }
    }
}

public struct DescribePlatformVersionOutputResponse: Equatable {
    /// <p>Detailed information about the platform version.</p>
    public let platformDescription: PlatformDescription?

    public init (
        platformDescription: PlatformDescription? = nil
    )
    {
        self.platformDescription = platformDescription
    }
}

struct DescribePlatformVersionOutputResponseBody: Equatable {
    public let platformDescription: PlatformDescription?
}

extension DescribePlatformVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case platformDescription = "PlatformDescription"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribePlatformVersionResult"))
        let platformDescriptionDecoded = try containerValues.decodeIfPresent(PlatformDescription.self, forKey: .platformDescription)
        platformDescription = platformDescriptionDecoded
    }
}

public struct DisassociateEnvironmentOperationsRoleInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateEnvironmentOperationsRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateEnvironmentOperationsRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateEnvironmentOperationsRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateEnvironmentOperationsRoleInput>
    public typealias MOutput = OperationOutput<DisassociateEnvironmentOperationsRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateEnvironmentOperationsRoleOutputError>
}

extension DisassociateEnvironmentOperationsRoleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateEnvironmentOperationsRoleInput(environmentName: \(String(describing: environmentName)))"}
}

extension DisassociateEnvironmentOperationsRoleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        try container.encode("DisassociateEnvironmentOperationsRole", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DisassociateEnvironmentOperationsRoleInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateEnvironmentOperationsRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateEnvironmentOperationsRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateEnvironmentOperationsRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateEnvironmentOperationsRoleInput>
    public typealias MOutput = OperationOutput<DisassociateEnvironmentOperationsRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateEnvironmentOperationsRoleOutputError>
}

public struct DisassociateEnvironmentOperationsRoleInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateEnvironmentOperationsRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateEnvironmentOperationsRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateEnvironmentOperationsRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateEnvironmentOperationsRoleInput>
    public typealias MOutput = OperationOutput<DisassociateEnvironmentOperationsRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateEnvironmentOperationsRoleOutputError>
}

/// <p>Request to disassociate the operations role from an environment.</p>
public struct DisassociateEnvironmentOperationsRoleInput: Equatable {
    /// <p>The name of the environment from which to disassociate the operations role.</p>
    public let environmentName: String?

    public init (
        environmentName: String? = nil
    )
    {
        self.environmentName = environmentName
    }
}

extension DisassociateEnvironmentOperationsRoleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DisassociateEnvironmentOperationsRoleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateEnvironmentOperationsRoleOutputError: Equatable {
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateEnvironmentOperationsRoleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateEnvironmentOperationsRoleOutputResponse()"}
}

extension DisassociateEnvironmentOperationsRoleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateEnvironmentOperationsRoleOutputResponse: Equatable {

    public init() {}
}

struct DisassociateEnvironmentOperationsRoleOutputResponseBody: Equatable {
}

extension DisassociateEnvironmentOperationsRoleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ElasticBeanstalkServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ElasticBeanstalkServiceException(message: \(String(describing: message)))"}
}

extension ElasticBeanstalkServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ElasticBeanstalkServiceExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A generic service exception has occurred.</p>
public struct ElasticBeanstalkServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ElasticBeanstalkServiceExceptionBody: Equatable {
    public let message: String?
}

extension ElasticBeanstalkServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EnvironmentDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case abortableOperationInProgress = "AbortableOperationInProgress"
        case applicationName = "ApplicationName"
        case cNAME = "CNAME"
        case dateCreated = "DateCreated"
        case dateUpdated = "DateUpdated"
        case description = "Description"
        case endpointURL = "EndpointURL"
        case environmentArn = "EnvironmentArn"
        case environmentId = "EnvironmentId"
        case environmentLinks = "EnvironmentLinks"
        case environmentName = "EnvironmentName"
        case health = "Health"
        case healthStatus = "HealthStatus"
        case operationsRole = "OperationsRole"
        case platformArn = "PlatformArn"
        case resources = "Resources"
        case solutionStackName = "SolutionStackName"
        case status = "Status"
        case templateName = "TemplateName"
        case tier = "Tier"
        case versionLabel = "VersionLabel"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let abortableOperationInProgress = abortableOperationInProgress {
            try container.encode(abortableOperationInProgress, forKey: Key("AbortableOperationInProgress"))
        }
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let cNAME = cNAME {
            try container.encode(cNAME, forKey: Key("CNAME"))
        }
        if let dateCreated = dateCreated {
            try container.encode(TimestampWrapper(dateCreated, format: .dateTime), forKey: Key("dateCreated"))
        }
        if let dateUpdated = dateUpdated {
            try container.encode(TimestampWrapper(dateUpdated, format: .dateTime), forKey: Key("dateUpdated"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let endpointURL = endpointURL {
            try container.encode(endpointURL, forKey: Key("EndpointURL"))
        }
        if let environmentArn = environmentArn {
            try container.encode(environmentArn, forKey: Key("EnvironmentArn"))
        }
        if let environmentId = environmentId {
            try container.encode(environmentId, forKey: Key("EnvironmentId"))
        }
        if let environmentLinks = environmentLinks {
            var environmentLinksContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnvironmentLinks"))
            for (index0, environmentlink0) in environmentLinks.enumerated() {
                try environmentLinksContainer.encode(environmentlink0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        if let health = health {
            try container.encode(health, forKey: Key("Health"))
        }
        if let healthStatus = healthStatus {
            try container.encode(healthStatus, forKey: Key("HealthStatus"))
        }
        if let operationsRole = operationsRole {
            try container.encode(operationsRole, forKey: Key("OperationsRole"))
        }
        if let platformArn = platformArn {
            try container.encode(platformArn, forKey: Key("PlatformArn"))
        }
        if let resources = resources {
            try container.encode(resources, forKey: Key("Resources"))
        }
        if let solutionStackName = solutionStackName {
            try container.encode(solutionStackName, forKey: Key("SolutionStackName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        if let tier = tier {
            try container.encode(tier, forKey: Key("Tier"))
        }
        if let versionLabel = versionLabel {
            try container.encode(versionLabel, forKey: Key("VersionLabel"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let versionLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionLabel)
        versionLabel = versionLabelDecoded
        let solutionStackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionStackName)
        solutionStackName = solutionStackNameDecoded
        let platformArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformArn)
        platformArn = platformArnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let endpointURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointURL)
        endpointURL = endpointURLDecoded
        let cNAMEDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cNAME)
        cNAME = cNAMEDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        var dateCreatedBuffer:Date? = nil
        if let dateCreatedDecoded = dateCreatedDecoded {
            dateCreatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateCreatedDecoded, format: .dateTime)
        }
        dateCreated = dateCreatedBuffer
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateUpdated)
        var dateUpdatedBuffer:Date? = nil
        if let dateUpdatedDecoded = dateUpdatedDecoded {
            dateUpdatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateUpdatedDecoded, format: .dateTime)
        }
        dateUpdated = dateUpdatedBuffer
        let statusDecoded = try containerValues.decodeIfPresent(EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let abortableOperationInProgressDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .abortableOperationInProgress)
        abortableOperationInProgress = abortableOperationInProgressDecoded
        let healthDecoded = try containerValues.decodeIfPresent(EnvironmentHealth.self, forKey: .health)
        health = healthDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(EnvironmentHealthStatus.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(EnvironmentResourcesDescription.self, forKey: .resources)
        resources = resourcesDecoded
        let tierDecoded = try containerValues.decodeIfPresent(EnvironmentTier.self, forKey: .tier)
        tier = tierDecoded
        if containerValues.contains(.environmentLinks) {
            struct KeyVal0{struct member{}}
            let environmentLinksWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .environmentLinks)
            if let environmentLinksWrappedContainer = environmentLinksWrappedContainer {
                let environmentLinksContainer = try environmentLinksWrappedContainer.decodeIfPresent([EnvironmentLink].self, forKey: .member)
                var environmentLinksBuffer:[EnvironmentLink]? = nil
                if let environmentLinksContainer = environmentLinksContainer {
                    environmentLinksBuffer = [EnvironmentLink]()
                    for structureContainer0 in environmentLinksContainer {
                        environmentLinksBuffer?.append(structureContainer0)
                    }
                }
                environmentLinks = environmentLinksBuffer
            } else {
                environmentLinks = []
            }
        } else {
            environmentLinks = nil
        }
        let environmentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentArn)
        environmentArn = environmentArnDecoded
        let operationsRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationsRole)
        operationsRole = operationsRoleDecoded
    }
}

extension EnvironmentDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnvironmentDescription(abortableOperationInProgress: \(String(describing: abortableOperationInProgress)), applicationName: \(String(describing: applicationName)), cNAME: \(String(describing: cNAME)), dateCreated: \(String(describing: dateCreated)), dateUpdated: \(String(describing: dateUpdated)), description: \(String(describing: description)), endpointURL: \(String(describing: endpointURL)), environmentArn: \(String(describing: environmentArn)), environmentId: \(String(describing: environmentId)), environmentLinks: \(String(describing: environmentLinks)), environmentName: \(String(describing: environmentName)), health: \(String(describing: health)), healthStatus: \(String(describing: healthStatus)), operationsRole: \(String(describing: operationsRole)), platformArn: \(String(describing: platformArn)), resources: \(String(describing: resources)), solutionStackName: \(String(describing: solutionStackName)), status: \(String(describing: status)), templateName: \(String(describing: templateName)), tier: \(String(describing: tier)), versionLabel: \(String(describing: versionLabel)))"}
}

/// <p>Describes the properties of an environment.</p>
public struct EnvironmentDescription: Equatable {
    /// <p>Indicates if there is an in-progress environment configuration update or application
    ///       version deployment that you can cancel.</p>
    ///          <p>
    ///             <code>true:</code> There is an update in progress. </p>
    ///          <p>
    ///             <code>false:</code> There are no updates currently in progress. </p>
    public let abortableOperationInProgress: Bool?
    /// <p>The name of the application associated with this environment.</p>
    public let applicationName: String?
    /// <p>The URL to the CNAME for this environment.</p>
    public let cNAME: String?
    /// <p>The creation date for this environment.</p>
    public let dateCreated: Date?
    /// <p>The last modified date for this environment.</p>
    public let dateUpdated: Date?
    /// <p>Describes this environment.</p>
    public let description: String?
    /// <p>For load-balanced, autoscaling environments, the URL to the LoadBalancer. For
    ///       single-instance environments, the IP address of the instance.</p>
    public let endpointURL: String?
    /// <p>The environment's Amazon Resource Name (ARN), which can be used in other API requests that require an ARN.</p>
    public let environmentArn: String?
    /// <p>The ID of this environment.</p>
    public let environmentId: String?
    /// <p>A list of links to other environments in the same group.</p>
    public let environmentLinks: [EnvironmentLink]?
    /// <p>The name of this environment.</p>
    public let environmentName: String?
    /// <p>Describes the health status of the environment. AWS Elastic Beanstalk indicates the
    ///       failure levels for a running environment:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Red</code>: Indicates the environment is not responsive. Occurs when three or more
    ///           consecutive failures occur for an environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Yellow</code>: Indicates that something is wrong. Occurs when two consecutive
    ///           failures occur for an environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Green</code>: Indicates the environment is healthy and fully functional.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Grey</code>: Default health for a new environment. The environment is not fully
    ///           launched and health checks have not started or health checks are suspended during an
    ///             <code>UpdateEnvironment</code> or <code>RestartEnvironment</code> request.</p>
    ///             </li>
    ///          </ul>
    ///          <p> Default: <code>Grey</code>
    ///          </p>
    public let health: EnvironmentHealth?
    /// <p>Returns the health status of the application running in your environment. For more
    ///       information, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/health-enhanced-status.html">Health Colors and
    ///         Statuses</a>.</p>
    public let healthStatus: EnvironmentHealthStatus?
    /// <p>The Amazon Resource Name (ARN) of the environment's operations role. For more information,
    ///       see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/iam-operationsrole.html">Operations roles</a> in the <i>AWS Elastic Beanstalk Developer Guide</i>.</p>
    public let operationsRole: String?
    /// <p>The ARN of the platform version.</p>
    public let platformArn: String?
    /// <p>The description of the AWS resources used by this environment.</p>
    public let resources: EnvironmentResourcesDescription?
    /// <p> The name of the <code>SolutionStack</code> deployed with this environment. </p>
    public let solutionStackName: String?
    /// <p>The current operational status of the environment:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Launching</code>: Environment is in the process of initial deployment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Updating</code>: Environment is in the process of updating its configuration
    ///           settings or application version.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Ready</code>: Environment is available to have an action performed on it, such as
    ///           update or terminate.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Terminating</code>: Environment is in the shut-down process.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Terminated</code>: Environment is not running.</p>
    ///             </li>
    ///          </ul>
    public let status: EnvironmentStatus?
    /// <p>The name of the configuration template used to originally launch this
    ///       environment.</p>
    public let templateName: String?
    /// <p>Describes the current tier of this environment.</p>
    public let tier: EnvironmentTier?
    /// <p>The application version deployed in this environment.</p>
    public let versionLabel: String?

    public init (
        abortableOperationInProgress: Bool? = nil,
        applicationName: String? = nil,
        cNAME: String? = nil,
        dateCreated: Date? = nil,
        dateUpdated: Date? = nil,
        description: String? = nil,
        endpointURL: String? = nil,
        environmentArn: String? = nil,
        environmentId: String? = nil,
        environmentLinks: [EnvironmentLink]? = nil,
        environmentName: String? = nil,
        health: EnvironmentHealth? = nil,
        healthStatus: EnvironmentHealthStatus? = nil,
        operationsRole: String? = nil,
        platformArn: String? = nil,
        resources: EnvironmentResourcesDescription? = nil,
        solutionStackName: String? = nil,
        status: EnvironmentStatus? = nil,
        templateName: String? = nil,
        tier: EnvironmentTier? = nil,
        versionLabel: String? = nil
    )
    {
        self.abortableOperationInProgress = abortableOperationInProgress
        self.applicationName = applicationName
        self.cNAME = cNAME
        self.dateCreated = dateCreated
        self.dateUpdated = dateUpdated
        self.description = description
        self.endpointURL = endpointURL
        self.environmentArn = environmentArn
        self.environmentId = environmentId
        self.environmentLinks = environmentLinks
        self.environmentName = environmentName
        self.health = health
        self.healthStatus = healthStatus
        self.operationsRole = operationsRole
        self.platformArn = platformArn
        self.resources = resources
        self.solutionStackName = solutionStackName
        self.status = status
        self.templateName = templateName
        self.tier = tier
        self.versionLabel = versionLabel
    }
}

public enum EnvironmentHealth {
    case green
    case grey
    case red
    case yellow
    case sdkUnknown(String)
}

extension EnvironmentHealth : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EnvironmentHealth] {
        return [
            .green,
            .grey,
            .red,
            .yellow,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .green: return "Green"
        case .grey: return "Grey"
        case .red: return "Red"
        case .yellow: return "Yellow"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EnvironmentHealth(rawValue: rawValue) ?? EnvironmentHealth.sdkUnknown(rawValue)
    }
}

public enum EnvironmentHealthAttribute {
    case all
    case applicationmetrics
    case causes
    case color
    case healthstatus
    case instanceshealth
    case refreshedat
    case status
    case sdkUnknown(String)
}

extension EnvironmentHealthAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EnvironmentHealthAttribute] {
        return [
            .all,
            .applicationmetrics,
            .causes,
            .color,
            .healthstatus,
            .instanceshealth,
            .refreshedat,
            .status,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "All"
        case .applicationmetrics: return "ApplicationMetrics"
        case .causes: return "Causes"
        case .color: return "Color"
        case .healthstatus: return "HealthStatus"
        case .instanceshealth: return "InstancesHealth"
        case .refreshedat: return "RefreshedAt"
        case .status: return "Status"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EnvironmentHealthAttribute(rawValue: rawValue) ?? EnvironmentHealthAttribute.sdkUnknown(rawValue)
    }
}

public enum EnvironmentHealthStatus {
    case degraded
    case info
    case nodata
    case ok
    case pending
    case severe
    case suspended
    case unknown
    case warning
    case sdkUnknown(String)
}

extension EnvironmentHealthStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EnvironmentHealthStatus] {
        return [
            .degraded,
            .info,
            .nodata,
            .ok,
            .pending,
            .severe,
            .suspended,
            .unknown,
            .warning,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .degraded: return "Degraded"
        case .info: return "Info"
        case .nodata: return "NoData"
        case .ok: return "Ok"
        case .pending: return "Pending"
        case .severe: return "Severe"
        case .suspended: return "Suspended"
        case .unknown: return "Unknown"
        case .warning: return "Warning"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EnvironmentHealthStatus(rawValue: rawValue) ?? EnvironmentHealthStatus.sdkUnknown(rawValue)
    }
}

extension EnvironmentInfoDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ec2InstanceId = "Ec2InstanceId"
        case infoType = "InfoType"
        case message = "Message"
        case sampleTimestamp = "SampleTimestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let ec2InstanceId = ec2InstanceId {
            try container.encode(ec2InstanceId, forKey: Key("Ec2InstanceId"))
        }
        if let infoType = infoType {
            try container.encode(infoType, forKey: Key("InfoType"))
        }
        if let message = message {
            try container.encode(message, forKey: Key("Message"))
        }
        if let sampleTimestamp = sampleTimestamp {
            try container.encode(TimestampWrapper(sampleTimestamp, format: .dateTime), forKey: Key("sampleTimestamp"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let infoTypeDecoded = try containerValues.decodeIfPresent(EnvironmentInfoType.self, forKey: .infoType)
        infoType = infoTypeDecoded
        let ec2InstanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ec2InstanceId)
        ec2InstanceId = ec2InstanceIdDecoded
        let sampleTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sampleTimestamp)
        var sampleTimestampBuffer:Date? = nil
        if let sampleTimestampDecoded = sampleTimestampDecoded {
            sampleTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(sampleTimestampDecoded, format: .dateTime)
        }
        sampleTimestamp = sampleTimestampBuffer
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EnvironmentInfoDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnvironmentInfoDescription(ec2InstanceId: \(String(describing: ec2InstanceId)), infoType: \(String(describing: infoType)), message: \(String(describing: message)), sampleTimestamp: \(String(describing: sampleTimestamp)))"}
}

/// <p>The information retrieved from the Amazon EC2 instances.</p>
public struct EnvironmentInfoDescription: Equatable {
    /// <p>The Amazon EC2 Instance ID for this information.</p>
    public let ec2InstanceId: String?
    /// <p>The type of information retrieved.</p>
    public let infoType: EnvironmentInfoType?
    /// <p>The retrieved information. Currently contains a presigned Amazon S3 URL. The files are
    ///       deleted after 15 minutes.</p>
    ///          <p>Anyone in possession of this URL can access the files before they are deleted. Make the
    ///       URL available only to trusted parties.</p>
    public let message: String?
    /// <p>The time stamp when this information was retrieved.</p>
    public let sampleTimestamp: Date?

    public init (
        ec2InstanceId: String? = nil,
        infoType: EnvironmentInfoType? = nil,
        message: String? = nil,
        sampleTimestamp: Date? = nil
    )
    {
        self.ec2InstanceId = ec2InstanceId
        self.infoType = infoType
        self.message = message
        self.sampleTimestamp = sampleTimestamp
    }
}

public enum EnvironmentInfoType {
    case bundle
    case tail
    case sdkUnknown(String)
}

extension EnvironmentInfoType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EnvironmentInfoType] {
        return [
            .bundle,
            .tail,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bundle: return "bundle"
        case .tail: return "tail"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EnvironmentInfoType(rawValue: rawValue) ?? EnvironmentInfoType.sdkUnknown(rawValue)
    }
}

extension EnvironmentLink: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case environmentName = "EnvironmentName"
        case linkName = "LinkName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        if let linkName = linkName {
            try container.encode(linkName, forKey: Key("LinkName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkName)
        linkName = linkNameDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
    }
}

extension EnvironmentLink: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnvironmentLink(environmentName: \(String(describing: environmentName)), linkName: \(String(describing: linkName)))"}
}

/// <p>A link to another environment, defined in the environment's manifest. Links provide
///       connection information in system properties that can be used to connect to another environment
///       in the same group. See <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/environment-cfg-manifest.html">Environment Manifest
///         (env.yaml)</a> for details.</p>
public struct EnvironmentLink: Equatable {
    /// <p>The name of the linked environment (the dependency).</p>
    public let environmentName: String?
    /// <p>The name of the link.</p>
    public let linkName: String?

    public init (
        environmentName: String? = nil,
        linkName: String? = nil
    )
    {
        self.environmentName = environmentName
        self.linkName = linkName
    }
}

extension EnvironmentResourceDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoScalingGroups = "AutoScalingGroups"
        case environmentName = "EnvironmentName"
        case instances = "Instances"
        case launchConfigurations = "LaunchConfigurations"
        case launchTemplates = "LaunchTemplates"
        case loadBalancers = "LoadBalancers"
        case queues = "Queues"
        case triggers = "Triggers"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let autoScalingGroups = autoScalingGroups {
            var autoScalingGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AutoScalingGroups"))
            for (index0, autoscalinggroup0) in autoScalingGroups.enumerated() {
                try autoScalingGroupsContainer.encode(autoscalinggroup0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        if let instances = instances {
            var instancesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Instances"))
            for (index0, instance0) in instances.enumerated() {
                try instancesContainer.encode(instance0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let launchConfigurations = launchConfigurations {
            var launchConfigurationsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LaunchConfigurations"))
            for (index0, launchconfiguration0) in launchConfigurations.enumerated() {
                try launchConfigurationsContainer.encode(launchconfiguration0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let launchTemplates = launchTemplates {
            var launchTemplatesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LaunchTemplates"))
            for (index0, launchtemplate0) in launchTemplates.enumerated() {
                try launchTemplatesContainer.encode(launchtemplate0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let loadBalancers = loadBalancers {
            var loadBalancersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LoadBalancers"))
            for (index0, loadbalancer0) in loadBalancers.enumerated() {
                try loadBalancersContainer.encode(loadbalancer0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let queues = queues {
            var queuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Queues"))
            for (index0, queue0) in queues.enumerated() {
                try queuesContainer.encode(queue0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let triggers = triggers {
            var triggersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Triggers"))
            for (index0, trigger0) in triggers.enumerated() {
                try triggersContainer.encode(trigger0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        if containerValues.contains(.autoScalingGroups) {
            struct KeyVal0{struct member{}}
            let autoScalingGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .autoScalingGroups)
            if let autoScalingGroupsWrappedContainer = autoScalingGroupsWrappedContainer {
                let autoScalingGroupsContainer = try autoScalingGroupsWrappedContainer.decodeIfPresent([AutoScalingGroup].self, forKey: .member)
                var autoScalingGroupsBuffer:[AutoScalingGroup]? = nil
                if let autoScalingGroupsContainer = autoScalingGroupsContainer {
                    autoScalingGroupsBuffer = [AutoScalingGroup]()
                    for structureContainer0 in autoScalingGroupsContainer {
                        autoScalingGroupsBuffer?.append(structureContainer0)
                    }
                }
                autoScalingGroups = autoScalingGroupsBuffer
            } else {
                autoScalingGroups = []
            }
        } else {
            autoScalingGroups = nil
        }
        if containerValues.contains(.instances) {
            struct KeyVal0{struct member{}}
            let instancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instances)
            if let instancesWrappedContainer = instancesWrappedContainer {
                let instancesContainer = try instancesWrappedContainer.decodeIfPresent([Instance].self, forKey: .member)
                var instancesBuffer:[Instance]? = nil
                if let instancesContainer = instancesContainer {
                    instancesBuffer = [Instance]()
                    for structureContainer0 in instancesContainer {
                        instancesBuffer?.append(structureContainer0)
                    }
                }
                instances = instancesBuffer
            } else {
                instances = []
            }
        } else {
            instances = nil
        }
        if containerValues.contains(.launchConfigurations) {
            struct KeyVal0{struct member{}}
            let launchConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .launchConfigurations)
            if let launchConfigurationsWrappedContainer = launchConfigurationsWrappedContainer {
                let launchConfigurationsContainer = try launchConfigurationsWrappedContainer.decodeIfPresent([LaunchConfiguration].self, forKey: .member)
                var launchConfigurationsBuffer:[LaunchConfiguration]? = nil
                if let launchConfigurationsContainer = launchConfigurationsContainer {
                    launchConfigurationsBuffer = [LaunchConfiguration]()
                    for structureContainer0 in launchConfigurationsContainer {
                        launchConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                launchConfigurations = launchConfigurationsBuffer
            } else {
                launchConfigurations = []
            }
        } else {
            launchConfigurations = nil
        }
        if containerValues.contains(.launchTemplates) {
            struct KeyVal0{struct member{}}
            let launchTemplatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .launchTemplates)
            if let launchTemplatesWrappedContainer = launchTemplatesWrappedContainer {
                let launchTemplatesContainer = try launchTemplatesWrappedContainer.decodeIfPresent([LaunchTemplate].self, forKey: .member)
                var launchTemplatesBuffer:[LaunchTemplate]? = nil
                if let launchTemplatesContainer = launchTemplatesContainer {
                    launchTemplatesBuffer = [LaunchTemplate]()
                    for structureContainer0 in launchTemplatesContainer {
                        launchTemplatesBuffer?.append(structureContainer0)
                    }
                }
                launchTemplates = launchTemplatesBuffer
            } else {
                launchTemplates = []
            }
        } else {
            launchTemplates = nil
        }
        if containerValues.contains(.loadBalancers) {
            struct KeyVal0{struct member{}}
            let loadBalancersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .loadBalancers)
            if let loadBalancersWrappedContainer = loadBalancersWrappedContainer {
                let loadBalancersContainer = try loadBalancersWrappedContainer.decodeIfPresent([LoadBalancer].self, forKey: .member)
                var loadBalancersBuffer:[LoadBalancer]? = nil
                if let loadBalancersContainer = loadBalancersContainer {
                    loadBalancersBuffer = [LoadBalancer]()
                    for structureContainer0 in loadBalancersContainer {
                        loadBalancersBuffer?.append(structureContainer0)
                    }
                }
                loadBalancers = loadBalancersBuffer
            } else {
                loadBalancers = []
            }
        } else {
            loadBalancers = nil
        }
        if containerValues.contains(.triggers) {
            struct KeyVal0{struct member{}}
            let triggersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .triggers)
            if let triggersWrappedContainer = triggersWrappedContainer {
                let triggersContainer = try triggersWrappedContainer.decodeIfPresent([Trigger].self, forKey: .member)
                var triggersBuffer:[Trigger]? = nil
                if let triggersContainer = triggersContainer {
                    triggersBuffer = [Trigger]()
                    for structureContainer0 in triggersContainer {
                        triggersBuffer?.append(structureContainer0)
                    }
                }
                triggers = triggersBuffer
            } else {
                triggers = []
            }
        } else {
            triggers = nil
        }
        if containerValues.contains(.queues) {
            struct KeyVal0{struct member{}}
            let queuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .queues)
            if let queuesWrappedContainer = queuesWrappedContainer {
                let queuesContainer = try queuesWrappedContainer.decodeIfPresent([Queue].self, forKey: .member)
                var queuesBuffer:[Queue]? = nil
                if let queuesContainer = queuesContainer {
                    queuesBuffer = [Queue]()
                    for structureContainer0 in queuesContainer {
                        queuesBuffer?.append(structureContainer0)
                    }
                }
                queues = queuesBuffer
            } else {
                queues = []
            }
        } else {
            queues = nil
        }
    }
}

extension EnvironmentResourceDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnvironmentResourceDescription(autoScalingGroups: \(String(describing: autoScalingGroups)), environmentName: \(String(describing: environmentName)), instances: \(String(describing: instances)), launchConfigurations: \(String(describing: launchConfigurations)), launchTemplates: \(String(describing: launchTemplates)), loadBalancers: \(String(describing: loadBalancers)), queues: \(String(describing: queues)), triggers: \(String(describing: triggers)))"}
}

/// <p>Describes the AWS resources in use by this environment. This data is live.</p>
public struct EnvironmentResourceDescription: Equatable {
    /// <p> The <code>AutoScalingGroups</code> used by this environment. </p>
    public let autoScalingGroups: [AutoScalingGroup]?
    /// <p>The name of the environment.</p>
    public let environmentName: String?
    /// <p>The Amazon EC2 instances used by this environment.</p>
    public let instances: [Instance]?
    /// <p>The Auto Scaling launch configurations in use by this environment.</p>
    public let launchConfigurations: [LaunchConfiguration]?
    /// <p>The Amazon EC2 launch templates in use by this environment.</p>
    public let launchTemplates: [LaunchTemplate]?
    /// <p>The LoadBalancers in use by this environment.</p>
    public let loadBalancers: [LoadBalancer]?
    /// <p>The queues used by this environment.</p>
    public let queues: [Queue]?
    /// <p>The <code>AutoScaling</code> triggers in use by this environment. </p>
    public let triggers: [Trigger]?

    public init (
        autoScalingGroups: [AutoScalingGroup]? = nil,
        environmentName: String? = nil,
        instances: [Instance]? = nil,
        launchConfigurations: [LaunchConfiguration]? = nil,
        launchTemplates: [LaunchTemplate]? = nil,
        loadBalancers: [LoadBalancer]? = nil,
        queues: [Queue]? = nil,
        triggers: [Trigger]? = nil
    )
    {
        self.autoScalingGroups = autoScalingGroups
        self.environmentName = environmentName
        self.instances = instances
        self.launchConfigurations = launchConfigurations
        self.launchTemplates = launchTemplates
        self.loadBalancers = loadBalancers
        self.queues = queues
        self.triggers = triggers
    }
}

extension EnvironmentResourcesDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case loadBalancer = "LoadBalancer"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancer = loadBalancer {
            try container.encode(loadBalancer, forKey: Key("LoadBalancer"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerDecoded = try containerValues.decodeIfPresent(LoadBalancerDescription.self, forKey: .loadBalancer)
        loadBalancer = loadBalancerDecoded
    }
}

extension EnvironmentResourcesDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnvironmentResourcesDescription(loadBalancer: \(String(describing: loadBalancer)))"}
}

/// <p>Describes the AWS resources in use by this environment. This data is not live
///       data.</p>
public struct EnvironmentResourcesDescription: Equatable {
    /// <p>Describes the LoadBalancer.</p>
    public let loadBalancer: LoadBalancerDescription?

    public init (
        loadBalancer: LoadBalancerDescription? = nil
    )
    {
        self.loadBalancer = loadBalancer
    }
}

public enum EnvironmentStatus {
    case aborting
    case launching
    case linkingfrom
    case linkingto
    case ready
    case terminated
    case terminating
    case updating
    case sdkUnknown(String)
}

extension EnvironmentStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EnvironmentStatus] {
        return [
            .aborting,
            .launching,
            .linkingfrom,
            .linkingto,
            .ready,
            .terminated,
            .terminating,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aborting: return "Aborting"
        case .launching: return "Launching"
        case .linkingfrom: return "LinkingFrom"
        case .linkingto: return "LinkingTo"
        case .ready: return "Ready"
        case .terminated: return "Terminated"
        case .terminating: return "Terminating"
        case .updating: return "Updating"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EnvironmentStatus(rawValue: rawValue) ?? EnvironmentStatus.sdkUnknown(rawValue)
    }
}

extension EnvironmentTier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case type = "Type"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("Type"))
        }
        if let version = version {
            try container.encode(version, forKey: Key("Version"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension EnvironmentTier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnvironmentTier(name: \(String(describing: name)), type: \(String(describing: type)), version: \(String(describing: version)))"}
}

/// <p>Describes the properties of an environment tier</p>
public struct EnvironmentTier: Equatable {
    /// <p>The name of this environment tier.</p>
    ///          <p>Valid values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>For <i>Web server tier</i> – <code>WebServer</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>For <i>Worker tier</i> – <code>Worker</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let name: String?
    /// <p>The type of this environment tier.</p>
    ///          <p>Valid values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>For <i>Web server tier</i> – <code>Standard</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>For <i>Worker tier</i> – <code>SQS/HTTP</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let type: String?
    /// <p>The version of this environment tier. When you don't set a value to it, Elastic Beanstalk uses the
    ///       latest compatible worker tier version.</p>
    ///          <note>
    ///             <p>This member is deprecated. Any specific version that you set may become out of date.
    ///         We recommend leaving it unspecified.</p>
    ///          </note>
    public let version: String?

    public init (
        name: String? = nil,
        type: String? = nil,
        version: String? = nil
    )
    {
        self.name = name
        self.type = type
        self.version = version
    }
}

extension EventDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case environmentName = "EnvironmentName"
        case eventDate = "EventDate"
        case message = "Message"
        case platformArn = "PlatformArn"
        case requestId = "RequestId"
        case severity = "Severity"
        case templateName = "TemplateName"
        case versionLabel = "VersionLabel"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        if let eventDate = eventDate {
            try container.encode(TimestampWrapper(eventDate, format: .dateTime), forKey: Key("eventDate"))
        }
        if let message = message {
            try container.encode(message, forKey: Key("Message"))
        }
        if let platformArn = platformArn {
            try container.encode(platformArn, forKey: Key("PlatformArn"))
        }
        if let requestId = requestId {
            try container.encode(requestId, forKey: Key("RequestId"))
        }
        if let severity = severity {
            try container.encode(severity, forKey: Key("Severity"))
        }
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        if let versionLabel = versionLabel {
            try container.encode(versionLabel, forKey: Key("VersionLabel"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventDate)
        var eventDateBuffer:Date? = nil
        if let eventDateDecoded = eventDateDecoded {
            eventDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(eventDateDecoded, format: .dateTime)
        }
        eventDate = eventDateBuffer
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let versionLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionLabel)
        versionLabel = versionLabelDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let platformArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformArn)
        platformArn = platformArnDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let severityDecoded = try containerValues.decodeIfPresent(EventSeverity.self, forKey: .severity)
        severity = severityDecoded
    }
}

extension EventDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventDescription(applicationName: \(String(describing: applicationName)), environmentName: \(String(describing: environmentName)), eventDate: \(String(describing: eventDate)), message: \(String(describing: message)), platformArn: \(String(describing: platformArn)), requestId: \(String(describing: requestId)), severity: \(String(describing: severity)), templateName: \(String(describing: templateName)), versionLabel: \(String(describing: versionLabel)))"}
}

/// <p>Describes an event.</p>
public struct EventDescription: Equatable {
    /// <p>The application associated with the event.</p>
    public let applicationName: String?
    /// <p>The name of the environment associated with this event.</p>
    public let environmentName: String?
    /// <p>The date when the event occurred.</p>
    public let eventDate: Date?
    /// <p>The event message.</p>
    public let message: String?
    /// <p>The ARN of the platform version.</p>
    public let platformArn: String?
    /// <p>The web service request ID for the activity of this event.</p>
    public let requestId: String?
    /// <p>The severity level of this event.</p>
    public let severity: EventSeverity?
    /// <p>The name of the configuration associated with this event.</p>
    public let templateName: String?
    /// <p>The release label for the application version associated with this event.</p>
    public let versionLabel: String?

    public init (
        applicationName: String? = nil,
        environmentName: String? = nil,
        eventDate: Date? = nil,
        message: String? = nil,
        platformArn: String? = nil,
        requestId: String? = nil,
        severity: EventSeverity? = nil,
        templateName: String? = nil,
        versionLabel: String? = nil
    )
    {
        self.applicationName = applicationName
        self.environmentName = environmentName
        self.eventDate = eventDate
        self.message = message
        self.platformArn = platformArn
        self.requestId = requestId
        self.severity = severity
        self.templateName = templateName
        self.versionLabel = versionLabel
    }
}

public enum EventSeverity {
    case debug
    case error
    case fatal
    case info
    case trace
    case warn
    case sdkUnknown(String)
}

extension EventSeverity : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventSeverity] {
        return [
            .debug,
            .error,
            .fatal,
            .info,
            .trace,
            .warn,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .debug: return "DEBUG"
        case .error: return "ERROR"
        case .fatal: return "FATAL"
        case .info: return "INFO"
        case .trace: return "TRACE"
        case .warn: return "WARN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventSeverity(rawValue: rawValue) ?? EventSeverity.sdkUnknown(rawValue)
    }
}

public enum FailureType {
    case cancellationfailed
    case internalfailure
    case invalidenvironmentstate
    case permissionserror
    case rollbackfailed
    case rollbacksuccessful
    case updatecancelled
    case sdkUnknown(String)
}

extension FailureType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FailureType] {
        return [
            .cancellationfailed,
            .internalfailure,
            .invalidenvironmentstate,
            .permissionserror,
            .rollbackfailed,
            .rollbacksuccessful,
            .updatecancelled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancellationfailed: return "CancellationFailed"
        case .internalfailure: return "InternalFailure"
        case .invalidenvironmentstate: return "InvalidEnvironmentState"
        case .permissionserror: return "PermissionsError"
        case .rollbackfailed: return "RollbackFailed"
        case .rollbacksuccessful: return "RollbackSuccessful"
        case .updatecancelled: return "UpdateCancelled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FailureType(rawValue: rawValue) ?? FailureType.sdkUnknown(rawValue)
    }
}

extension Instance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let id = id {
            try container.encode(id, forKey: Key("Id"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension Instance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Instance(id: \(String(describing: id)))"}
}

/// <p>The description of an Amazon EC2 instance.</p>
public struct Instance: Equatable {
    /// <p>The ID of the Amazon EC2 instance.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

extension InstanceHealthSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case degraded = "Degraded"
        case info = "Info"
        case noData = "NoData"
        case ok = "Ok"
        case pending = "Pending"
        case severe = "Severe"
        case unknown = "Unknown"
        case warning = "Warning"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let degraded = degraded {
            try container.encode(degraded, forKey: Key("Degraded"))
        }
        if let info = info {
            try container.encode(info, forKey: Key("Info"))
        }
        if let noData = noData {
            try container.encode(noData, forKey: Key("NoData"))
        }
        if let ok = ok {
            try container.encode(ok, forKey: Key("Ok"))
        }
        if let pending = pending {
            try container.encode(pending, forKey: Key("Pending"))
        }
        if let severe = severe {
            try container.encode(severe, forKey: Key("Severe"))
        }
        if let unknown = unknown {
            try container.encode(unknown, forKey: Key("Unknown"))
        }
        if let warning = warning {
            try container.encode(warning, forKey: Key("Warning"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noDataDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .noData)
        noData = noDataDecoded
        let unknownDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .unknown)
        unknown = unknownDecoded
        let pendingDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .pending)
        pending = pendingDecoded
        let okDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .ok)
        ok = okDecoded
        let infoDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .info)
        info = infoDecoded
        let warningDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .warning)
        warning = warningDecoded
        let degradedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .degraded)
        degraded = degradedDecoded
        let severeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .severe)
        severe = severeDecoded
    }
}

extension InstanceHealthSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceHealthSummary(degraded: \(String(describing: degraded)), info: \(String(describing: info)), noData: \(String(describing: noData)), ok: \(String(describing: ok)), pending: \(String(describing: pending)), severe: \(String(describing: severe)), unknown: \(String(describing: unknown)), warning: \(String(describing: warning)))"}
}

/// <p>Represents summary information about the health of an instance. For more information,
///       see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/health-enhanced-status.html">Health Colors and Statuses</a>.</p>
public struct InstanceHealthSummary: Equatable {
    /// <p>
    ///             <b>Red.</b> The health agent is reporting a high number of request
    ///       failures or other issues for an instance or environment.</p>
    public let degraded: Int?
    /// <p>
    ///             <b>Green.</b> An operation is in progress on an instance.</p>
    public let info: Int?
    /// <p>
    ///             <b>Grey.</b> AWS Elastic Beanstalk and the health agent are
    ///       reporting no data on an instance.</p>
    public let noData: Int?
    /// <p>
    ///             <b>Green.</b> An instance is passing health checks and the health
    ///       agent is not reporting any problems.</p>
    public let ok: Int?
    /// <p>
    ///             <b>Grey.</b> An operation is in progress on an instance within the
    ///       command timeout.</p>
    public let pending: Int?
    /// <p>
    ///             <b>Red.</b> The health agent is reporting a very high number of
    ///       request failures or other issues for an instance or environment.</p>
    public let severe: Int?
    /// <p>
    ///             <b>Grey.</b> AWS Elastic Beanstalk and the health agent are
    ///       reporting an insufficient amount of data on an instance.</p>
    public let unknown: Int?
    /// <p>
    ///             <b>Yellow.</b> The health agent is reporting a moderate number of
    ///       request failures or other issues for an instance or environment.</p>
    public let warning: Int?

    public init (
        degraded: Int? = nil,
        info: Int? = nil,
        noData: Int? = nil,
        ok: Int? = nil,
        pending: Int? = nil,
        severe: Int? = nil,
        unknown: Int? = nil,
        warning: Int? = nil
    )
    {
        self.degraded = degraded
        self.info = info
        self.noData = noData
        self.ok = ok
        self.pending = pending
        self.severe = severe
        self.unknown = unknown
        self.warning = warning
    }
}

public enum InstancesHealthAttribute {
    case all
    case applicationmetrics
    case availabilityzone
    case causes
    case color
    case deployment
    case healthstatus
    case instancetype
    case launchedat
    case refreshedat
    case system
    case sdkUnknown(String)
}

extension InstancesHealthAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InstancesHealthAttribute] {
        return [
            .all,
            .applicationmetrics,
            .availabilityzone,
            .causes,
            .color,
            .deployment,
            .healthstatus,
            .instancetype,
            .launchedat,
            .refreshedat,
            .system,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "All"
        case .applicationmetrics: return "ApplicationMetrics"
        case .availabilityzone: return "AvailabilityZone"
        case .causes: return "Causes"
        case .color: return "Color"
        case .deployment: return "Deployment"
        case .healthstatus: return "HealthStatus"
        case .instancetype: return "InstanceType"
        case .launchedat: return "LaunchedAt"
        case .refreshedat: return "RefreshedAt"
        case .system: return "System"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InstancesHealthAttribute(rawValue: rawValue) ?? InstancesHealthAttribute.sdkUnknown(rawValue)
    }
}

extension InsufficientPrivilegesException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientPrivilegesException(message: \(String(describing: message)))"}
}

extension InsufficientPrivilegesException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InsufficientPrivilegesExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified account does not have sufficient privileges for one or more AWS
///       services.</p>
public struct InsufficientPrivilegesException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientPrivilegesExceptionBody: Equatable {
    public let message: String?
}

extension InsufficientPrivilegesExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidRequestExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more input parameters is not valid. Please correct the input parameters and try
///       the operation again.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Latency: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case p10 = "P10"
        case p50 = "P50"
        case p75 = "P75"
        case p85 = "P85"
        case p90 = "P90"
        case p95 = "P95"
        case p99 = "P99"
        case p999 = "P999"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let p10 = p10 {
            try container.encode(p10, forKey: Key("P10"))
        }
        if let p50 = p50 {
            try container.encode(p50, forKey: Key("P50"))
        }
        if let p75 = p75 {
            try container.encode(p75, forKey: Key("P75"))
        }
        if let p85 = p85 {
            try container.encode(p85, forKey: Key("P85"))
        }
        if let p90 = p90 {
            try container.encode(p90, forKey: Key("P90"))
        }
        if let p95 = p95 {
            try container.encode(p95, forKey: Key("P95"))
        }
        if let p99 = p99 {
            try container.encode(p99, forKey: Key("P99"))
        }
        if let p999 = p999 {
            try container.encode(p999, forKey: Key("P999"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let p999Decoded = try containerValues.decodeIfPresent(Double.self, forKey: .p999)
        p999 = p999Decoded
        let p99Decoded = try containerValues.decodeIfPresent(Double.self, forKey: .p99)
        p99 = p99Decoded
        let p95Decoded = try containerValues.decodeIfPresent(Double.self, forKey: .p95)
        p95 = p95Decoded
        let p90Decoded = try containerValues.decodeIfPresent(Double.self, forKey: .p90)
        p90 = p90Decoded
        let p85Decoded = try containerValues.decodeIfPresent(Double.self, forKey: .p85)
        p85 = p85Decoded
        let p75Decoded = try containerValues.decodeIfPresent(Double.self, forKey: .p75)
        p75 = p75Decoded
        let p50Decoded = try containerValues.decodeIfPresent(Double.self, forKey: .p50)
        p50 = p50Decoded
        let p10Decoded = try containerValues.decodeIfPresent(Double.self, forKey: .p10)
        p10 = p10Decoded
    }
}

extension Latency: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Latency(p10: \(String(describing: p10)), p50: \(String(describing: p50)), p75: \(String(describing: p75)), p85: \(String(describing: p85)), p90: \(String(describing: p90)), p95: \(String(describing: p95)), p99: \(String(describing: p99)), p999: \(String(describing: p999)))"}
}

/// <p>Represents the average latency for the slowest X percent of requests over the last 10
///       seconds.</p>
public struct Latency: Equatable {
    /// <p>The average latency for the slowest 90 percent of requests over the last 10
    ///       seconds.</p>
    public let p10: Double?
    /// <p>The average latency for the slowest 50 percent of requests over the last 10
    ///       seconds.</p>
    public let p50: Double?
    /// <p>The average latency for the slowest 25 percent of requests over the last 10
    ///       seconds.</p>
    public let p75: Double?
    /// <p>The average latency for the slowest 15 percent of requests over the last 10
    ///       seconds.</p>
    public let p85: Double?
    /// <p>The average latency for the slowest 10 percent of requests over the last 10
    ///       seconds.</p>
    public let p90: Double?
    /// <p>The average latency for the slowest 5 percent of requests over the last 10
    ///       seconds.</p>
    public let p95: Double?
    /// <p>The average latency for the slowest 1 percent of requests over the last 10
    ///       seconds.</p>
    public let p99: Double?
    /// <p>The average latency for the slowest 0.1 percent of requests over the last 10
    ///       seconds.</p>
    public let p999: Double?

    public init (
        p10: Double? = nil,
        p50: Double? = nil,
        p75: Double? = nil,
        p85: Double? = nil,
        p90: Double? = nil,
        p95: Double? = nil,
        p99: Double? = nil,
        p999: Double? = nil
    )
    {
        self.p10 = p10
        self.p50 = p50
        self.p75 = p75
        self.p85 = p85
        self.p90 = p90
        self.p95 = p95
        self.p99 = p99
        self.p999 = p999
    }
}

extension LaunchConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension LaunchConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LaunchConfiguration(name: \(String(describing: name)))"}
}

/// <p>Describes an Auto Scaling launch configuration.</p>
public struct LaunchConfiguration: Equatable {
    /// <p>The name of the launch configuration.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension LaunchTemplate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let id = id {
            try container.encode(id, forKey: Key("Id"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension LaunchTemplate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LaunchTemplate(id: \(String(describing: id)))"}
}

/// <p>Describes an Amazon EC2 launch template.</p>
public struct LaunchTemplate: Equatable {
    /// <p>The ID of the launch template.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

public struct ListAvailableSolutionStacksInputBodyMiddleware: Middleware {
    public let id: String = "ListAvailableSolutionStacksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAvailableSolutionStacksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAvailableSolutionStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAvailableSolutionStacksInput>
    public typealias MOutput = OperationOutput<ListAvailableSolutionStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAvailableSolutionStacksOutputError>
}

extension ListAvailableSolutionStacksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAvailableSolutionStacksInput()"}
}

extension ListAvailableSolutionStacksInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("ListAvailableSolutionStacks", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct ListAvailableSolutionStacksInputHeadersMiddleware: Middleware {
    public let id: String = "ListAvailableSolutionStacksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAvailableSolutionStacksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAvailableSolutionStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAvailableSolutionStacksInput>
    public typealias MOutput = OperationOutput<ListAvailableSolutionStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAvailableSolutionStacksOutputError>
}

public struct ListAvailableSolutionStacksInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAvailableSolutionStacksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAvailableSolutionStacksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAvailableSolutionStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAvailableSolutionStacksInput>
    public typealias MOutput = OperationOutput<ListAvailableSolutionStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAvailableSolutionStacksOutputError>
}

public struct ListAvailableSolutionStacksInput: Equatable {

    public init() {}
}

extension ListAvailableSolutionStacksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListAvailableSolutionStacksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAvailableSolutionStacksOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAvailableSolutionStacksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAvailableSolutionStacksOutputResponse(solutionStackDetails: \(String(describing: solutionStackDetails)), solutionStacks: \(String(describing: solutionStacks)))"}
}

extension ListAvailableSolutionStacksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAvailableSolutionStacksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.solutionStackDetails = output.solutionStackDetails
            self.solutionStacks = output.solutionStacks
        } else {
            self.solutionStackDetails = nil
            self.solutionStacks = nil
        }
    }
}

/// <p>A list of available AWS Elastic Beanstalk solution stacks.</p>
public struct ListAvailableSolutionStacksOutputResponse: Equatable {
    /// <p> A list of available solution stacks and their <a>SolutionStackDescription</a>. </p>
    public let solutionStackDetails: [SolutionStackDescription]?
    /// <p>A list of available solution stacks.</p>
    public let solutionStacks: [String]?

    public init (
        solutionStackDetails: [SolutionStackDescription]? = nil,
        solutionStacks: [String]? = nil
    )
    {
        self.solutionStackDetails = solutionStackDetails
        self.solutionStacks = solutionStacks
    }
}

struct ListAvailableSolutionStacksOutputResponseBody: Equatable {
    public let solutionStacks: [String]?
    public let solutionStackDetails: [SolutionStackDescription]?
}

extension ListAvailableSolutionStacksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case solutionStackDetails = "SolutionStackDetails"
        case solutionStacks = "SolutionStacks"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListAvailableSolutionStacksResult"))
        if containerValues.contains(.solutionStacks) {
            struct KeyVal0{struct member{}}
            let solutionStacksWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .solutionStacks)
            if let solutionStacksWrappedContainer = solutionStacksWrappedContainer {
                let solutionStacksContainer = try solutionStacksWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var solutionStacksBuffer:[String]? = nil
                if let solutionStacksContainer = solutionStacksContainer {
                    solutionStacksBuffer = [String]()
                    for stringContainer0 in solutionStacksContainer {
                        solutionStacksBuffer?.append(stringContainer0)
                    }
                }
                solutionStacks = solutionStacksBuffer
            } else {
                solutionStacks = []
            }
        } else {
            solutionStacks = nil
        }
        if containerValues.contains(.solutionStackDetails) {
            struct KeyVal0{struct member{}}
            let solutionStackDetailsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .solutionStackDetails)
            if let solutionStackDetailsWrappedContainer = solutionStackDetailsWrappedContainer {
                let solutionStackDetailsContainer = try solutionStackDetailsWrappedContainer.decodeIfPresent([SolutionStackDescription].self, forKey: .member)
                var solutionStackDetailsBuffer:[SolutionStackDescription]? = nil
                if let solutionStackDetailsContainer = solutionStackDetailsContainer {
                    solutionStackDetailsBuffer = [SolutionStackDescription]()
                    for structureContainer0 in solutionStackDetailsContainer {
                        solutionStackDetailsBuffer?.append(structureContainer0)
                    }
                }
                solutionStackDetails = solutionStackDetailsBuffer
            } else {
                solutionStackDetails = []
            }
        } else {
            solutionStackDetails = nil
        }
    }
}

public struct ListPlatformBranchesInputBodyMiddleware: Middleware {
    public let id: String = "ListPlatformBranchesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPlatformBranchesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPlatformBranchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPlatformBranchesInput>
    public typealias MOutput = OperationOutput<ListPlatformBranchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPlatformBranchesOutputError>
}

extension ListPlatformBranchesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPlatformBranchesInput(filters: \(String(describing: filters)), maxRecords: \(String(describing: maxRecords)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPlatformBranchesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, searchfilter0) in filters.enumerated() {
                try filtersContainer.encode(searchfilter0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        try container.encode("ListPlatformBranches", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct ListPlatformBranchesInputHeadersMiddleware: Middleware {
    public let id: String = "ListPlatformBranchesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPlatformBranchesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPlatformBranchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPlatformBranchesInput>
    public typealias MOutput = OperationOutput<ListPlatformBranchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPlatformBranchesOutputError>
}

public struct ListPlatformBranchesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPlatformBranchesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPlatformBranchesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPlatformBranchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPlatformBranchesInput>
    public typealias MOutput = OperationOutput<ListPlatformBranchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPlatformBranchesOutputError>
}

public struct ListPlatformBranchesInput: Equatable {
    /// <p>Criteria for restricting the resulting list of platform branches. The filter is evaluated
    ///       as a logical conjunction (AND) of the separate <code>SearchFilter</code> terms.</p>
    ///          <p>The following list shows valid attribute values for each of the <code>SearchFilter</code>
    ///       terms. Most operators take a single value. The <code>in</code> and <code>not_in</code>
    ///       operators can take multiple values.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Attribute = BranchName</code>:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>Operator</code>: <code>=</code> | <code>!=</code> | <code>begins_with</code>
    ///               | <code>ends_with</code> | <code>contains</code> | <code>in</code> |
    ///                 <code>not_in</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Attribute = LifecycleState</code>:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>Operator</code>: <code>=</code> | <code>!=</code> | <code>in</code> |
    ///                 <code>not_in</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>Values</code>: <code>beta</code> | <code>supported</code> |
    ///                 <code>deprecated</code> | <code>retired</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Attribute = PlatformName</code>:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>Operator</code>: <code>=</code> | <code>!=</code> | <code>begins_with</code>
    ///               | <code>ends_with</code> | <code>contains</code> | <code>in</code> |
    ///               <code>not_in</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Attribute = TierType</code>:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>Operator</code>: <code>=</code> | <code>!=</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>Values</code>: <code>WebServer/Standard</code> | <code>Worker/SQS/HTTP</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    ///          <p>Array size: limited to 10 <code>SearchFilter</code> objects.</p>
    ///          <p>Within each <code>SearchFilter</code> item, the <code>Values</code> array is limited to 10
    ///       items.</p>
    public let filters: [SearchFilter]?
    /// <p>The maximum number of platform branch values returned in one call.</p>
    public let maxRecords: Int?
    /// <p>For a paginated request. Specify a token from a previous response page to retrieve the
    ///       next response page. All other parameter values must be identical to the ones specified in the
    ///       initial request.</p>
    ///          <p>If no <code>NextToken</code> is specified, the first page is retrieved.</p>
    public let nextToken: String?

    public init (
        filters: [SearchFilter]? = nil,
        maxRecords: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

extension ListPlatformBranchesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPlatformBranchesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPlatformBranchesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPlatformBranchesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPlatformBranchesOutputResponse(nextToken: \(String(describing: nextToken)), platformBranchSummaryList: \(String(describing: platformBranchSummaryList)))"}
}

extension ListPlatformBranchesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPlatformBranchesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.platformBranchSummaryList = output.platformBranchSummaryList
        } else {
            self.nextToken = nil
            self.platformBranchSummaryList = nil
        }
    }
}

public struct ListPlatformBranchesOutputResponse: Equatable {
    /// <p>In a paginated request, if this value isn't <code>null</code>, it's the token that you can
    ///       pass in a subsequent request to get the next response page.</p>
    public let nextToken: String?
    /// <p>Summary information about the platform branches.</p>
    public let platformBranchSummaryList: [PlatformBranchSummary]?

    public init (
        nextToken: String? = nil,
        platformBranchSummaryList: [PlatformBranchSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.platformBranchSummaryList = platformBranchSummaryList
    }
}

struct ListPlatformBranchesOutputResponseBody: Equatable {
    public let platformBranchSummaryList: [PlatformBranchSummary]?
    public let nextToken: String?
}

extension ListPlatformBranchesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case platformBranchSummaryList = "PlatformBranchSummaryList"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListPlatformBranchesResult"))
        if containerValues.contains(.platformBranchSummaryList) {
            struct KeyVal0{struct member{}}
            let platformBranchSummaryListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .platformBranchSummaryList)
            if let platformBranchSummaryListWrappedContainer = platformBranchSummaryListWrappedContainer {
                let platformBranchSummaryListContainer = try platformBranchSummaryListWrappedContainer.decodeIfPresent([PlatformBranchSummary].self, forKey: .member)
                var platformBranchSummaryListBuffer:[PlatformBranchSummary]? = nil
                if let platformBranchSummaryListContainer = platformBranchSummaryListContainer {
                    platformBranchSummaryListBuffer = [PlatformBranchSummary]()
                    for structureContainer0 in platformBranchSummaryListContainer {
                        platformBranchSummaryListBuffer?.append(structureContainer0)
                    }
                }
                platformBranchSummaryList = platformBranchSummaryListBuffer
            } else {
                platformBranchSummaryList = []
            }
        } else {
            platformBranchSummaryList = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPlatformVersionsInputBodyMiddleware: Middleware {
    public let id: String = "ListPlatformVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPlatformVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPlatformVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPlatformVersionsInput>
    public typealias MOutput = OperationOutput<ListPlatformVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPlatformVersionsOutputError>
}

extension ListPlatformVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPlatformVersionsInput(filters: \(String(describing: filters)), maxRecords: \(String(describing: maxRecords)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPlatformVersionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, platformfilter0) in filters.enumerated() {
                try filtersContainer.encode(platformfilter0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        try container.encode("ListPlatformVersions", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct ListPlatformVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPlatformVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPlatformVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPlatformVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPlatformVersionsInput>
    public typealias MOutput = OperationOutput<ListPlatformVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPlatformVersionsOutputError>
}

public struct ListPlatformVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPlatformVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPlatformVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPlatformVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPlatformVersionsInput>
    public typealias MOutput = OperationOutput<ListPlatformVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPlatformVersionsOutputError>
}

public struct ListPlatformVersionsInput: Equatable {
    /// <p>Criteria for restricting the resulting list of platform versions. The filter is
    ///       interpreted as a logical conjunction (AND) of the separate <code>PlatformFilter</code>
    ///       terms.</p>
    public let filters: [PlatformFilter]?
    /// <p>The maximum number of platform version values returned in one call.</p>
    public let maxRecords: Int?
    /// <p>For a paginated request. Specify a token from a previous response page to retrieve the
    ///       next response page. All other parameter values must be identical to the ones specified in the
    ///       initial request.</p>
    ///          <p>If no <code>NextToken</code> is specified, the first page is retrieved.</p>
    public let nextToken: String?

    public init (
        filters: [PlatformFilter]? = nil,
        maxRecords: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

extension ListPlatformVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPlatformVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ElasticBeanstalkServiceException" : self = .elasticBeanstalkServiceException(try ElasticBeanstalkServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPlatformVersionsOutputError: Equatable {
    case elasticBeanstalkServiceException(ElasticBeanstalkServiceException)
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPlatformVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPlatformVersionsOutputResponse(nextToken: \(String(describing: nextToken)), platformSummaryList: \(String(describing: platformSummaryList)))"}
}

extension ListPlatformVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPlatformVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.platformSummaryList = output.platformSummaryList
        } else {
            self.nextToken = nil
            self.platformSummaryList = nil
        }
    }
}

public struct ListPlatformVersionsOutputResponse: Equatable {
    /// <p>In a paginated request, if this value isn't <code>null</code>, it's the token that you can
    ///       pass in a subsequent request to get the next response page.</p>
    public let nextToken: String?
    /// <p>Summary information about the platform versions.</p>
    public let platformSummaryList: [PlatformSummary]?

    public init (
        nextToken: String? = nil,
        platformSummaryList: [PlatformSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.platformSummaryList = platformSummaryList
    }
}

struct ListPlatformVersionsOutputResponseBody: Equatable {
    public let platformSummaryList: [PlatformSummary]?
    public let nextToken: String?
}

extension ListPlatformVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case platformSummaryList = "PlatformSummaryList"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListPlatformVersionsResult"))
        if containerValues.contains(.platformSummaryList) {
            struct KeyVal0{struct member{}}
            let platformSummaryListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .platformSummaryList)
            if let platformSummaryListWrappedContainer = platformSummaryListWrappedContainer {
                let platformSummaryListContainer = try platformSummaryListWrappedContainer.decodeIfPresent([PlatformSummary].self, forKey: .member)
                var platformSummaryListBuffer:[PlatformSummary]? = nil
                if let platformSummaryListContainer = platformSummaryListContainer {
                    platformSummaryListBuffer = [PlatformSummary]()
                    for structureContainer0 in platformSummaryListContainer {
                        platformSummaryListBuffer?.append(structureContainer0)
                    }
                }
                platformSummaryList = platformSummaryListBuffer
            } else {
                platformSummaryList = []
            }
        } else {
            platformSummaryList = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: Key("ResourceArn"))
        }
        try container.encode("ListTagsForResource", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resouce for which a tag list is requested.</p>
    ///          <p>Must be the ARN of an Elastic Beanstalk resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceTypeNotSupportedException" : self = .resourceTypeNotSupportedException(try ResourceTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceTypeNotSupportedException(ResourceTypeNotSupportedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(resourceArn: \(String(describing: resourceArn)), resourceTags: \(String(describing: resourceTags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceArn = output.resourceArn
            self.resourceTags = output.resourceTags
        } else {
            self.resourceArn = nil
            self.resourceTags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource for which a tag list was requested.</p>
    public let resourceArn: String?
    /// <p>A list of tag key-value pairs.</p>
    public let resourceTags: [Tag]?

    public init (
        resourceArn: String? = nil,
        resourceTags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourceTags = resourceTags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let resourceArn: String?
    public let resourceTags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case resourceTags = "ResourceTags"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListTagsForResourceResult"))
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        if containerValues.contains(.resourceTags) {
            struct KeyVal0{struct member{}}
            let resourceTagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .resourceTags)
            if let resourceTagsWrappedContainer = resourceTagsWrappedContainer {
                let resourceTagsContainer = try resourceTagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var resourceTagsBuffer:[Tag]? = nil
                if let resourceTagsContainer = resourceTagsContainer {
                    resourceTagsBuffer = [Tag]()
                    for structureContainer0 in resourceTagsContainer {
                        resourceTagsBuffer?.append(structureContainer0)
                    }
                }
                resourceTags = resourceTagsBuffer
            } else {
                resourceTags = []
            }
        } else {
            resourceTags = nil
        }
    }
}

extension Listener: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case port = "Port"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if port != 0 {
            try container.encode(port, forKey: Key("Port"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: Key("Protocol"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
    }
}

extension Listener: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Listener(port: \(String(describing: port)), protocol: \(String(describing: `protocol`)))"}
}

/// <p>Describes the properties of a Listener for the LoadBalancer.</p>
public struct Listener: Equatable {
    /// <p>The protocol that is used by the Listener.</p>
    public let `protocol`: String?
    /// <p>The port that is used by the Listener.</p>
    public let port: Int

    public init (
        `protocol`: String? = nil,
        port: Int = 0
    )
    {
        self.`protocol` = `protocol`
        self.port = port
    }
}

extension LoadBalancer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension LoadBalancer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoadBalancer(name: \(String(describing: name)))"}
}

/// <p>Describes a LoadBalancer.</p>
public struct LoadBalancer: Equatable {
    /// <p>The name of the LoadBalancer.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension LoadBalancerDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domain = "Domain"
        case listeners = "Listeners"
        case loadBalancerName = "LoadBalancerName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let domain = domain {
            try container.encode(domain, forKey: Key("Domain"))
        }
        if let listeners = listeners {
            var listenersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Listeners"))
            for (index0, listener0) in listeners.enumerated() {
                try listenersContainer.encode(listener0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
        if containerValues.contains(.listeners) {
            struct KeyVal0{struct member{}}
            let listenersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .listeners)
            if let listenersWrappedContainer = listenersWrappedContainer {
                let listenersContainer = try listenersWrappedContainer.decodeIfPresent([Listener].self, forKey: .member)
                var listenersBuffer:[Listener]? = nil
                if let listenersContainer = listenersContainer {
                    listenersBuffer = [Listener]()
                    for structureContainer0 in listenersContainer {
                        listenersBuffer?.append(structureContainer0)
                    }
                }
                listeners = listenersBuffer
            } else {
                listeners = []
            }
        } else {
            listeners = nil
        }
    }
}

extension LoadBalancerDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoadBalancerDescription(domain: \(String(describing: domain)), listeners: \(String(describing: listeners)), loadBalancerName: \(String(describing: loadBalancerName)))"}
}

/// <p>Describes the details of a LoadBalancer.</p>
public struct LoadBalancerDescription: Equatable {
    /// <p>The domain name of the LoadBalancer.</p>
    public let domain: String?
    /// <p>A list of Listeners used by the LoadBalancer.</p>
    public let listeners: [Listener]?
    /// <p>The name of the LoadBalancer.</p>
    public let loadBalancerName: String?

    public init (
        domain: String? = nil,
        listeners: [Listener]? = nil,
        loadBalancerName: String? = nil
    )
    {
        self.domain = domain
        self.listeners = listeners
        self.loadBalancerName = loadBalancerName
    }
}

extension ManagedAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionDescription = "ActionDescription"
        case actionId = "ActionId"
        case actionType = "ActionType"
        case status = "Status"
        case windowStartTime = "WindowStartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let actionDescription = actionDescription {
            try container.encode(actionDescription, forKey: Key("ActionDescription"))
        }
        if let actionId = actionId {
            try container.encode(actionId, forKey: Key("ActionId"))
        }
        if let actionType = actionType {
            try container.encode(actionType, forKey: Key("ActionType"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let windowStartTime = windowStartTime {
            try container.encode(TimestampWrapper(windowStartTime, format: .dateTime), forKey: Key("windowStartTime"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let actionDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionDescription)
        actionDescription = actionDescriptionDecoded
        let actionTypeDecoded = try containerValues.decodeIfPresent(ActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ActionStatus.self, forKey: .status)
        status = statusDecoded
        let windowStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowStartTime)
        var windowStartTimeBuffer:Date? = nil
        if let windowStartTimeDecoded = windowStartTimeDecoded {
            windowStartTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(windowStartTimeDecoded, format: .dateTime)
        }
        windowStartTime = windowStartTimeBuffer
    }
}

extension ManagedAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ManagedAction(actionDescription: \(String(describing: actionDescription)), actionId: \(String(describing: actionId)), actionType: \(String(describing: actionType)), status: \(String(describing: status)), windowStartTime: \(String(describing: windowStartTime)))"}
}

/// <p>The record of an upcoming or in-progress managed action.</p>
public struct ManagedAction: Equatable {
    /// <p>A description of the managed action.</p>
    public let actionDescription: String?
    /// <p>A unique identifier for the managed action.</p>
    public let actionId: String?
    /// <p>The type of managed action.</p>
    public let actionType: ActionType?
    /// <p>The status of the managed action. If the action is <code>Scheduled</code>, you can
    ///       apply it immediately with <a>ApplyEnvironmentManagedAction</a>.</p>
    public let status: ActionStatus?
    /// <p>The start time of the maintenance window in which the managed action will
    ///       execute.</p>
    public let windowStartTime: Date?

    public init (
        actionDescription: String? = nil,
        actionId: String? = nil,
        actionType: ActionType? = nil,
        status: ActionStatus? = nil,
        windowStartTime: Date? = nil
    )
    {
        self.actionDescription = actionDescription
        self.actionId = actionId
        self.actionType = actionType
        self.status = status
        self.windowStartTime = windowStartTime
    }
}

extension ManagedActionHistoryItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionDescription = "ActionDescription"
        case actionId = "ActionId"
        case actionType = "ActionType"
        case executedTime = "ExecutedTime"
        case failureDescription = "FailureDescription"
        case failureType = "FailureType"
        case finishedTime = "FinishedTime"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let actionDescription = actionDescription {
            try container.encode(actionDescription, forKey: Key("ActionDescription"))
        }
        if let actionId = actionId {
            try container.encode(actionId, forKey: Key("ActionId"))
        }
        if let actionType = actionType {
            try container.encode(actionType, forKey: Key("ActionType"))
        }
        if let executedTime = executedTime {
            try container.encode(TimestampWrapper(executedTime, format: .dateTime), forKey: Key("executedTime"))
        }
        if let failureDescription = failureDescription {
            try container.encode(failureDescription, forKey: Key("FailureDescription"))
        }
        if let failureType = failureType {
            try container.encode(failureType, forKey: Key("FailureType"))
        }
        if let finishedTime = finishedTime {
            try container.encode(TimestampWrapper(finishedTime, format: .dateTime), forKey: Key("finishedTime"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let actionTypeDecoded = try containerValues.decodeIfPresent(ActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let actionDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionDescription)
        actionDescription = actionDescriptionDecoded
        let failureTypeDecoded = try containerValues.decodeIfPresent(FailureType.self, forKey: .failureType)
        failureType = failureTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ActionHistoryStatus.self, forKey: .status)
        status = statusDecoded
        let failureDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureDescription)
        failureDescription = failureDescriptionDecoded
        let executedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executedTime)
        var executedTimeBuffer:Date? = nil
        if let executedTimeDecoded = executedTimeDecoded {
            executedTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(executedTimeDecoded, format: .dateTime)
        }
        executedTime = executedTimeBuffer
        let finishedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .finishedTime)
        var finishedTimeBuffer:Date? = nil
        if let finishedTimeDecoded = finishedTimeDecoded {
            finishedTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(finishedTimeDecoded, format: .dateTime)
        }
        finishedTime = finishedTimeBuffer
    }
}

extension ManagedActionHistoryItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ManagedActionHistoryItem(actionDescription: \(String(describing: actionDescription)), actionId: \(String(describing: actionId)), actionType: \(String(describing: actionType)), executedTime: \(String(describing: executedTime)), failureDescription: \(String(describing: failureDescription)), failureType: \(String(describing: failureType)), finishedTime: \(String(describing: finishedTime)), status: \(String(describing: status)))"}
}

/// <p>The record of a completed or failed managed action.</p>
public struct ManagedActionHistoryItem: Equatable {
    /// <p>A description of the managed action.</p>
    public let actionDescription: String?
    /// <p>A unique identifier for the managed action.</p>
    public let actionId: String?
    /// <p>The type of the managed action.</p>
    public let actionType: ActionType?
    /// <p>The date and time that the action started executing.</p>
    public let executedTime: Date?
    /// <p>If the action failed, a description of the failure.</p>
    public let failureDescription: String?
    /// <p>If the action failed, the type of failure.</p>
    public let failureType: FailureType?
    /// <p>The date and time that the action finished executing.</p>
    public let finishedTime: Date?
    /// <p>The status of the action.</p>
    public let status: ActionHistoryStatus?

    public init (
        actionDescription: String? = nil,
        actionId: String? = nil,
        actionType: ActionType? = nil,
        executedTime: Date? = nil,
        failureDescription: String? = nil,
        failureType: FailureType? = nil,
        finishedTime: Date? = nil,
        status: ActionHistoryStatus? = nil
    )
    {
        self.actionDescription = actionDescription
        self.actionId = actionId
        self.actionType = actionType
        self.executedTime = executedTime
        self.failureDescription = failureDescription
        self.failureType = failureType
        self.finishedTime = finishedTime
        self.status = status
    }
}

extension ManagedActionInvalidStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ManagedActionInvalidStateException(message: \(String(describing: message)))"}
}

extension ManagedActionInvalidStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ManagedActionInvalidStateExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cannot modify the managed action in its current state.</p>
public struct ManagedActionInvalidStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ManagedActionInvalidStateExceptionBody: Equatable {
    public let message: String?
}

extension ManagedActionInvalidStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxAgeRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deleteSourceFromS3 = "DeleteSourceFromS3"
        case enabled = "Enabled"
        case maxAgeInDays = "MaxAgeInDays"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let deleteSourceFromS3 = deleteSourceFromS3 {
            try container.encode(deleteSourceFromS3, forKey: Key("DeleteSourceFromS3"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        if let maxAgeInDays = maxAgeInDays {
            try container.encode(maxAgeInDays, forKey: Key("MaxAgeInDays"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let maxAgeInDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxAgeInDays)
        maxAgeInDays = maxAgeInDaysDecoded
        let deleteSourceFromS3Decoded = try containerValues.decodeIfPresent(Bool.self, forKey: .deleteSourceFromS3)
        deleteSourceFromS3 = deleteSourceFromS3Decoded
    }
}

extension MaxAgeRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaxAgeRule(deleteSourceFromS3: \(String(describing: deleteSourceFromS3)), enabled: \(String(describing: enabled)), maxAgeInDays: \(String(describing: maxAgeInDays)))"}
}

/// <p>A lifecycle rule that deletes application versions after the specified number of
///       days.</p>
public struct MaxAgeRule: Equatable {
    /// <p>Set to <code>true</code> to delete a version's source bundle from Amazon S3 when
    ///       Elastic Beanstalk deletes the application version.</p>
    public let deleteSourceFromS3: Bool?
    /// <p>Specify <code>true</code> to apply the rule, or <code>false</code> to disable
    ///       it.</p>
    public let enabled: Bool?
    /// <p>Specify the number of days to retain an application versions.</p>
    public let maxAgeInDays: Int?

    public init (
        deleteSourceFromS3: Bool? = nil,
        enabled: Bool? = nil,
        maxAgeInDays: Int? = nil
    )
    {
        self.deleteSourceFromS3 = deleteSourceFromS3
        self.enabled = enabled
        self.maxAgeInDays = maxAgeInDays
    }
}

extension MaxCountRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deleteSourceFromS3 = "DeleteSourceFromS3"
        case enabled = "Enabled"
        case maxCount = "MaxCount"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let deleteSourceFromS3 = deleteSourceFromS3 {
            try container.encode(deleteSourceFromS3, forKey: Key("DeleteSourceFromS3"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        if let maxCount = maxCount {
            try container.encode(maxCount, forKey: Key("MaxCount"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let maxCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxCount)
        maxCount = maxCountDecoded
        let deleteSourceFromS3Decoded = try containerValues.decodeIfPresent(Bool.self, forKey: .deleteSourceFromS3)
        deleteSourceFromS3 = deleteSourceFromS3Decoded
    }
}

extension MaxCountRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaxCountRule(deleteSourceFromS3: \(String(describing: deleteSourceFromS3)), enabled: \(String(describing: enabled)), maxCount: \(String(describing: maxCount)))"}
}

/// <p>A lifecycle rule that deletes the oldest application version when the maximum count is
///       exceeded.</p>
public struct MaxCountRule: Equatable {
    /// <p>Set to <code>true</code> to delete a version's source bundle from Amazon S3 when
    ///       Elastic Beanstalk deletes the application version.</p>
    public let deleteSourceFromS3: Bool?
    /// <p>Specify <code>true</code> to apply the rule, or <code>false</code> to disable
    ///       it.</p>
    public let enabled: Bool?
    /// <p>Specify the maximum number of application versions to retain.</p>
    public let maxCount: Int?

    public init (
        deleteSourceFromS3: Bool? = nil,
        enabled: Bool? = nil,
        maxCount: Int? = nil
    )
    {
        self.deleteSourceFromS3 = deleteSourceFromS3
        self.enabled = enabled
        self.maxCount = maxCount
    }
}

extension OperationInProgressException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationInProgressException(message: \(String(describing: message)))"}
}

extension OperationInProgressException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<OperationInProgressExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Unable to perform the specified operation because another operation that effects an
///       element in this activity is already in progress.</p>
public struct OperationInProgressException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OperationInProgressExceptionBody: Equatable {
    public let message: String?
}

extension OperationInProgressExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OptionRestrictionRegex: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case label = "Label"
        case pattern = "Pattern"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let label = label {
            try container.encode(label, forKey: Key("Label"))
        }
        if let pattern = pattern {
            try container.encode(pattern, forKey: Key("Pattern"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pattern)
        pattern = patternDecoded
        let labelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .label)
        label = labelDecoded
    }
}

extension OptionRestrictionRegex: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptionRestrictionRegex(label: \(String(describing: label)), pattern: \(String(describing: pattern)))"}
}

/// <p>A regular expression representing a restriction on a string configuration option
///       value.</p>
public struct OptionRestrictionRegex: Equatable {
    /// <p>A unique name representing this regular expression.</p>
    public let label: String?
    /// <p>The regular expression pattern that a string configuration option value with this
    ///       restriction must match.</p>
    public let pattern: String?

    public init (
        label: String? = nil,
        pattern: String? = nil
    )
    {
        self.label = label
        self.pattern = pattern
    }
}

extension OptionSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case namespace = "Namespace"
        case optionName = "OptionName"
        case resourceName = "ResourceName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let namespace = namespace {
            try container.encode(namespace, forKey: Key("Namespace"))
        }
        if let optionName = optionName {
            try container.encode(optionName, forKey: Key("OptionName"))
        }
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: Key("ResourceName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let optionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optionName)
        optionName = optionNameDecoded
    }
}

extension OptionSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptionSpecification(namespace: \(String(describing: namespace)), optionName: \(String(describing: optionName)), resourceName: \(String(describing: resourceName)))"}
}

/// <p>A specification identifying an individual configuration option.</p>
public struct OptionSpecification: Equatable {
    /// <p>A unique namespace identifying the option's associated AWS resource.</p>
    public let namespace: String?
    /// <p>The name of the configuration option.</p>
    public let optionName: String?
    /// <p>A unique resource name for a time-based scaling configuration option.</p>
    public let resourceName: String?

    public init (
        namespace: String? = nil,
        optionName: String? = nil,
        resourceName: String? = nil
    )
    {
        self.namespace = namespace
        self.optionName = optionName
        self.resourceName = resourceName
    }
}

extension PlatformBranchSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branchName = "BranchName"
        case branchOrder = "BranchOrder"
        case lifecycleState = "LifecycleState"
        case platformName = "PlatformName"
        case supportedTierList = "SupportedTierList"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let branchName = branchName {
            try container.encode(branchName, forKey: Key("BranchName"))
        }
        if branchOrder != 0 {
            try container.encode(branchOrder, forKey: Key("BranchOrder"))
        }
        if let lifecycleState = lifecycleState {
            try container.encode(lifecycleState, forKey: Key("LifecycleState"))
        }
        if let platformName = platformName {
            try container.encode(platformName, forKey: Key("PlatformName"))
        }
        if let supportedTierList = supportedTierList {
            var supportedTierListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedTierList"))
            for (index0, supportedtier0) in supportedTierList.enumerated() {
                try supportedTierListContainer.encode(supportedtier0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformName)
        platformName = platformNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let lifecycleStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lifecycleState)
        lifecycleState = lifecycleStateDecoded
        let branchOrderDecoded = try containerValues.decode(Int.self, forKey: .branchOrder)
        branchOrder = branchOrderDecoded
        if containerValues.contains(.supportedTierList) {
            struct KeyVal0{struct member{}}
            let supportedTierListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedTierList)
            if let supportedTierListWrappedContainer = supportedTierListWrappedContainer {
                let supportedTierListContainer = try supportedTierListWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var supportedTierListBuffer:[String]? = nil
                if let supportedTierListContainer = supportedTierListContainer {
                    supportedTierListBuffer = [String]()
                    for stringContainer0 in supportedTierListContainer {
                        supportedTierListBuffer?.append(stringContainer0)
                    }
                }
                supportedTierList = supportedTierListBuffer
            } else {
                supportedTierList = []
            }
        } else {
            supportedTierList = nil
        }
    }
}

extension PlatformBranchSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlatformBranchSummary(branchName: \(String(describing: branchName)), branchOrder: \(String(describing: branchOrder)), lifecycleState: \(String(describing: lifecycleState)), platformName: \(String(describing: platformName)), supportedTierList: \(String(describing: supportedTierList)))"}
}

/// <p>Summary information about a platform branch.</p>
public struct PlatformBranchSummary: Equatable {
    /// <p>The name of the platform branch.</p>
    public let branchName: String?
    /// <p>An ordinal number that designates the order in which platform branches have been added to
    ///       a platform. This can be helpful, for example, if your code calls the
    ///         <code>ListPlatformBranches</code> action and then displays a list of platform
    ///       branches.</p>
    ///          <p>A larger <code>BranchOrder</code> value designates a newer platform branch within the
    ///       platform.</p>
    public let branchOrder: Int
    /// <p>The support life cycle state of the platform branch.</p>
    ///          <p>Possible values: <code>beta</code> | <code>supported</code> | <code>deprecated</code> |
    ///       <code>retired</code>
    ///          </p>
    public let lifecycleState: String?
    /// <p>The name of the platform to which this platform branch belongs.</p>
    public let platformName: String?
    /// <p>The environment tiers that platform versions in this branch support.</p>
    ///          <p>Possible values: <code>WebServer/Standard</code> | <code>Worker/SQS/HTTP</code>
    ///          </p>
    public let supportedTierList: [String]?

    public init (
        branchName: String? = nil,
        branchOrder: Int = 0,
        lifecycleState: String? = nil,
        platformName: String? = nil,
        supportedTierList: [String]? = nil
    )
    {
        self.branchName = branchName
        self.branchOrder = branchOrder
        self.lifecycleState = lifecycleState
        self.platformName = platformName
        self.supportedTierList = supportedTierList
    }
}

extension PlatformDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customAmiList = "CustomAmiList"
        case dateCreated = "DateCreated"
        case dateUpdated = "DateUpdated"
        case description = "Description"
        case frameworks = "Frameworks"
        case maintainer = "Maintainer"
        case operatingSystemName = "OperatingSystemName"
        case operatingSystemVersion = "OperatingSystemVersion"
        case platformArn = "PlatformArn"
        case platformBranchLifecycleState = "PlatformBranchLifecycleState"
        case platformBranchName = "PlatformBranchName"
        case platformCategory = "PlatformCategory"
        case platformLifecycleState = "PlatformLifecycleState"
        case platformName = "PlatformName"
        case platformOwner = "PlatformOwner"
        case platformStatus = "PlatformStatus"
        case platformVersion = "PlatformVersion"
        case programmingLanguages = "ProgrammingLanguages"
        case solutionStackName = "SolutionStackName"
        case supportedAddonList = "SupportedAddonList"
        case supportedTierList = "SupportedTierList"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let customAmiList = customAmiList {
            var customAmiListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("CustomAmiList"))
            for (index0, customami0) in customAmiList.enumerated() {
                try customAmiListContainer.encode(customami0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dateCreated = dateCreated {
            try container.encode(TimestampWrapper(dateCreated, format: .dateTime), forKey: Key("dateCreated"))
        }
        if let dateUpdated = dateUpdated {
            try container.encode(TimestampWrapper(dateUpdated, format: .dateTime), forKey: Key("dateUpdated"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let frameworks = frameworks {
            var frameworksContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Frameworks"))
            for (index0, platformframework0) in frameworks.enumerated() {
                try frameworksContainer.encode(platformframework0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let maintainer = maintainer {
            try container.encode(maintainer, forKey: Key("Maintainer"))
        }
        if let operatingSystemName = operatingSystemName {
            try container.encode(operatingSystemName, forKey: Key("OperatingSystemName"))
        }
        if let operatingSystemVersion = operatingSystemVersion {
            try container.encode(operatingSystemVersion, forKey: Key("OperatingSystemVersion"))
        }
        if let platformArn = platformArn {
            try container.encode(platformArn, forKey: Key("PlatformArn"))
        }
        if let platformBranchLifecycleState = platformBranchLifecycleState {
            try container.encode(platformBranchLifecycleState, forKey: Key("PlatformBranchLifecycleState"))
        }
        if let platformBranchName = platformBranchName {
            try container.encode(platformBranchName, forKey: Key("PlatformBranchName"))
        }
        if let platformCategory = platformCategory {
            try container.encode(platformCategory, forKey: Key("PlatformCategory"))
        }
        if let platformLifecycleState = platformLifecycleState {
            try container.encode(platformLifecycleState, forKey: Key("PlatformLifecycleState"))
        }
        if let platformName = platformName {
            try container.encode(platformName, forKey: Key("PlatformName"))
        }
        if let platformOwner = platformOwner {
            try container.encode(platformOwner, forKey: Key("PlatformOwner"))
        }
        if let platformStatus = platformStatus {
            try container.encode(platformStatus, forKey: Key("PlatformStatus"))
        }
        if let platformVersion = platformVersion {
            try container.encode(platformVersion, forKey: Key("PlatformVersion"))
        }
        if let programmingLanguages = programmingLanguages {
            var programmingLanguagesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ProgrammingLanguages"))
            for (index0, platformprogramminglanguage0) in programmingLanguages.enumerated() {
                try programmingLanguagesContainer.encode(platformprogramminglanguage0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let solutionStackName = solutionStackName {
            try container.encode(solutionStackName, forKey: Key("SolutionStackName"))
        }
        if let supportedAddonList = supportedAddonList {
            var supportedAddonListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedAddonList"))
            for (index0, supportedaddon0) in supportedAddonList.enumerated() {
                try supportedAddonListContainer.encode(supportedaddon0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedTierList = supportedTierList {
            var supportedTierListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedTierList"))
            for (index0, supportedtier0) in supportedTierList.enumerated() {
                try supportedTierListContainer.encode(supportedtier0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformArn)
        platformArn = platformArnDecoded
        let platformOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformOwner)
        platformOwner = platformOwnerDecoded
        let platformNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformName)
        platformName = platformNameDecoded
        let platformVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformVersion)
        platformVersion = platformVersionDecoded
        let solutionStackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionStackName)
        solutionStackName = solutionStackNameDecoded
        let platformStatusDecoded = try containerValues.decodeIfPresent(PlatformStatus.self, forKey: .platformStatus)
        platformStatus = platformStatusDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        var dateCreatedBuffer:Date? = nil
        if let dateCreatedDecoded = dateCreatedDecoded {
            dateCreatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateCreatedDecoded, format: .dateTime)
        }
        dateCreated = dateCreatedBuffer
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateUpdated)
        var dateUpdatedBuffer:Date? = nil
        if let dateUpdatedDecoded = dateUpdatedDecoded {
            dateUpdatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateUpdatedDecoded, format: .dateTime)
        }
        dateUpdated = dateUpdatedBuffer
        let platformCategoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformCategory)
        platformCategory = platformCategoryDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let maintainerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maintainer)
        maintainer = maintainerDecoded
        let operatingSystemNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operatingSystemName)
        operatingSystemName = operatingSystemNameDecoded
        let operatingSystemVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operatingSystemVersion)
        operatingSystemVersion = operatingSystemVersionDecoded
        if containerValues.contains(.programmingLanguages) {
            struct KeyVal0{struct member{}}
            let programmingLanguagesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .programmingLanguages)
            if let programmingLanguagesWrappedContainer = programmingLanguagesWrappedContainer {
                let programmingLanguagesContainer = try programmingLanguagesWrappedContainer.decodeIfPresent([PlatformProgrammingLanguage].self, forKey: .member)
                var programmingLanguagesBuffer:[PlatformProgrammingLanguage]? = nil
                if let programmingLanguagesContainer = programmingLanguagesContainer {
                    programmingLanguagesBuffer = [PlatformProgrammingLanguage]()
                    for structureContainer0 in programmingLanguagesContainer {
                        programmingLanguagesBuffer?.append(structureContainer0)
                    }
                }
                programmingLanguages = programmingLanguagesBuffer
            } else {
                programmingLanguages = []
            }
        } else {
            programmingLanguages = nil
        }
        if containerValues.contains(.frameworks) {
            struct KeyVal0{struct member{}}
            let frameworksWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .frameworks)
            if let frameworksWrappedContainer = frameworksWrappedContainer {
                let frameworksContainer = try frameworksWrappedContainer.decodeIfPresent([PlatformFramework].self, forKey: .member)
                var frameworksBuffer:[PlatformFramework]? = nil
                if let frameworksContainer = frameworksContainer {
                    frameworksBuffer = [PlatformFramework]()
                    for structureContainer0 in frameworksContainer {
                        frameworksBuffer?.append(structureContainer0)
                    }
                }
                frameworks = frameworksBuffer
            } else {
                frameworks = []
            }
        } else {
            frameworks = nil
        }
        if containerValues.contains(.customAmiList) {
            struct KeyVal0{struct member{}}
            let customAmiListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .customAmiList)
            if let customAmiListWrappedContainer = customAmiListWrappedContainer {
                let customAmiListContainer = try customAmiListWrappedContainer.decodeIfPresent([CustomAmi].self, forKey: .member)
                var customAmiListBuffer:[CustomAmi]? = nil
                if let customAmiListContainer = customAmiListContainer {
                    customAmiListBuffer = [CustomAmi]()
                    for structureContainer0 in customAmiListContainer {
                        customAmiListBuffer?.append(structureContainer0)
                    }
                }
                customAmiList = customAmiListBuffer
            } else {
                customAmiList = []
            }
        } else {
            customAmiList = nil
        }
        if containerValues.contains(.supportedTierList) {
            struct KeyVal0{struct member{}}
            let supportedTierListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedTierList)
            if let supportedTierListWrappedContainer = supportedTierListWrappedContainer {
                let supportedTierListContainer = try supportedTierListWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var supportedTierListBuffer:[String]? = nil
                if let supportedTierListContainer = supportedTierListContainer {
                    supportedTierListBuffer = [String]()
                    for stringContainer0 in supportedTierListContainer {
                        supportedTierListBuffer?.append(stringContainer0)
                    }
                }
                supportedTierList = supportedTierListBuffer
            } else {
                supportedTierList = []
            }
        } else {
            supportedTierList = nil
        }
        if containerValues.contains(.supportedAddonList) {
            struct KeyVal0{struct member{}}
            let supportedAddonListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedAddonList)
            if let supportedAddonListWrappedContainer = supportedAddonListWrappedContainer {
                let supportedAddonListContainer = try supportedAddonListWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var supportedAddonListBuffer:[String]? = nil
                if let supportedAddonListContainer = supportedAddonListContainer {
                    supportedAddonListBuffer = [String]()
                    for stringContainer0 in supportedAddonListContainer {
                        supportedAddonListBuffer?.append(stringContainer0)
                    }
                }
                supportedAddonList = supportedAddonListBuffer
            } else {
                supportedAddonList = []
            }
        } else {
            supportedAddonList = nil
        }
        let platformLifecycleStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformLifecycleState)
        platformLifecycleState = platformLifecycleStateDecoded
        let platformBranchNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformBranchName)
        platformBranchName = platformBranchNameDecoded
        let platformBranchLifecycleStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformBranchLifecycleState)
        platformBranchLifecycleState = platformBranchLifecycleStateDecoded
    }
}

extension PlatformDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlatformDescription(customAmiList: \(String(describing: customAmiList)), dateCreated: \(String(describing: dateCreated)), dateUpdated: \(String(describing: dateUpdated)), description: \(String(describing: description)), frameworks: \(String(describing: frameworks)), maintainer: \(String(describing: maintainer)), operatingSystemName: \(String(describing: operatingSystemName)), operatingSystemVersion: \(String(describing: operatingSystemVersion)), platformArn: \(String(describing: platformArn)), platformBranchLifecycleState: \(String(describing: platformBranchLifecycleState)), platformBranchName: \(String(describing: platformBranchName)), platformCategory: \(String(describing: platformCategory)), platformLifecycleState: \(String(describing: platformLifecycleState)), platformName: \(String(describing: platformName)), platformOwner: \(String(describing: platformOwner)), platformStatus: \(String(describing: platformStatus)), platformVersion: \(String(describing: platformVersion)), programmingLanguages: \(String(describing: programmingLanguages)), solutionStackName: \(String(describing: solutionStackName)), supportedAddonList: \(String(describing: supportedAddonList)), supportedTierList: \(String(describing: supportedTierList)))"}
}

/// <p>Detailed information about a platform version.</p>
public struct PlatformDescription: Equatable {
    /// <p>The custom AMIs supported by the platform version.</p>
    public let customAmiList: [CustomAmi]?
    /// <p>The date when the platform version was created.</p>
    public let dateCreated: Date?
    /// <p>The date when the platform version was last updated.</p>
    public let dateUpdated: Date?
    /// <p>The description of the platform version.</p>
    public let description: String?
    /// <p>The frameworks supported by the platform version.</p>
    public let frameworks: [PlatformFramework]?
    /// <p>Information about the maintainer of the platform version.</p>
    public let maintainer: String?
    /// <p>The operating system used by the platform version.</p>
    public let operatingSystemName: String?
    /// <p>The version of the operating system used by the platform version.</p>
    public let operatingSystemVersion: String?
    /// <p>The ARN of the platform version.</p>
    public let platformArn: String?
    /// <p>The state of the platform version's branch in its lifecycle.</p>
    ///          <p>Possible values: <code>Beta</code> | <code>Supported</code> | <code>Deprecated</code> |
    ///       <code>Retired</code>
    ///          </p>
    public let platformBranchLifecycleState: String?
    /// <p>The platform branch to which the platform version belongs.</p>
    public let platformBranchName: String?
    /// <p>The category of the platform version.</p>
    public let platformCategory: String?
    /// <p>The state of the platform version in its lifecycle.</p>
    ///          <p>Possible values: <code>Recommended</code> | <code>null</code>
    ///          </p>
    ///          <p>If a null value is returned, the platform version isn't the recommended one for its
    ///       branch. Each platform branch has a single recommended platform version, typically the most
    ///       recent one.</p>
    public let platformLifecycleState: String?
    /// <p>The name of the platform version.</p>
    public let platformName: String?
    /// <p>The AWS account ID of the person who created the platform version.</p>
    public let platformOwner: String?
    /// <p>The status of the platform version.</p>
    public let platformStatus: PlatformStatus?
    /// <p>The version of the platform version.</p>
    public let platformVersion: String?
    /// <p>The programming languages supported by the platform version.</p>
    public let programmingLanguages: [PlatformProgrammingLanguage]?
    /// <p>The name of the solution stack used by the platform version.</p>
    public let solutionStackName: String?
    /// <p>The additions supported by the platform version.</p>
    public let supportedAddonList: [String]?
    /// <p>The tiers supported by the platform version.</p>
    public let supportedTierList: [String]?

    public init (
        customAmiList: [CustomAmi]? = nil,
        dateCreated: Date? = nil,
        dateUpdated: Date? = nil,
        description: String? = nil,
        frameworks: [PlatformFramework]? = nil,
        maintainer: String? = nil,
        operatingSystemName: String? = nil,
        operatingSystemVersion: String? = nil,
        platformArn: String? = nil,
        platformBranchLifecycleState: String? = nil,
        platformBranchName: String? = nil,
        platformCategory: String? = nil,
        platformLifecycleState: String? = nil,
        platformName: String? = nil,
        platformOwner: String? = nil,
        platformStatus: PlatformStatus? = nil,
        platformVersion: String? = nil,
        programmingLanguages: [PlatformProgrammingLanguage]? = nil,
        solutionStackName: String? = nil,
        supportedAddonList: [String]? = nil,
        supportedTierList: [String]? = nil
    )
    {
        self.customAmiList = customAmiList
        self.dateCreated = dateCreated
        self.dateUpdated = dateUpdated
        self.description = description
        self.frameworks = frameworks
        self.maintainer = maintainer
        self.operatingSystemName = operatingSystemName
        self.operatingSystemVersion = operatingSystemVersion
        self.platformArn = platformArn
        self.platformBranchLifecycleState = platformBranchLifecycleState
        self.platformBranchName = platformBranchName
        self.platformCategory = platformCategory
        self.platformLifecycleState = platformLifecycleState
        self.platformName = platformName
        self.platformOwner = platformOwner
        self.platformStatus = platformStatus
        self.platformVersion = platformVersion
        self.programmingLanguages = programmingLanguages
        self.solutionStackName = solutionStackName
        self.supportedAddonList = supportedAddonList
        self.supportedTierList = supportedTierList
    }
}

extension PlatformFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case `operator` = "Operator"
        case type = "Type"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let `operator` = `operator` {
            try container.encode(`operator`, forKey: Key("Operator"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("Type"))
        }
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Values"))
            for (index0, platformfiltervalue0) in values.enumerated() {
                try valuesContainer.encode(platformfiltervalue0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operator)
        `operator` = operatorDecoded
        if containerValues.contains(.values) {
            struct KeyVal0{struct member{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var valuesBuffer:[String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension PlatformFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlatformFilter(operator: \(String(describing: `operator`)), type: \(String(describing: type)), values: \(String(describing: values)))"}
}

/// <p>Describes criteria to restrict the results when listing platform versions.</p>
///          <p>The filter is evaluated as follows: <code>Type Operator Values[1]</code>
///          </p>
public struct PlatformFilter: Equatable {
    /// <p>The operator to apply to the <code>Type</code> with each of the
    ///       <code>Values</code>.</p>
    ///          <p>Valid values: <code>=</code> | <code>!=</code> |
    ///         <code><</code> | <code><=</code> |
    ///         <code>></code> | <code>>=</code> |
    ///         <code>contains</code> | <code>begins_with</code> | <code>ends_with</code>
    ///          </p>
    public let `operator`: String?
    /// <p>The platform version attribute to which the filter values are applied.</p>
    ///          <p>Valid values: <code>PlatformName</code> | <code>PlatformVersion</code> |
    ///         <code>PlatformStatus</code> | <code>PlatformBranchName</code> |
    ///         <code>PlatformLifecycleState</code> | <code>PlatformOwner</code> |
    ///         <code>SupportedTier</code> | <code>SupportedAddon</code> |
    ///         <code>ProgrammingLanguageName</code> | <code>OperatingSystemName</code>
    ///          </p>
    public let type: String?
    /// <p>The list of values applied to the filtering platform version attribute. Only one value is supported
    ///       for all current operators.</p>
    ///          <p>The following list shows valid filter values for some filter attributes.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PlatformStatus</code>: <code>Creating</code> | <code>Failed</code> |
    ///             <code>Ready</code> | <code>Deleting</code> | <code>Deleted</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PlatformLifecycleState</code>: <code>recommended</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SupportedTier</code>: <code>WebServer/Standard</code> |
    ///             <code>Worker/SQS/HTTP</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SupportedAddon</code>: <code>Log/S3</code> | <code>Monitoring/Healthd</code> |
    ///             <code>WorkerDaemon/SQSD</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let values: [String]?

    public init (
        `operator`: String? = nil,
        type: String? = nil,
        values: [String]? = nil
    )
    {
        self.`operator` = `operator`
        self.type = type
        self.values = values
    }
}

extension PlatformFramework: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let version = version {
            try container.encode(version, forKey: Key("Version"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension PlatformFramework: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlatformFramework(name: \(String(describing: name)), version: \(String(describing: version)))"}
}

/// <p>A framework supported by the platform.</p>
public struct PlatformFramework: Equatable {
    /// <p>The name of the framework.</p>
    public let name: String?
    /// <p>The version of the framework.</p>
    public let version: String?

    public init (
        name: String? = nil,
        version: String? = nil
    )
    {
        self.name = name
        self.version = version
    }
}

extension PlatformProgrammingLanguage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let version = version {
            try container.encode(version, forKey: Key("Version"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension PlatformProgrammingLanguage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlatformProgrammingLanguage(name: \(String(describing: name)), version: \(String(describing: version)))"}
}

/// <p>A programming language supported by the platform.</p>
public struct PlatformProgrammingLanguage: Equatable {
    /// <p>The name of the programming language.</p>
    public let name: String?
    /// <p>The version of the programming language.</p>
    public let version: String?

    public init (
        name: String? = nil,
        version: String? = nil
    )
    {
        self.name = name
        self.version = version
    }
}

public enum PlatformStatus {
    case creating
    case deleted
    case deleting
    case failed
    case ready
    case sdkUnknown(String)
}

extension PlatformStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PlatformStatus] {
        return [
            .creating,
            .deleted,
            .deleting,
            .failed,
            .ready,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .creating: return "Creating"
        case .deleted: return "Deleted"
        case .deleting: return "Deleting"
        case .failed: return "Failed"
        case .ready: return "Ready"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PlatformStatus(rawValue: rawValue) ?? PlatformStatus.sdkUnknown(rawValue)
    }
}

extension PlatformSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case operatingSystemName = "OperatingSystemName"
        case operatingSystemVersion = "OperatingSystemVersion"
        case platformArn = "PlatformArn"
        case platformBranchLifecycleState = "PlatformBranchLifecycleState"
        case platformBranchName = "PlatformBranchName"
        case platformCategory = "PlatformCategory"
        case platformLifecycleState = "PlatformLifecycleState"
        case platformOwner = "PlatformOwner"
        case platformStatus = "PlatformStatus"
        case platformVersion = "PlatformVersion"
        case supportedAddonList = "SupportedAddonList"
        case supportedTierList = "SupportedTierList"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let operatingSystemName = operatingSystemName {
            try container.encode(operatingSystemName, forKey: Key("OperatingSystemName"))
        }
        if let operatingSystemVersion = operatingSystemVersion {
            try container.encode(operatingSystemVersion, forKey: Key("OperatingSystemVersion"))
        }
        if let platformArn = platformArn {
            try container.encode(platformArn, forKey: Key("PlatformArn"))
        }
        if let platformBranchLifecycleState = platformBranchLifecycleState {
            try container.encode(platformBranchLifecycleState, forKey: Key("PlatformBranchLifecycleState"))
        }
        if let platformBranchName = platformBranchName {
            try container.encode(platformBranchName, forKey: Key("PlatformBranchName"))
        }
        if let platformCategory = platformCategory {
            try container.encode(platformCategory, forKey: Key("PlatformCategory"))
        }
        if let platformLifecycleState = platformLifecycleState {
            try container.encode(platformLifecycleState, forKey: Key("PlatformLifecycleState"))
        }
        if let platformOwner = platformOwner {
            try container.encode(platformOwner, forKey: Key("PlatformOwner"))
        }
        if let platformStatus = platformStatus {
            try container.encode(platformStatus, forKey: Key("PlatformStatus"))
        }
        if let platformVersion = platformVersion {
            try container.encode(platformVersion, forKey: Key("PlatformVersion"))
        }
        if let supportedAddonList = supportedAddonList {
            var supportedAddonListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedAddonList"))
            for (index0, supportedaddon0) in supportedAddonList.enumerated() {
                try supportedAddonListContainer.encode(supportedaddon0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedTierList = supportedTierList {
            var supportedTierListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedTierList"))
            for (index0, supportedtier0) in supportedTierList.enumerated() {
                try supportedTierListContainer.encode(supportedtier0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformArn)
        platformArn = platformArnDecoded
        let platformOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformOwner)
        platformOwner = platformOwnerDecoded
        let platformStatusDecoded = try containerValues.decodeIfPresent(PlatformStatus.self, forKey: .platformStatus)
        platformStatus = platformStatusDecoded
        let platformCategoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformCategory)
        platformCategory = platformCategoryDecoded
        let operatingSystemNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operatingSystemName)
        operatingSystemName = operatingSystemNameDecoded
        let operatingSystemVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operatingSystemVersion)
        operatingSystemVersion = operatingSystemVersionDecoded
        if containerValues.contains(.supportedTierList) {
            struct KeyVal0{struct member{}}
            let supportedTierListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedTierList)
            if let supportedTierListWrappedContainer = supportedTierListWrappedContainer {
                let supportedTierListContainer = try supportedTierListWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var supportedTierListBuffer:[String]? = nil
                if let supportedTierListContainer = supportedTierListContainer {
                    supportedTierListBuffer = [String]()
                    for stringContainer0 in supportedTierListContainer {
                        supportedTierListBuffer?.append(stringContainer0)
                    }
                }
                supportedTierList = supportedTierListBuffer
            } else {
                supportedTierList = []
            }
        } else {
            supportedTierList = nil
        }
        if containerValues.contains(.supportedAddonList) {
            struct KeyVal0{struct member{}}
            let supportedAddonListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedAddonList)
            if let supportedAddonListWrappedContainer = supportedAddonListWrappedContainer {
                let supportedAddonListContainer = try supportedAddonListWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var supportedAddonListBuffer:[String]? = nil
                if let supportedAddonListContainer = supportedAddonListContainer {
                    supportedAddonListBuffer = [String]()
                    for stringContainer0 in supportedAddonListContainer {
                        supportedAddonListBuffer?.append(stringContainer0)
                    }
                }
                supportedAddonList = supportedAddonListBuffer
            } else {
                supportedAddonList = []
            }
        } else {
            supportedAddonList = nil
        }
        let platformLifecycleStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformLifecycleState)
        platformLifecycleState = platformLifecycleStateDecoded
        let platformVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformVersion)
        platformVersion = platformVersionDecoded
        let platformBranchNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformBranchName)
        platformBranchName = platformBranchNameDecoded
        let platformBranchLifecycleStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformBranchLifecycleState)
        platformBranchLifecycleState = platformBranchLifecycleStateDecoded
    }
}

extension PlatformSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlatformSummary(operatingSystemName: \(String(describing: operatingSystemName)), operatingSystemVersion: \(String(describing: operatingSystemVersion)), platformArn: \(String(describing: platformArn)), platformBranchLifecycleState: \(String(describing: platformBranchLifecycleState)), platformBranchName: \(String(describing: platformBranchName)), platformCategory: \(String(describing: platformCategory)), platformLifecycleState: \(String(describing: platformLifecycleState)), platformOwner: \(String(describing: platformOwner)), platformStatus: \(String(describing: platformStatus)), platformVersion: \(String(describing: platformVersion)), supportedAddonList: \(String(describing: supportedAddonList)), supportedTierList: \(String(describing: supportedTierList)))"}
}

/// <p>Summary information about a platform version.</p>
public struct PlatformSummary: Equatable {
    /// <p>The operating system used by the platform version.</p>
    public let operatingSystemName: String?
    /// <p>The version of the operating system used by the platform version.</p>
    public let operatingSystemVersion: String?
    /// <p>The ARN of the platform version.</p>
    public let platformArn: String?
    /// <p>The state of the platform version's branch in its lifecycle.</p>
    ///          <p>Possible values: <code>beta</code> | <code>supported</code> | <code>deprecated</code> |
    ///         <code>retired</code>
    ///          </p>
    public let platformBranchLifecycleState: String?
    /// <p>The platform branch to which the platform version belongs.</p>
    public let platformBranchName: String?
    /// <p>The category of platform version.</p>
    public let platformCategory: String?
    /// <p>The state of the platform version in its lifecycle.</p>
    ///          <p>Possible values: <code>recommended</code> | empty</p>
    ///          <p>If an empty value is returned, the platform version is supported but isn't the recommended
    ///     one for its branch.</p>
    public let platformLifecycleState: String?
    /// <p>The AWS account ID of the person who created the platform version.</p>
    public let platformOwner: String?
    /// <p>The status of the platform version. You can create an environment from the platform
    ///       version once it is ready.</p>
    public let platformStatus: PlatformStatus?
    /// <p>The version string of the platform version.</p>
    public let platformVersion: String?
    /// <p>The additions associated with the platform version.</p>
    public let supportedAddonList: [String]?
    /// <p>The tiers in which the platform version runs.</p>
    public let supportedTierList: [String]?

    public init (
        operatingSystemName: String? = nil,
        operatingSystemVersion: String? = nil,
        platformArn: String? = nil,
        platformBranchLifecycleState: String? = nil,
        platformBranchName: String? = nil,
        platformCategory: String? = nil,
        platformLifecycleState: String? = nil,
        platformOwner: String? = nil,
        platformStatus: PlatformStatus? = nil,
        platformVersion: String? = nil,
        supportedAddonList: [String]? = nil,
        supportedTierList: [String]? = nil
    )
    {
        self.operatingSystemName = operatingSystemName
        self.operatingSystemVersion = operatingSystemVersion
        self.platformArn = platformArn
        self.platformBranchLifecycleState = platformBranchLifecycleState
        self.platformBranchName = platformBranchName
        self.platformCategory = platformCategory
        self.platformLifecycleState = platformLifecycleState
        self.platformOwner = platformOwner
        self.platformStatus = platformStatus
        self.platformVersion = platformVersion
        self.supportedAddonList = supportedAddonList
        self.supportedTierList = supportedTierList
    }
}

extension PlatformVersionStillReferencedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlatformVersionStillReferencedException(message: \(String(describing: message)))"}
}

extension PlatformVersionStillReferencedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<PlatformVersionStillReferencedExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You cannot delete the platform version because there are still environments running on it.</p>
public struct PlatformVersionStillReferencedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PlatformVersionStillReferencedExceptionBody: Equatable {
    public let message: String?
}

extension PlatformVersionStillReferencedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Queue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case uRL = "URL"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let uRL = uRL {
            try container.encode(uRL, forKey: Key("URL"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let uRLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uRL)
        uRL = uRLDecoded
    }
}

extension Queue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Queue(name: \(String(describing: name)), uRL: \(String(describing: uRL)))"}
}

/// <p>Describes a queue.</p>
public struct Queue: Equatable {
    /// <p>The name of the queue.</p>
    public let name: String?
    /// <p>The URL of the queue.</p>
    public let uRL: String?

    public init (
        name: String? = nil,
        uRL: String? = nil
    )
    {
        self.name = name
        self.uRL = uRL
    }
}

public struct RebuildEnvironmentInputBodyMiddleware: Middleware {
    public let id: String = "RebuildEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebuildEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<RebuildEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebuildEnvironmentInput>
    public typealias MOutput = OperationOutput<RebuildEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebuildEnvironmentOutputError>
}

extension RebuildEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebuildEnvironmentInput(environmentId: \(String(describing: environmentId)), environmentName: \(String(describing: environmentName)))"}
}

extension RebuildEnvironmentInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let environmentId = environmentId {
            try container.encode(environmentId, forKey: Key("EnvironmentId"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        try container.encode("RebuildEnvironment", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct RebuildEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "RebuildEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebuildEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<RebuildEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebuildEnvironmentInput>
    public typealias MOutput = OperationOutput<RebuildEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebuildEnvironmentOutputError>
}

public struct RebuildEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "RebuildEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebuildEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<RebuildEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebuildEnvironmentInput>
    public typealias MOutput = OperationOutput<RebuildEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebuildEnvironmentOutputError>
}

/// <p></p>
public struct RebuildEnvironmentInput: Equatable {
    /// <p>The ID of the environment to rebuild.</p>
    ///          <p> Condition: You must specify either this or an EnvironmentName, or both. If you do not
    ///       specify either, AWS Elastic Beanstalk returns <code>MissingRequiredParameter</code> error.
    ///     </p>
    public let environmentId: String?
    /// <p>The name of the environment to rebuild.</p>
    ///          <p> Condition: You must specify either this or an EnvironmentId, or both. If you do not
    ///       specify either, AWS Elastic Beanstalk returns <code>MissingRequiredParameter</code> error.
    ///     </p>
    public let environmentName: String?

    public init (
        environmentId: String? = nil,
        environmentName: String? = nil
    )
    {
        self.environmentId = environmentId
        self.environmentName = environmentName
    }
}

extension RebuildEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RebuildEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebuildEnvironmentOutputError: Equatable {
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebuildEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebuildEnvironmentOutputResponse()"}
}

extension RebuildEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RebuildEnvironmentOutputResponse: Equatable {

    public init() {}
}

struct RebuildEnvironmentOutputResponseBody: Equatable {
}

extension RebuildEnvironmentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RequestEnvironmentInfoInputBodyMiddleware: Middleware {
    public let id: String = "RequestEnvironmentInfoInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RequestEnvironmentInfoInput>,
                  next: H) -> Swift.Result<OperationOutput<RequestEnvironmentInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RequestEnvironmentInfoInput>
    public typealias MOutput = OperationOutput<RequestEnvironmentInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RequestEnvironmentInfoOutputError>
}

extension RequestEnvironmentInfoInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestEnvironmentInfoInput(environmentId: \(String(describing: environmentId)), environmentName: \(String(describing: environmentName)), infoType: \(String(describing: infoType)))"}
}

extension RequestEnvironmentInfoInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let environmentId = environmentId {
            try container.encode(environmentId, forKey: Key("EnvironmentId"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        if let infoType = infoType {
            try container.encode(infoType, forKey: Key("InfoType"))
        }
        try container.encode("RequestEnvironmentInfo", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct RequestEnvironmentInfoInputHeadersMiddleware: Middleware {
    public let id: String = "RequestEnvironmentInfoInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RequestEnvironmentInfoInput>,
                  next: H) -> Swift.Result<OperationOutput<RequestEnvironmentInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RequestEnvironmentInfoInput>
    public typealias MOutput = OperationOutput<RequestEnvironmentInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RequestEnvironmentInfoOutputError>
}

public struct RequestEnvironmentInfoInputQueryItemMiddleware: Middleware {
    public let id: String = "RequestEnvironmentInfoInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RequestEnvironmentInfoInput>,
                  next: H) -> Swift.Result<OperationOutput<RequestEnvironmentInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RequestEnvironmentInfoInput>
    public typealias MOutput = OperationOutput<RequestEnvironmentInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RequestEnvironmentInfoOutputError>
}

/// <p>Request to retrieve logs from an environment and store them in your Elastic Beanstalk
///       storage bucket.</p>
public struct RequestEnvironmentInfoInput: Equatable {
    /// <p>The ID of the environment of the requested data.</p>
    ///          <p>If no such environment is found, <code>RequestEnvironmentInfo</code> returns an
    ///       <code>InvalidParameterValue</code> error. </p>
    ///          <p>Condition: You must specify either this or an EnvironmentName, or both. If you do not
    ///       specify either, AWS Elastic Beanstalk returns <code>MissingRequiredParameter</code> error.
    ///     </p>
    public let environmentId: String?
    /// <p>The name of the environment of the requested data.</p>
    ///          <p>If no such environment is found, <code>RequestEnvironmentInfo</code> returns an
    ///       <code>InvalidParameterValue</code> error. </p>
    ///          <p>Condition: You must specify either this or an EnvironmentId, or both. If you do not
    ///       specify either, AWS Elastic Beanstalk returns <code>MissingRequiredParameter</code> error.
    ///     </p>
    public let environmentName: String?
    /// <p>The type of information to request.</p>
    public let infoType: EnvironmentInfoType?

    public init (
        environmentId: String? = nil,
        environmentName: String? = nil,
        infoType: EnvironmentInfoType? = nil
    )
    {
        self.environmentId = environmentId
        self.environmentName = environmentName
        self.infoType = infoType
    }
}

extension RequestEnvironmentInfoOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RequestEnvironmentInfoOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RequestEnvironmentInfoOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension RequestEnvironmentInfoOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestEnvironmentInfoOutputResponse()"}
}

extension RequestEnvironmentInfoOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RequestEnvironmentInfoOutputResponse: Equatable {

    public init() {}
}

struct RequestEnvironmentInfoOutputResponseBody: Equatable {
}

extension RequestEnvironmentInfoOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ResourceNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource doesn't exist for the specified Amazon Resource Name (ARN).</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceQuota: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maximum = "Maximum"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let maximum = maximum {
            try container.encode(maximum, forKey: Key("Maximum"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximum)
        maximum = maximumDecoded
    }
}

extension ResourceQuota: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceQuota(maximum: \(String(describing: maximum)))"}
}

/// <p>The AWS Elastic Beanstalk quota information for a single resource type in an AWS account. It
///       reflects the resource's limits for this account.</p>
public struct ResourceQuota: Equatable {
    /// <p>The maximum number of instances of this Elastic Beanstalk resource type that an AWS account can
    ///       use.</p>
    public let maximum: Int?

    public init (
        maximum: Int? = nil
    )
    {
        self.maximum = maximum
    }
}

extension ResourceQuotas: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationQuota = "ApplicationQuota"
        case applicationVersionQuota = "ApplicationVersionQuota"
        case configurationTemplateQuota = "ConfigurationTemplateQuota"
        case customPlatformQuota = "CustomPlatformQuota"
        case environmentQuota = "EnvironmentQuota"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationQuota = applicationQuota {
            try container.encode(applicationQuota, forKey: Key("ApplicationQuota"))
        }
        if let applicationVersionQuota = applicationVersionQuota {
            try container.encode(applicationVersionQuota, forKey: Key("ApplicationVersionQuota"))
        }
        if let configurationTemplateQuota = configurationTemplateQuota {
            try container.encode(configurationTemplateQuota, forKey: Key("ConfigurationTemplateQuota"))
        }
        if let customPlatformQuota = customPlatformQuota {
            try container.encode(customPlatformQuota, forKey: Key("CustomPlatformQuota"))
        }
        if let environmentQuota = environmentQuota {
            try container.encode(environmentQuota, forKey: Key("EnvironmentQuota"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationQuotaDecoded = try containerValues.decodeIfPresent(ResourceQuota.self, forKey: .applicationQuota)
        applicationQuota = applicationQuotaDecoded
        let applicationVersionQuotaDecoded = try containerValues.decodeIfPresent(ResourceQuota.self, forKey: .applicationVersionQuota)
        applicationVersionQuota = applicationVersionQuotaDecoded
        let environmentQuotaDecoded = try containerValues.decodeIfPresent(ResourceQuota.self, forKey: .environmentQuota)
        environmentQuota = environmentQuotaDecoded
        let configurationTemplateQuotaDecoded = try containerValues.decodeIfPresent(ResourceQuota.self, forKey: .configurationTemplateQuota)
        configurationTemplateQuota = configurationTemplateQuotaDecoded
        let customPlatformQuotaDecoded = try containerValues.decodeIfPresent(ResourceQuota.self, forKey: .customPlatformQuota)
        customPlatformQuota = customPlatformQuotaDecoded
    }
}

extension ResourceQuotas: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceQuotas(applicationQuota: \(String(describing: applicationQuota)), applicationVersionQuota: \(String(describing: applicationVersionQuota)), configurationTemplateQuota: \(String(describing: configurationTemplateQuota)), customPlatformQuota: \(String(describing: customPlatformQuota)), environmentQuota: \(String(describing: environmentQuota)))"}
}

/// <p>A set of per-resource AWS Elastic Beanstalk quotas associated with an AWS account. They reflect
///       Elastic Beanstalk resource limits for this account.</p>
public struct ResourceQuotas: Equatable {
    /// <p>The quota for applications in the AWS account.</p>
    public let applicationQuota: ResourceQuota?
    /// <p>The quota for application versions in the AWS account.</p>
    public let applicationVersionQuota: ResourceQuota?
    /// <p>The quota for configuration templates in the AWS account.</p>
    public let configurationTemplateQuota: ResourceQuota?
    /// <p>The quota for custom platforms in the AWS account.</p>
    public let customPlatformQuota: ResourceQuota?
    /// <p>The quota for environments in the AWS account.</p>
    public let environmentQuota: ResourceQuota?

    public init (
        applicationQuota: ResourceQuota? = nil,
        applicationVersionQuota: ResourceQuota? = nil,
        configurationTemplateQuota: ResourceQuota? = nil,
        customPlatformQuota: ResourceQuota? = nil,
        environmentQuota: ResourceQuota? = nil
    )
    {
        self.applicationQuota = applicationQuota
        self.applicationVersionQuota = applicationVersionQuota
        self.configurationTemplateQuota = configurationTemplateQuota
        self.customPlatformQuota = customPlatformQuota
        self.environmentQuota = environmentQuota
    }
}

extension ResourceTypeNotSupportedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceTypeNotSupportedException(message: \(String(describing: message)))"}
}

extension ResourceTypeNotSupportedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ResourceTypeNotSupportedExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The type of the specified Amazon Resource Name (ARN) isn't supported for this operation.</p>
public struct ResourceTypeNotSupportedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceTypeNotSupportedExceptionBody: Equatable {
    public let message: String?
}

extension ResourceTypeNotSupportedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct RestartAppServerInputBodyMiddleware: Middleware {
    public let id: String = "RestartAppServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestartAppServerInput>,
                  next: H) -> Swift.Result<OperationOutput<RestartAppServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestartAppServerInput>
    public typealias MOutput = OperationOutput<RestartAppServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestartAppServerOutputError>
}

extension RestartAppServerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestartAppServerInput(environmentId: \(String(describing: environmentId)), environmentName: \(String(describing: environmentName)))"}
}

extension RestartAppServerInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let environmentId = environmentId {
            try container.encode(environmentId, forKey: Key("EnvironmentId"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        try container.encode("RestartAppServer", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct RestartAppServerInputHeadersMiddleware: Middleware {
    public let id: String = "RestartAppServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestartAppServerInput>,
                  next: H) -> Swift.Result<OperationOutput<RestartAppServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestartAppServerInput>
    public typealias MOutput = OperationOutput<RestartAppServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestartAppServerOutputError>
}

public struct RestartAppServerInputQueryItemMiddleware: Middleware {
    public let id: String = "RestartAppServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestartAppServerInput>,
                  next: H) -> Swift.Result<OperationOutput<RestartAppServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestartAppServerInput>
    public typealias MOutput = OperationOutput<RestartAppServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestartAppServerOutputError>
}

/// <p></p>
public struct RestartAppServerInput: Equatable {
    /// <p>The ID of the environment to restart the server for.</p>
    ///          <p> Condition: You must specify either this or an EnvironmentName, or both. If you do not
    ///       specify either, AWS Elastic Beanstalk returns <code>MissingRequiredParameter</code> error.
    ///     </p>
    public let environmentId: String?
    /// <p>The name of the environment to restart the server for.</p>
    ///          <p> Condition: You must specify either this or an EnvironmentId, or both. If you do not
    ///       specify either, AWS Elastic Beanstalk returns <code>MissingRequiredParameter</code> error.
    ///     </p>
    public let environmentName: String?

    public init (
        environmentId: String? = nil,
        environmentName: String? = nil
    )
    {
        self.environmentId = environmentId
        self.environmentName = environmentName
    }
}

extension RestartAppServerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestartAppServerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestartAppServerOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension RestartAppServerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestartAppServerOutputResponse()"}
}

extension RestartAppServerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RestartAppServerOutputResponse: Equatable {

    public init() {}
}

struct RestartAppServerOutputResponseBody: Equatable {
}

extension RestartAppServerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RetrieveEnvironmentInfoInputBodyMiddleware: Middleware {
    public let id: String = "RetrieveEnvironmentInfoInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetrieveEnvironmentInfoInput>,
                  next: H) -> Swift.Result<OperationOutput<RetrieveEnvironmentInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetrieveEnvironmentInfoInput>
    public typealias MOutput = OperationOutput<RetrieveEnvironmentInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetrieveEnvironmentInfoOutputError>
}

extension RetrieveEnvironmentInfoInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetrieveEnvironmentInfoInput(environmentId: \(String(describing: environmentId)), environmentName: \(String(describing: environmentName)), infoType: \(String(describing: infoType)))"}
}

extension RetrieveEnvironmentInfoInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let environmentId = environmentId {
            try container.encode(environmentId, forKey: Key("EnvironmentId"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        if let infoType = infoType {
            try container.encode(infoType, forKey: Key("InfoType"))
        }
        try container.encode("RetrieveEnvironmentInfo", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct RetrieveEnvironmentInfoInputHeadersMiddleware: Middleware {
    public let id: String = "RetrieveEnvironmentInfoInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetrieveEnvironmentInfoInput>,
                  next: H) -> Swift.Result<OperationOutput<RetrieveEnvironmentInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetrieveEnvironmentInfoInput>
    public typealias MOutput = OperationOutput<RetrieveEnvironmentInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetrieveEnvironmentInfoOutputError>
}

public struct RetrieveEnvironmentInfoInputQueryItemMiddleware: Middleware {
    public let id: String = "RetrieveEnvironmentInfoInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetrieveEnvironmentInfoInput>,
                  next: H) -> Swift.Result<OperationOutput<RetrieveEnvironmentInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetrieveEnvironmentInfoInput>
    public typealias MOutput = OperationOutput<RetrieveEnvironmentInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetrieveEnvironmentInfoOutputError>
}

/// <p>Request to download logs retrieved with <a>RequestEnvironmentInfo</a>.</p>
public struct RetrieveEnvironmentInfoInput: Equatable {
    /// <p>The ID of the data's environment.</p>
    ///          <p>If no such environment is found, returns an <code>InvalidParameterValue</code>
    ///       error.</p>
    ///          <p>Condition: You must specify either this or an EnvironmentName, or both. If you do not
    ///       specify either, AWS Elastic Beanstalk returns <code>MissingRequiredParameter</code>
    ///       error.</p>
    public let environmentId: String?
    /// <p>The name of the data's environment.</p>
    ///          <p> If no such environment is found, returns an <code>InvalidParameterValue</code> error. </p>
    ///          <p> Condition: You must specify either this or an EnvironmentId, or both. If you do not
    ///       specify either, AWS Elastic Beanstalk returns <code>MissingRequiredParameter</code> error.
    ///     </p>
    public let environmentName: String?
    /// <p>The type of information to retrieve.</p>
    public let infoType: EnvironmentInfoType?

    public init (
        environmentId: String? = nil,
        environmentName: String? = nil,
        infoType: EnvironmentInfoType? = nil
    )
    {
        self.environmentId = environmentId
        self.environmentName = environmentName
        self.infoType = infoType
    }
}

extension RetrieveEnvironmentInfoOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RetrieveEnvironmentInfoOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RetrieveEnvironmentInfoOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension RetrieveEnvironmentInfoOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetrieveEnvironmentInfoOutputResponse(environmentInfo: \(String(describing: environmentInfo)))"}
}

extension RetrieveEnvironmentInfoOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RetrieveEnvironmentInfoOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.environmentInfo = output.environmentInfo
        } else {
            self.environmentInfo = nil
        }
    }
}

/// <p>Result message containing a description of the requested environment info.</p>
public struct RetrieveEnvironmentInfoOutputResponse: Equatable {
    /// <p> The <a>EnvironmentInfoDescription</a> of the environment. </p>
    public let environmentInfo: [EnvironmentInfoDescription]?

    public init (
        environmentInfo: [EnvironmentInfoDescription]? = nil
    )
    {
        self.environmentInfo = environmentInfo
    }
}

struct RetrieveEnvironmentInfoOutputResponseBody: Equatable {
    public let environmentInfo: [EnvironmentInfoDescription]?
}

extension RetrieveEnvironmentInfoOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case environmentInfo = "EnvironmentInfo"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RetrieveEnvironmentInfoResult"))
        if containerValues.contains(.environmentInfo) {
            struct KeyVal0{struct member{}}
            let environmentInfoWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .environmentInfo)
            if let environmentInfoWrappedContainer = environmentInfoWrappedContainer {
                let environmentInfoContainer = try environmentInfoWrappedContainer.decodeIfPresent([EnvironmentInfoDescription].self, forKey: .member)
                var environmentInfoBuffer:[EnvironmentInfoDescription]? = nil
                if let environmentInfoContainer = environmentInfoContainer {
                    environmentInfoBuffer = [EnvironmentInfoDescription]()
                    for structureContainer0 in environmentInfoContainer {
                        environmentInfoBuffer?.append(structureContainer0)
                    }
                }
                environmentInfo = environmentInfoBuffer
            } else {
                environmentInfo = []
            }
        } else {
            environmentInfo = nil
        }
    }
}

extension S3Location: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let s3Bucket = s3Bucket {
            try container.encode(s3Bucket, forKey: Key("S3Bucket"))
        }
        if let s3Key = s3Key {
            try container.encode(s3Key, forKey: Key("S3Key"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
    }
}

extension S3Location: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Location(s3Bucket: \(String(describing: s3Bucket)), s3Key: \(String(describing: s3Key)))"}
}

/// <p>The bucket and key of an item stored in Amazon S3.</p>
public struct S3Location: Equatable {
    /// <p>The Amazon S3 bucket where the data is located.</p>
    public let s3Bucket: String?
    /// <p>The Amazon S3 key where the data is located.</p>
    public let s3Key: String?

    public init (
        s3Bucket: String? = nil,
        s3Key: String? = nil
    )
    {
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
    }
}

extension S3LocationNotInServiceRegionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3LocationNotInServiceRegionException(message: \(String(describing: message)))"}
}

extension S3LocationNotInServiceRegionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<S3LocationNotInServiceRegionExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified S3 bucket does not belong to the S3 region in which the service is
///       running. The following regions are supported:</p>
///          <ul>
///             <li>
/// 	              <p>IAD/us-east-1</p>
/// 	           </li>
///             <li>
/// 	              <p>PDX/us-west-2</p>
/// 	           </li>
///             <li>
/// 	              <p>DUB/eu-west-1</p>
/// 	           </li>
///          </ul>
public struct S3LocationNotInServiceRegionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct S3LocationNotInServiceRegionExceptionBody: Equatable {
    public let message: String?
}

extension S3LocationNotInServiceRegionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3SubscriptionRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3SubscriptionRequiredException(message: \(String(describing: message)))"}
}

extension S3SubscriptionRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<S3SubscriptionRequiredExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified account does not have a subscription to Amazon S3.</p>
public struct S3SubscriptionRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct S3SubscriptionRequiredExceptionBody: Equatable {
    public let message: String?
}

extension S3SubscriptionRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SearchFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case `operator` = "Operator"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attribute = attribute {
            try container.encode(attribute, forKey: Key("Attribute"))
        }
        if let `operator` = `operator` {
            try container.encode(`operator`, forKey: Key("Operator"))
        }
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Values"))
            for (index0, searchfiltervalue0) in values.enumerated() {
                try valuesContainer.encode(searchfiltervalue0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attribute)
        attribute = attributeDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operator)
        `operator` = operatorDecoded
        if containerValues.contains(.values) {
            struct KeyVal0{struct member{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var valuesBuffer:[String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension SearchFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchFilter(attribute: \(String(describing: attribute)), operator: \(String(describing: `operator`)), values: \(String(describing: values)))"}
}

/// <p>Describes criteria to restrict a list of results.</p>
///          <p>For operators that apply a single value to the attribute, the filter is evaluated as
///       follows: <code>Attribute Operator Values[1]</code>
///          </p>
///          <p>Some operators, e.g. <code>in</code>, can apply multiple values. In this case, the filter
///       is evaluated as a logical union (OR) of applications of the operator to the attribute with
///       each one of the values: <code>(Attribute Operator Values[1]) OR (Attribute Operator Values[2])
///         OR ...</code>
///          </p>
///          <p>The valid values for attributes of <code>SearchFilter</code> depend on the API action. For
///       valid values, see the reference page for the API action you're calling that takes a
///         <code>SearchFilter</code> parameter.</p>
public struct SearchFilter: Equatable {
    /// <p>The operator to apply to the <code>Attribute</code> with each of the <code>Values</code>.
    ///       Valid values vary by <code>Attribute</code>.</p>
    public let `operator`: String?
    /// <p>The result attribute to which the filter values are applied. Valid values vary by API
    ///       action.</p>
    public let attribute: String?
    /// <p>The list of values applied to the <code>Attribute</code> and <code>Operator</code>
    ///       attributes. Number of values and valid values vary by <code>Attribute</code>.</p>
    public let values: [String]?

    public init (
        `operator`: String? = nil,
        attribute: String? = nil,
        values: [String]? = nil
    )
    {
        self.`operator` = `operator`
        self.attribute = attribute
        self.values = values
    }
}

extension SingleInstanceHealth: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationMetrics = "ApplicationMetrics"
        case availabilityZone = "AvailabilityZone"
        case causes = "Causes"
        case color = "Color"
        case deployment = "Deployment"
        case healthStatus = "HealthStatus"
        case instanceId = "InstanceId"
        case instanceType = "InstanceType"
        case launchedAt = "LaunchedAt"
        case system = "System"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationMetrics = applicationMetrics {
            try container.encode(applicationMetrics, forKey: Key("ApplicationMetrics"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if let causes = causes {
            var causesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Causes"))
            for (index0, cause0) in causes.enumerated() {
                try causesContainer.encode(cause0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let color = color {
            try container.encode(color, forKey: Key("Color"))
        }
        if let deployment = deployment {
            try container.encode(deployment, forKey: Key("Deployment"))
        }
        if let healthStatus = healthStatus {
            try container.encode(healthStatus, forKey: Key("HealthStatus"))
        }
        if let instanceId = instanceId {
            try container.encode(instanceId, forKey: Key("InstanceId"))
        }
        if let instanceType = instanceType {
            try container.encode(instanceType, forKey: Key("InstanceType"))
        }
        if let launchedAt = launchedAt {
            try container.encode(TimestampWrapper(launchedAt, format: .dateTime), forKey: Key("launchedAt"))
        }
        if let system = system {
            try container.encode(system, forKey: Key("System"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let colorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .color)
        color = colorDecoded
        if containerValues.contains(.causes) {
            struct KeyVal0{struct member{}}
            let causesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .causes)
            if let causesWrappedContainer = causesWrappedContainer {
                let causesContainer = try causesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var causesBuffer:[String]? = nil
                if let causesContainer = causesContainer {
                    causesBuffer = [String]()
                    for stringContainer0 in causesContainer {
                        causesBuffer?.append(stringContainer0)
                    }
                }
                causes = causesBuffer
            } else {
                causes = []
            }
        } else {
            causes = nil
        }
        let launchedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchedAt)
        var launchedAtBuffer:Date? = nil
        if let launchedAtDecoded = launchedAtDecoded {
            launchedAtBuffer = try TimestampWrapperDecoder.parseDateStringValue(launchedAtDecoded, format: .dateTime)
        }
        launchedAt = launchedAtBuffer
        let applicationMetricsDecoded = try containerValues.decodeIfPresent(ApplicationMetrics.self, forKey: .applicationMetrics)
        applicationMetrics = applicationMetricsDecoded
        let systemDecoded = try containerValues.decodeIfPresent(SystemStatus.self, forKey: .system)
        system = systemDecoded
        let deploymentDecoded = try containerValues.decodeIfPresent(Deployment.self, forKey: .deployment)
        deployment = deploymentDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
    }
}

extension SingleInstanceHealth: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SingleInstanceHealth(applicationMetrics: \(String(describing: applicationMetrics)), availabilityZone: \(String(describing: availabilityZone)), causes: \(String(describing: causes)), color: \(String(describing: color)), deployment: \(String(describing: deployment)), healthStatus: \(String(describing: healthStatus)), instanceId: \(String(describing: instanceId)), instanceType: \(String(describing: instanceType)), launchedAt: \(String(describing: launchedAt)), system: \(String(describing: system)))"}
}

/// <p>Detailed health information about an Amazon EC2 instance in your Elastic Beanstalk
///       environment.</p>
public struct SingleInstanceHealth: Equatable {
    /// <p>Request metrics from your application.</p>
    public let applicationMetrics: ApplicationMetrics?
    /// <p>The availability zone in which the instance runs.</p>
    public let availabilityZone: String?
    /// <p>Represents the causes, which provide more information about the current health
    ///       status.</p>
    public let causes: [String]?
    /// <p>Represents the color indicator that gives you information about the health of the EC2
    ///       instance. For more information, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/health-enhanced-status.html">Health Colors and
    ///         Statuses</a>.</p>
    public let color: String?
    /// <p>Information about the most recent deployment to an instance.</p>
    public let deployment: Deployment?
    /// <p>Returns the health status of the specified instance. For more information, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/health-enhanced-status.html">Health
    ///         Colors and Statuses</a>.</p>
    public let healthStatus: String?
    /// <p>The ID of the Amazon EC2 instance.</p>
    public let instanceId: String?
    /// <p>The instance's type.</p>
    public let instanceType: String?
    /// <p>The time at which the EC2 instance was launched.</p>
    public let launchedAt: Date?
    /// <p>Operating system metrics from the instance.</p>
    public let system: SystemStatus?

    public init (
        applicationMetrics: ApplicationMetrics? = nil,
        availabilityZone: String? = nil,
        causes: [String]? = nil,
        color: String? = nil,
        deployment: Deployment? = nil,
        healthStatus: String? = nil,
        instanceId: String? = nil,
        instanceType: String? = nil,
        launchedAt: Date? = nil,
        system: SystemStatus? = nil
    )
    {
        self.applicationMetrics = applicationMetrics
        self.availabilityZone = availabilityZone
        self.causes = causes
        self.color = color
        self.deployment = deployment
        self.healthStatus = healthStatus
        self.instanceId = instanceId
        self.instanceType = instanceType
        self.launchedAt = launchedAt
        self.system = system
    }
}

extension SolutionStackDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case permittedFileTypes = "PermittedFileTypes"
        case solutionStackName = "SolutionStackName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let permittedFileTypes = permittedFileTypes {
            var permittedFileTypesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PermittedFileTypes"))
            for (index0, filetypeextension0) in permittedFileTypes.enumerated() {
                try permittedFileTypesContainer.encode(filetypeextension0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let solutionStackName = solutionStackName {
            try container.encode(solutionStackName, forKey: Key("SolutionStackName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionStackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionStackName)
        solutionStackName = solutionStackNameDecoded
        if containerValues.contains(.permittedFileTypes) {
            struct KeyVal0{struct member{}}
            let permittedFileTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .permittedFileTypes)
            if let permittedFileTypesWrappedContainer = permittedFileTypesWrappedContainer {
                let permittedFileTypesContainer = try permittedFileTypesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var permittedFileTypesBuffer:[String]? = nil
                if let permittedFileTypesContainer = permittedFileTypesContainer {
                    permittedFileTypesBuffer = [String]()
                    for stringContainer0 in permittedFileTypesContainer {
                        permittedFileTypesBuffer?.append(stringContainer0)
                    }
                }
                permittedFileTypes = permittedFileTypesBuffer
            } else {
                permittedFileTypes = []
            }
        } else {
            permittedFileTypes = nil
        }
    }
}

extension SolutionStackDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SolutionStackDescription(permittedFileTypes: \(String(describing: permittedFileTypes)), solutionStackName: \(String(describing: solutionStackName)))"}
}

/// <p>Describes the solution stack.</p>
public struct SolutionStackDescription: Equatable {
    /// <p>The permitted file types allowed for a solution stack.</p>
    public let permittedFileTypes: [String]?
    /// <p>The name of the solution stack.</p>
    public let solutionStackName: String?

    public init (
        permittedFileTypes: [String]? = nil,
        solutionStackName: String? = nil
    )
    {
        self.permittedFileTypes = permittedFileTypes
        self.solutionStackName = solutionStackName
    }
}

extension SourceBuildInformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceLocation = "SourceLocation"
        case sourceRepository = "SourceRepository"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sourceLocation = sourceLocation {
            try container.encode(sourceLocation, forKey: Key("SourceLocation"))
        }
        if let sourceRepository = sourceRepository {
            try container.encode(sourceRepository, forKey: Key("SourceRepository"))
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceRepositoryDecoded = try containerValues.decodeIfPresent(SourceRepository.self, forKey: .sourceRepository)
        sourceRepository = sourceRepositoryDecoded
        let sourceLocationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLocation)
        sourceLocation = sourceLocationDecoded
    }
}

extension SourceBuildInformation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceBuildInformation(sourceLocation: \(String(describing: sourceLocation)), sourceRepository: \(String(describing: sourceRepository)), sourceType: \(String(describing: sourceType)))"}
}

/// <p>Location of the source code for an application version.</p>
public struct SourceBuildInformation: Equatable {
    /// <p>The location of the source code, as a formatted string, depending on the value of <code>SourceRepository</code>
    ///          </p>
    ///         <ul>
    ///             <li>
    /// 	              <p>For <code>CodeCommit</code>,
    /// 	the format is the repository name and commit ID, separated by a forward slash.
    /// 	For example,
    /// 	<code>my-git-repo/265cfa0cf6af46153527f55d6503ec030551f57a</code>.</p>
    ///             </li>
    ///             <li>
    /// 	              <p>For <code>S3</code>,
    /// 	the format is the S3 bucket name and object key, separated by a forward slash.
    /// 	For example,
    /// 	<code>my-s3-bucket/Folders/my-source-file</code>.</p>
    ///             </li>
    ///          </ul>
    public let sourceLocation: String?
    /// <p>Location where the repository is stored.</p>
    ///          <ul>
    ///             <li>
    /// 	              <p>
    ///                   <code>CodeCommit</code>
    ///                </p>
    ///             </li>
    ///             <li>
    /// 	              <p>
    ///                   <code>S3</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let sourceRepository: SourceRepository?
    /// <p>The type of repository.</p>
    ///          <ul>
    ///             <li>
    /// 	              <p>
    ///                   <code>Git</code>
    ///                </p>
    ///             </li>
    ///             <li>
    /// 	              <p>
    ///                   <code>Zip</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let sourceType: SourceType?

    public init (
        sourceLocation: String? = nil,
        sourceRepository: SourceRepository? = nil,
        sourceType: SourceType? = nil
    )
    {
        self.sourceLocation = sourceLocation
        self.sourceRepository = sourceRepository
        self.sourceType = sourceType
    }
}

extension SourceBundleDeletionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceBundleDeletionException(message: \(String(describing: message)))"}
}

extension SourceBundleDeletionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SourceBundleDeletionExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Unable to delete the Amazon S3 source bundle associated with the application version.
///       The application version was deleted successfully.</p>
public struct SourceBundleDeletionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SourceBundleDeletionExceptionBody: Equatable {
    public let message: String?
}

extension SourceBundleDeletionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SourceConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case templateName = "TemplateName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
    }
}

extension SourceConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceConfiguration(applicationName: \(String(describing: applicationName)), templateName: \(String(describing: templateName)))"}
}

/// <p>A specification for an environment configuration.</p>
public struct SourceConfiguration: Equatable {
    /// <p>The name of the application associated with the configuration.</p>
    public let applicationName: String?
    /// <p>The name of the configuration template.</p>
    public let templateName: String?

    public init (
        applicationName: String? = nil,
        templateName: String? = nil
    )
    {
        self.applicationName = applicationName
        self.templateName = templateName
    }
}

public enum SourceRepository {
    case codecommit
    case s3
    case sdkUnknown(String)
}

extension SourceRepository : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SourceRepository] {
        return [
            .codecommit,
            .s3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .codecommit: return "CodeCommit"
        case .s3: return "S3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SourceRepository(rawValue: rawValue) ?? SourceRepository.sdkUnknown(rawValue)
    }
}

public enum SourceType {
    case git
    case zip
    case sdkUnknown(String)
}

extension SourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SourceType] {
        return [
            .git,
            .zip,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .git: return "Git"
        case .zip: return "Zip"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
    }
}

extension StatusCodes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status2xx = "Status2xx"
        case status3xx = "Status3xx"
        case status4xx = "Status4xx"
        case status5xx = "Status5xx"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let status2xx = status2xx {
            try container.encode(status2xx, forKey: Key("Status2xx"))
        }
        if let status3xx = status3xx {
            try container.encode(status3xx, forKey: Key("Status3xx"))
        }
        if let status4xx = status4xx {
            try container.encode(status4xx, forKey: Key("Status4xx"))
        }
        if let status5xx = status5xx {
            try container.encode(status5xx, forKey: Key("Status5xx"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let status2xxDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .status2xx)
        status2xx = status2xxDecoded
        let status3xxDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .status3xx)
        status3xx = status3xxDecoded
        let status4xxDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .status4xx)
        status4xx = status4xxDecoded
        let status5xxDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .status5xx)
        status5xx = status5xxDecoded
    }
}

extension StatusCodes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StatusCodes(status2xx: \(String(describing: status2xx)), status3xx: \(String(describing: status3xx)), status4xx: \(String(describing: status4xx)), status5xx: \(String(describing: status5xx)))"}
}

/// <p>Represents the percentage of requests over the last 10 seconds that resulted in each
///       type of status code response. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">Status Code
///       Definitions</a>.</p>
public struct StatusCodes: Equatable {
    /// <p>The percentage of requests over the last 10 seconds that resulted in a 2xx (200, 201,
    ///       etc.) status code.</p>
    public let status2xx: Int?
    /// <p>The percentage of requests over the last 10 seconds that resulted in a 3xx (300, 301,
    ///       etc.) status code.</p>
    public let status3xx: Int?
    /// <p>The percentage of requests over the last 10 seconds that resulted in a 4xx (400, 401,
    ///       etc.) status code.</p>
    public let status4xx: Int?
    /// <p>The percentage of requests over the last 10 seconds that resulted in a 5xx (500, 501,
    ///       etc.) status code.</p>
    public let status5xx: Int?

    public init (
        status2xx: Int? = nil,
        status3xx: Int? = nil,
        status4xx: Int? = nil,
        status5xx: Int? = nil
    )
    {
        self.status2xx = status2xx
        self.status3xx = status3xx
        self.status4xx = status4xx
        self.status5xx = status5xx
    }
}

public struct SwapEnvironmentCNAMEsInputBodyMiddleware: Middleware {
    public let id: String = "SwapEnvironmentCNAMEsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SwapEnvironmentCNAMEsInput>,
                  next: H) -> Swift.Result<OperationOutput<SwapEnvironmentCNAMEsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SwapEnvironmentCNAMEsInput>
    public typealias MOutput = OperationOutput<SwapEnvironmentCNAMEsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SwapEnvironmentCNAMEsOutputError>
}

extension SwapEnvironmentCNAMEsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SwapEnvironmentCNAMEsInput(destinationEnvironmentId: \(String(describing: destinationEnvironmentId)), destinationEnvironmentName: \(String(describing: destinationEnvironmentName)), sourceEnvironmentId: \(String(describing: sourceEnvironmentId)), sourceEnvironmentName: \(String(describing: sourceEnvironmentName)))"}
}

extension SwapEnvironmentCNAMEsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let destinationEnvironmentId = destinationEnvironmentId {
            try container.encode(destinationEnvironmentId, forKey: Key("DestinationEnvironmentId"))
        }
        if let destinationEnvironmentName = destinationEnvironmentName {
            try container.encode(destinationEnvironmentName, forKey: Key("DestinationEnvironmentName"))
        }
        if let sourceEnvironmentId = sourceEnvironmentId {
            try container.encode(sourceEnvironmentId, forKey: Key("SourceEnvironmentId"))
        }
        if let sourceEnvironmentName = sourceEnvironmentName {
            try container.encode(sourceEnvironmentName, forKey: Key("SourceEnvironmentName"))
        }
        try container.encode("SwapEnvironmentCNAMEs", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct SwapEnvironmentCNAMEsInputHeadersMiddleware: Middleware {
    public let id: String = "SwapEnvironmentCNAMEsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SwapEnvironmentCNAMEsInput>,
                  next: H) -> Swift.Result<OperationOutput<SwapEnvironmentCNAMEsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SwapEnvironmentCNAMEsInput>
    public typealias MOutput = OperationOutput<SwapEnvironmentCNAMEsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SwapEnvironmentCNAMEsOutputError>
}

public struct SwapEnvironmentCNAMEsInputQueryItemMiddleware: Middleware {
    public let id: String = "SwapEnvironmentCNAMEsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SwapEnvironmentCNAMEsInput>,
                  next: H) -> Swift.Result<OperationOutput<SwapEnvironmentCNAMEsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SwapEnvironmentCNAMEsInput>
    public typealias MOutput = OperationOutput<SwapEnvironmentCNAMEsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SwapEnvironmentCNAMEsOutputError>
}

/// <p>Swaps the CNAMEs of two environments.</p>
public struct SwapEnvironmentCNAMEsInput: Equatable {
    /// <p>The ID of the destination environment.</p>
    ///          <p> Condition: You must specify at least the <code>DestinationEnvironmentID</code> or the
    ///       <code>DestinationEnvironmentName</code>. You may also specify both. You must specify the
    ///       <code>SourceEnvironmentId</code> with the <code>DestinationEnvironmentId</code>. </p>
    public let destinationEnvironmentId: String?
    /// <p>The name of the destination environment.</p>
    ///          <p> Condition: You must specify at least the <code>DestinationEnvironmentID</code> or the
    ///       <code>DestinationEnvironmentName</code>. You may also specify both. You must specify the
    ///       <code>SourceEnvironmentName</code> with the <code>DestinationEnvironmentName</code>.
    ///     </p>
    public let destinationEnvironmentName: String?
    /// <p>The ID of the source environment.</p>
    ///          <p> Condition: You must specify at least the <code>SourceEnvironmentID</code> or the
    ///       <code>SourceEnvironmentName</code>. You may also specify both. If you specify the
    ///       <code>SourceEnvironmentId</code>, you must specify the
    ///       <code>DestinationEnvironmentId</code>. </p>
    public let sourceEnvironmentId: String?
    /// <p>The name of the source environment.</p>
    ///          <p> Condition: You must specify at least the <code>SourceEnvironmentID</code> or the
    ///       <code>SourceEnvironmentName</code>. You may also specify both. If you specify the
    ///       <code>SourceEnvironmentName</code>, you must specify the
    ///       <code>DestinationEnvironmentName</code>. </p>
    public let sourceEnvironmentName: String?

    public init (
        destinationEnvironmentId: String? = nil,
        destinationEnvironmentName: String? = nil,
        sourceEnvironmentId: String? = nil,
        sourceEnvironmentName: String? = nil
    )
    {
        self.destinationEnvironmentId = destinationEnvironmentId
        self.destinationEnvironmentName = destinationEnvironmentName
        self.sourceEnvironmentId = sourceEnvironmentId
        self.sourceEnvironmentName = sourceEnvironmentName
    }
}

extension SwapEnvironmentCNAMEsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SwapEnvironmentCNAMEsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SwapEnvironmentCNAMEsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SwapEnvironmentCNAMEsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SwapEnvironmentCNAMEsOutputResponse()"}
}

extension SwapEnvironmentCNAMEsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SwapEnvironmentCNAMEsOutputResponse: Equatable {

    public init() {}
}

struct SwapEnvironmentCNAMEsOutputResponseBody: Equatable {
}

extension SwapEnvironmentCNAMEsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension SystemStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cPUUtilization = "CPUUtilization"
        case loadAverage = "LoadAverage"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let cPUUtilization = cPUUtilization {
            try container.encode(cPUUtilization, forKey: Key("CPUUtilization"))
        }
        if let loadAverage = loadAverage {
            var loadAverageContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LoadAverage"))
            for (index0, loadaveragevalue0) in loadAverage.enumerated() {
                try loadAverageContainer.encode(loadaveragevalue0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cPUUtilizationDecoded = try containerValues.decodeIfPresent(CPUUtilization.self, forKey: .cPUUtilization)
        cPUUtilization = cPUUtilizationDecoded
        if containerValues.contains(.loadAverage) {
            struct KeyVal0{struct member{}}
            let loadAverageWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .loadAverage)
            if let loadAverageWrappedContainer = loadAverageWrappedContainer {
                let loadAverageContainer = try loadAverageWrappedContainer.decodeIfPresent([Double].self, forKey: .member)
                var loadAverageBuffer:[Double]? = nil
                if let loadAverageContainer = loadAverageContainer {
                    loadAverageBuffer = [Double]()
                    for doubleContainer0 in loadAverageContainer {
                        loadAverageBuffer?.append(doubleContainer0)
                    }
                }
                loadAverage = loadAverageBuffer
            } else {
                loadAverage = []
            }
        } else {
            loadAverage = nil
        }
    }
}

extension SystemStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SystemStatus(cPUUtilization: \(String(describing: cPUUtilization)), loadAverage: \(String(describing: loadAverage)))"}
}

/// <p>CPU utilization and load average metrics for an Amazon EC2 instance.</p>
public struct SystemStatus: Equatable {
    /// <p>CPU utilization metrics for the instance.</p>
    public let cPUUtilization: CPUUtilization?
    /// <p>Load average in the last 1-minute, 5-minute, and 15-minute periods.
    ///       For more information, see
    ///         <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/health-enhanced-metrics.html#health-enhanced-metrics-os">Operating System Metrics</a>.</p>
    public let loadAverage: [Double]?

    public init (
        cPUUtilization: CPUUtilization? = nil,
        loadAverage: [Double]? = nil
    )
    {
        self.cPUUtilization = cPUUtilization
        self.loadAverage = loadAverage
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let key = key {
            try container.encode(key, forKey: Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Describes a tag applied to a resource in an environment.</p>
public struct Tag: Equatable {
    /// <p>The key of the tag.</p>
    public let key: String?
    /// <p>The value of the tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TerminateEnvironmentInputBodyMiddleware: Middleware {
    public let id: String = "TerminateEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TerminateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<TerminateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TerminateEnvironmentInput>
    public typealias MOutput = OperationOutput<TerminateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TerminateEnvironmentOutputError>
}

extension TerminateEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TerminateEnvironmentInput(environmentId: \(String(describing: environmentId)), environmentName: \(String(describing: environmentName)), forceTerminate: \(String(describing: forceTerminate)), terminateResources: \(String(describing: terminateResources)))"}
}

extension TerminateEnvironmentInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let environmentId = environmentId {
            try container.encode(environmentId, forKey: Key("EnvironmentId"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        if let forceTerminate = forceTerminate {
            try container.encode(forceTerminate, forKey: Key("ForceTerminate"))
        }
        if let terminateResources = terminateResources {
            try container.encode(terminateResources, forKey: Key("TerminateResources"))
        }
        try container.encode("TerminateEnvironment", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct TerminateEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "TerminateEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TerminateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<TerminateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TerminateEnvironmentInput>
    public typealias MOutput = OperationOutput<TerminateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TerminateEnvironmentOutputError>
}

public struct TerminateEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "TerminateEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TerminateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<TerminateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TerminateEnvironmentInput>
    public typealias MOutput = OperationOutput<TerminateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TerminateEnvironmentOutputError>
}

/// <p>Request to terminate an environment.</p>
public struct TerminateEnvironmentInput: Equatable {
    /// <p>The ID of the environment to terminate.</p>
    ///          <p> Condition: You must specify either this or an EnvironmentName, or both. If you do not
    ///       specify either, AWS Elastic Beanstalk returns <code>MissingRequiredParameter</code> error.
    ///     </p>
    public let environmentId: String?
    /// <p>The name of the environment to terminate.</p>
    ///          <p> Condition: You must specify either this or an EnvironmentId, or both. If you do not
    ///       specify either, AWS Elastic Beanstalk returns <code>MissingRequiredParameter</code> error.
    ///     </p>
    public let environmentName: String?
    /// <p>Terminates the target environment even if another environment in the same group is
    ///       dependent on it.</p>
    public let forceTerminate: Bool?
    /// <p>Indicates whether the associated AWS resources should shut down when the environment is
    ///       terminated:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>true</code>: The specified environment as well as the associated AWS resources, such
    ///           as Auto Scaling group and LoadBalancer, are terminated.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>false</code>: AWS Elastic Beanstalk resource management is removed from the
    ///           environment, but the AWS resources continue to operate.</p>
    ///             </li>
    ///          </ul>
    ///          <p> For more information, see the <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/ug/"> AWS Elastic Beanstalk User Guide. </a>
    ///          </p>
    ///          <p> Default: <code>true</code>
    ///          </p>
    ///          <p> Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let terminateResources: Bool?

    public init (
        environmentId: String? = nil,
        environmentName: String? = nil,
        forceTerminate: Bool? = nil,
        terminateResources: Bool? = nil
    )
    {
        self.environmentId = environmentId
        self.environmentName = environmentName
        self.forceTerminate = forceTerminate
        self.terminateResources = terminateResources
    }
}

extension TerminateEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TerminateEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TerminateEnvironmentOutputError: Equatable {
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TerminateEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TerminateEnvironmentOutputResponse(abortableOperationInProgress: \(String(describing: abortableOperationInProgress)), applicationName: \(String(describing: applicationName)), cNAME: \(String(describing: cNAME)), dateCreated: \(String(describing: dateCreated)), dateUpdated: \(String(describing: dateUpdated)), description: \(String(describing: description)), endpointURL: \(String(describing: endpointURL)), environmentArn: \(String(describing: environmentArn)), environmentId: \(String(describing: environmentId)), environmentLinks: \(String(describing: environmentLinks)), environmentName: \(String(describing: environmentName)), health: \(String(describing: health)), healthStatus: \(String(describing: healthStatus)), operationsRole: \(String(describing: operationsRole)), platformArn: \(String(describing: platformArn)), resources: \(String(describing: resources)), solutionStackName: \(String(describing: solutionStackName)), status: \(String(describing: status)), templateName: \(String(describing: templateName)), tier: \(String(describing: tier)), versionLabel: \(String(describing: versionLabel)))"}
}

extension TerminateEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TerminateEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.abortableOperationInProgress = output.abortableOperationInProgress
            self.applicationName = output.applicationName
            self.cNAME = output.cNAME
            self.dateCreated = output.dateCreated
            self.dateUpdated = output.dateUpdated
            self.description = output.description
            self.endpointURL = output.endpointURL
            self.environmentArn = output.environmentArn
            self.environmentId = output.environmentId
            self.environmentLinks = output.environmentLinks
            self.environmentName = output.environmentName
            self.health = output.health
            self.healthStatus = output.healthStatus
            self.operationsRole = output.operationsRole
            self.platformArn = output.platformArn
            self.resources = output.resources
            self.solutionStackName = output.solutionStackName
            self.status = output.status
            self.templateName = output.templateName
            self.tier = output.tier
            self.versionLabel = output.versionLabel
        } else {
            self.abortableOperationInProgress = nil
            self.applicationName = nil
            self.cNAME = nil
            self.dateCreated = nil
            self.dateUpdated = nil
            self.description = nil
            self.endpointURL = nil
            self.environmentArn = nil
            self.environmentId = nil
            self.environmentLinks = nil
            self.environmentName = nil
            self.health = nil
            self.healthStatus = nil
            self.operationsRole = nil
            self.platformArn = nil
            self.resources = nil
            self.solutionStackName = nil
            self.status = nil
            self.templateName = nil
            self.tier = nil
            self.versionLabel = nil
        }
    }
}

/// <p>Describes the properties of an environment.</p>
public struct TerminateEnvironmentOutputResponse: Equatable {
    /// <p>Indicates if there is an in-progress environment configuration update or application
    ///       version deployment that you can cancel.</p>
    ///          <p>
    ///             <code>true:</code> There is an update in progress. </p>
    ///          <p>
    ///             <code>false:</code> There are no updates currently in progress. </p>
    public let abortableOperationInProgress: Bool?
    /// <p>The name of the application associated with this environment.</p>
    public let applicationName: String?
    /// <p>The URL to the CNAME for this environment.</p>
    public let cNAME: String?
    /// <p>The creation date for this environment.</p>
    public let dateCreated: Date?
    /// <p>The last modified date for this environment.</p>
    public let dateUpdated: Date?
    /// <p>Describes this environment.</p>
    public let description: String?
    /// <p>For load-balanced, autoscaling environments, the URL to the LoadBalancer. For
    ///       single-instance environments, the IP address of the instance.</p>
    public let endpointURL: String?
    /// <p>The environment's Amazon Resource Name (ARN), which can be used in other API requests that require an ARN.</p>
    public let environmentArn: String?
    /// <p>The ID of this environment.</p>
    public let environmentId: String?
    /// <p>A list of links to other environments in the same group.</p>
    public let environmentLinks: [EnvironmentLink]?
    /// <p>The name of this environment.</p>
    public let environmentName: String?
    /// <p>Describes the health status of the environment. AWS Elastic Beanstalk indicates the
    ///       failure levels for a running environment:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Red</code>: Indicates the environment is not responsive. Occurs when three or more
    ///           consecutive failures occur for an environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Yellow</code>: Indicates that something is wrong. Occurs when two consecutive
    ///           failures occur for an environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Green</code>: Indicates the environment is healthy and fully functional.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Grey</code>: Default health for a new environment. The environment is not fully
    ///           launched and health checks have not started or health checks are suspended during an
    ///             <code>UpdateEnvironment</code> or <code>RestartEnvironment</code> request.</p>
    ///             </li>
    ///          </ul>
    ///          <p> Default: <code>Grey</code>
    ///          </p>
    public let health: EnvironmentHealth?
    /// <p>Returns the health status of the application running in your environment. For more
    ///       information, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/health-enhanced-status.html">Health Colors and
    ///         Statuses</a>.</p>
    public let healthStatus: EnvironmentHealthStatus?
    /// <p>The Amazon Resource Name (ARN) of the environment's operations role. For more information,
    ///       see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/iam-operationsrole.html">Operations roles</a> in the <i>AWS Elastic Beanstalk Developer Guide</i>.</p>
    public let operationsRole: String?
    /// <p>The ARN of the platform version.</p>
    public let platformArn: String?
    /// <p>The description of the AWS resources used by this environment.</p>
    public let resources: EnvironmentResourcesDescription?
    /// <p> The name of the <code>SolutionStack</code> deployed with this environment. </p>
    public let solutionStackName: String?
    /// <p>The current operational status of the environment:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Launching</code>: Environment is in the process of initial deployment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Updating</code>: Environment is in the process of updating its configuration
    ///           settings or application version.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Ready</code>: Environment is available to have an action performed on it, such as
    ///           update or terminate.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Terminating</code>: Environment is in the shut-down process.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Terminated</code>: Environment is not running.</p>
    ///             </li>
    ///          </ul>
    public let status: EnvironmentStatus?
    /// <p>The name of the configuration template used to originally launch this
    ///       environment.</p>
    public let templateName: String?
    /// <p>Describes the current tier of this environment.</p>
    public let tier: EnvironmentTier?
    /// <p>The application version deployed in this environment.</p>
    public let versionLabel: String?

    public init (
        abortableOperationInProgress: Bool? = nil,
        applicationName: String? = nil,
        cNAME: String? = nil,
        dateCreated: Date? = nil,
        dateUpdated: Date? = nil,
        description: String? = nil,
        endpointURL: String? = nil,
        environmentArn: String? = nil,
        environmentId: String? = nil,
        environmentLinks: [EnvironmentLink]? = nil,
        environmentName: String? = nil,
        health: EnvironmentHealth? = nil,
        healthStatus: EnvironmentHealthStatus? = nil,
        operationsRole: String? = nil,
        platformArn: String? = nil,
        resources: EnvironmentResourcesDescription? = nil,
        solutionStackName: String? = nil,
        status: EnvironmentStatus? = nil,
        templateName: String? = nil,
        tier: EnvironmentTier? = nil,
        versionLabel: String? = nil
    )
    {
        self.abortableOperationInProgress = abortableOperationInProgress
        self.applicationName = applicationName
        self.cNAME = cNAME
        self.dateCreated = dateCreated
        self.dateUpdated = dateUpdated
        self.description = description
        self.endpointURL = endpointURL
        self.environmentArn = environmentArn
        self.environmentId = environmentId
        self.environmentLinks = environmentLinks
        self.environmentName = environmentName
        self.health = health
        self.healthStatus = healthStatus
        self.operationsRole = operationsRole
        self.platformArn = platformArn
        self.resources = resources
        self.solutionStackName = solutionStackName
        self.status = status
        self.templateName = templateName
        self.tier = tier
        self.versionLabel = versionLabel
    }
}

struct TerminateEnvironmentOutputResponseBody: Equatable {
    public let environmentName: String?
    public let environmentId: String?
    public let applicationName: String?
    public let versionLabel: String?
    public let solutionStackName: String?
    public let platformArn: String?
    public let templateName: String?
    public let description: String?
    public let endpointURL: String?
    public let cNAME: String?
    public let dateCreated: Date?
    public let dateUpdated: Date?
    public let status: EnvironmentStatus?
    public let abortableOperationInProgress: Bool?
    public let health: EnvironmentHealth?
    public let healthStatus: EnvironmentHealthStatus?
    public let resources: EnvironmentResourcesDescription?
    public let tier: EnvironmentTier?
    public let environmentLinks: [EnvironmentLink]?
    public let environmentArn: String?
    public let operationsRole: String?
}

extension TerminateEnvironmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case abortableOperationInProgress = "AbortableOperationInProgress"
        case applicationName = "ApplicationName"
        case cNAME = "CNAME"
        case dateCreated = "DateCreated"
        case dateUpdated = "DateUpdated"
        case description = "Description"
        case endpointURL = "EndpointURL"
        case environmentArn = "EnvironmentArn"
        case environmentId = "EnvironmentId"
        case environmentLinks = "EnvironmentLinks"
        case environmentName = "EnvironmentName"
        case health = "Health"
        case healthStatus = "HealthStatus"
        case operationsRole = "OperationsRole"
        case platformArn = "PlatformArn"
        case resources = "Resources"
        case solutionStackName = "SolutionStackName"
        case status = "Status"
        case templateName = "TemplateName"
        case tier = "Tier"
        case versionLabel = "VersionLabel"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("TerminateEnvironmentResult"))
        let environmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let versionLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionLabel)
        versionLabel = versionLabelDecoded
        let solutionStackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionStackName)
        solutionStackName = solutionStackNameDecoded
        let platformArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformArn)
        platformArn = platformArnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let endpointURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointURL)
        endpointURL = endpointURLDecoded
        let cNAMEDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cNAME)
        cNAME = cNAMEDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        var dateCreatedBuffer:Date? = nil
        if let dateCreatedDecoded = dateCreatedDecoded {
            dateCreatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateCreatedDecoded, format: .dateTime)
        }
        dateCreated = dateCreatedBuffer
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateUpdated)
        var dateUpdatedBuffer:Date? = nil
        if let dateUpdatedDecoded = dateUpdatedDecoded {
            dateUpdatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateUpdatedDecoded, format: .dateTime)
        }
        dateUpdated = dateUpdatedBuffer
        let statusDecoded = try containerValues.decodeIfPresent(EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let abortableOperationInProgressDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .abortableOperationInProgress)
        abortableOperationInProgress = abortableOperationInProgressDecoded
        let healthDecoded = try containerValues.decodeIfPresent(EnvironmentHealth.self, forKey: .health)
        health = healthDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(EnvironmentHealthStatus.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(EnvironmentResourcesDescription.self, forKey: .resources)
        resources = resourcesDecoded
        let tierDecoded = try containerValues.decodeIfPresent(EnvironmentTier.self, forKey: .tier)
        tier = tierDecoded
        if containerValues.contains(.environmentLinks) {
            struct KeyVal0{struct member{}}
            let environmentLinksWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .environmentLinks)
            if let environmentLinksWrappedContainer = environmentLinksWrappedContainer {
                let environmentLinksContainer = try environmentLinksWrappedContainer.decodeIfPresent([EnvironmentLink].self, forKey: .member)
                var environmentLinksBuffer:[EnvironmentLink]? = nil
                if let environmentLinksContainer = environmentLinksContainer {
                    environmentLinksBuffer = [EnvironmentLink]()
                    for structureContainer0 in environmentLinksContainer {
                        environmentLinksBuffer?.append(structureContainer0)
                    }
                }
                environmentLinks = environmentLinksBuffer
            } else {
                environmentLinks = []
            }
        } else {
            environmentLinks = nil
        }
        let environmentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentArn)
        environmentArn = environmentArnDecoded
        let operationsRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationsRole)
        operationsRole = operationsRoleDecoded
    }
}

extension TooManyApplicationVersionsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyApplicationVersionsException(message: \(String(describing: message)))"}
}

extension TooManyApplicationVersionsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyApplicationVersionsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified account has reached its limit of application versions.</p>
public struct TooManyApplicationVersionsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyApplicationVersionsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyApplicationVersionsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyApplicationsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyApplicationsException(message: \(String(describing: message)))"}
}

extension TooManyApplicationsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyApplicationsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified account has reached its limit of applications.</p>
public struct TooManyApplicationsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyApplicationsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyApplicationsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyBucketsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyBucketsException(message: \(String(describing: message)))"}
}

extension TooManyBucketsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyBucketsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified account has reached its limit of Amazon S3 buckets.</p>
public struct TooManyBucketsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyBucketsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyBucketsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyConfigurationTemplatesException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyConfigurationTemplatesException(message: \(String(describing: message)))"}
}

extension TooManyConfigurationTemplatesException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyConfigurationTemplatesExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified account has reached its limit of configuration templates.</p>
public struct TooManyConfigurationTemplatesException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyConfigurationTemplatesExceptionBody: Equatable {
    public let message: String?
}

extension TooManyConfigurationTemplatesExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyEnvironmentsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyEnvironmentsException(message: \(String(describing: message)))"}
}

extension TooManyEnvironmentsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyEnvironmentsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified account has reached its limit of environments.</p>
public struct TooManyEnvironmentsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyEnvironmentsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyEnvironmentsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyPlatformsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyPlatformsException(message: \(String(describing: message)))"}
}

extension TooManyPlatformsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyPlatformsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the maximum number of allowed platforms associated with the account.</p>
public struct TooManyPlatformsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyPlatformsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyPlatformsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyTagsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of tags in the resource would exceed the number of tags that each resource
///       can have.</p>
///          <p>To calculate this, the operation considers both the number of tags the resource already has
///       and the tags this operation would add if it succeeded.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Trigger: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension Trigger: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Trigger(name: \(String(describing: name)))"}
}

/// <p>Describes a trigger.</p>
public struct Trigger: Equatable {
    /// <p>The name of the trigger.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

public struct UpdateApplicationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

extension UpdateApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationInput(applicationName: \(String(describing: applicationName)), description: \(String(describing: description)))"}
}

extension UpdateApplicationInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        try container.encode("UpdateApplication", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct UpdateApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

/// <p>Request to update an application.</p>
public struct UpdateApplicationInput: Equatable {
    /// <p>The name of the application to update. If no such application is found,
    ///         <code>UpdateApplication</code> returns an <code>InvalidParameterValue</code> error.
    ///     </p>
    public let applicationName: String?
    /// <p>A new description for the application.</p>
    ///          <p>Default: If not specified, AWS Elastic Beanstalk does not update the
    ///       description.</p>
    public let description: String?

    public init (
        applicationName: String? = nil,
        description: String? = nil
    )
    {
        self.applicationName = applicationName
        self.description = description
    }
}

extension UpdateApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationOutputResponse(application: \(String(describing: application)))"}
}

extension UpdateApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.application = output.application
        } else {
            self.application = nil
        }
    }
}

/// <p>Result message containing a single description of an application.</p>
public struct UpdateApplicationOutputResponse: Equatable {
    /// <p> The <a>ApplicationDescription</a> of the application. </p>
    public let application: ApplicationDescription?

    public init (
        application: ApplicationDescription? = nil
    )
    {
        self.application = application
    }
}

struct UpdateApplicationOutputResponseBody: Equatable {
    public let application: ApplicationDescription?
}

extension UpdateApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case application = "Application"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("UpdateApplicationResult"))
        let applicationDecoded = try containerValues.decodeIfPresent(ApplicationDescription.self, forKey: .application)
        application = applicationDecoded
    }
}

public struct UpdateApplicationResourceLifecycleInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApplicationResourceLifecycleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationResourceLifecycleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationResourceLifecycleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationResourceLifecycleInput>
    public typealias MOutput = OperationOutput<UpdateApplicationResourceLifecycleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationResourceLifecycleOutputError>
}

extension UpdateApplicationResourceLifecycleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationResourceLifecycleInput(applicationName: \(String(describing: applicationName)), resourceLifecycleConfig: \(String(describing: resourceLifecycleConfig)))"}
}

extension UpdateApplicationResourceLifecycleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let resourceLifecycleConfig = resourceLifecycleConfig {
            try container.encode(resourceLifecycleConfig, forKey: Key("ResourceLifecycleConfig"))
        }
        try container.encode("UpdateApplicationResourceLifecycle", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct UpdateApplicationResourceLifecycleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApplicationResourceLifecycleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationResourceLifecycleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationResourceLifecycleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationResourceLifecycleInput>
    public typealias MOutput = OperationOutput<UpdateApplicationResourceLifecycleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationResourceLifecycleOutputError>
}

public struct UpdateApplicationResourceLifecycleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApplicationResourceLifecycleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationResourceLifecycleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationResourceLifecycleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationResourceLifecycleInput>
    public typealias MOutput = OperationOutput<UpdateApplicationResourceLifecycleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationResourceLifecycleOutputError>
}

public struct UpdateApplicationResourceLifecycleInput: Equatable {
    /// <p>The name of the application.</p>
    public let applicationName: String?
    /// <p>The lifecycle configuration.</p>
    public let resourceLifecycleConfig: ApplicationResourceLifecycleConfig?

    public init (
        applicationName: String? = nil,
        resourceLifecycleConfig: ApplicationResourceLifecycleConfig? = nil
    )
    {
        self.applicationName = applicationName
        self.resourceLifecycleConfig = resourceLifecycleConfig
    }
}

extension UpdateApplicationResourceLifecycleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateApplicationResourceLifecycleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationResourceLifecycleOutputError: Equatable {
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationResourceLifecycleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationResourceLifecycleOutputResponse(applicationName: \(String(describing: applicationName)), resourceLifecycleConfig: \(String(describing: resourceLifecycleConfig)))"}
}

extension UpdateApplicationResourceLifecycleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateApplicationResourceLifecycleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationName = output.applicationName
            self.resourceLifecycleConfig = output.resourceLifecycleConfig
        } else {
            self.applicationName = nil
            self.resourceLifecycleConfig = nil
        }
    }
}

public struct UpdateApplicationResourceLifecycleOutputResponse: Equatable {
    /// <p>The name of the application.</p>
    public let applicationName: String?
    /// <p>The lifecycle configuration.</p>
    public let resourceLifecycleConfig: ApplicationResourceLifecycleConfig?

    public init (
        applicationName: String? = nil,
        resourceLifecycleConfig: ApplicationResourceLifecycleConfig? = nil
    )
    {
        self.applicationName = applicationName
        self.resourceLifecycleConfig = resourceLifecycleConfig
    }
}

struct UpdateApplicationResourceLifecycleOutputResponseBody: Equatable {
    public let applicationName: String?
    public let resourceLifecycleConfig: ApplicationResourceLifecycleConfig?
}

extension UpdateApplicationResourceLifecycleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case resourceLifecycleConfig = "ResourceLifecycleConfig"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("UpdateApplicationResourceLifecycleResult"))
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let resourceLifecycleConfigDecoded = try containerValues.decodeIfPresent(ApplicationResourceLifecycleConfig.self, forKey: .resourceLifecycleConfig)
        resourceLifecycleConfig = resourceLifecycleConfigDecoded
    }
}

public struct UpdateApplicationVersionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApplicationVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationVersionInput>
    public typealias MOutput = OperationOutput<UpdateApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationVersionOutputError>
}

extension UpdateApplicationVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationVersionInput(applicationName: \(String(describing: applicationName)), description: \(String(describing: description)), versionLabel: \(String(describing: versionLabel)))"}
}

extension UpdateApplicationVersionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let versionLabel = versionLabel {
            try container.encode(versionLabel, forKey: Key("VersionLabel"))
        }
        try container.encode("UpdateApplicationVersion", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct UpdateApplicationVersionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApplicationVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationVersionInput>
    public typealias MOutput = OperationOutput<UpdateApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationVersionOutputError>
}

public struct UpdateApplicationVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApplicationVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationVersionInput>
    public typealias MOutput = OperationOutput<UpdateApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationVersionOutputError>
}

/// <p></p>
public struct UpdateApplicationVersionInput: Equatable {
    /// <p>The name of the application associated with this version.</p>
    ///          <p> If no application is found with this name, <code>UpdateApplication</code> returns an
    ///         <code>InvalidParameterValue</code> error.</p>
    public let applicationName: String?
    /// <p>A new description for this version.</p>
    public let description: String?
    /// <p>The name of the version to update.</p>
    ///          <p>If no application version is found with this label, <code>UpdateApplication</code>
    ///       returns an <code>InvalidParameterValue</code> error. </p>
    public let versionLabel: String?

    public init (
        applicationName: String? = nil,
        description: String? = nil,
        versionLabel: String? = nil
    )
    {
        self.applicationName = applicationName
        self.description = description
        self.versionLabel = versionLabel
    }
}

extension UpdateApplicationVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateApplicationVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationVersionOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationVersionOutputResponse(applicationVersion: \(String(describing: applicationVersion)))"}
}

extension UpdateApplicationVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateApplicationVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationVersion = output.applicationVersion
        } else {
            self.applicationVersion = nil
        }
    }
}

/// <p>Result message wrapping a single description of an application version.</p>
public struct UpdateApplicationVersionOutputResponse: Equatable {
    /// <p> The <a>ApplicationVersionDescription</a> of the application version.
    ///     </p>
    public let applicationVersion: ApplicationVersionDescription?

    public init (
        applicationVersion: ApplicationVersionDescription? = nil
    )
    {
        self.applicationVersion = applicationVersion
    }
}

struct UpdateApplicationVersionOutputResponseBody: Equatable {
    public let applicationVersion: ApplicationVersionDescription?
}

extension UpdateApplicationVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationVersion = "ApplicationVersion"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("UpdateApplicationVersionResult"))
        let applicationVersionDecoded = try containerValues.decodeIfPresent(ApplicationVersionDescription.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
    }
}

public struct UpdateConfigurationTemplateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConfigurationTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationTemplateInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationTemplateOutputError>
}

extension UpdateConfigurationTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationTemplateInput(applicationName: \(String(describing: applicationName)), description: \(String(describing: description)), optionSettings: \(String(describing: optionSettings)), optionsToRemove: \(String(describing: optionsToRemove)), templateName: \(String(describing: templateName)))"}
}

extension UpdateConfigurationTemplateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let optionSettings = optionSettings {
            var optionSettingsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionSettings"))
            for (index0, configurationoptionsetting0) in optionSettings.enumerated() {
                try optionSettingsContainer.encode(configurationoptionsetting0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let optionsToRemove = optionsToRemove {
            var optionsToRemoveContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionsToRemove"))
            for (index0, optionspecification0) in optionsToRemove.enumerated() {
                try optionsToRemoveContainer.encode(optionspecification0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        try container.encode("UpdateConfigurationTemplate", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct UpdateConfigurationTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConfigurationTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationTemplateInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationTemplateOutputError>
}

public struct UpdateConfigurationTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConfigurationTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationTemplateInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationTemplateOutputError>
}

/// <p>The result message containing the options for the specified solution stack.</p>
public struct UpdateConfigurationTemplateInput: Equatable {
    /// <p>The name of the application associated with the configuration template to
    ///       update.</p>
    ///          <p> If no application is found with this name, <code>UpdateConfigurationTemplate</code>
    ///       returns an <code>InvalidParameterValue</code> error. </p>
    public let applicationName: String?
    /// <p>A new description for the configuration.</p>
    public let description: String?
    /// <p>A list of configuration option settings to update with the new specified option
    ///       value.</p>
    public let optionSettings: [ConfigurationOptionSetting]?
    /// <p>A list of configuration options to remove from the configuration set.</p>
    ///          <p> Constraint: You can remove only <code>UserDefined</code> configuration options.
    ///     </p>
    public let optionsToRemove: [OptionSpecification]?
    /// <p>The name of the configuration template to update.</p>
    ///          <p> If no configuration template is found with this name,
    ///         <code>UpdateConfigurationTemplate</code> returns an <code>InvalidParameterValue</code>
    ///       error. </p>
    public let templateName: String?

    public init (
        applicationName: String? = nil,
        description: String? = nil,
        optionSettings: [ConfigurationOptionSetting]? = nil,
        optionsToRemove: [OptionSpecification]? = nil,
        templateName: String? = nil
    )
    {
        self.applicationName = applicationName
        self.description = description
        self.optionSettings = optionSettings
        self.optionsToRemove = optionsToRemove
        self.templateName = templateName
    }
}

extension UpdateConfigurationTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateConfigurationTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyBucketsException" : self = .tooManyBucketsException(try TooManyBucketsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigurationTemplateOutputError: Equatable {
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case tooManyBucketsException(TooManyBucketsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigurationTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationTemplateOutputResponse(applicationName: \(String(describing: applicationName)), dateCreated: \(String(describing: dateCreated)), dateUpdated: \(String(describing: dateUpdated)), deploymentStatus: \(String(describing: deploymentStatus)), description: \(String(describing: description)), environmentName: \(String(describing: environmentName)), optionSettings: \(String(describing: optionSettings)), platformArn: \(String(describing: platformArn)), solutionStackName: \(String(describing: solutionStackName)), templateName: \(String(describing: templateName)))"}
}

extension UpdateConfigurationTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateConfigurationTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationName = output.applicationName
            self.dateCreated = output.dateCreated
            self.dateUpdated = output.dateUpdated
            self.deploymentStatus = output.deploymentStatus
            self.description = output.description
            self.environmentName = output.environmentName
            self.optionSettings = output.optionSettings
            self.platformArn = output.platformArn
            self.solutionStackName = output.solutionStackName
            self.templateName = output.templateName
        } else {
            self.applicationName = nil
            self.dateCreated = nil
            self.dateUpdated = nil
            self.deploymentStatus = nil
            self.description = nil
            self.environmentName = nil
            self.optionSettings = nil
            self.platformArn = nil
            self.solutionStackName = nil
            self.templateName = nil
        }
    }
}

/// <p>Describes the settings for a configuration set.</p>
public struct UpdateConfigurationTemplateOutputResponse: Equatable {
    /// <p>The name of the application associated with this configuration set.</p>
    public let applicationName: String?
    /// <p>The date (in UTC time) when this configuration set was created.</p>
    public let dateCreated: Date?
    /// <p>The date (in UTC time) when this configuration set was last modified.</p>
    public let dateUpdated: Date?
    /// <p> If this configuration set is associated with an environment, the
    ///         <code>DeploymentStatus</code> parameter indicates the deployment status of this
    ///       configuration set: </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>null</code>: This configuration is not associated with a running
    ///           environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: This is a draft configuration that is not deployed to the associated
    ///           environment but is in the process of deploying.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deployed</code>: This is the configuration that is currently deployed to the
    ///           associated running environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>failed</code>: This is a draft configuration that failed to successfully
    ///           deploy.</p>
    ///             </li>
    ///          </ul>
    public let deploymentStatus: ConfigurationDeploymentStatus?
    /// <p>Describes this configuration set.</p>
    public let description: String?
    /// <p> If not <code>null</code>, the name of the environment for this configuration set.
    ///     </p>
    public let environmentName: String?
    /// <p>A list of the configuration options and their values in this configuration
    ///       set.</p>
    public let optionSettings: [ConfigurationOptionSetting]?
    /// <p>The ARN of the platform version.</p>
    public let platformArn: String?
    /// <p>The name of the solution stack this configuration set uses.</p>
    public let solutionStackName: String?
    /// <p> If not <code>null</code>, the name of the configuration template for this
    ///       configuration set. </p>
    public let templateName: String?

    public init (
        applicationName: String? = nil,
        dateCreated: Date? = nil,
        dateUpdated: Date? = nil,
        deploymentStatus: ConfigurationDeploymentStatus? = nil,
        description: String? = nil,
        environmentName: String? = nil,
        optionSettings: [ConfigurationOptionSetting]? = nil,
        platformArn: String? = nil,
        solutionStackName: String? = nil,
        templateName: String? = nil
    )
    {
        self.applicationName = applicationName
        self.dateCreated = dateCreated
        self.dateUpdated = dateUpdated
        self.deploymentStatus = deploymentStatus
        self.description = description
        self.environmentName = environmentName
        self.optionSettings = optionSettings
        self.platformArn = platformArn
        self.solutionStackName = solutionStackName
        self.templateName = templateName
    }
}

struct UpdateConfigurationTemplateOutputResponseBody: Equatable {
    public let solutionStackName: String?
    public let platformArn: String?
    public let applicationName: String?
    public let templateName: String?
    public let description: String?
    public let environmentName: String?
    public let deploymentStatus: ConfigurationDeploymentStatus?
    public let dateCreated: Date?
    public let dateUpdated: Date?
    public let optionSettings: [ConfigurationOptionSetting]?
}

extension UpdateConfigurationTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case dateCreated = "DateCreated"
        case dateUpdated = "DateUpdated"
        case deploymentStatus = "DeploymentStatus"
        case description = "Description"
        case environmentName = "EnvironmentName"
        case optionSettings = "OptionSettings"
        case platformArn = "PlatformArn"
        case solutionStackName = "SolutionStackName"
        case templateName = "TemplateName"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("UpdateConfigurationTemplateResult"))
        let solutionStackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionStackName)
        solutionStackName = solutionStackNameDecoded
        let platformArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformArn)
        platformArn = platformArnDecoded
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ConfigurationDeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        var dateCreatedBuffer:Date? = nil
        if let dateCreatedDecoded = dateCreatedDecoded {
            dateCreatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateCreatedDecoded, format: .dateTime)
        }
        dateCreated = dateCreatedBuffer
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateUpdated)
        var dateUpdatedBuffer:Date? = nil
        if let dateUpdatedDecoded = dateUpdatedDecoded {
            dateUpdatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateUpdatedDecoded, format: .dateTime)
        }
        dateUpdated = dateUpdatedBuffer
        if containerValues.contains(.optionSettings) {
            struct KeyVal0{struct member{}}
            let optionSettingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .optionSettings)
            if let optionSettingsWrappedContainer = optionSettingsWrappedContainer {
                let optionSettingsContainer = try optionSettingsWrappedContainer.decodeIfPresent([ConfigurationOptionSetting].self, forKey: .member)
                var optionSettingsBuffer:[ConfigurationOptionSetting]? = nil
                if let optionSettingsContainer = optionSettingsContainer {
                    optionSettingsBuffer = [ConfigurationOptionSetting]()
                    for structureContainer0 in optionSettingsContainer {
                        optionSettingsBuffer?.append(structureContainer0)
                    }
                }
                optionSettings = optionSettingsBuffer
            } else {
                optionSettings = []
            }
        } else {
            optionSettings = nil
        }
    }
}

public struct UpdateEnvironmentInputBodyMiddleware: Middleware {
    public let id: String = "UpdateEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnvironmentOutputError>
}

extension UpdateEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEnvironmentInput(applicationName: \(String(describing: applicationName)), description: \(String(describing: description)), environmentId: \(String(describing: environmentId)), environmentName: \(String(describing: environmentName)), groupName: \(String(describing: groupName)), optionSettings: \(String(describing: optionSettings)), optionsToRemove: \(String(describing: optionsToRemove)), platformArn: \(String(describing: platformArn)), solutionStackName: \(String(describing: solutionStackName)), templateName: \(String(describing: templateName)), tier: \(String(describing: tier)), versionLabel: \(String(describing: versionLabel)))"}
}

extension UpdateEnvironmentInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let environmentId = environmentId {
            try container.encode(environmentId, forKey: Key("EnvironmentId"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        if let groupName = groupName {
            try container.encode(groupName, forKey: Key("GroupName"))
        }
        if let optionSettings = optionSettings {
            var optionSettingsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionSettings"))
            for (index0, configurationoptionsetting0) in optionSettings.enumerated() {
                try optionSettingsContainer.encode(configurationoptionsetting0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let optionsToRemove = optionsToRemove {
            var optionsToRemoveContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionsToRemove"))
            for (index0, optionspecification0) in optionsToRemove.enumerated() {
                try optionsToRemoveContainer.encode(optionspecification0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let platformArn = platformArn {
            try container.encode(platformArn, forKey: Key("PlatformArn"))
        }
        if let solutionStackName = solutionStackName {
            try container.encode(solutionStackName, forKey: Key("SolutionStackName"))
        }
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        if let tier = tier {
            try container.encode(tier, forKey: Key("Tier"))
        }
        if let versionLabel = versionLabel {
            try container.encode(versionLabel, forKey: Key("VersionLabel"))
        }
        try container.encode("UpdateEnvironment", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct UpdateEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnvironmentOutputError>
}

/// <p>Request to update an environment.</p>
public struct UpdateEnvironmentInput: Equatable {
    /// <p>The name of the application with which the environment is associated.</p>
    public let applicationName: String?
    /// <p>If this parameter is specified, AWS Elastic Beanstalk updates the description of this
    ///       environment.</p>
    public let description: String?
    /// <p>The ID of the environment to update.</p>
    ///          <p>If no environment with this ID exists, AWS Elastic Beanstalk returns an
    ///         <code>InvalidParameterValue</code> error.</p>
    ///          <p>Condition: You must specify either this or an EnvironmentName, or both. If you do not
    ///       specify either, AWS Elastic Beanstalk returns <code>MissingRequiredParameter</code> error.
    ///     </p>
    public let environmentId: String?
    /// <p>The name of the environment to update. If no environment with this name exists, AWS
    ///       Elastic Beanstalk returns an <code>InvalidParameterValue</code> error. </p>
    ///          <p>Condition: You must specify either this or an EnvironmentId, or both. If you do not
    ///       specify either, AWS Elastic Beanstalk returns <code>MissingRequiredParameter</code> error.
    ///     </p>
    public let environmentName: String?
    /// <p>The name of the group to which the target environment belongs. Specify a group name
    ///       only if the environment's name is specified in an environment manifest and not with the
    ///       environment name or environment ID parameters. See <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/environment-cfg-manifest.html">Environment Manifest
    ///         (env.yaml)</a> for details.</p>
    public let groupName: String?
    /// <p>If specified, AWS Elastic Beanstalk updates the configuration set associated with the
    ///       running environment and sets the specified configuration options to the requested
    ///       value.</p>
    public let optionSettings: [ConfigurationOptionSetting]?
    /// <p>A list of custom user-defined configuration options to remove from the configuration
    ///       set for this environment.</p>
    public let optionsToRemove: [OptionSpecification]?
    /// <p>The ARN of the platform, if used.</p>
    public let platformArn: String?
    /// <p>This specifies the platform version that the environment will run after the environment
    ///       is updated.</p>
    public let solutionStackName: String?
    /// <p>If this parameter is specified, AWS Elastic Beanstalk deploys this configuration
    ///       template to the environment. If no such configuration template is found, AWS Elastic Beanstalk
    ///       returns an <code>InvalidParameterValue</code> error. </p>
    public let templateName: String?
    /// <p>This specifies the tier to use to update the environment.</p>
    ///          <p>Condition: At this time, if you change the tier version, name, or type, AWS Elastic
    ///       Beanstalk returns <code>InvalidParameterValue</code> error. </p>
    public let tier: EnvironmentTier?
    /// <p>If this parameter is specified, AWS Elastic Beanstalk deploys the named application
    ///       version to the environment. If no such application version is found, returns an
    ///         <code>InvalidParameterValue</code> error. </p>
    public let versionLabel: String?

    public init (
        applicationName: String? = nil,
        description: String? = nil,
        environmentId: String? = nil,
        environmentName: String? = nil,
        groupName: String? = nil,
        optionSettings: [ConfigurationOptionSetting]? = nil,
        optionsToRemove: [OptionSpecification]? = nil,
        platformArn: String? = nil,
        solutionStackName: String? = nil,
        templateName: String? = nil,
        tier: EnvironmentTier? = nil,
        versionLabel: String? = nil
    )
    {
        self.applicationName = applicationName
        self.description = description
        self.environmentId = environmentId
        self.environmentName = environmentName
        self.groupName = groupName
        self.optionSettings = optionSettings
        self.optionsToRemove = optionsToRemove
        self.platformArn = platformArn
        self.solutionStackName = solutionStackName
        self.templateName = templateName
        self.tier = tier
        self.versionLabel = versionLabel
    }
}

extension UpdateEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyBucketsException" : self = .tooManyBucketsException(try TooManyBucketsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEnvironmentOutputError: Equatable {
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case tooManyBucketsException(TooManyBucketsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEnvironmentOutputResponse(abortableOperationInProgress: \(String(describing: abortableOperationInProgress)), applicationName: \(String(describing: applicationName)), cNAME: \(String(describing: cNAME)), dateCreated: \(String(describing: dateCreated)), dateUpdated: \(String(describing: dateUpdated)), description: \(String(describing: description)), endpointURL: \(String(describing: endpointURL)), environmentArn: \(String(describing: environmentArn)), environmentId: \(String(describing: environmentId)), environmentLinks: \(String(describing: environmentLinks)), environmentName: \(String(describing: environmentName)), health: \(String(describing: health)), healthStatus: \(String(describing: healthStatus)), operationsRole: \(String(describing: operationsRole)), platformArn: \(String(describing: platformArn)), resources: \(String(describing: resources)), solutionStackName: \(String(describing: solutionStackName)), status: \(String(describing: status)), templateName: \(String(describing: templateName)), tier: \(String(describing: tier)), versionLabel: \(String(describing: versionLabel)))"}
}

extension UpdateEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.abortableOperationInProgress = output.abortableOperationInProgress
            self.applicationName = output.applicationName
            self.cNAME = output.cNAME
            self.dateCreated = output.dateCreated
            self.dateUpdated = output.dateUpdated
            self.description = output.description
            self.endpointURL = output.endpointURL
            self.environmentArn = output.environmentArn
            self.environmentId = output.environmentId
            self.environmentLinks = output.environmentLinks
            self.environmentName = output.environmentName
            self.health = output.health
            self.healthStatus = output.healthStatus
            self.operationsRole = output.operationsRole
            self.platformArn = output.platformArn
            self.resources = output.resources
            self.solutionStackName = output.solutionStackName
            self.status = output.status
            self.templateName = output.templateName
            self.tier = output.tier
            self.versionLabel = output.versionLabel
        } else {
            self.abortableOperationInProgress = nil
            self.applicationName = nil
            self.cNAME = nil
            self.dateCreated = nil
            self.dateUpdated = nil
            self.description = nil
            self.endpointURL = nil
            self.environmentArn = nil
            self.environmentId = nil
            self.environmentLinks = nil
            self.environmentName = nil
            self.health = nil
            self.healthStatus = nil
            self.operationsRole = nil
            self.platformArn = nil
            self.resources = nil
            self.solutionStackName = nil
            self.status = nil
            self.templateName = nil
            self.tier = nil
            self.versionLabel = nil
        }
    }
}

/// <p>Describes the properties of an environment.</p>
public struct UpdateEnvironmentOutputResponse: Equatable {
    /// <p>Indicates if there is an in-progress environment configuration update or application
    ///       version deployment that you can cancel.</p>
    ///          <p>
    ///             <code>true:</code> There is an update in progress. </p>
    ///          <p>
    ///             <code>false:</code> There are no updates currently in progress. </p>
    public let abortableOperationInProgress: Bool?
    /// <p>The name of the application associated with this environment.</p>
    public let applicationName: String?
    /// <p>The URL to the CNAME for this environment.</p>
    public let cNAME: String?
    /// <p>The creation date for this environment.</p>
    public let dateCreated: Date?
    /// <p>The last modified date for this environment.</p>
    public let dateUpdated: Date?
    /// <p>Describes this environment.</p>
    public let description: String?
    /// <p>For load-balanced, autoscaling environments, the URL to the LoadBalancer. For
    ///       single-instance environments, the IP address of the instance.</p>
    public let endpointURL: String?
    /// <p>The environment's Amazon Resource Name (ARN), which can be used in other API requests that require an ARN.</p>
    public let environmentArn: String?
    /// <p>The ID of this environment.</p>
    public let environmentId: String?
    /// <p>A list of links to other environments in the same group.</p>
    public let environmentLinks: [EnvironmentLink]?
    /// <p>The name of this environment.</p>
    public let environmentName: String?
    /// <p>Describes the health status of the environment. AWS Elastic Beanstalk indicates the
    ///       failure levels for a running environment:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Red</code>: Indicates the environment is not responsive. Occurs when three or more
    ///           consecutive failures occur for an environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Yellow</code>: Indicates that something is wrong. Occurs when two consecutive
    ///           failures occur for an environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Green</code>: Indicates the environment is healthy and fully functional.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Grey</code>: Default health for a new environment. The environment is not fully
    ///           launched and health checks have not started or health checks are suspended during an
    ///             <code>UpdateEnvironment</code> or <code>RestartEnvironment</code> request.</p>
    ///             </li>
    ///          </ul>
    ///          <p> Default: <code>Grey</code>
    ///          </p>
    public let health: EnvironmentHealth?
    /// <p>Returns the health status of the application running in your environment. For more
    ///       information, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/health-enhanced-status.html">Health Colors and
    ///         Statuses</a>.</p>
    public let healthStatus: EnvironmentHealthStatus?
    /// <p>The Amazon Resource Name (ARN) of the environment's operations role. For more information,
    ///       see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/iam-operationsrole.html">Operations roles</a> in the <i>AWS Elastic Beanstalk Developer Guide</i>.</p>
    public let operationsRole: String?
    /// <p>The ARN of the platform version.</p>
    public let platformArn: String?
    /// <p>The description of the AWS resources used by this environment.</p>
    public let resources: EnvironmentResourcesDescription?
    /// <p> The name of the <code>SolutionStack</code> deployed with this environment. </p>
    public let solutionStackName: String?
    /// <p>The current operational status of the environment:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Launching</code>: Environment is in the process of initial deployment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Updating</code>: Environment is in the process of updating its configuration
    ///           settings or application version.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Ready</code>: Environment is available to have an action performed on it, such as
    ///           update or terminate.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Terminating</code>: Environment is in the shut-down process.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Terminated</code>: Environment is not running.</p>
    ///             </li>
    ///          </ul>
    public let status: EnvironmentStatus?
    /// <p>The name of the configuration template used to originally launch this
    ///       environment.</p>
    public let templateName: String?
    /// <p>Describes the current tier of this environment.</p>
    public let tier: EnvironmentTier?
    /// <p>The application version deployed in this environment.</p>
    public let versionLabel: String?

    public init (
        abortableOperationInProgress: Bool? = nil,
        applicationName: String? = nil,
        cNAME: String? = nil,
        dateCreated: Date? = nil,
        dateUpdated: Date? = nil,
        description: String? = nil,
        endpointURL: String? = nil,
        environmentArn: String? = nil,
        environmentId: String? = nil,
        environmentLinks: [EnvironmentLink]? = nil,
        environmentName: String? = nil,
        health: EnvironmentHealth? = nil,
        healthStatus: EnvironmentHealthStatus? = nil,
        operationsRole: String? = nil,
        platformArn: String? = nil,
        resources: EnvironmentResourcesDescription? = nil,
        solutionStackName: String? = nil,
        status: EnvironmentStatus? = nil,
        templateName: String? = nil,
        tier: EnvironmentTier? = nil,
        versionLabel: String? = nil
    )
    {
        self.abortableOperationInProgress = abortableOperationInProgress
        self.applicationName = applicationName
        self.cNAME = cNAME
        self.dateCreated = dateCreated
        self.dateUpdated = dateUpdated
        self.description = description
        self.endpointURL = endpointURL
        self.environmentArn = environmentArn
        self.environmentId = environmentId
        self.environmentLinks = environmentLinks
        self.environmentName = environmentName
        self.health = health
        self.healthStatus = healthStatus
        self.operationsRole = operationsRole
        self.platformArn = platformArn
        self.resources = resources
        self.solutionStackName = solutionStackName
        self.status = status
        self.templateName = templateName
        self.tier = tier
        self.versionLabel = versionLabel
    }
}

struct UpdateEnvironmentOutputResponseBody: Equatable {
    public let environmentName: String?
    public let environmentId: String?
    public let applicationName: String?
    public let versionLabel: String?
    public let solutionStackName: String?
    public let platformArn: String?
    public let templateName: String?
    public let description: String?
    public let endpointURL: String?
    public let cNAME: String?
    public let dateCreated: Date?
    public let dateUpdated: Date?
    public let status: EnvironmentStatus?
    public let abortableOperationInProgress: Bool?
    public let health: EnvironmentHealth?
    public let healthStatus: EnvironmentHealthStatus?
    public let resources: EnvironmentResourcesDescription?
    public let tier: EnvironmentTier?
    public let environmentLinks: [EnvironmentLink]?
    public let environmentArn: String?
    public let operationsRole: String?
}

extension UpdateEnvironmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case abortableOperationInProgress = "AbortableOperationInProgress"
        case applicationName = "ApplicationName"
        case cNAME = "CNAME"
        case dateCreated = "DateCreated"
        case dateUpdated = "DateUpdated"
        case description = "Description"
        case endpointURL = "EndpointURL"
        case environmentArn = "EnvironmentArn"
        case environmentId = "EnvironmentId"
        case environmentLinks = "EnvironmentLinks"
        case environmentName = "EnvironmentName"
        case health = "Health"
        case healthStatus = "HealthStatus"
        case operationsRole = "OperationsRole"
        case platformArn = "PlatformArn"
        case resources = "Resources"
        case solutionStackName = "SolutionStackName"
        case status = "Status"
        case templateName = "TemplateName"
        case tier = "Tier"
        case versionLabel = "VersionLabel"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("UpdateEnvironmentResult"))
        let environmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let versionLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionLabel)
        versionLabel = versionLabelDecoded
        let solutionStackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionStackName)
        solutionStackName = solutionStackNameDecoded
        let platformArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformArn)
        platformArn = platformArnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let endpointURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointURL)
        endpointURL = endpointURLDecoded
        let cNAMEDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cNAME)
        cNAME = cNAMEDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        var dateCreatedBuffer:Date? = nil
        if let dateCreatedDecoded = dateCreatedDecoded {
            dateCreatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateCreatedDecoded, format: .dateTime)
        }
        dateCreated = dateCreatedBuffer
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateUpdated)
        var dateUpdatedBuffer:Date? = nil
        if let dateUpdatedDecoded = dateUpdatedDecoded {
            dateUpdatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateUpdatedDecoded, format: .dateTime)
        }
        dateUpdated = dateUpdatedBuffer
        let statusDecoded = try containerValues.decodeIfPresent(EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let abortableOperationInProgressDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .abortableOperationInProgress)
        abortableOperationInProgress = abortableOperationInProgressDecoded
        let healthDecoded = try containerValues.decodeIfPresent(EnvironmentHealth.self, forKey: .health)
        health = healthDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(EnvironmentHealthStatus.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(EnvironmentResourcesDescription.self, forKey: .resources)
        resources = resourcesDecoded
        let tierDecoded = try containerValues.decodeIfPresent(EnvironmentTier.self, forKey: .tier)
        tier = tierDecoded
        if containerValues.contains(.environmentLinks) {
            struct KeyVal0{struct member{}}
            let environmentLinksWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .environmentLinks)
            if let environmentLinksWrappedContainer = environmentLinksWrappedContainer {
                let environmentLinksContainer = try environmentLinksWrappedContainer.decodeIfPresent([EnvironmentLink].self, forKey: .member)
                var environmentLinksBuffer:[EnvironmentLink]? = nil
                if let environmentLinksContainer = environmentLinksContainer {
                    environmentLinksBuffer = [EnvironmentLink]()
                    for structureContainer0 in environmentLinksContainer {
                        environmentLinksBuffer?.append(structureContainer0)
                    }
                }
                environmentLinks = environmentLinksBuffer
            } else {
                environmentLinks = []
            }
        } else {
            environmentLinks = nil
        }
        let environmentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentArn)
        environmentArn = environmentArnDecoded
        let operationsRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationsRole)
        operationsRole = operationsRoleDecoded
    }
}

public struct UpdateTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTagsForResourceInput>
    public typealias MOutput = OperationOutput<UpdateTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTagsForResourceOutputError>
}

extension UpdateTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTagsForResourceInput(resourceArn: \(String(describing: resourceArn)), tagsToAdd: \(String(describing: tagsToAdd)), tagsToRemove: \(String(describing: tagsToRemove)))"}
}

extension UpdateTagsForResourceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: Key("ResourceArn"))
        }
        if let tagsToAdd = tagsToAdd {
            var tagsToAddContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagsToAdd"))
            for (index0, tag0) in tagsToAdd.enumerated() {
                try tagsToAddContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tagsToRemove = tagsToRemove {
            var tagsToRemoveContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagsToRemove"))
            for (index0, tagkey0) in tagsToRemove.enumerated() {
                try tagsToRemoveContainer.encode(tagkey0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("UpdateTagsForResource", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct UpdateTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTagsForResourceInput>
    public typealias MOutput = OperationOutput<UpdateTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTagsForResourceOutputError>
}

public struct UpdateTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTagsForResourceInput>
    public typealias MOutput = OperationOutput<UpdateTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTagsForResourceOutputError>
}

public struct UpdateTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resouce to be updated.</p>
    ///          <p>Must be the ARN of an Elastic Beanstalk resource.</p>
    public let resourceArn: String?
    /// <p>A list of tags to add or update. If a key of an existing tag is added, the tag's value is
    ///       updated.</p>
    ///          <p>Specify at least one of these parameters: <code>TagsToAdd</code>,
    ///         <code>TagsToRemove</code>.</p>
    public let tagsToAdd: [Tag]?
    /// <p>A list of tag keys to remove. If a tag key doesn't exist, it is silently ignored.</p>
    ///          <p>Specify at least one of these parameters: <code>TagsToAdd</code>,
    ///       <code>TagsToRemove</code>.</p>
    public let tagsToRemove: [String]?

    public init (
        resourceArn: String? = nil,
        tagsToAdd: [Tag]? = nil,
        tagsToRemove: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagsToAdd = tagsToAdd
        self.tagsToRemove = tagsToRemove
    }
}

extension UpdateTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationInProgressException" : self = .operationInProgressException(try OperationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceTypeNotSupportedException" : self = .resourceTypeNotSupportedException(try ResourceTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTagsForResourceOutputError: Equatable {
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case operationInProgressException(OperationInProgressException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceTypeNotSupportedException(ResourceTypeNotSupportedException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTagsForResourceOutputResponse()"}
}

extension UpdateTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateTagsForResourceOutputResponse: Equatable {

    public init() {}
}

struct UpdateTagsForResourceOutputResponseBody: Equatable {
}

extension UpdateTagsForResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ValidateConfigurationSettingsInputBodyMiddleware: Middleware {
    public let id: String = "ValidateConfigurationSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidateConfigurationSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidateConfigurationSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidateConfigurationSettingsInput>
    public typealias MOutput = OperationOutput<ValidateConfigurationSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidateConfigurationSettingsOutputError>
}

extension ValidateConfigurationSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidateConfigurationSettingsInput(applicationName: \(String(describing: applicationName)), environmentName: \(String(describing: environmentName)), optionSettings: \(String(describing: optionSettings)), templateName: \(String(describing: templateName)))"}
}

extension ValidateConfigurationSettingsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applicationName = applicationName {
            try container.encode(applicationName, forKey: Key("ApplicationName"))
        }
        if let environmentName = environmentName {
            try container.encode(environmentName, forKey: Key("EnvironmentName"))
        }
        if let optionSettings = optionSettings {
            var optionSettingsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionSettings"))
            for (index0, configurationoptionsetting0) in optionSettings.enumerated() {
                try optionSettingsContainer.encode(configurationoptionsetting0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        try container.encode("ValidateConfigurationSettings", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct ValidateConfigurationSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "ValidateConfigurationSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidateConfigurationSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidateConfigurationSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidateConfigurationSettingsInput>
    public typealias MOutput = OperationOutput<ValidateConfigurationSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidateConfigurationSettingsOutputError>
}

public struct ValidateConfigurationSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "ValidateConfigurationSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidateConfigurationSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidateConfigurationSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidateConfigurationSettingsInput>
    public typealias MOutput = OperationOutput<ValidateConfigurationSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidateConfigurationSettingsOutputError>
}

/// <p>A list of validation messages for a specified configuration template.</p>
public struct ValidateConfigurationSettingsInput: Equatable {
    /// <p>The name of the application that the configuration template or environment belongs
    ///       to.</p>
    public let applicationName: String?
    /// <p>The name of the environment to validate the settings against.</p>
    ///          <p>Condition: You cannot specify both this and a configuration template name.</p>
    public let environmentName: String?
    /// <p>A list of the options and desired values to evaluate.</p>
    public let optionSettings: [ConfigurationOptionSetting]?
    /// <p>The name of the configuration template to validate the settings against.</p>
    ///          <p>Condition: You cannot specify both this and an environment name.</p>
    public let templateName: String?

    public init (
        applicationName: String? = nil,
        environmentName: String? = nil,
        optionSettings: [ConfigurationOptionSetting]? = nil,
        templateName: String? = nil
    )
    {
        self.applicationName = applicationName
        self.environmentName = environmentName
        self.optionSettings = optionSettings
        self.templateName = templateName
    }
}

extension ValidateConfigurationSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ValidateConfigurationSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPrivilegesException" : self = .insufficientPrivilegesException(try InsufficientPrivilegesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyBucketsException" : self = .tooManyBucketsException(try TooManyBucketsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ValidateConfigurationSettingsOutputError: Equatable {
    case insufficientPrivilegesException(InsufficientPrivilegesException)
    case tooManyBucketsException(TooManyBucketsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ValidateConfigurationSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidateConfigurationSettingsOutputResponse(messages: \(String(describing: messages)))"}
}

extension ValidateConfigurationSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidateConfigurationSettingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.messages = output.messages
        } else {
            self.messages = nil
        }
    }
}

/// <p>Provides a list of validation messages.</p>
public struct ValidateConfigurationSettingsOutputResponse: Equatable {
    /// <p> A list of <a>ValidationMessage</a>. </p>
    public let messages: [ValidationMessage]?

    public init (
        messages: [ValidationMessage]? = nil
    )
    {
        self.messages = messages
    }
}

struct ValidateConfigurationSettingsOutputResponseBody: Equatable {
    public let messages: [ValidationMessage]?
}

extension ValidateConfigurationSettingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messages = "Messages"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ValidateConfigurationSettingsResult"))
        if containerValues.contains(.messages) {
            struct KeyVal0{struct member{}}
            let messagesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .messages)
            if let messagesWrappedContainer = messagesWrappedContainer {
                let messagesContainer = try messagesWrappedContainer.decodeIfPresent([ValidationMessage].self, forKey: .member)
                var messagesBuffer:[ValidationMessage]? = nil
                if let messagesContainer = messagesContainer {
                    messagesBuffer = [ValidationMessage]()
                    for structureContainer0 in messagesContainer {
                        messagesBuffer?.append(structureContainer0)
                    }
                }
                messages = messagesBuffer
            } else {
                messages = []
            }
        } else {
            messages = nil
        }
    }
}

extension ValidationMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case namespace = "Namespace"
        case optionName = "OptionName"
        case severity = "Severity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let message = message {
            try container.encode(message, forKey: Key("Message"))
        }
        if let namespace = namespace {
            try container.encode(namespace, forKey: Key("Namespace"))
        }
        if let optionName = optionName {
            try container.encode(optionName, forKey: Key("OptionName"))
        }
        if let severity = severity {
            try container.encode(severity, forKey: Key("Severity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let severityDecoded = try containerValues.decodeIfPresent(ValidationSeverity.self, forKey: .severity)
        severity = severityDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let optionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optionName)
        optionName = optionNameDecoded
    }
}

extension ValidationMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationMessage(message: \(String(describing: message)), namespace: \(String(describing: namespace)), optionName: \(String(describing: optionName)), severity: \(String(describing: severity)))"}
}

/// <p>An error or warning for a desired configuration option value.</p>
public struct ValidationMessage: Equatable {
    /// <p>A message describing the error or warning.</p>
    public let message: String?
    /// <p>The namespace to which the option belongs.</p>
    public let namespace: String?
    /// <p>The name of the option.</p>
    public let optionName: String?
    /// <p>An indication of the severity of this message:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>error</code>: This message indicates that this is not a valid setting for an
    ///           option.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>warning</code>: This message is providing information you should take into
    ///           account.</p>
    ///             </li>
    ///          </ul>
    public let severity: ValidationSeverity?

    public init (
        message: String? = nil,
        namespace: String? = nil,
        optionName: String? = nil,
        severity: ValidationSeverity? = nil
    )
    {
        self.message = message
        self.namespace = namespace
        self.optionName = optionName
        self.severity = severity
    }
}

public enum ValidationSeverity {
    case error
    case warning
    case sdkUnknown(String)
}

extension ValidationSeverity : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ValidationSeverity] {
        return [
            .error,
            .warning,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .error: return "error"
        case .warning: return "warning"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ValidationSeverity(rawValue: rawValue) ?? ValidationSeverity.sdkUnknown(rawValue)
    }
}
