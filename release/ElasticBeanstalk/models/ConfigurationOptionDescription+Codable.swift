// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension ConfigurationOptionDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeSeverity = "ChangeSeverity"
        case defaultValue = "DefaultValue"
        case maxLength = "MaxLength"
        case maxValue = "MaxValue"
        case minValue = "MinValue"
        case name = "Name"
        case namespace = "Namespace"
        case regex = "Regex"
        case userDefined = "UserDefined"
        case valueOptions = "ValueOptions"
        case valueType = "ValueType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let changeSeverity = changeSeverity {
            try container.encode(changeSeverity, forKey: Key("ChangeSeverity"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: Key("DefaultValue"))
        }
        if let maxLength = maxLength {
            try container.encode(maxLength, forKey: Key("MaxLength"))
        }
        if let maxValue = maxValue {
            try container.encode(maxValue, forKey: Key("MaxValue"))
        }
        if let minValue = minValue {
            try container.encode(minValue, forKey: Key("MinValue"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let namespace = namespace {
            try container.encode(namespace, forKey: Key("Namespace"))
        }
        if let regex = regex {
            try container.encode(regex, forKey: Key("Regex"))
        }
        if let userDefined = userDefined {
            try container.encode(userDefined, forKey: Key("UserDefined"))
        }
        if let valueOptions = valueOptions {
            var valueOptionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ValueOptions"))
            for (index0, configurationoptionpossiblevalue0) in valueOptions.enumerated() {
                try valueOptionsContainer.encode(configurationoptionpossiblevalue0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let valueType = valueType {
            try container.encode(valueType, forKey: Key("ValueType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let changeSeverityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSeverity)
        changeSeverity = changeSeverityDecoded
        let userDefinedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .userDefined)
        userDefined = userDefinedDecoded
        let valueTypeDecoded = try containerValues.decodeIfPresent(ConfigurationOptionValueType.self, forKey: .valueType)
        valueType = valueTypeDecoded
        if containerValues.contains(.valueOptions) {
            struct KeyVal0{struct member{}}
            let valueOptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .valueOptions)
            if let valueOptionsWrappedContainer = valueOptionsWrappedContainer {
                let valueOptionsContainer = try valueOptionsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var valueOptionsBuffer:[String]? = nil
                if let valueOptionsContainer = valueOptionsContainer {
                    valueOptionsBuffer = [String]()
                    for stringContainer0 in valueOptionsContainer {
                        valueOptionsBuffer?.append(stringContainer0)
                    }
                }
                valueOptions = valueOptionsBuffer
            } else {
                valueOptions = []
            }
        } else {
            valueOptions = nil
        }
        let minValueDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minValue)
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let maxLengthDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxLength)
        maxLength = maxLengthDecoded
        let regexDecoded = try containerValues.decodeIfPresent(OptionRestrictionRegex.self, forKey: .regex)
        regex = regexDecoded
    }
}
