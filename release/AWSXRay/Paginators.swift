// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[BatchGetTracesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[BatchGetTracesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `BatchGetTracesOutputResponse`
extension XRayClient {
    public func batchGetTracesPaginated(input: BatchGetTracesInput) -> ClientRuntime.PaginatorSequence<BatchGetTracesInput, BatchGetTracesOutputResponse> {
        return ClientRuntime.PaginatorSequence<BatchGetTracesInput, BatchGetTracesOutputResponse>(input: input, inputKey: \BatchGetTracesInput.nextToken, outputKey: \BatchGetTracesOutputResponse.nextToken, paginationFunction: self.batchGetTraces(input:))
    }
}

extension BatchGetTracesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> BatchGetTracesInput {
        return BatchGetTracesInput(
            nextToken: token,
            traceIds: self.traceIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `batchGetTracesPaginated`
/// to access the nested member `[XRayClientTypes.Trace]`
/// - Returns: `[XRayClientTypes.Trace]`
extension PaginatorSequence where Input == BatchGetTracesInput, Output == BatchGetTracesOutputResponse {
    public func traces() async throws -> [XRayClientTypes.Trace] {
        return try await self.asyncCompactMap { item in item.traces }
    }
}

/// Paginate over `[GetGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetGroupsOutputResponse`
extension XRayClient {
    public func getGroupsPaginated(input: GetGroupsInput) -> ClientRuntime.PaginatorSequence<GetGroupsInput, GetGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetGroupsInput, GetGroupsOutputResponse>(input: input, inputKey: \GetGroupsInput.nextToken, outputKey: \GetGroupsOutputResponse.nextToken, paginationFunction: self.getGroups(input:))
    }
}

extension GetGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetGroupsInput {
        return GetGroupsInput(
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getGroupsPaginated`
/// to access the nested member `[XRayClientTypes.GroupSummary]`
/// - Returns: `[XRayClientTypes.GroupSummary]`
extension PaginatorSequence where Input == GetGroupsInput, Output == GetGroupsOutputResponse {
    public func groups() async throws -> [XRayClientTypes.GroupSummary] {
        return try await self.asyncCompactMap { item in item.groups }
    }
}

/// Paginate over `[GetInsightEventsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetInsightEventsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetInsightEventsOutputResponse`
extension XRayClient {
    public func getInsightEventsPaginated(input: GetInsightEventsInput) -> ClientRuntime.PaginatorSequence<GetInsightEventsInput, GetInsightEventsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetInsightEventsInput, GetInsightEventsOutputResponse>(input: input, inputKey: \GetInsightEventsInput.nextToken, outputKey: \GetInsightEventsOutputResponse.nextToken, paginationFunction: self.getInsightEvents(input:))
    }
}

extension GetInsightEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetInsightEventsInput {
        return GetInsightEventsInput(
            insightId: self.insightId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[GetInsightSummariesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetInsightSummariesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetInsightSummariesOutputResponse`
extension XRayClient {
    public func getInsightSummariesPaginated(input: GetInsightSummariesInput) -> ClientRuntime.PaginatorSequence<GetInsightSummariesInput, GetInsightSummariesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetInsightSummariesInput, GetInsightSummariesOutputResponse>(input: input, inputKey: \GetInsightSummariesInput.nextToken, outputKey: \GetInsightSummariesOutputResponse.nextToken, paginationFunction: self.getInsightSummaries(input:))
    }
}

extension GetInsightSummariesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetInsightSummariesInput {
        return GetInsightSummariesInput(
            endTime: self.endTime,
            groupARN: self.groupARN,
            groupName: self.groupName,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime,
            states: self.states
        )}
}

/// Paginate over `[GetSamplingRulesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetSamplingRulesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetSamplingRulesOutputResponse`
extension XRayClient {
    public func getSamplingRulesPaginated(input: GetSamplingRulesInput) -> ClientRuntime.PaginatorSequence<GetSamplingRulesInput, GetSamplingRulesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetSamplingRulesInput, GetSamplingRulesOutputResponse>(input: input, inputKey: \GetSamplingRulesInput.nextToken, outputKey: \GetSamplingRulesOutputResponse.nextToken, paginationFunction: self.getSamplingRules(input:))
    }
}

extension GetSamplingRulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetSamplingRulesInput {
        return GetSamplingRulesInput(
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getSamplingRulesPaginated`
/// to access the nested member `[XRayClientTypes.SamplingRuleRecord]`
/// - Returns: `[XRayClientTypes.SamplingRuleRecord]`
extension PaginatorSequence where Input == GetSamplingRulesInput, Output == GetSamplingRulesOutputResponse {
    public func samplingRuleRecords() async throws -> [XRayClientTypes.SamplingRuleRecord] {
        return try await self.asyncCompactMap { item in item.samplingRuleRecords }
    }
}

/// Paginate over `[GetSamplingStatisticSummariesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetSamplingStatisticSummariesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetSamplingStatisticSummariesOutputResponse`
extension XRayClient {
    public func getSamplingStatisticSummariesPaginated(input: GetSamplingStatisticSummariesInput) -> ClientRuntime.PaginatorSequence<GetSamplingStatisticSummariesInput, GetSamplingStatisticSummariesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetSamplingStatisticSummariesInput, GetSamplingStatisticSummariesOutputResponse>(input: input, inputKey: \GetSamplingStatisticSummariesInput.nextToken, outputKey: \GetSamplingStatisticSummariesOutputResponse.nextToken, paginationFunction: self.getSamplingStatisticSummaries(input:))
    }
}

extension GetSamplingStatisticSummariesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetSamplingStatisticSummariesInput {
        return GetSamplingStatisticSummariesInput(
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getSamplingStatisticSummariesPaginated`
/// to access the nested member `[XRayClientTypes.SamplingStatisticSummary]`
/// - Returns: `[XRayClientTypes.SamplingStatisticSummary]`
extension PaginatorSequence where Input == GetSamplingStatisticSummariesInput, Output == GetSamplingStatisticSummariesOutputResponse {
    public func samplingStatisticSummaries() async throws -> [XRayClientTypes.SamplingStatisticSummary] {
        return try await self.asyncCompactMap { item in item.samplingStatisticSummaries }
    }
}

/// Paginate over `[GetServiceGraphOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetServiceGraphInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetServiceGraphOutputResponse`
extension XRayClient {
    public func getServiceGraphPaginated(input: GetServiceGraphInput) -> ClientRuntime.PaginatorSequence<GetServiceGraphInput, GetServiceGraphOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetServiceGraphInput, GetServiceGraphOutputResponse>(input: input, inputKey: \GetServiceGraphInput.nextToken, outputKey: \GetServiceGraphOutputResponse.nextToken, paginationFunction: self.getServiceGraph(input:))
    }
}

extension GetServiceGraphInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetServiceGraphInput {
        return GetServiceGraphInput(
            endTime: self.endTime,
            groupARN: self.groupARN,
            groupName: self.groupName,
            nextToken: token,
            startTime: self.startTime
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getServiceGraphPaginated`
/// to access the nested member `[XRayClientTypes.Service]`
/// - Returns: `[XRayClientTypes.Service]`
extension PaginatorSequence where Input == GetServiceGraphInput, Output == GetServiceGraphOutputResponse {
    public func services() async throws -> [XRayClientTypes.Service] {
        return try await self.asyncCompactMap { item in item.services }
    }
}

/// Paginate over `[GetTimeSeriesServiceStatisticsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetTimeSeriesServiceStatisticsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetTimeSeriesServiceStatisticsOutputResponse`
extension XRayClient {
    public func getTimeSeriesServiceStatisticsPaginated(input: GetTimeSeriesServiceStatisticsInput) -> ClientRuntime.PaginatorSequence<GetTimeSeriesServiceStatisticsInput, GetTimeSeriesServiceStatisticsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetTimeSeriesServiceStatisticsInput, GetTimeSeriesServiceStatisticsOutputResponse>(input: input, inputKey: \GetTimeSeriesServiceStatisticsInput.nextToken, outputKey: \GetTimeSeriesServiceStatisticsOutputResponse.nextToken, paginationFunction: self.getTimeSeriesServiceStatistics(input:))
    }
}

extension GetTimeSeriesServiceStatisticsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTimeSeriesServiceStatisticsInput {
        return GetTimeSeriesServiceStatisticsInput(
            endTime: self.endTime,
            entitySelectorExpression: self.entitySelectorExpression,
            forecastStatistics: self.forecastStatistics,
            groupARN: self.groupARN,
            groupName: self.groupName,
            nextToken: token,
            period: self.period,
            startTime: self.startTime
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getTimeSeriesServiceStatisticsPaginated`
/// to access the nested member `[XRayClientTypes.TimeSeriesServiceStatistics]`
/// - Returns: `[XRayClientTypes.TimeSeriesServiceStatistics]`
extension PaginatorSequence where Input == GetTimeSeriesServiceStatisticsInput, Output == GetTimeSeriesServiceStatisticsOutputResponse {
    public func timeSeriesServiceStatistics() async throws -> [XRayClientTypes.TimeSeriesServiceStatistics] {
        return try await self.asyncCompactMap { item in item.timeSeriesServiceStatistics }
    }
}

/// Paginate over `[GetTraceGraphOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetTraceGraphInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetTraceGraphOutputResponse`
extension XRayClient {
    public func getTraceGraphPaginated(input: GetTraceGraphInput) -> ClientRuntime.PaginatorSequence<GetTraceGraphInput, GetTraceGraphOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetTraceGraphInput, GetTraceGraphOutputResponse>(input: input, inputKey: \GetTraceGraphInput.nextToken, outputKey: \GetTraceGraphOutputResponse.nextToken, paginationFunction: self.getTraceGraph(input:))
    }
}

extension GetTraceGraphInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTraceGraphInput {
        return GetTraceGraphInput(
            nextToken: token,
            traceIds: self.traceIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getTraceGraphPaginated`
/// to access the nested member `[XRayClientTypes.Service]`
/// - Returns: `[XRayClientTypes.Service]`
extension PaginatorSequence where Input == GetTraceGraphInput, Output == GetTraceGraphOutputResponse {
    public func services() async throws -> [XRayClientTypes.Service] {
        return try await self.asyncCompactMap { item in item.services }
    }
}

/// Paginate over `[GetTraceSummariesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetTraceSummariesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetTraceSummariesOutputResponse`
extension XRayClient {
    public func getTraceSummariesPaginated(input: GetTraceSummariesInput) -> ClientRuntime.PaginatorSequence<GetTraceSummariesInput, GetTraceSummariesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetTraceSummariesInput, GetTraceSummariesOutputResponse>(input: input, inputKey: \GetTraceSummariesInput.nextToken, outputKey: \GetTraceSummariesOutputResponse.nextToken, paginationFunction: self.getTraceSummaries(input:))
    }
}

extension GetTraceSummariesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTraceSummariesInput {
        return GetTraceSummariesInput(
            endTime: self.endTime,
            filterExpression: self.filterExpression,
            nextToken: token,
            sampling: self.sampling,
            samplingStrategy: self.samplingStrategy,
            startTime: self.startTime,
            timeRangeType: self.timeRangeType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getTraceSummariesPaginated`
/// to access the nested member `[XRayClientTypes.TraceSummary]`
/// - Returns: `[XRayClientTypes.TraceSummary]`
extension PaginatorSequence where Input == GetTraceSummariesInput, Output == GetTraceSummariesOutputResponse {
    public func traceSummaries() async throws -> [XRayClientTypes.TraceSummary] {
        return try await self.asyncCompactMap { item in item.traceSummaries }
    }
}
