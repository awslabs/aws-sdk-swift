// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AssociateRepositoryInputBodyMiddleware: Middleware {
    public let id: String = "AssociateRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateRepositoryInput>
    public typealias MOutput = OperationOutput<AssociateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateRepositoryOutputError>
}

extension AssociateRepositoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateRepositoryInput(clientRequestToken: \(String(describing: clientRequestToken)), kMSKeyDetails: \(String(describing: kMSKeyDetails)), repository: \(String(describing: repository)), tags: \(String(describing: tags)))"}
}

extension AssociateRepositoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case kMSKeyDetails = "KMSKeyDetails"
        case repository = "Repository"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let kMSKeyDetails = kMSKeyDetails {
            try encodeContainer.encode(kMSKeyDetails, forKey: .kMSKeyDetails)
        }
        if let repository = repository {
            try encodeContainer.encode(repository, forKey: .repository)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct AssociateRepositoryInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateRepositoryInput>
    public typealias MOutput = OperationOutput<AssociateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateRepositoryOutputError>
}

public struct AssociateRepositoryInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateRepositoryInput>
    public typealias MOutput = OperationOutput<AssociateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateRepositoryOutputError>
}

public struct AssociateRepositoryInput: Equatable {
    /// <p>Amazon CodeGuru Reviewer uses this value to prevent the accidental creation of duplicate repository
    ///         associations if there are failures and retries. </p>
    public var clientRequestToken: String?
    /// <p>A <code>KMSKeyDetails</code> object that contains:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The encryption option for this repository association. It is either owned by AWS
    ///             Key Management Service (KMS) (<code>AWS_OWNED_CMK</code>) or customer managed (<code>CUSTOMER_MANAGED_CMK</code>).</p>
    ///             </li>
    ///             <li>
    ///                <p>The ID of the AWS KMS key that
    ///             is associated with this respository association.</p>
    ///             </li>
    ///          </ul>
    public let kMSKeyDetails: KMSKeyDetails?
    /// <p>The repository to associate.</p>
    public let repository: Repository?
    /// <p>
    /// 			An array of key-value pairs used to tag an associated repository. A tag is a custom attribute label with two parts:
    /// 		</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>A <i>tag key</i> (for example, <code>CostCenter</code>,
    /// 					<code>Environment</code>, <code>Project</code>, or <code>Secret</code>). Tag
    /// 					keys are case sensitive.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>An optional field known as a <i>tag value</i> (for example,
    /// 					<code>111122223333</code>, <code>Production</code>, or a team name).
    /// 					Omitting the tag value is the same as using an empty string. Like tag keys, tag
    /// 					values are case sensitive.</p>
    /// 			         </li>
    ///          </ul>
    public let tags: [String:String]?

    public init (
        clientRequestToken: String? = nil,
        kMSKeyDetails: KMSKeyDetails? = nil,
        repository: Repository? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.kMSKeyDetails = kMSKeyDetails
        self.repository = repository
        self.tags = tags
    }
}

struct AssociateRepositoryInputBody: Equatable {
    public let repository: Repository?
    public let clientRequestToken: String?
    public let tags: [String:String]?
    public let kMSKeyDetails: KMSKeyDetails?
}

extension AssociateRepositoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case kMSKeyDetails = "KMSKeyDetails"
        case repository = "Repository"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(Repository.self, forKey: .repository)
        repository = repositoryDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let kMSKeyDetailsDecoded = try containerValues.decodeIfPresent(KMSKeyDetails.self, forKey: .kMSKeyDetails)
        kMSKeyDetails = kMSKeyDetailsDecoded
    }
}

extension AssociateRepositoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateRepositoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateRepositoryOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateRepositoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateRepositoryOutputResponse(repositoryAssociation: \(String(describing: repositoryAssociation)), tags: \(String(describing: tags)))"}
}

extension AssociateRepositoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repositoryAssociation = output.repositoryAssociation
            self.tags = output.tags
        } else {
            self.repositoryAssociation = nil
            self.tags = nil
        }
    }
}

public struct AssociateRepositoryOutputResponse: Equatable {
    /// <p>Information about the repository association.</p>
    public let repositoryAssociation: RepositoryAssociation?
    /// <p>
    /// 			An array of key-value pairs used to tag an associated repository. A tag is a custom attribute label with two parts:
    /// 		</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>A <i>tag key</i> (for example, <code>CostCenter</code>,
    /// 					<code>Environment</code>, <code>Project</code>, or <code>Secret</code>). Tag
    /// 					keys are case sensitive.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>An optional field known as a <i>tag value</i> (for example,
    /// 					<code>111122223333</code>, <code>Production</code>, or a team name).
    /// 					Omitting the tag value is the same as using an empty string. Like tag keys, tag
    /// 					values are case sensitive.</p>
    /// 			         </li>
    ///          </ul>
    public let tags: [String:String]?

    public init (
        repositoryAssociation: RepositoryAssociation? = nil,
        tags: [String:String]? = nil
    )
    {
        self.repositoryAssociation = repositoryAssociation
        self.tags = tags
    }
}

struct AssociateRepositoryOutputResponseBody: Equatable {
    public let repositoryAssociation: RepositoryAssociation?
    public let tags: [String:String]?
}

extension AssociateRepositoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repositoryAssociation = "RepositoryAssociation"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryAssociationDecoded = try containerValues.decodeIfPresent(RepositoryAssociation.self, forKey: .repositoryAssociation)
        repositoryAssociation = repositoryAssociationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CodeCommitRepository: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CodeCommitRepository: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeCommitRepository(name: \(String(describing: name)))"}
}

/// <p>Information about an AWS CodeCommit repository. The CodeCommit repository must be in the same
///       AWS Region and AWS account where its CodeGuru Reviewer code reviews are configured. </p>
public struct CodeCommitRepository: Equatable {
    /// <p>The name of the AWS CodeCommit repository. For more information, see
    ///          <a href="https://docs.aws.amazon.com/codecommit/latest/APIReference/API_GetRepository.html#CodeCommit-GetRepository-request-repositoryName">repositoryName</a>
    ///          in the <i>AWS CodeCommit API Reference</i>.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension CodeReview: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationArn = "AssociationArn"
        case codeReviewArn = "CodeReviewArn"
        case createdTimeStamp = "CreatedTimeStamp"
        case lastUpdatedTimeStamp = "LastUpdatedTimeStamp"
        case metrics = "Metrics"
        case name = "Name"
        case owner = "Owner"
        case providerType = "ProviderType"
        case pullRequestId = "PullRequestId"
        case repositoryName = "RepositoryName"
        case sourceCodeType = "SourceCodeType"
        case state = "State"
        case stateReason = "StateReason"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationArn = associationArn {
            try encodeContainer.encode(associationArn, forKey: .associationArn)
        }
        if let codeReviewArn = codeReviewArn {
            try encodeContainer.encode(codeReviewArn, forKey: .codeReviewArn)
        }
        if let createdTimeStamp = createdTimeStamp {
            try encodeContainer.encode(createdTimeStamp.timeIntervalSince1970, forKey: .createdTimeStamp)
        }
        if let lastUpdatedTimeStamp = lastUpdatedTimeStamp {
            try encodeContainer.encode(lastUpdatedTimeStamp.timeIntervalSince1970, forKey: .lastUpdatedTimeStamp)
        }
        if let metrics = metrics {
            try encodeContainer.encode(metrics, forKey: .metrics)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCodeType = sourceCodeType {
            try encodeContainer.encode(sourceCodeType, forKey: .sourceCodeType)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let codeReviewArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .codeReviewArn)
        codeReviewArn = codeReviewArnDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(JobState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let createdTimeStampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimeStamp)
        createdTimeStamp = createdTimeStampDecoded
        let lastUpdatedTimeStampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTimeStamp)
        lastUpdatedTimeStamp = lastUpdatedTimeStampDecoded
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let sourceCodeTypeDecoded = try containerValues.decodeIfPresent(SourceCodeType.self, forKey: .sourceCodeType)
        sourceCodeType = sourceCodeTypeDecoded
        let associationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationArn)
        associationArn = associationArnDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(Metrics.self, forKey: .metrics)
        metrics = metricsDecoded
    }
}

extension CodeReview: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeReview(associationArn: \(String(describing: associationArn)), codeReviewArn: \(String(describing: codeReviewArn)), createdTimeStamp: \(String(describing: createdTimeStamp)), lastUpdatedTimeStamp: \(String(describing: lastUpdatedTimeStamp)), metrics: \(String(describing: metrics)), name: \(String(describing: name)), owner: \(String(describing: owner)), providerType: \(String(describing: providerType)), pullRequestId: \(String(describing: pullRequestId)), repositoryName: \(String(describing: repositoryName)), sourceCodeType: \(String(describing: sourceCodeType)), state: \(String(describing: state)), stateReason: \(String(describing: stateReason)), type: \(String(describing: type)))"}
}

/// <p>
///          Information about a code review. A code review belongs to the associated repository that contains the reviewed code.
///       </p>
public struct CodeReview: Equatable {
    /// <p>
    /// 			The Amazon Resource Name (ARN) of the
    /// 			<a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_RepositoryAssociation.html">
    ///                <code>RepositoryAssociation</code>
    ///             </a> that contains
    /// 			the reviewed source code. You can retrieve associated repository ARNs by calling
    /// 			<a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_ListRepositoryAssociations.html">
    ///                <code>ListRepositoryAssociations</code>
    ///             </a>.
    /// 		</p>
    public let associationArn: String?
    /// <p>The Amazon Resource Name (ARN) of the <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CodeReview.html">
    ///                <code>CodeReview</code>
    ///             </a> object.
    ///       </p>
    public let codeReviewArn: String?
    /// <p>
    ///          The time, in milliseconds since the epoch, when the code review was created.
    ///       </p>
    public let createdTimeStamp: Date?
    /// <p>
    ///          The time, in milliseconds since the epoch, when the code review was last updated.
    ///       </p>
    public let lastUpdatedTimeStamp: Date?
    /// <p>
    ///          The statistics from the code review.
    ///       </p>
    public let metrics: Metrics?
    /// <p>
    ///          The name of the code review.
    ///       </p>
    public let name: String?
    /// <p>The owner of the repository. For an AWS CodeCommit repository, this is the AWS account ID of the
    ///       account that owns the repository. For a GitHub, GitHub Enterprise Server, or Bitbucket repository, this is the username for the account that owns the repository.</p>
    public let owner: String?
    /// <p>
    ///          The type of repository that contains the reviewed code (for example, GitHub or Bitbucket).
    ///       </p>
    public let providerType: ProviderType?
    /// <p>
    ///          The pull request ID for the code review.
    ///       </p>
    public let pullRequestId: String?
    /// <p>
    ///          The name of the repository.
    ///       </p>
    public let repositoryName: String?
    /// <p>
    ///          The type of the source code for the code review.
    ///       </p>
    public let sourceCodeType: SourceCodeType?
    /// <p>The valid code review states are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Completed</code>: The code review is complete.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Pending</code>: The code review started and has not completed or failed.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Failed</code>: The code review failed.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Deleting</code>: The code review is being deleted.
    ///             </p>
    ///             </li>
    ///          </ul>
    public let state: JobState?
    /// <p>
    ///          The reason for the state of the code review.
    ///       </p>
    public let stateReason: String?
    /// <p>
    ///          The type of code review.
    ///       </p>
    public let type: `Type`?

    public init (
        associationArn: String? = nil,
        codeReviewArn: String? = nil,
        createdTimeStamp: Date? = nil,
        lastUpdatedTimeStamp: Date? = nil,
        metrics: Metrics? = nil,
        name: String? = nil,
        owner: String? = nil,
        providerType: ProviderType? = nil,
        pullRequestId: String? = nil,
        repositoryName: String? = nil,
        sourceCodeType: SourceCodeType? = nil,
        state: JobState? = nil,
        stateReason: String? = nil,
        type: `Type`? = nil
    )
    {
        self.associationArn = associationArn
        self.codeReviewArn = codeReviewArn
        self.createdTimeStamp = createdTimeStamp
        self.lastUpdatedTimeStamp = lastUpdatedTimeStamp
        self.metrics = metrics
        self.name = name
        self.owner = owner
        self.providerType = providerType
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
        self.sourceCodeType = sourceCodeType
        self.state = state
        self.stateReason = stateReason
        self.type = type
    }
}

extension CodeReviewSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case codeReviewArn = "CodeReviewArn"
        case createdTimeStamp = "CreatedTimeStamp"
        case lastUpdatedTimeStamp = "LastUpdatedTimeStamp"
        case metricsSummary = "MetricsSummary"
        case name = "Name"
        case owner = "Owner"
        case providerType = "ProviderType"
        case pullRequestId = "PullRequestId"
        case repositoryName = "RepositoryName"
        case state = "State"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeReviewArn = codeReviewArn {
            try encodeContainer.encode(codeReviewArn, forKey: .codeReviewArn)
        }
        if let createdTimeStamp = createdTimeStamp {
            try encodeContainer.encode(createdTimeStamp.timeIntervalSince1970, forKey: .createdTimeStamp)
        }
        if let lastUpdatedTimeStamp = lastUpdatedTimeStamp {
            try encodeContainer.encode(lastUpdatedTimeStamp.timeIntervalSince1970, forKey: .lastUpdatedTimeStamp)
        }
        if let metricsSummary = metricsSummary {
            try encodeContainer.encode(metricsSummary, forKey: .metricsSummary)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let codeReviewArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .codeReviewArn)
        codeReviewArn = codeReviewArnDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(JobState.self, forKey: .state)
        state = stateDecoded
        let createdTimeStampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimeStamp)
        createdTimeStamp = createdTimeStampDecoded
        let lastUpdatedTimeStampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTimeStamp)
        lastUpdatedTimeStamp = lastUpdatedTimeStampDecoded
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let metricsSummaryDecoded = try containerValues.decodeIfPresent(MetricsSummary.self, forKey: .metricsSummary)
        metricsSummary = metricsSummaryDecoded
    }
}

extension CodeReviewSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeReviewSummary(codeReviewArn: \(String(describing: codeReviewArn)), createdTimeStamp: \(String(describing: createdTimeStamp)), lastUpdatedTimeStamp: \(String(describing: lastUpdatedTimeStamp)), metricsSummary: \(String(describing: metricsSummary)), name: \(String(describing: name)), owner: \(String(describing: owner)), providerType: \(String(describing: providerType)), pullRequestId: \(String(describing: pullRequestId)), repositoryName: \(String(describing: repositoryName)), state: \(String(describing: state)), type: \(String(describing: type)))"}
}

/// <p>
///          Information about the summary of the code review.
///       </p>
public struct CodeReviewSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CodeReview.html">
    ///                <code>CodeReview</code>
    ///             </a> object.
    ///       </p>
    public let codeReviewArn: String?
    /// <p>
    ///          The time, in milliseconds since the epoch, when the code review was created.
    ///       </p>
    public let createdTimeStamp: Date?
    /// <p>
    ///          The time, in milliseconds since the epoch, when the code review was last updated.
    ///       </p>
    public let lastUpdatedTimeStamp: Date?
    /// <p>
    ///          The statistics from the code review.
    ///       </p>
    public let metricsSummary: MetricsSummary?
    /// <p>
    ///          The name of the code review.
    ///       </p>
    public let name: String?
    /// <p>The owner of the repository. For an AWS CodeCommit repository, this is the AWS account ID of the
    ///       account that owns the repository. For a GitHub, GitHub Enterprise Server, or Bitbucket repository, this is the username for the account that owns the repository.</p>
    public let owner: String?
    /// <p>
    ///          The provider type of the repository association.
    ///       </p>
    public let providerType: ProviderType?
    /// <p>
    ///          The pull request ID for the code review.
    ///       </p>
    public let pullRequestId: String?
    /// <p>
    ///          The name of the repository.
    ///       </p>
    public let repositoryName: String?
    /// <p>
    ///          The state of the code review.
    ///       </p>
    ///          <p>The valid code review states are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Completed</code>: The code review is complete.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Pending</code>: The code review started and has not completed or failed.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Failed</code>: The code review failed.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Deleting</code>: The code review is being deleted.
    ///             </p>
    ///             </li>
    ///          </ul>
    public let state: JobState?
    /// <p>
    ///          The type of the code review.
    ///       </p>
    public let type: `Type`?

    public init (
        codeReviewArn: String? = nil,
        createdTimeStamp: Date? = nil,
        lastUpdatedTimeStamp: Date? = nil,
        metricsSummary: MetricsSummary? = nil,
        name: String? = nil,
        owner: String? = nil,
        providerType: ProviderType? = nil,
        pullRequestId: String? = nil,
        repositoryName: String? = nil,
        state: JobState? = nil,
        type: `Type`? = nil
    )
    {
        self.codeReviewArn = codeReviewArn
        self.createdTimeStamp = createdTimeStamp
        self.lastUpdatedTimeStamp = lastUpdatedTimeStamp
        self.metricsSummary = metricsSummary
        self.name = name
        self.owner = owner
        self.providerType = providerType
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
        self.state = state
        self.type = type
    }
}

extension CodeReviewType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case repositoryAnalysis = "RepositoryAnalysis"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryAnalysis = repositoryAnalysis {
            try encodeContainer.encode(repositoryAnalysis, forKey: .repositoryAnalysis)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryAnalysisDecoded = try containerValues.decodeIfPresent(RepositoryAnalysis.self, forKey: .repositoryAnalysis)
        repositoryAnalysis = repositoryAnalysisDecoded
    }
}

extension CodeReviewType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeReviewType(repositoryAnalysis: \(String(describing: repositoryAnalysis)))"}
}

/// <p>
///          The type of a code review. There are two code review types:
///       </p>
///          <ul>
///             <li>
///                <p>
///                   <code>PullRequest</code> - A code review that is automatically triggered by a pull request on an associated repository. Because this
///                type of code review is automatically generated, you cannot specify this code review type using <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CreateCodeReview">
///                      <code>CreateCodeReview</code>
///                   </a>.
///             </p>
///             </li>
///             <li>
///                <p>
/// 					             <code>RepositoryAnalysis</code> - A code review that analyzes all code under a specified
/// 					branch in an associated repository. The associated repository is specified using its ARN
/// 					in <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CreateCodeReview">
///                      <code>CreateCodeReview</code>
///                   </a>. </p>
///             </li>
///          </ul>
public struct CodeReviewType: Equatable {
    /// <p> A code review that analyzes all code under a specified branch in an associated
    /// 			repository. The associated repository is specified using its ARN in <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CreateCodeReview">
    ///                <code>CreateCodeReview</code>
    ///             </a>. </p>
    public let repositoryAnalysis: RepositoryAnalysis?

    public init (
        repositoryAnalysis: RepositoryAnalysis? = nil
    )
    {
        self.repositoryAnalysis = repositoryAnalysis
    }
}

extension CommitDiffSourceCodeType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationCommit = "DestinationCommit"
        case sourceCommit = "SourceCommit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationCommit = destinationCommit {
            try encodeContainer.encode(destinationCommit, forKey: .destinationCommit)
        }
        if let sourceCommit = sourceCommit {
            try encodeContainer.encode(sourceCommit, forKey: .sourceCommit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceCommitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCommit)
        sourceCommit = sourceCommitDecoded
        let destinationCommitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationCommit)
        destinationCommit = destinationCommitDecoded
    }
}

extension CommitDiffSourceCodeType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommitDiffSourceCodeType(destinationCommit: \(String(describing: destinationCommit)), sourceCommit: \(String(describing: sourceCommit)))"}
}

/// <p>
///          A type of <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_SourceCodeType">
///                <code>SourceCodeType</code>
///             </a> that
///          specifies the commit diff for a pull request on an associated repository.
///       </p>
public struct CommitDiffSourceCodeType: Equatable {
    /// <p>
    ///          The SHA of the destination commit used to generate a commit diff.
    ///       </p>
    public let destinationCommit: String?
    /// <p>
    ///          The SHA of the source commit used to generate a commit diff.
    ///       </p>
    public let sourceCommit: String?

    public init (
        destinationCommit: String? = nil,
        sourceCommit: String? = nil
    )
    {
        self.destinationCommit = destinationCommit
        self.sourceCommit = sourceCommit
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested operation would cause a conflict with the current state of a service
///          resource associated with the request. Resolve the conflict before retrying this request. </p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateCodeReviewInputBodyMiddleware: Middleware {
    public let id: String = "CreateCodeReviewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCodeReviewInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCodeReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCodeReviewInput>
    public typealias MOutput = OperationOutput<CreateCodeReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCodeReviewOutputError>
}

extension CreateCodeReviewInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCodeReviewInput(clientRequestToken: \(String(describing: clientRequestToken)), name: \(String(describing: name)), repositoryAssociationArn: \(String(describing: repositoryAssociationArn)), type: \(String(describing: type)))"}
}

extension CreateCodeReviewInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case repositoryAssociationArn = "RepositoryAssociationArn"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let repositoryAssociationArn = repositoryAssociationArn {
            try encodeContainer.encode(repositoryAssociationArn, forKey: .repositoryAssociationArn)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

public struct CreateCodeReviewInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCodeReviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCodeReviewInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCodeReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCodeReviewInput>
    public typealias MOutput = OperationOutput<CreateCodeReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCodeReviewOutputError>
}

public struct CreateCodeReviewInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCodeReviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCodeReviewInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCodeReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCodeReviewInput>
    public typealias MOutput = OperationOutput<CreateCodeReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCodeReviewOutputError>
}

public struct CreateCodeReviewInput: Equatable {
    /// <p>
    ///          Amazon CodeGuru Reviewer uses this value to prevent the accidental creation of duplicate code
    ///          reviews if there are failures and retries.
    ///       </p>
    public var clientRequestToken: String?
    /// <p>
    ///          The name of the code review. The name of each code review in your AWS account must be unique.
    ///       </p>
    public let name: String?
    /// <p>
    ///          The Amazon Resource Name (ARN) of the
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_RepositoryAssociation.html">
    ///                <code>RepositoryAssociation</code>
    ///             </a> object.
    ///          You can retrieve this ARN by calling
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_ListRepositoryAssociations.html">
    ///                <code>ListRepositoryAssociations</code>
    ///             </a>.
    ///       </p>
    ///          <p>
    ///          A code review can only be created on an associated repository. This is the ARN of the
    ///          associated repository.
    ///       </p>
    public let repositoryAssociationArn: String?
    /// <p>
    ///          The type of code review to create. This is specified using a
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CodeReviewType.html">
    ///                <code>CodeReviewType</code>
    ///             </a>
    ///          object. You can create a code review only of type <code>RepositoryAnalysis</code>.
    ///       </p>
    public let type: CodeReviewType?

    public init (
        clientRequestToken: String? = nil,
        name: String? = nil,
        repositoryAssociationArn: String? = nil,
        type: CodeReviewType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.repositoryAssociationArn = repositoryAssociationArn
        self.type = type
    }
}

struct CreateCodeReviewInputBody: Equatable {
    public let name: String?
    public let repositoryAssociationArn: String?
    public let type: CodeReviewType?
    public let clientRequestToken: String?
}

extension CreateCodeReviewInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case repositoryAssociationArn = "RepositoryAssociationArn"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let repositoryAssociationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryAssociationArn)
        repositoryAssociationArn = repositoryAssociationArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CodeReviewType.self, forKey: .type)
        type = typeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateCodeReviewOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCodeReviewOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCodeReviewOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCodeReviewOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCodeReviewOutputResponse(codeReview: \(String(describing: codeReview)))"}
}

extension CreateCodeReviewOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCodeReviewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.codeReview = output.codeReview
        } else {
            self.codeReview = nil
        }
    }
}

public struct CreateCodeReviewOutputResponse: Equatable {
    /// <p>
    ///          Information about a code review. A code review belongs to the associated repository that contains the reviewed code.
    ///       </p>
    public let codeReview: CodeReview?

    public init (
        codeReview: CodeReview? = nil
    )
    {
        self.codeReview = codeReview
    }
}

struct CreateCodeReviewOutputResponseBody: Equatable {
    public let codeReview: CodeReview?
}

extension CreateCodeReviewOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeReview = "CodeReview"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeReviewDecoded = try containerValues.decodeIfPresent(CodeReview.self, forKey: .codeReview)
        codeReview = codeReviewDecoded
    }
}

extension DescribeCodeReviewInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCodeReviewInput(codeReviewArn: \(String(describing: codeReviewArn)))"}
}

extension DescribeCodeReviewInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeCodeReviewInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCodeReviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCodeReviewInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCodeReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCodeReviewInput>
    public typealias MOutput = OperationOutput<DescribeCodeReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCodeReviewOutputError>
}

public struct DescribeCodeReviewInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCodeReviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCodeReviewInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCodeReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCodeReviewInput>
    public typealias MOutput = OperationOutput<DescribeCodeReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCodeReviewOutputError>
}

public struct DescribeCodeReviewInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CodeReview.html">
    ///                <code>CodeReview</code>
    ///             </a> object.
    ///       </p>
    public let codeReviewArn: String?

    public init (
        codeReviewArn: String? = nil
    )
    {
        self.codeReviewArn = codeReviewArn
    }
}

struct DescribeCodeReviewInputBody: Equatable {
}

extension DescribeCodeReviewInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeCodeReviewOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCodeReviewOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCodeReviewOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCodeReviewOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCodeReviewOutputResponse(codeReview: \(String(describing: codeReview)))"}
}

extension DescribeCodeReviewOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCodeReviewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.codeReview = output.codeReview
        } else {
            self.codeReview = nil
        }
    }
}

public struct DescribeCodeReviewOutputResponse: Equatable {
    /// <p>
    ///          Information about the code review.
    ///       </p>
    public let codeReview: CodeReview?

    public init (
        codeReview: CodeReview? = nil
    )
    {
        self.codeReview = codeReview
    }
}

struct DescribeCodeReviewOutputResponseBody: Equatable {
    public let codeReview: CodeReview?
}

extension DescribeCodeReviewOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeReview = "CodeReview"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeReviewDecoded = try containerValues.decodeIfPresent(CodeReview.self, forKey: .codeReview)
        codeReview = codeReviewDecoded
    }
}

extension DescribeRecommendationFeedbackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRecommendationFeedbackInput(codeReviewArn: \(String(describing: codeReviewArn)), recommendationId: \(String(describing: recommendationId)), userId: \(String(describing: userId)))"}
}

extension DescribeRecommendationFeedbackInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeRecommendationFeedbackInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRecommendationFeedbackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRecommendationFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRecommendationFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRecommendationFeedbackInput>
    public typealias MOutput = OperationOutput<DescribeRecommendationFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRecommendationFeedbackOutputError>
}

public struct DescribeRecommendationFeedbackInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRecommendationFeedbackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRecommendationFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRecommendationFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let userId = input.operationInput.userId {
            let userIdQueryItem = URLQueryItem(name: "UserId".urlPercentEncoding(), value: String(userId).urlPercentEncoding())
            input.builder.withQueryItem(userIdQueryItem)
        }
        if let recommendationId = input.operationInput.recommendationId {
            let recommendationIdQueryItem = URLQueryItem(name: "RecommendationId".urlPercentEncoding(), value: String(recommendationId).urlPercentEncoding())
            input.builder.withQueryItem(recommendationIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRecommendationFeedbackInput>
    public typealias MOutput = OperationOutput<DescribeRecommendationFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRecommendationFeedbackOutputError>
}

public struct DescribeRecommendationFeedbackInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CodeReview.html">
    ///                <code>CodeReview</code>
    ///             </a> object.
    ///       </p>
    public let codeReviewArn: String?
    /// <p>
    ///          The recommendation ID that can be used to track the provided recommendations and then to collect the feedback.
    ///       </p>
    public let recommendationId: String?
    /// <p>
    ///          Optional parameter to describe the feedback for a given user. If this is not supplied, it defaults to the user making the request.
    ///       </p>
    ///          <p>
    ///          The <code>UserId</code> is an IAM principal that can be specified as an AWS account ID or an Amazon Resource Name (ARN). For
    ///          more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html#Principal_specifying">
    ///             Specifying a Principal</a> in the <i>AWS Identity and Access Management User Guide</i>.
    ///       </p>
    public let userId: String?

    public init (
        codeReviewArn: String? = nil,
        recommendationId: String? = nil,
        userId: String? = nil
    )
    {
        self.codeReviewArn = codeReviewArn
        self.recommendationId = recommendationId
        self.userId = userId
    }
}

struct DescribeRecommendationFeedbackInputBody: Equatable {
}

extension DescribeRecommendationFeedbackInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeRecommendationFeedbackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRecommendationFeedbackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRecommendationFeedbackOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRecommendationFeedbackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRecommendationFeedbackOutputResponse(recommendationFeedback: \(String(describing: recommendationFeedback)))"}
}

extension DescribeRecommendationFeedbackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRecommendationFeedbackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recommendationFeedback = output.recommendationFeedback
        } else {
            self.recommendationFeedback = nil
        }
    }
}

public struct DescribeRecommendationFeedbackOutputResponse: Equatable {
    /// <p>
    ///          The recommendation feedback given by the user.
    ///       </p>
    public let recommendationFeedback: RecommendationFeedback?

    public init (
        recommendationFeedback: RecommendationFeedback? = nil
    )
    {
        self.recommendationFeedback = recommendationFeedback
    }
}

struct DescribeRecommendationFeedbackOutputResponseBody: Equatable {
    public let recommendationFeedback: RecommendationFeedback?
}

extension DescribeRecommendationFeedbackOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case recommendationFeedback = "RecommendationFeedback"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationFeedbackDecoded = try containerValues.decodeIfPresent(RecommendationFeedback.self, forKey: .recommendationFeedback)
        recommendationFeedback = recommendationFeedbackDecoded
    }
}

extension DescribeRepositoryAssociationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRepositoryAssociationInput(associationArn: \(String(describing: associationArn)))"}
}

extension DescribeRepositoryAssociationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeRepositoryAssociationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRepositoryAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRepositoryAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRepositoryAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRepositoryAssociationInput>
    public typealias MOutput = OperationOutput<DescribeRepositoryAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRepositoryAssociationOutputError>
}

public struct DescribeRepositoryAssociationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRepositoryAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRepositoryAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRepositoryAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRepositoryAssociationInput>
    public typealias MOutput = OperationOutput<DescribeRepositoryAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRepositoryAssociationOutputError>
}

public struct DescribeRepositoryAssociationInput: Equatable {
    /// <p>
    ///          The Amazon Resource Name (ARN) of the
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_RepositoryAssociation.html">
    ///                <code>RepositoryAssociation</code>
    ///             </a> object.
    ///          You can retrieve this ARN by calling
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_ListRepositoryAssociations.html">
    ///                <code>ListRepositoryAssociations</code>
    ///             </a>.
    ///       </p>
    public let associationArn: String?

    public init (
        associationArn: String? = nil
    )
    {
        self.associationArn = associationArn
    }
}

struct DescribeRepositoryAssociationInputBody: Equatable {
}

extension DescribeRepositoryAssociationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeRepositoryAssociationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRepositoryAssociationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRepositoryAssociationOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRepositoryAssociationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRepositoryAssociationOutputResponse(repositoryAssociation: \(String(describing: repositoryAssociation)), tags: \(String(describing: tags)))"}
}

extension DescribeRepositoryAssociationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRepositoryAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repositoryAssociation = output.repositoryAssociation
            self.tags = output.tags
        } else {
            self.repositoryAssociation = nil
            self.tags = nil
        }
    }
}

public struct DescribeRepositoryAssociationOutputResponse: Equatable {
    /// <p>Information about the repository association.</p>
    public let repositoryAssociation: RepositoryAssociation?
    /// <p>
    /// 			An array of key-value pairs used to tag an associated repository. A tag is a custom attribute label with two parts:
    /// 		</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>A <i>tag key</i> (for example, <code>CostCenter</code>,
    /// 					<code>Environment</code>, <code>Project</code>, or <code>Secret</code>). Tag
    /// 					keys are case sensitive.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>An optional field known as a <i>tag value</i> (for example,
    /// 					<code>111122223333</code>, <code>Production</code>, or a team name).
    /// 					Omitting the tag value is the same as using an empty string. Like tag keys, tag
    /// 					values are case sensitive.</p>
    /// 			         </li>
    ///          </ul>
    public let tags: [String:String]?

    public init (
        repositoryAssociation: RepositoryAssociation? = nil,
        tags: [String:String]? = nil
    )
    {
        self.repositoryAssociation = repositoryAssociation
        self.tags = tags
    }
}

struct DescribeRepositoryAssociationOutputResponseBody: Equatable {
    public let repositoryAssociation: RepositoryAssociation?
    public let tags: [String:String]?
}

extension DescribeRepositoryAssociationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repositoryAssociation = "RepositoryAssociation"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryAssociationDecoded = try containerValues.decodeIfPresent(RepositoryAssociation.self, forKey: .repositoryAssociation)
        repositoryAssociation = repositoryAssociationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DisassociateRepositoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateRepositoryInput(associationArn: \(String(describing: associationArn)))"}
}

extension DisassociateRepositoryInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateRepositoryInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateRepositoryInput>
    public typealias MOutput = OperationOutput<DisassociateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateRepositoryOutputError>
}

public struct DisassociateRepositoryInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateRepositoryInput>
    public typealias MOutput = OperationOutput<DisassociateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateRepositoryOutputError>
}

public struct DisassociateRepositoryInput: Equatable {
    /// <p>
    ///          The Amazon Resource Name (ARN) of the
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_RepositoryAssociation.html">
    ///                <code>RepositoryAssociation</code>
    ///             </a> object.
    ///          You can retrieve this ARN by calling
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_ListRepositoryAssociations.html">
    ///                <code>ListRepositoryAssociations</code>
    ///             </a>.
    ///       </p>
    public let associationArn: String?

    public init (
        associationArn: String? = nil
    )
    {
        self.associationArn = associationArn
    }
}

struct DisassociateRepositoryInputBody: Equatable {
}

extension DisassociateRepositoryInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateRepositoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateRepositoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateRepositoryOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateRepositoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateRepositoryOutputResponse(repositoryAssociation: \(String(describing: repositoryAssociation)), tags: \(String(describing: tags)))"}
}

extension DisassociateRepositoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repositoryAssociation = output.repositoryAssociation
            self.tags = output.tags
        } else {
            self.repositoryAssociation = nil
            self.tags = nil
        }
    }
}

public struct DisassociateRepositoryOutputResponse: Equatable {
    /// <p>Information about the disassociated repository.</p>
    public let repositoryAssociation: RepositoryAssociation?
    /// <p>
    /// 			An array of key-value pairs used to tag an associated repository. A tag is a custom attribute label with two parts:
    /// 		</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>A <i>tag key</i> (for example, <code>CostCenter</code>,
    /// 					<code>Environment</code>, <code>Project</code>, or <code>Secret</code>). Tag
    /// 					keys are case sensitive.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>An optional field known as a <i>tag value</i> (for example,
    /// 					<code>111122223333</code>, <code>Production</code>, or a team name).
    /// 					Omitting the tag value is the same as using an empty string. Like tag keys, tag
    /// 					values are case sensitive.</p>
    /// 			         </li>
    ///          </ul>
    public let tags: [String:String]?

    public init (
        repositoryAssociation: RepositoryAssociation? = nil,
        tags: [String:String]? = nil
    )
    {
        self.repositoryAssociation = repositoryAssociation
        self.tags = tags
    }
}

struct DisassociateRepositoryOutputResponseBody: Equatable {
    public let repositoryAssociation: RepositoryAssociation?
    public let tags: [String:String]?
}

extension DisassociateRepositoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repositoryAssociation = "RepositoryAssociation"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryAssociationDecoded = try containerValues.decodeIfPresent(RepositoryAssociation.self, forKey: .repositoryAssociation)
        repositoryAssociation = repositoryAssociationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum EncryptionOption {
    case aocmk
    case cmcmk
    case sdkUnknown(String)
}

extension EncryptionOption : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncryptionOption] {
        return [
            .aocmk,
            .cmcmk,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aocmk: return "AWS_OWNED_CMK"
        case .cmcmk: return "CUSTOMER_MANAGED_CMK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncryptionOption(rawValue: rawValue) ?? EncryptionOption.sdkUnknown(rawValue)
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The server encountered an internal error and is unable to complete the request.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum JobState {
    case completed
    case deleting
    case failed
    case pending
    case sdkUnknown(String)
}

extension JobState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobState] {
        return [
            .completed,
            .deleting,
            .failed,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "Completed"
        case .deleting: return "Deleting"
        case .failed: return "Failed"
        case .pending: return "Pending"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobState(rawValue: rawValue) ?? JobState.sdkUnknown(rawValue)
    }
}

extension KMSKeyDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionOption = "EncryptionOption"
        case kMSKeyId = "KMSKeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionOption = encryptionOption {
            try encodeContainer.encode(encryptionOption.rawValue, forKey: .encryptionOption)
        }
        if let kMSKeyId = kMSKeyId {
            try encodeContainer.encode(kMSKeyId, forKey: .kMSKeyId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kMSKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKeyId)
        kMSKeyId = kMSKeyIdDecoded
        let encryptionOptionDecoded = try containerValues.decodeIfPresent(EncryptionOption.self, forKey: .encryptionOption)
        encryptionOption = encryptionOptionDecoded
    }
}

extension KMSKeyDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSKeyDetails(encryptionOption: \(String(describing: encryptionOption)), kMSKeyId: \(String(describing: kMSKeyId)))"}
}

/// <p>An object that contains:</p>
///          <ul>
///             <li>
///                <p>The encryption option for a repository association. It is either owned by AWS
///             Key Management Service (KMS) (<code>AWS_OWNED_CMK</code>) or customer managed (<code>CUSTOMER_MANAGED_CMK</code>).</p>
///             </li>
///             <li>
///                <p>The ID of the AWS KMS key that
///             is associated with a respository association.</p>
///             </li>
///          </ul>
public struct KMSKeyDetails: Equatable {
    /// <p>The encryption option for a repository association. It is either owned by AWS
    ///             Key Management Service (KMS) (<code>AWS_OWNED_CMK</code>) or customer managed (<code>CUSTOMER_MANAGED_CMK</code>).</p>
    public let encryptionOption: EncryptionOption?
    /// <p>The ID of the AWS KMS key that is associated with a respository association.</p>
    public let kMSKeyId: String?

    public init (
        encryptionOption: EncryptionOption? = nil,
        kMSKeyId: String? = nil
    )
    {
        self.encryptionOption = encryptionOption
        self.kMSKeyId = kMSKeyId
    }
}

extension ListCodeReviewsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCodeReviewsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), providerTypes: \(String(describing: providerTypes)), repositoryNames: \(String(describing: repositoryNames)), states: \(String(describing: states)), type: \(String(describing: type)))"}
}

extension ListCodeReviewsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListCodeReviewsInputHeadersMiddleware: Middleware {
    public let id: String = "ListCodeReviewsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCodeReviewsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCodeReviewsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCodeReviewsInput>
    public typealias MOutput = OperationOutput<ListCodeReviewsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCodeReviewsOutputError>
}

public struct ListCodeReviewsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCodeReviewsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCodeReviewsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCodeReviewsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let states = input.operationInput.states {
            states.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "States".urlPercentEncoding(), value: String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let repositoryNames = input.operationInput.repositoryNames {
            repositoryNames.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "RepositoryNames".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let type = input.operationInput.type {
            let typeQueryItem = URLQueryItem(name: "Type".urlPercentEncoding(), value: String(type.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let providerTypes = input.operationInput.providerTypes {
            providerTypes.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "ProviderTypes".urlPercentEncoding(), value: String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCodeReviewsInput>
    public typealias MOutput = OperationOutput<ListCodeReviewsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCodeReviewsOutputError>
}

public struct ListCodeReviewsInput: Equatable {
    /// <p>
    ///          The maximum number of results that are returned per call. The default is 100.
    ///       </p>
    public let maxResults: Int?
    /// <p>
    ///          If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page.
    ///          Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    ///       </p>
    public let nextToken: String?
    /// <p>
    ///          List of provider types for filtering that needs to be applied before displaying the result. For example, <code>providerTypes=[GitHub]</code>  lists code reviews from GitHub.
    ///       </p>
    public let providerTypes: [ProviderType]?
    /// <p>
    ///          List of repository names for filtering that needs to be applied before displaying the result.
    ///       </p>
    public let repositoryNames: [String]?
    /// <p>
    ///          List of states for filtering that needs to be applied before displaying the result. For example, <code>states=[Pending]</code> lists code reviews in the Pending state.
    ///       </p>
    ///          <p>The valid code review states are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Completed</code>: The code review is complete.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Pending</code>: The code review started and has not completed or failed.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Failed</code>: The code review failed.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Deleting</code>: The code review is being deleted.
    ///             </p>
    ///             </li>
    ///          </ul>
    public let states: [JobState]?
    /// <p>
    ///          The type of code reviews to list in the response.
    ///       </p>
    public let type: `Type`?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        providerTypes: [ProviderType]? = nil,
        repositoryNames: [String]? = nil,
        states: [JobState]? = nil,
        type: `Type`? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.providerTypes = providerTypes
        self.repositoryNames = repositoryNames
        self.states = states
        self.type = type
    }
}

struct ListCodeReviewsInputBody: Equatable {
}

extension ListCodeReviewsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListCodeReviewsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCodeReviewsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCodeReviewsOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCodeReviewsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCodeReviewsOutputResponse(codeReviewSummaries: \(String(describing: codeReviewSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCodeReviewsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCodeReviewsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.codeReviewSummaries = output.codeReviewSummaries
            self.nextToken = output.nextToken
        } else {
            self.codeReviewSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListCodeReviewsOutputResponse: Equatable {
    /// <p>
    ///          A list of code reviews that meet the criteria of the request.
    ///       </p>
    public let codeReviewSummaries: [CodeReviewSummary]?
    /// <p>
    ///          Pagination token.
    ///       </p>
    public let nextToken: String?

    public init (
        codeReviewSummaries: [CodeReviewSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.codeReviewSummaries = codeReviewSummaries
        self.nextToken = nextToken
    }
}

struct ListCodeReviewsOutputResponseBody: Equatable {
    public let codeReviewSummaries: [CodeReviewSummary]?
    public let nextToken: String?
}

extension ListCodeReviewsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeReviewSummaries = "CodeReviewSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeReviewSummariesContainer = try containerValues.decodeIfPresent([CodeReviewSummary?].self, forKey: .codeReviewSummaries)
        var codeReviewSummariesDecoded0:[CodeReviewSummary]? = nil
        if let codeReviewSummariesContainer = codeReviewSummariesContainer {
            codeReviewSummariesDecoded0 = [CodeReviewSummary]()
            for structure0 in codeReviewSummariesContainer {
                if let structure0 = structure0 {
                    codeReviewSummariesDecoded0?.append(structure0)
                }
            }
        }
        codeReviewSummaries = codeReviewSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecommendationFeedbackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecommendationFeedbackInput(codeReviewArn: \(String(describing: codeReviewArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), recommendationIds: \(String(describing: recommendationIds)), userIds: \(String(describing: userIds)))"}
}

extension ListRecommendationFeedbackInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListRecommendationFeedbackInputHeadersMiddleware: Middleware {
    public let id: String = "ListRecommendationFeedbackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecommendationFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecommendationFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecommendationFeedbackInput>
    public typealias MOutput = OperationOutput<ListRecommendationFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecommendationFeedbackOutputError>
}

public struct ListRecommendationFeedbackInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRecommendationFeedbackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecommendationFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecommendationFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let recommendationIds = input.operationInput.recommendationIds {
            recommendationIds.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "RecommendationIds".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let userIds = input.operationInput.userIds {
            userIds.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "UserIds".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecommendationFeedbackInput>
    public typealias MOutput = OperationOutput<ListRecommendationFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecommendationFeedbackOutputError>
}

public struct ListRecommendationFeedbackInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CodeReview.html">
    ///                <code>CodeReview</code>
    ///             </a> object.
    ///       </p>
    public let codeReviewArn: String?
    /// <p>
    ///          The maximum number of results that are returned per call. The default is 100.
    ///       </p>
    public let maxResults: Int?
    /// <p>
    ///          If <code>nextToken</code> is returned, there are more results available. The value of nextToken is a unique pagination token for each page.
    ///          Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    ///       </p>
    public let nextToken: String?
    /// <p>
    ///          Used to query the recommendation feedback for a given recommendation.
    ///       </p>
    public let recommendationIds: [String]?
    /// <p>
    ///          An AWS user's account ID or Amazon Resource Name (ARN). Use this ID to query the recommendation feedback for a code review from that user.
    ///       </p>
    ///          <p>
    ///          The <code>UserId</code> is an IAM principal that can be specified as an AWS account ID or an Amazon Resource Name (ARN). For
    ///          more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html#Principal_specifying">
    ///             Specifying a Principal</a> in the <i>AWS Identity and Access Management User Guide</i>.
    ///       </p>
    public let userIds: [String]?

    public init (
        codeReviewArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        recommendationIds: [String]? = nil,
        userIds: [String]? = nil
    )
    {
        self.codeReviewArn = codeReviewArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recommendationIds = recommendationIds
        self.userIds = userIds
    }
}

struct ListRecommendationFeedbackInputBody: Equatable {
}

extension ListRecommendationFeedbackInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListRecommendationFeedbackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecommendationFeedbackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecommendationFeedbackOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecommendationFeedbackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecommendationFeedbackOutputResponse(nextToken: \(String(describing: nextToken)), recommendationFeedbackSummaries: \(String(describing: recommendationFeedbackSummaries)))"}
}

extension ListRecommendationFeedbackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRecommendationFeedbackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recommendationFeedbackSummaries = output.recommendationFeedbackSummaries
        } else {
            self.nextToken = nil
            self.recommendationFeedbackSummaries = nil
        }
    }
}

public struct ListRecommendationFeedbackOutputResponse: Equatable {
    /// <p>
    ///          If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page.
    ///          Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    ///       </p>
    public let nextToken: String?
    /// <p> Recommendation feedback summaries corresponding to the code review ARN. </p>
    public let recommendationFeedbackSummaries: [RecommendationFeedbackSummary]?

    public init (
        nextToken: String? = nil,
        recommendationFeedbackSummaries: [RecommendationFeedbackSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommendationFeedbackSummaries = recommendationFeedbackSummaries
    }
}

struct ListRecommendationFeedbackOutputResponseBody: Equatable {
    public let recommendationFeedbackSummaries: [RecommendationFeedbackSummary]?
    public let nextToken: String?
}

extension ListRecommendationFeedbackOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case recommendationFeedbackSummaries = "RecommendationFeedbackSummaries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationFeedbackSummariesContainer = try containerValues.decodeIfPresent([RecommendationFeedbackSummary?].self, forKey: .recommendationFeedbackSummaries)
        var recommendationFeedbackSummariesDecoded0:[RecommendationFeedbackSummary]? = nil
        if let recommendationFeedbackSummariesContainer = recommendationFeedbackSummariesContainer {
            recommendationFeedbackSummariesDecoded0 = [RecommendationFeedbackSummary]()
            for structure0 in recommendationFeedbackSummariesContainer {
                if let structure0 = structure0 {
                    recommendationFeedbackSummariesDecoded0?.append(structure0)
                }
            }
        }
        recommendationFeedbackSummaries = recommendationFeedbackSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecommendationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecommendationsInput(codeReviewArn: \(String(describing: codeReviewArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListRecommendationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListRecommendationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRecommendationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecommendationsInput>
    public typealias MOutput = OperationOutput<ListRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecommendationsOutputError>
}

public struct ListRecommendationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRecommendationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecommendationsInput>
    public typealias MOutput = OperationOutput<ListRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecommendationsOutputError>
}

public struct ListRecommendationsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CodeReview.html">
    ///                <code>CodeReview</code>
    ///             </a> object.
    ///       </p>
    public let codeReviewArn: String?
    /// <p>
    ///          The maximum number of results that are returned per call. The default is 100.
    ///       </p>
    public let maxResults: Int?
    /// <p>
    ///          Pagination token.
    ///       </p>
    public let nextToken: String?

    public init (
        codeReviewArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.codeReviewArn = codeReviewArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRecommendationsInputBody: Equatable {
}

extension ListRecommendationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListRecommendationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecommendationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecommendationsOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecommendationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecommendationsOutputResponse(nextToken: \(String(describing: nextToken)), recommendationSummaries: \(String(describing: recommendationSummaries)))"}
}

extension ListRecommendationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recommendationSummaries = output.recommendationSummaries
        } else {
            self.nextToken = nil
            self.recommendationSummaries = nil
        }
    }
}

public struct ListRecommendationsOutputResponse: Equatable {
    /// <p>
    ///          Pagination token.
    ///       </p>
    public let nextToken: String?
    /// <p>
    ///          List of recommendations for the requested code review.
    ///       </p>
    public let recommendationSummaries: [RecommendationSummary]?

    public init (
        nextToken: String? = nil,
        recommendationSummaries: [RecommendationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommendationSummaries = recommendationSummaries
    }
}

struct ListRecommendationsOutputResponseBody: Equatable {
    public let recommendationSummaries: [RecommendationSummary]?
    public let nextToken: String?
}

extension ListRecommendationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case recommendationSummaries = "RecommendationSummaries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationSummariesContainer = try containerValues.decodeIfPresent([RecommendationSummary?].self, forKey: .recommendationSummaries)
        var recommendationSummariesDecoded0:[RecommendationSummary]? = nil
        if let recommendationSummariesContainer = recommendationSummariesContainer {
            recommendationSummariesDecoded0 = [RecommendationSummary]()
            for structure0 in recommendationSummariesContainer {
                if let structure0 = structure0 {
                    recommendationSummariesDecoded0?.append(structure0)
                }
            }
        }
        recommendationSummaries = recommendationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRepositoryAssociationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRepositoryAssociationsInput(maxResults: \(String(describing: maxResults)), names: \(String(describing: names)), nextToken: \(String(describing: nextToken)), owners: \(String(describing: owners)), providerTypes: \(String(describing: providerTypes)), states: \(String(describing: states)))"}
}

extension ListRepositoryAssociationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListRepositoryAssociationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRepositoryAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRepositoryAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRepositoryAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRepositoryAssociationsInput>
    public typealias MOutput = OperationOutput<ListRepositoryAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRepositoryAssociationsOutputError>
}

public struct ListRepositoryAssociationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRepositoryAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRepositoryAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRepositoryAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let states = input.operationInput.states {
            states.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "State".urlPercentEncoding(), value: String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let names = input.operationInput.names {
            names.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "Name".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let providerTypes = input.operationInput.providerTypes {
            providerTypes.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "ProviderType".urlPercentEncoding(), value: String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let owners = input.operationInput.owners {
            owners.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "Owner".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRepositoryAssociationsInput>
    public typealias MOutput = OperationOutput<ListRepositoryAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRepositoryAssociationsOutputError>
}

public struct ListRepositoryAssociationsInput: Equatable {
    /// <p>The maximum number of repository association results returned by <code>ListRepositoryAssociations</code>
    ///          in paginated output. When this parameter is used, <code>ListRepositoryAssociations</code> only returns
    ///          <code>maxResults</code> results in a single page with a <code>nextToken</code> response
    ///          element. The remaining results of the initial request
    ///          can be seen by sending another <code>ListRepositoryAssociations</code> request with the returned
    ///          <code>nextToken</code> value.
    ///          This value can be between 1 and 100. If this parameter is not used, <code>ListRepositoryAssociations</code>
    ///          returns up to 100 results and a <code>nextToken</code> value if applicable. </p>
    public let maxResults: Int?
    /// <p>List of repository names to use as a filter.</p>
    public let names: [String]?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///          <code>ListRepositoryAssociations</code> request where <code>maxResults</code> was used and the results
    ///          exceeded the value of that parameter. Pagination continues from the end of the previous results
    ///          that returned the <code>nextToken</code> value.
    ///       </p>
    ///          <note>
    ///             <p>Treat this token as an opaque identifier that is only used to retrieve
    ///          the next items in a list and not for other programmatic purposes.</p>
    ///          </note>
    public let nextToken: String?
    /// <p>List of owners to use as a filter.
    ///         For AWS CodeCommit, it is the name of the CodeCommit account that was
    ///         used to associate the repository. For other repository source providers, such as Bitbucket and GitHub Enterprise Server, this is name of the account
    ///         that was used to associate the repository. </p>
    public let owners: [String]?
    /// <p>List of provider types to use as a filter.</p>
    public let providerTypes: [ProviderType]?
    /// <p>List of repository association states to use as a filter.</p>
    ///          <p>The valid repository association states are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Associated</b>: The repository
    ///                association is complete.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Associating</b>: CodeGuru Reviewer is:
    ///             </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                      Setting up pull request notifications. This is required
    ///                      for pull requests to trigger a CodeGuru Reviewer review.
    ///                   </p>
    ///                      <note>
    ///                         <p>
    ///                         If your repository <code>ProviderType</code> is <code>GitHub</code>, <code>GitHub Enterprise Server</code>, or <code>Bitbucket</code>,
    ///                         CodeGuru Reviewer creates webhooks in your repository to trigger CodeGuru Reviewer reviews. If you delete these webhooks,
    ///                         reviews of code in your repository cannot be triggered.
    ///                      </p>
    ///                      </note>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                      Setting up source code access. This is required for CodeGuru Reviewer to securely
    ///                      clone code in your repository.
    ///                   </p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Failed</b>: The repository failed to associate or disassociate.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Disassociating</b>: CodeGuru Reviewer is removing the repository's pull request notifications and
    ///                source code access.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Disassociated</b>: CodeGuru Reviewer successfully disassociated the repository. You can create a new association
    ///                with this repository if you want to review source code in it later. You can control access to code reviews created in an
    ///                associated repository with tags after it has been disassociated. For more information, see <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-ug/auth-and-access-control-using-tags.html">Using tags to control access to
    ///                associated repositories</a> in the <i>Amazon CodeGuru Reviewer User Guide</i>.
    ///             </p>
    ///             </li>
    ///          </ul>
    public let states: [RepositoryAssociationState]?

    public init (
        maxResults: Int? = nil,
        names: [String]? = nil,
        nextToken: String? = nil,
        owners: [String]? = nil,
        providerTypes: [ProviderType]? = nil,
        states: [RepositoryAssociationState]? = nil
    )
    {
        self.maxResults = maxResults
        self.names = names
        self.nextToken = nextToken
        self.owners = owners
        self.providerTypes = providerTypes
        self.states = states
    }
}

struct ListRepositoryAssociationsInputBody: Equatable {
}

extension ListRepositoryAssociationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListRepositoryAssociationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRepositoryAssociationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRepositoryAssociationsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRepositoryAssociationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRepositoryAssociationsOutputResponse(nextToken: \(String(describing: nextToken)), repositoryAssociationSummaries: \(String(describing: repositoryAssociationSummaries)))"}
}

extension ListRepositoryAssociationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRepositoryAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.repositoryAssociationSummaries = output.repositoryAssociationSummaries
        } else {
            self.nextToken = nil
            self.repositoryAssociationSummaries = nil
        }
    }
}

public struct ListRepositoryAssociationsOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> value to include in a future <code>ListRecommendations</code> request.
    ///          When the results of a <code>ListRecommendations</code> request exceed <code>maxResults</code>, this
    ///          value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more
    ///          results to return. </p>
    public let nextToken: String?
    /// <p>A list of repository associations that meet the criteria of the request.</p>
    public let repositoryAssociationSummaries: [RepositoryAssociationSummary]?

    public init (
        nextToken: String? = nil,
        repositoryAssociationSummaries: [RepositoryAssociationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositoryAssociationSummaries = repositoryAssociationSummaries
    }
}

struct ListRepositoryAssociationsOutputResponseBody: Equatable {
    public let repositoryAssociationSummaries: [RepositoryAssociationSummary]?
    public let nextToken: String?
}

extension ListRepositoryAssociationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case repositoryAssociationSummaries = "RepositoryAssociationSummaries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryAssociationSummariesContainer = try containerValues.decodeIfPresent([RepositoryAssociationSummary?].self, forKey: .repositoryAssociationSummaries)
        var repositoryAssociationSummariesDecoded0:[RepositoryAssociationSummary]? = nil
        if let repositoryAssociationSummariesContainer = repositoryAssociationSummariesContainer {
            repositoryAssociationSummariesDecoded0 = [RepositoryAssociationSummary]()
            for structure0 in repositoryAssociationSummariesContainer {
                if let structure0 = structure0 {
                    repositoryAssociationSummariesDecoded0?.append(structure0)
                }
            }
        }
        repositoryAssociationSummaries = repositoryAssociationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>
    ///          The Amazon Resource Name (ARN) of the
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_RepositoryAssociation.html">
    ///                <code>RepositoryAssociation</code>
    ///             </a> object.
    ///          You can retrieve this ARN by calling
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_ListRepositoryAssociations.html">
    ///                <code>ListRepositoryAssociations</code>
    ///             </a>.
    ///       </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>
    /// 			An array of key-value pairs used to tag an associated repository. A tag is a custom attribute label with two parts:
    /// 		</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>A <i>tag key</i> (for example, <code>CostCenter</code>,
    /// 					<code>Environment</code>, <code>Project</code>, or <code>Secret</code>). Tag
    /// 					keys are case sensitive.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>An optional field known as a <i>tag value</i> (for example,
    /// 					<code>111122223333</code>, <code>Production</code>, or a team name).
    /// 					Omitting the tag value is the same as using an empty string. Like tag keys, tag
    /// 					values are case sensitive.</p>
    /// 			         </li>
    ///          </ul>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Metrics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case findingsCount = "FindingsCount"
        case meteredLinesOfCodeCount = "MeteredLinesOfCodeCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingsCount = findingsCount {
            try encodeContainer.encode(findingsCount, forKey: .findingsCount)
        }
        if let meteredLinesOfCodeCount = meteredLinesOfCodeCount {
            try encodeContainer.encode(meteredLinesOfCodeCount, forKey: .meteredLinesOfCodeCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meteredLinesOfCodeCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .meteredLinesOfCodeCount)
        meteredLinesOfCodeCount = meteredLinesOfCodeCountDecoded
        let findingsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .findingsCount)
        findingsCount = findingsCountDecoded
    }
}

extension Metrics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Metrics(findingsCount: \(String(describing: findingsCount)), meteredLinesOfCodeCount: \(String(describing: meteredLinesOfCodeCount)))"}
}

/// <p>
///          Information about the statistics from the code review.
///       </p>
public struct Metrics: Equatable {
    /// <p>
    ///          Total number of recommendations found in the code review.
    ///       </p>
    public let findingsCount: Int?
    /// <p>
    ///         Lines of code metered in the code review. For the initial code review pull request and all subsequent revisions,
    ///         this includes all lines of code in the files added to the pull request. In subsequent revisions, for files that already
    ///         existed in the pull request, this includes only the changed lines of code. In both cases, this does not include non-code lines such as comments
    ///         and import statements. For example, if you submit a pull request containing 5 files, each with 500 lines of code, and in
    ///         a subsequent revision you added a new file with 200 lines of code, and also modified a total of 25 lines across the initial 5 files,
    ///         <code>MeteredLinesOfCodeCount</code> includes the first 5 files (5 * 500 = 2,500 lines), the new file (200 lines) and the 25 changed lines of
    ///          code for a total of 2,725 lines of code.
    ///       </p>
    public let meteredLinesOfCodeCount: Int?

    public init (
        findingsCount: Int? = nil,
        meteredLinesOfCodeCount: Int? = nil
    )
    {
        self.findingsCount = findingsCount
        self.meteredLinesOfCodeCount = meteredLinesOfCodeCount
    }
}

extension MetricsSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case findingsCount = "FindingsCount"
        case meteredLinesOfCodeCount = "MeteredLinesOfCodeCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingsCount = findingsCount {
            try encodeContainer.encode(findingsCount, forKey: .findingsCount)
        }
        if let meteredLinesOfCodeCount = meteredLinesOfCodeCount {
            try encodeContainer.encode(meteredLinesOfCodeCount, forKey: .meteredLinesOfCodeCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meteredLinesOfCodeCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .meteredLinesOfCodeCount)
        meteredLinesOfCodeCount = meteredLinesOfCodeCountDecoded
        let findingsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .findingsCount)
        findingsCount = findingsCountDecoded
    }
}

extension MetricsSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricsSummary(findingsCount: \(String(describing: findingsCount)), meteredLinesOfCodeCount: \(String(describing: meteredLinesOfCodeCount)))"}
}

/// <p>
///          Information about metrics summaries.
///       </p>
public struct MetricsSummary: Equatable {
    /// <p>
    ///          Total number of recommendations found in the code review.
    ///       </p>
    public let findingsCount: Int?
    /// <p>
    ///          Lines of code metered in the code review. For the initial code review pull request and all subsequent revisions,
    ///          this includes all lines of code in the files added to the pull request. In subsequent revisions, for files that already
    ///          existed in the pull request, this includes only the changed lines of code. In both cases, this does not include non-code lines such as comments
    ///          and import statements. For example, if you submit a pull request containing 5 files, each with 500 lines of code, and in
    ///          a subsequent revision you added a new file with 200 lines of code, and also modified a total of 25 lines across the initial 5 files,
    ///          <code>MeteredLinesOfCodeCount</code> includes the first 5 files (5 * 500 = 2,500 lines), the new file (200 lines) and the 25 changed lines of
    ///          code for a total of 2,725 lines of code.
    ///       </p>
    public let meteredLinesOfCodeCount: Int?

    public init (
        findingsCount: Int? = nil,
        meteredLinesOfCodeCount: Int? = nil
    )
    {
        self.findingsCount = findingsCount
        self.meteredLinesOfCodeCount = meteredLinesOfCodeCount
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource specified in the request was not found.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ProviderType {
    case bitbucket
    case codeCommit
    case gitHub
    case gitHubEnterpriseServer
    case sdkUnknown(String)
}

extension ProviderType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProviderType] {
        return [
            .bitbucket,
            .codeCommit,
            .gitHub,
            .gitHubEnterpriseServer,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bitbucket: return "Bitbucket"
        case .codeCommit: return "CodeCommit"
        case .gitHub: return "GitHub"
        case .gitHubEnterpriseServer: return "GitHubEnterpriseServer"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProviderType(rawValue: rawValue) ?? ProviderType.sdkUnknown(rawValue)
    }
}

public struct PutRecommendationFeedbackInputBodyMiddleware: Middleware {
    public let id: String = "PutRecommendationFeedbackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRecommendationFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRecommendationFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRecommendationFeedbackInput>
    public typealias MOutput = OperationOutput<PutRecommendationFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRecommendationFeedbackOutputError>
}

extension PutRecommendationFeedbackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRecommendationFeedbackInput(codeReviewArn: \(String(describing: codeReviewArn)), reactions: \(String(describing: reactions)), recommendationId: \(String(describing: recommendationId)))"}
}

extension PutRecommendationFeedbackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case codeReviewArn = "CodeReviewArn"
        case reactions = "Reactions"
        case recommendationId = "RecommendationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeReviewArn = codeReviewArn {
            try encodeContainer.encode(codeReviewArn, forKey: .codeReviewArn)
        }
        if let reactions = reactions {
            var reactionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reactions)
            for reactions0 in reactions {
                try reactionsContainer.encode(reactions0.rawValue)
            }
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
    }
}

public struct PutRecommendationFeedbackInputHeadersMiddleware: Middleware {
    public let id: String = "PutRecommendationFeedbackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRecommendationFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRecommendationFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRecommendationFeedbackInput>
    public typealias MOutput = OperationOutput<PutRecommendationFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRecommendationFeedbackOutputError>
}

public struct PutRecommendationFeedbackInputQueryItemMiddleware: Middleware {
    public let id: String = "PutRecommendationFeedbackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRecommendationFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRecommendationFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRecommendationFeedbackInput>
    public typealias MOutput = OperationOutput<PutRecommendationFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRecommendationFeedbackOutputError>
}

public struct PutRecommendationFeedbackInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CodeReview.html">
    ///                <code>CodeReview</code>
    ///             </a> object.
    ///       </p>
    public let codeReviewArn: String?
    /// <p>
    ///          List for storing reactions. Reactions are utf-8 text code for emojis. If you send an empty list it clears all your feedback.
    ///       </p>
    public let reactions: [Reaction]?
    /// <p>
    ///          The recommendation ID that can be used to track the provided recommendations and then to collect the feedback.
    ///       </p>
    public let recommendationId: String?

    public init (
        codeReviewArn: String? = nil,
        reactions: [Reaction]? = nil,
        recommendationId: String? = nil
    )
    {
        self.codeReviewArn = codeReviewArn
        self.reactions = reactions
        self.recommendationId = recommendationId
    }
}

struct PutRecommendationFeedbackInputBody: Equatable {
    public let codeReviewArn: String?
    public let recommendationId: String?
    public let reactions: [Reaction]?
}

extension PutRecommendationFeedbackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeReviewArn = "CodeReviewArn"
        case reactions = "Reactions"
        case recommendationId = "RecommendationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeReviewArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .codeReviewArn)
        codeReviewArn = codeReviewArnDecoded
        let recommendationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let reactionsContainer = try containerValues.decodeIfPresent([Reaction?].self, forKey: .reactions)
        var reactionsDecoded0:[Reaction]? = nil
        if let reactionsContainer = reactionsContainer {
            reactionsDecoded0 = [Reaction]()
            for string0 in reactionsContainer {
                if let string0 = string0 {
                    reactionsDecoded0?.append(string0)
                }
            }
        }
        reactions = reactionsDecoded0
    }
}

extension PutRecommendationFeedbackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRecommendationFeedbackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRecommendationFeedbackOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRecommendationFeedbackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRecommendationFeedbackOutputResponse()"}
}

extension PutRecommendationFeedbackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutRecommendationFeedbackOutputResponse: Equatable {

    public init() {}
}

struct PutRecommendationFeedbackOutputResponseBody: Equatable {
}

extension PutRecommendationFeedbackOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum Reaction {
    case thumbsDown
    case thumbsUp
    case sdkUnknown(String)
}

extension Reaction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Reaction] {
        return [
            .thumbsDown,
            .thumbsUp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .thumbsDown: return "ThumbsDown"
        case .thumbsUp: return "ThumbsUp"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Reaction(rawValue: rawValue) ?? Reaction.sdkUnknown(rawValue)
    }
}

extension RecommendationFeedback: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case codeReviewArn = "CodeReviewArn"
        case createdTimeStamp = "CreatedTimeStamp"
        case lastUpdatedTimeStamp = "LastUpdatedTimeStamp"
        case reactions = "Reactions"
        case recommendationId = "RecommendationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeReviewArn = codeReviewArn {
            try encodeContainer.encode(codeReviewArn, forKey: .codeReviewArn)
        }
        if let createdTimeStamp = createdTimeStamp {
            try encodeContainer.encode(createdTimeStamp.timeIntervalSince1970, forKey: .createdTimeStamp)
        }
        if let lastUpdatedTimeStamp = lastUpdatedTimeStamp {
            try encodeContainer.encode(lastUpdatedTimeStamp.timeIntervalSince1970, forKey: .lastUpdatedTimeStamp)
        }
        if let reactions = reactions {
            var reactionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reactions)
            for reactions0 in reactions {
                try reactionsContainer.encode(reactions0.rawValue)
            }
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeReviewArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .codeReviewArn)
        codeReviewArn = codeReviewArnDecoded
        let recommendationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let reactionsContainer = try containerValues.decodeIfPresent([Reaction?].self, forKey: .reactions)
        var reactionsDecoded0:[Reaction]? = nil
        if let reactionsContainer = reactionsContainer {
            reactionsDecoded0 = [Reaction]()
            for string0 in reactionsContainer {
                if let string0 = string0 {
                    reactionsDecoded0?.append(string0)
                }
            }
        }
        reactions = reactionsDecoded0
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let createdTimeStampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimeStamp)
        createdTimeStamp = createdTimeStampDecoded
        let lastUpdatedTimeStampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTimeStamp)
        lastUpdatedTimeStamp = lastUpdatedTimeStampDecoded
    }
}

extension RecommendationFeedback: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecommendationFeedback(codeReviewArn: \(String(describing: codeReviewArn)), createdTimeStamp: \(String(describing: createdTimeStamp)), lastUpdatedTimeStamp: \(String(describing: lastUpdatedTimeStamp)), reactions: \(String(describing: reactions)), recommendationId: \(String(describing: recommendationId)), userId: \(String(describing: userId)))"}
}

/// <p>
///          Information about the recommendation feedback.
///       </p>
public struct RecommendationFeedback: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CodeReview.html">
    ///                <code>CodeReview</code>
    ///             </a> object.
    ///       </p>
    public let codeReviewArn: String?
    /// <p>
    ///          The time at which the feedback was created.
    ///       </p>
    public let createdTimeStamp: Date?
    /// <p>
    ///          The time at which the feedback was last updated.
    ///       </p>
    public let lastUpdatedTimeStamp: Date?
    /// <p>
    ///          List for storing reactions. Reactions are utf-8 text code for emojis. You can send an empty list to clear off all your feedback.
    ///       </p>
    public let reactions: [Reaction]?
    /// <p>
    ///          The recommendation ID that can be used to track the provided recommendations. Later on it can be used to collect the feedback.
    ///       </p>
    public let recommendationId: String?
    /// <p>
    ///          The ID of the user that made the API call.
    ///       </p>
    ///          <p>
    ///          The <code>UserId</code> is an IAM principal that can be specified as an AWS account ID or an Amazon Resource Name (ARN). For
    ///          more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html#Principal_specifying">
    ///             Specifying a Principal</a> in the <i>AWS Identity and Access Management User Guide</i>.
    ///       </p>
    public let userId: String?

    public init (
        codeReviewArn: String? = nil,
        createdTimeStamp: Date? = nil,
        lastUpdatedTimeStamp: Date? = nil,
        reactions: [Reaction]? = nil,
        recommendationId: String? = nil,
        userId: String? = nil
    )
    {
        self.codeReviewArn = codeReviewArn
        self.createdTimeStamp = createdTimeStamp
        self.lastUpdatedTimeStamp = lastUpdatedTimeStamp
        self.reactions = reactions
        self.recommendationId = recommendationId
        self.userId = userId
    }
}

extension RecommendationFeedbackSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reactions = "Reactions"
        case recommendationId = "RecommendationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reactions = reactions {
            var reactionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reactions)
            for reactions0 in reactions {
                try reactionsContainer.encode(reactions0.rawValue)
            }
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let reactionsContainer = try containerValues.decodeIfPresent([Reaction?].self, forKey: .reactions)
        var reactionsDecoded0:[Reaction]? = nil
        if let reactionsContainer = reactionsContainer {
            reactionsDecoded0 = [Reaction]()
            for string0 in reactionsContainer {
                if let string0 = string0 {
                    reactionsDecoded0?.append(string0)
                }
            }
        }
        reactions = reactionsDecoded0
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension RecommendationFeedbackSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecommendationFeedbackSummary(reactions: \(String(describing: reactions)), recommendationId: \(String(describing: recommendationId)), userId: \(String(describing: userId)))"}
}

/// <p>
///          Information about recommendation feedback summaries.
///       </p>
public struct RecommendationFeedbackSummary: Equatable {
    /// <p>
    ///          List for storing reactions. Reactions are utf-8 text code for emojis.
    ///       </p>
    public let reactions: [Reaction]?
    /// <p>
    ///          The recommendation ID that can be used to track the provided recommendations. Later on it can be used to collect the feedback.
    ///       </p>
    public let recommendationId: String?
    /// <p>
    ///          The ID of the user that gave the feedback.
    ///       </p>
    ///          <p>
    ///          The <code>UserId</code> is an IAM principal that can be specified as an AWS account ID or an Amazon Resource Name (ARN). For
    ///          more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html#Principal_specifying">
    ///             Specifying a Principal</a> in the <i>AWS Identity and Access Management User Guide</i>.
    ///       </p>
    public let userId: String?

    public init (
        reactions: [Reaction]? = nil,
        recommendationId: String? = nil,
        userId: String? = nil
    )
    {
        self.reactions = reactions
        self.recommendationId = recommendationId
        self.userId = userId
    }
}

extension RecommendationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case endLine = "EndLine"
        case filePath = "FilePath"
        case recommendationId = "RecommendationId"
        case startLine = "StartLine"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endLine = endLine {
            try encodeContainer.encode(endLine, forKey: .endLine)
        }
        if let filePath = filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
        if let startLine = startLine {
            try encodeContainer.encode(startLine, forKey: .startLine)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filePath)
        filePath = filePathDecoded
        let recommendationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let startLineDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .startLine)
        startLine = startLineDecoded
        let endLineDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .endLine)
        endLine = endLineDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension RecommendationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecommendationSummary(description: \(String(describing: description)), endLine: \(String(describing: endLine)), filePath: \(String(describing: filePath)), recommendationId: \(String(describing: recommendationId)), startLine: \(String(describing: startLine)))"}
}

/// <p>
///          Information about recommendations.
///       </p>
public struct RecommendationSummary: Equatable {
    /// <p>
    ///          A description of the recommendation generated by CodeGuru Reviewer for the lines of code between the start line and the end line.
    ///       </p>
    public let description: String?
    /// <p>
    ///          Last line where the recommendation is applicable in the source commit or source branch. For a single line comment the start line and end line values are the same.
    ///       </p>
    public let endLine: Int?
    /// <p>Name of the file on which a recommendation is provided.</p>
    public let filePath: String?
    /// <p>
    ///          The recommendation ID that can be used to track the provided recommendations. Later on it can be used to collect the feedback.
    ///       </p>
    public let recommendationId: String?
    /// <p>
    ///          Start line from where the recommendation is applicable in the source commit or source branch.
    ///       </p>
    public let startLine: Int?

    public init (
        description: String? = nil,
        endLine: Int? = nil,
        filePath: String? = nil,
        recommendationId: String? = nil,
        startLine: Int? = nil
    )
    {
        self.description = description
        self.endLine = endLine
        self.filePath = filePath
        self.recommendationId = recommendationId
        self.startLine = startLine
    }
}

extension Repository: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bitbucket = "Bitbucket"
        case codeCommit = "CodeCommit"
        case gitHubEnterpriseServer = "GitHubEnterpriseServer"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bitbucket = bitbucket {
            try encodeContainer.encode(bitbucket, forKey: .bitbucket)
        }
        if let codeCommit = codeCommit {
            try encodeContainer.encode(codeCommit, forKey: .codeCommit)
        }
        if let gitHubEnterpriseServer = gitHubEnterpriseServer {
            try encodeContainer.encode(gitHubEnterpriseServer, forKey: .gitHubEnterpriseServer)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeCommitDecoded = try containerValues.decodeIfPresent(CodeCommitRepository.self, forKey: .codeCommit)
        codeCommit = codeCommitDecoded
        let bitbucketDecoded = try containerValues.decodeIfPresent(ThirdPartySourceRepository.self, forKey: .bitbucket)
        bitbucket = bitbucketDecoded
        let gitHubEnterpriseServerDecoded = try containerValues.decodeIfPresent(ThirdPartySourceRepository.self, forKey: .gitHubEnterpriseServer)
        gitHubEnterpriseServer = gitHubEnterpriseServerDecoded
    }
}

extension Repository: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Repository(bitbucket: \(String(describing: bitbucket)), codeCommit: \(String(describing: codeCommit)), gitHubEnterpriseServer: \(String(describing: gitHubEnterpriseServer)))"}
}

/// <p>
///          Information about an associated AWS CodeCommit repository or an associated repository that is managed
///          by AWS CodeStar Connections (for example, Bitbucket). This <code>Repository</code> object
///          is not used if your source code is in an associated GitHub repository.
///       </p>
public struct Repository: Equatable {
    /// <p>
    ///          Information about a Bitbucket repository.
    ///       </p>
    public let bitbucket: ThirdPartySourceRepository?
    /// <p>Information about an AWS CodeCommit repository.</p>
    public let codeCommit: CodeCommitRepository?
    /// <p>
    ///          Information about a GitHub Enterprise Server repository.
    ///       </p>
    public let gitHubEnterpriseServer: ThirdPartySourceRepository?

    public init (
        bitbucket: ThirdPartySourceRepository? = nil,
        codeCommit: CodeCommitRepository? = nil,
        gitHubEnterpriseServer: ThirdPartySourceRepository? = nil
    )
    {
        self.bitbucket = bitbucket
        self.codeCommit = codeCommit
        self.gitHubEnterpriseServer = gitHubEnterpriseServer
    }
}

extension RepositoryAnalysis: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case repositoryHead = "RepositoryHead"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryHead = repositoryHead {
            try encodeContainer.encode(repositoryHead, forKey: .repositoryHead)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryHeadDecoded = try containerValues.decodeIfPresent(RepositoryHeadSourceCodeType.self, forKey: .repositoryHead)
        repositoryHead = repositoryHeadDecoded
    }
}

extension RepositoryAnalysis: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryAnalysis(repositoryHead: \(String(describing: repositoryHead)))"}
}

/// <p> A code review type that analyzes all code under a specified branch in an associated
/// 			repository. The associated repository is specified using its ARN when you call <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CreateCodeReview">
///                <code>CreateCodeReview</code>
///             </a>. </p>
public struct RepositoryAnalysis: Equatable {
    /// <p>
    ///          A <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_SourceCodeType">
    ///                <code>SourceCodeType</code>
    ///             </a> that
    ///          specifies the tip of a branch in an associated repository.
    ///       </p>
    public let repositoryHead: RepositoryHeadSourceCodeType?

    public init (
        repositoryHead: RepositoryHeadSourceCodeType? = nil
    )
    {
        self.repositoryHead = repositoryHead
    }
}

extension RepositoryAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationArn = "AssociationArn"
        case associationId = "AssociationId"
        case connectionArn = "ConnectionArn"
        case createdTimeStamp = "CreatedTimeStamp"
        case kMSKeyDetails = "KMSKeyDetails"
        case lastUpdatedTimeStamp = "LastUpdatedTimeStamp"
        case name = "Name"
        case owner = "Owner"
        case providerType = "ProviderType"
        case state = "State"
        case stateReason = "StateReason"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationArn = associationArn {
            try encodeContainer.encode(associationArn, forKey: .associationArn)
        }
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let createdTimeStamp = createdTimeStamp {
            try encodeContainer.encode(createdTimeStamp.timeIntervalSince1970, forKey: .createdTimeStamp)
        }
        if let kMSKeyDetails = kMSKeyDetails {
            try encodeContainer.encode(kMSKeyDetails, forKey: .kMSKeyDetails)
        }
        if let lastUpdatedTimeStamp = lastUpdatedTimeStamp {
            try encodeContainer.encode(lastUpdatedTimeStamp.timeIntervalSince1970, forKey: .lastUpdatedTimeStamp)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationArn)
        associationArn = associationArnDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(RepositoryAssociationState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let lastUpdatedTimeStampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTimeStamp)
        lastUpdatedTimeStamp = lastUpdatedTimeStampDecoded
        let createdTimeStampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimeStamp)
        createdTimeStamp = createdTimeStampDecoded
        let kMSKeyDetailsDecoded = try containerValues.decodeIfPresent(KMSKeyDetails.self, forKey: .kMSKeyDetails)
        kMSKeyDetails = kMSKeyDetailsDecoded
    }
}

extension RepositoryAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryAssociation(associationArn: \(String(describing: associationArn)), associationId: \(String(describing: associationId)), connectionArn: \(String(describing: connectionArn)), createdTimeStamp: \(String(describing: createdTimeStamp)), kMSKeyDetails: \(String(describing: kMSKeyDetails)), lastUpdatedTimeStamp: \(String(describing: lastUpdatedTimeStamp)), name: \(String(describing: name)), owner: \(String(describing: owner)), providerType: \(String(describing: providerType)), state: \(String(describing: state)), stateReason: \(String(describing: stateReason)))"}
}

/// <p>Information about a repository association. The
///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_DescribeRepositoryAssociation.html">
///                <code>DescribeRepositoryAssociation</code>
///             </a>
///          operation returns a <code>RepositoryAssociation</code> object.</p>
public struct RepositoryAssociation: Equatable {
    /// <p>The Amazon Resource Name (ARN) identifying the repository association.</p>
    public let associationArn: String?
    /// <p>The ID of the repository association.</p>
    public let associationId: String?
    /// <p>
    ///          The Amazon Resource Name (ARN) of an AWS CodeStar Connections connection. Its format is
    ///          <code>arn:aws:codestar-connections:region-id:aws-account_id:connection/connection-id</code>. For more information, see
    ///          <a href="https://docs.aws.amazon.com/codestar-connections/latest/APIReference/API_Connection.html">
    ///                <code>Connection</code>
    ///             </a> in
    ///          the <i>AWS CodeStar Connections API Reference</i>.
    ///       </p>
    public let connectionArn: String?
    /// <p>The time, in milliseconds since the epoch, when the repository association was created.</p>
    public let createdTimeStamp: Date?
    /// <p>A <code>KMSKeyDetails</code> object that contains:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The encryption option for this repository association. It is either owned by AWS
    ///             Key Management Service (KMS) (<code>AWS_OWNED_CMK</code>) or customer managed (<code>CUSTOMER_MANAGED_CMK</code>).</p>
    ///             </li>
    ///             <li>
    ///                <p>The ID of the AWS KMS key that
    ///             is associated with this respository association.</p>
    ///             </li>
    ///          </ul>
    public let kMSKeyDetails: KMSKeyDetails?
    /// <p>The time, in milliseconds since the epoch, when the repository association was last updated.</p>
    public let lastUpdatedTimeStamp: Date?
    /// <p>The name of the repository.</p>
    public let name: String?
    /// <p>The owner of the repository. For an AWS CodeCommit repository, this is the AWS account ID of the
    ///       account that owns the repository. For a GitHub, GitHub Enterprise Server, or Bitbucket repository, this is the username for the account that owns the repository.</p>
    public let owner: String?
    /// <p>The provider type of the repository association.</p>
    public let providerType: ProviderType?
    /// <p>The state of the repository association.</p>
    ///          <p>The valid repository association states are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Associated</b>: The repository
    ///                association is complete.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Associating</b>: CodeGuru Reviewer is:
    ///             </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                      Setting up pull request notifications. This is required
    ///                      for pull requests to trigger a CodeGuru Reviewer review.
    ///                   </p>
    ///                      <note>
    ///                         <p>
    ///                         If your repository <code>ProviderType</code> is <code>GitHub</code>, <code>GitHub Enterprise Server</code>, or <code>Bitbucket</code>,
    ///                         CodeGuru Reviewer creates webhooks in your repository to trigger CodeGuru Reviewer reviews. If you delete these webhooks,
    ///                         reviews of code in your repository cannot be triggered.
    ///                      </p>
    ///                      </note>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                      Setting up source code access. This is required for CodeGuru Reviewer to securely
    ///                      clone code in your repository.
    ///                   </p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Failed</b>: The repository failed to associate or disassociate.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Disassociating</b>: CodeGuru Reviewer is removing the repository's pull request notifications and
    ///                source code access.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Disassociated</b>: CodeGuru Reviewer successfully disassociated the repository. You can create a new association
    ///                with this repository if you want to review source code in it later. You can control access to code reviews created in an
    ///                associated repository with tags after it has been disassociated. For more information, see <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-ug/auth-and-access-control-using-tags.html">Using tags to control access to
    ///                associated repositories</a> in the <i>Amazon CodeGuru Reviewer User Guide</i>.
    ///             </p>
    ///             </li>
    ///          </ul>
    public let state: RepositoryAssociationState?
    /// <p>A description of why the repository association is in the current state.</p>
    public let stateReason: String?

    public init (
        associationArn: String? = nil,
        associationId: String? = nil,
        connectionArn: String? = nil,
        createdTimeStamp: Date? = nil,
        kMSKeyDetails: KMSKeyDetails? = nil,
        lastUpdatedTimeStamp: Date? = nil,
        name: String? = nil,
        owner: String? = nil,
        providerType: ProviderType? = nil,
        state: RepositoryAssociationState? = nil,
        stateReason: String? = nil
    )
    {
        self.associationArn = associationArn
        self.associationId = associationId
        self.connectionArn = connectionArn
        self.createdTimeStamp = createdTimeStamp
        self.kMSKeyDetails = kMSKeyDetails
        self.lastUpdatedTimeStamp = lastUpdatedTimeStamp
        self.name = name
        self.owner = owner
        self.providerType = providerType
        self.state = state
        self.stateReason = stateReason
    }
}

public enum RepositoryAssociationState {
    case associated
    case associating
    case disassociated
    case disassociating
    case failed
    case sdkUnknown(String)
}

extension RepositoryAssociationState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RepositoryAssociationState] {
        return [
            .associated,
            .associating,
            .disassociated,
            .disassociating,
            .failed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .associated: return "Associated"
        case .associating: return "Associating"
        case .disassociated: return "Disassociated"
        case .disassociating: return "Disassociating"
        case .failed: return "Failed"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RepositoryAssociationState(rawValue: rawValue) ?? RepositoryAssociationState.sdkUnknown(rawValue)
    }
}

extension RepositoryAssociationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationArn = "AssociationArn"
        case associationId = "AssociationId"
        case connectionArn = "ConnectionArn"
        case lastUpdatedTimeStamp = "LastUpdatedTimeStamp"
        case name = "Name"
        case owner = "Owner"
        case providerType = "ProviderType"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationArn = associationArn {
            try encodeContainer.encode(associationArn, forKey: .associationArn)
        }
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let lastUpdatedTimeStamp = lastUpdatedTimeStamp {
            try encodeContainer.encode(lastUpdatedTimeStamp.timeIntervalSince1970, forKey: .lastUpdatedTimeStamp)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationArn)
        associationArn = associationArnDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let lastUpdatedTimeStampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTimeStamp)
        lastUpdatedTimeStamp = lastUpdatedTimeStampDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(RepositoryAssociationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension RepositoryAssociationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryAssociationSummary(associationArn: \(String(describing: associationArn)), associationId: \(String(describing: associationId)), connectionArn: \(String(describing: connectionArn)), lastUpdatedTimeStamp: \(String(describing: lastUpdatedTimeStamp)), name: \(String(describing: name)), owner: \(String(describing: owner)), providerType: \(String(describing: providerType)), state: \(String(describing: state)))"}
}

/// <p>Summary information about a repository association. The
///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_ListRepositoryAssociations.html">
///                <code>ListRepositoryAssociations</code>
///             </a>
///          operation returns a list of <code>RepositoryAssociationSummary</code> objects.</p>
public struct RepositoryAssociationSummary: Equatable {
    /// <p>
    ///          The Amazon Resource Name (ARN) of the
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_RepositoryAssociation.html">
    ///                <code>RepositoryAssociation</code>
    ///             </a> object.
    ///          You can retrieve this ARN by calling
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_ListRepositoryAssociations.html">
    ///                <code>ListRepositoryAssociations</code>
    ///             </a>.
    ///       </p>
    public let associationArn: String?
    /// <p>
    ///          The repository association ID.
    ///       </p>
    public let associationId: String?
    /// <p>
    ///          The Amazon Resource Name (ARN) of an AWS CodeStar Connections connection. Its format is
    ///          <code>arn:aws:codestar-connections:region-id:aws-account_id:connection/connection-id</code>. For more information, see
    ///          <a href="https://docs.aws.amazon.com/codestar-connections/latest/APIReference/API_Connection.html">
    ///                <code>Connection</code>
    ///             </a> in
    ///          the <i>AWS CodeStar Connections API Reference</i>.
    ///       </p>
    public let connectionArn: String?
    /// <p>The time, in milliseconds since the epoch, since the repository association
    ///         was last updated.
    ///       </p>
    public let lastUpdatedTimeStamp: Date?
    /// <p>The name of the repository association.</p>
    public let name: String?
    /// <p>The owner of the repository. For an AWS CodeCommit repository, this is the AWS account ID of the
    ///       account that owns the repository. For a GitHub, GitHub Enterprise Server, or Bitbucket repository, this is the username for the account that owns the repository.</p>
    public let owner: String?
    /// <p>The provider type of the repository association.</p>
    public let providerType: ProviderType?
    /// <p>The state of the repository association.</p>
    ///          <p>The valid repository association states are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Associated</b>: The repository
    ///                association is complete.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Associating</b>: CodeGuru Reviewer is:
    ///             </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                      Setting up pull request notifications. This is required
    ///                      for pull requests to trigger a CodeGuru Reviewer review.
    ///                   </p>
    ///                      <note>
    ///                         <p>
    ///                         If your repository <code>ProviderType</code> is <code>GitHub</code>, <code>GitHub Enterprise Server</code>, or <code>Bitbucket</code>,
    ///                         CodeGuru Reviewer creates webhooks in your repository to trigger CodeGuru Reviewer reviews. If you delete these webhooks,
    ///                         reviews of code in your repository cannot be triggered.
    ///                      </p>
    ///                      </note>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                      Setting up source code access. This is required for CodeGuru Reviewer to securely
    ///                      clone code in your repository.
    ///                   </p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Failed</b>: The repository failed to associate or disassociate.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Disassociating</b>: CodeGuru Reviewer is removing the repository's pull request notifications and
    ///                source code access.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Disassociated</b>: CodeGuru Reviewer successfully disassociated the repository. You can create a new association
    ///                with this repository if you want to review source code in it later. You can control access to code reviews created in an
    ///                associated repository with tags after it has been disassociated. For more information, see <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-ug/auth-and-access-control-using-tags.html">Using tags to control access to
    ///                associated repositories</a> in the <i>Amazon CodeGuru Reviewer User Guide</i>.
    ///             </p>
    ///             </li>
    ///          </ul>
    public let state: RepositoryAssociationState?

    public init (
        associationArn: String? = nil,
        associationId: String? = nil,
        connectionArn: String? = nil,
        lastUpdatedTimeStamp: Date? = nil,
        name: String? = nil,
        owner: String? = nil,
        providerType: ProviderType? = nil,
        state: RepositoryAssociationState? = nil
    )
    {
        self.associationArn = associationArn
        self.associationId = associationId
        self.connectionArn = connectionArn
        self.lastUpdatedTimeStamp = lastUpdatedTimeStamp
        self.name = name
        self.owner = owner
        self.providerType = providerType
        self.state = state
    }
}

extension RepositoryHeadSourceCodeType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branchName = "BranchName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .branchName)
        branchName = branchNameDecoded
    }
}

extension RepositoryHeadSourceCodeType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryHeadSourceCodeType(branchName: \(String(describing: branchName)))"}
}

/// <p>
///          A <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_SourceCodeType">
///                <code>SourceCodeType</code>
///             </a> that specifies
///          the tip of a branch in an associated repository.
///       </p>
public struct RepositoryHeadSourceCodeType: Equatable {
    /// <p>
    ///          The name of the branch in an associated repository. The <code>RepositoryHeadSourceCodeType</code> specifies
    ///          the tip of this branch.
    ///       </p>
    public let branchName: String?

    public init (
        branchName: String? = nil
    )
    {
        self.branchName = branchName
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///          The resource specified in the request was not found.
///       </p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SourceCodeType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commitDiff = "CommitDiff"
        case repositoryHead = "RepositoryHead"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitDiff = commitDiff {
            try encodeContainer.encode(commitDiff, forKey: .commitDiff)
        }
        if let repositoryHead = repositoryHead {
            try encodeContainer.encode(repositoryHead, forKey: .repositoryHead)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitDiffDecoded = try containerValues.decodeIfPresent(CommitDiffSourceCodeType.self, forKey: .commitDiff)
        commitDiff = commitDiffDecoded
        let repositoryHeadDecoded = try containerValues.decodeIfPresent(RepositoryHeadSourceCodeType.self, forKey: .repositoryHead)
        repositoryHead = repositoryHeadDecoded
    }
}

extension SourceCodeType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceCodeType(commitDiff: \(String(describing: commitDiff)), repositoryHead: \(String(describing: repositoryHead)))"}
}

/// <p>
///          Specifies the source code that is analyzed in a code review. A code review can analyze the source code that is specified
///          using a pull request diff or a branch in an associated repository.
///       </p>
public struct SourceCodeType: Equatable {
    /// <p>
    ///          A <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_SourceCodeType">
    ///                <code>SourceCodeType</code>
    ///             </a> that
    ///          specifies a commit diff created by a pull request on an associated repository.
    ///       </p>
    public let commitDiff: CommitDiffSourceCodeType?
    /// <p>
    ///          A <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_SourceCodeType">
    ///                <code>SourceCodeType</code>
    ///             </a> that specifies
    ///          the tip of a branch in an associated repository.
    ///       </p>
    public let repositoryHead: RepositoryHeadSourceCodeType?

    public init (
        commitDiff: CommitDiffSourceCodeType? = nil,
        repositoryHead: RepositoryHeadSourceCodeType? = nil
    )
    {
        self.commitDiff = commitDiff
        self.repositoryHead = repositoryHead
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(tags: \(String(describing: tags)), resourceArn: \(String(describing: resourceArn)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>
    ///          The Amazon Resource Name (ARN) of the
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_RepositoryAssociation.html">
    ///                <code>RepositoryAssociation</code>
    ///             </a> object.
    ///          You can retrieve this ARN by calling
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_ListRepositoryAssociations.html">
    ///                <code>ListRepositoryAssociations</code>
    ///             </a>.
    ///       </p>
    public let resourceArn: String?
    /// <p>
    /// 			An array of key-value pairs used to tag an associated repository. A tag is a custom attribute label with two parts:
    /// 		</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>A <i>tag key</i> (for example, <code>CostCenter</code>,
    /// 					<code>Environment</code>, <code>Project</code>, or <code>Secret</code>). Tag
    /// 					keys are case sensitive.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>An optional field known as a <i>tag value</i> (for example,
    /// 					<code>111122223333</code>, <code>Production</code>, or a team name).
    /// 					Omitting the tag value is the same as using an empty string. Like tag keys, tag
    /// 					values are case sensitive.</p>
    /// 			         </li>
    ///          </ul>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThirdPartySourceRepository: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
        case name = "Name"
        case owner = "Owner"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
    }
}

extension ThirdPartySourceRepository: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThirdPartySourceRepository(connectionArn: \(String(describing: connectionArn)), name: \(String(describing: name)), owner: \(String(describing: owner)))"}
}

/// <p>
///          Information about a third-party source repository connected to CodeGuru Reviewer.
///       </p>
public struct ThirdPartySourceRepository: Equatable {
    /// <p>
    ///          The Amazon Resource Name (ARN) of an AWS CodeStar Connections connection. Its format is
    ///          <code>arn:aws:codestar-connections:region-id:aws-account_id:connection/connection-id</code>. For more information, see
    ///          <a href="https://docs.aws.amazon.com/codestar-connections/latest/APIReference/API_Connection.html">
    ///                <code>Connection</code>
    ///             </a> in
    ///          the <i>AWS CodeStar Connections API Reference</i>.
    ///       </p>
    public let connectionArn: String?
    /// <p>
    ///          The name of the third party source repository.
    ///       </p>
    public let name: String?
    /// <p>
    ///          The owner of the repository. For a GitHub, GitHub Enterprise, or Bitbucket repository,
    ///          this is the username for the account that owns the repository.
    ///       </p>
    public let owner: String?

    public init (
        connectionArn: String? = nil,
        name: String? = nil,
        owner: String? = nil
    )
    {
        self.connectionArn = connectionArn
        self.name = name
        self.owner = owner
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum `Type` {
    case pullRequest
    case repositoryAnalysis
    case sdkUnknown(String)
}

extension `Type` : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [`Type`] {
        return [
            .pullRequest,
            .repositoryAnalysis,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .pullRequest: return "PullRequest"
        case .repositoryAnalysis: return "RepositoryAnalysis"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = `Type`(rawValue: rawValue) ?? `Type`.sdkUnknown(rawValue)
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(tagKeys: \(String(describing: tagKeys)), resourceArn: \(String(describing: resourceArn)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>
    ///          The Amazon Resource Name (ARN) of the
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_RepositoryAssociation.html">
    ///                <code>RepositoryAssociation</code>
    ///             </a> object.
    ///          You can retrieve this ARN by calling
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_ListRepositoryAssociations.html">
    ///                <code>ListRepositoryAssociations</code>
    ///             </a>.
    ///       </p>
    public let resourceArn: String?
    /// <p>A list of the keys for each tag you want to remove from an associated repository.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input fails to satisfy the specified constraints.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
