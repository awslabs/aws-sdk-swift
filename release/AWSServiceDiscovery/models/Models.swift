// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CreateHttpNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateHttpNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateHttpNamespaceInput: Swift.Equatable {
    /// A unique string that identifies the request and that allows failed CreateHttpNamespace requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string (for example, a date/time stamp).
    public var creatorRequestId: Swift.String?
    /// A description for the namespace.
    public var description: Swift.String?
    /// The name that you want to assign to this namespace.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to add to the namespace. Each tag consists of a key and an optional value that you define. Tags keys can be up to 128 characters in length, and tag values can be up to 256 characters in length.
    public var tags: [ServiceDiscoveryClientTypes.Tag]?

    public init (
        creatorRequestId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateHttpNamespaceInputBody: Swift.Equatable {
    let name: Swift.String?
    let creatorRequestId: Swift.String?
    let description: Swift.String?
    let tags: [ServiceDiscoveryClientTypes.Tag]?
}

extension CreateHttpNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateHttpNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHttpNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceAlreadyExists" : self = .namespaceAlreadyExists(try NamespaceAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceeded(try ResourceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHttpNamespaceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceAlreadyExists(NamespaceAlreadyExists)
    case resourceLimitExceeded(ResourceLimitExceeded)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHttpNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateHttpNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct CreateHttpNamespaceOutputResponse: Swift.Equatable {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the operation, see [GetOperation](https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html).
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct CreateHttpNamespaceOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension CreateHttpNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension CreatePrivateDnsNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case properties = "Properties"
        case tags = "Tags"
        case vpc = "Vpc"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let vpc = vpc {
            try encodeContainer.encode(vpc, forKey: .vpc)
        }
    }
}

extension CreatePrivateDnsNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePrivateDnsNamespaceInput: Swift.Equatable {
    /// A unique string that identifies the request and that allows failed CreatePrivateDnsNamespace requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string (for example, a date/timestamp).
    public var creatorRequestId: Swift.String?
    /// A description for the namespace.
    public var description: Swift.String?
    /// The name that you want to assign to this namespace. When you create a private DNS namespace, Cloud Map automatically creates an Amazon Route 53 private hosted zone that has the same name as the namespace.
    /// This member is required.
    public var name: Swift.String?
    /// Properties for the private DNS namespace.
    public var properties: ServiceDiscoveryClientTypes.PrivateDnsNamespaceProperties?
    /// The tags to add to the namespace. Each tag consists of a key and an optional value that you define. Tags keys can be up to 128 characters in length, and tag values can be up to 256 characters in length.
    public var tags: [ServiceDiscoveryClientTypes.Tag]?
    /// The ID of the Amazon VPC that you want to associate the namespace with.
    /// This member is required.
    public var vpc: Swift.String?

    public init (
        creatorRequestId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        properties: ServiceDiscoveryClientTypes.PrivateDnsNamespaceProperties? = nil,
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil,
        vpc: Swift.String? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.name = name
        self.properties = properties
        self.tags = tags
        self.vpc = vpc
    }
}

struct CreatePrivateDnsNamespaceInputBody: Swift.Equatable {
    let name: Swift.String?
    let creatorRequestId: Swift.String?
    let description: Swift.String?
    let vpc: Swift.String?
    let tags: [ServiceDiscoveryClientTypes.Tag]?
    let properties: ServiceDiscoveryClientTypes.PrivateDnsNamespaceProperties?
}

extension CreatePrivateDnsNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case properties = "Properties"
        case tags = "Tags"
        case vpc = "Vpc"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpc)
        vpc = vpcDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let propertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.PrivateDnsNamespaceProperties.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension CreatePrivateDnsNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePrivateDnsNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceAlreadyExists" : self = .namespaceAlreadyExists(try NamespaceAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceeded(try ResourceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePrivateDnsNamespaceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceAlreadyExists(NamespaceAlreadyExists)
    case resourceLimitExceeded(ResourceLimitExceeded)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePrivateDnsNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePrivateDnsNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct CreatePrivateDnsNamespaceOutputResponse: Swift.Equatable {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the operation, see [GetOperation](https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html).
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct CreatePrivateDnsNamespaceOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension CreatePrivateDnsNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension CreatePublicDnsNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case properties = "Properties"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreatePublicDnsNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePublicDnsNamespaceInput: Swift.Equatable {
    /// A unique string that identifies the request and that allows failed CreatePublicDnsNamespace requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string (for example, a date/timestamp).
    public var creatorRequestId: Swift.String?
    /// A description for the namespace.
    public var description: Swift.String?
    /// The name that you want to assign to this namespace.
    /// This member is required.
    public var name: Swift.String?
    /// Properties for the public DNS namespace.
    public var properties: ServiceDiscoveryClientTypes.PublicDnsNamespaceProperties?
    /// The tags to add to the namespace. Each tag consists of a key and an optional value that you define. Tags keys can be up to 128 characters in length, and tag values can be up to 256 characters in length.
    public var tags: [ServiceDiscoveryClientTypes.Tag]?

    public init (
        creatorRequestId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        properties: ServiceDiscoveryClientTypes.PublicDnsNamespaceProperties? = nil,
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.name = name
        self.properties = properties
        self.tags = tags
    }
}

struct CreatePublicDnsNamespaceInputBody: Swift.Equatable {
    let name: Swift.String?
    let creatorRequestId: Swift.String?
    let description: Swift.String?
    let tags: [ServiceDiscoveryClientTypes.Tag]?
    let properties: ServiceDiscoveryClientTypes.PublicDnsNamespaceProperties?
}

extension CreatePublicDnsNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case properties = "Properties"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let propertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.PublicDnsNamespaceProperties.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension CreatePublicDnsNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePublicDnsNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceAlreadyExists" : self = .namespaceAlreadyExists(try NamespaceAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceeded(try ResourceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePublicDnsNamespaceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceAlreadyExists(NamespaceAlreadyExists)
    case resourceLimitExceeded(ResourceLimitExceeded)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePublicDnsNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePublicDnsNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct CreatePublicDnsNamespaceOutputResponse: Swift.Equatable {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the operation, see [GetOperation](https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html).
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct CreatePublicDnsNamespaceOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension CreatePublicDnsNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension CreateServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case dnsConfig = "DnsConfig"
        case healthCheckConfig = "HealthCheckConfig"
        case healthCheckCustomConfig = "HealthCheckCustomConfig"
        case name = "Name"
        case namespaceId = "NamespaceId"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dnsConfig = dnsConfig {
            try encodeContainer.encode(dnsConfig, forKey: .dnsConfig)
        }
        if let healthCheckConfig = healthCheckConfig {
            try encodeContainer.encode(healthCheckConfig, forKey: .healthCheckConfig)
        }
        if let healthCheckCustomConfig = healthCheckCustomConfig {
            try encodeContainer.encode(healthCheckCustomConfig, forKey: .healthCheckCustomConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespaceId = namespaceId {
            try encodeContainer.encode(namespaceId, forKey: .namespaceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateServiceInput: Swift.Equatable {
    /// A unique string that identifies the request and that allows failed CreateService requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string (for example, a date/timestamp).
    public var creatorRequestId: Swift.String?
    /// A description for the service.
    public var description: Swift.String?
    /// A complex type that contains information about the Amazon Route 53 records that you want Cloud Map to create when you register an instance.
    public var dnsConfig: ServiceDiscoveryClientTypes.DnsConfig?
    /// Public DNS and HTTP namespaces only. A complex type that contains settings for an optional Route 53 health check. If you specify settings for a health check, Cloud Map associates the health check with all the Route 53 DNS records that you specify in DnsConfig. If you specify a health check configuration, you can specify either HealthCheckCustomConfig or HealthCheckConfig but not both. For information about the charges for health checks, see [Cloud Map Pricing](http://aws.amazon.com/cloud-map/pricing/).
    public var healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig?
    /// A complex type that contains information about an optional custom health check. If you specify a health check configuration, you can specify either HealthCheckCustomConfig or HealthCheckConfig but not both. You can't add, update, or delete a HealthCheckCustomConfig configuration from an existing service.
    public var healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig?
    /// The name that you want to assign to the service. If you want Cloud Map to create an SRV record when you register an instance and you're using a system that requires a specific SRV format, such as [HAProxy](http://www.haproxy.org/), specify the following for Name:
    ///
    /// * Start the name with an underscore (_), such as _exampleservice.
    ///
    /// * End the name with ._protocol, such as ._tcp.
    ///
    ///
    /// When you register an instance, Cloud Map creates an SRV record and assigns a name to the record by concatenating the service name and the namespace name (for example, _exampleservice._tcp.example.com). For services that are accessible by DNS queries, you can't create multiple services with names that differ only by case (such as EXAMPLE and example). Otherwise, these services have the same DNS name and can't be distinguished. However, if you use a namespace that's only accessible by API calls, then you can create services that with names that differ only by case.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the namespace that you want to use to create the service. The namespace ID must be specified, but it can be specified either here or in the DnsConfig object.
    public var namespaceId: Swift.String?
    /// The tags to add to the service. Each tag consists of a key and an optional value that you define. Tags keys can be up to 128 characters in length, and tag values can be up to 256 characters in length.
    public var tags: [ServiceDiscoveryClientTypes.Tag]?
    /// If present, specifies that the service instances are only discoverable using the DiscoverInstances API operation. No DNS records is registered for the service instances. The only valid value is HTTP.
    public var type: ServiceDiscoveryClientTypes.ServiceTypeOption?

    public init (
        creatorRequestId: Swift.String? = nil,
        description: Swift.String? = nil,
        dnsConfig: ServiceDiscoveryClientTypes.DnsConfig? = nil,
        healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig? = nil,
        healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig? = nil,
        name: Swift.String? = nil,
        namespaceId: Swift.String? = nil,
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil,
        type: ServiceDiscoveryClientTypes.ServiceTypeOption? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.dnsConfig = dnsConfig
        self.healthCheckConfig = healthCheckConfig
        self.healthCheckCustomConfig = healthCheckCustomConfig
        self.name = name
        self.namespaceId = namespaceId
        self.tags = tags
        self.type = type
    }
}

struct CreateServiceInputBody: Swift.Equatable {
    let name: Swift.String?
    let namespaceId: Swift.String?
    let creatorRequestId: Swift.String?
    let description: Swift.String?
    let dnsConfig: ServiceDiscoveryClientTypes.DnsConfig?
    let healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig?
    let healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig?
    let tags: [ServiceDiscoveryClientTypes.Tag]?
    let type: ServiceDiscoveryClientTypes.ServiceTypeOption?
}

extension CreateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case dnsConfig = "DnsConfig"
        case healthCheckConfig = "HealthCheckConfig"
        case healthCheckCustomConfig = "HealthCheckCustomConfig"
        case name = "Name"
        case namespaceId = "NamespaceId"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let namespaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dnsConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.DnsConfig.self, forKey: .dnsConfig)
        dnsConfig = dnsConfigDecoded
        let healthCheckConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckConfig.self, forKey: .healthCheckConfig)
        healthCheckConfig = healthCheckConfigDecoded
        let healthCheckCustomConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckCustomConfig.self, forKey: .healthCheckCustomConfig)
        healthCheckCustomConfig = healthCheckCustomConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.ServiceTypeOption.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceeded(try ResourceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAlreadyExists" : self = .serviceAlreadyExists(try ServiceAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServiceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case resourceLimitExceeded(ResourceLimitExceeded)
    case serviceAlreadyExists(ServiceAlreadyExists)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.service = output.service
        } else {
            self.service = nil
        }
    }
}

public struct CreateServiceOutputResponse: Swift.Equatable {
    /// A complex type that contains information about the new service.
    public var service: ServiceDiscoveryClientTypes.Service?

    public init (
        service: ServiceDiscoveryClientTypes.Service? = nil
    )
    {
        self.service = service
    }
}

struct CreateServiceOutputResponseBody: Swift.Equatable {
    let service: ServiceDiscoveryClientTypes.Service?
}

extension CreateServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
    }
}

extension CustomHealthNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CustomHealthNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The health check for the instance that's specified by ServiceId and InstanceId isn't a custom health check.
public struct CustomHealthNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CustomHealthNotFoundBody: Swift.Equatable {
    let message: Swift.String?
}

extension CustomHealthNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    public enum CustomHealthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomHealthStatus] {
            return [
                .healthy,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomHealthStatus(rawValue: rawValue) ?? CustomHealthStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeleteNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteNamespaceInput: Swift.Equatable {
    /// The ID of the namespace that you want to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteNamespaceInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNamespaceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case resourceInUse(ResourceInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct DeleteNamespaceOutputResponse: Swift.Equatable {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the operation, see [GetOperation](https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html).
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct DeleteNamespaceOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension DeleteNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension DeleteServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteServiceInput: Swift.Equatable {
    /// The ID of the service that you want to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteServiceInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServiceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case resourceInUse(ResourceInUse)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServiceOutputResponse: Swift.Equatable {

}

extension DeregisterInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }
}

extension DeregisterInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeregisterInstanceInput: Swift.Equatable {
    /// The value that you specified for Id in the [RegisterInstance](https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html) request.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The ID of the service that the instance is associated with.
    /// This member is required.
    public var serviceId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.serviceId = serviceId
    }
}

struct DeregisterInstanceInputBody: Swift.Equatable {
    let serviceId: Swift.String?
    let instanceId: Swift.String?
}

extension DeregisterInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension DeregisterInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceNotFound" : self = .instanceNotFound(try InstanceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterInstanceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case instanceNotFound(InstanceNotFound)
    case invalidInput(InvalidInput)
    case resourceInUse(ResourceInUse)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeregisterInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct DeregisterInstanceOutputResponse: Swift.Equatable {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the operation, see [GetOperation](https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html).
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct DeregisterInstanceOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension DeregisterInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension DiscoverInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthStatus = "HealthStatus"
        case maxResults = "MaxResults"
        case namespaceName = "NamespaceName"
        case optionalParameters = "OptionalParameters"
        case queryParameters = "QueryParameters"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthStatus = healthStatus {
            try encodeContainer.encode(healthStatus.rawValue, forKey: .healthStatus)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let namespaceName = namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let optionalParameters = optionalParameters {
            var optionalParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .optionalParameters)
            for (dictKey0, attributes0) in optionalParameters {
                try optionalParametersContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let queryParameters = queryParameters {
            var queryParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .queryParameters)
            for (dictKey0, attributes0) in queryParameters {
                try queryParametersContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

extension DiscoverInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DiscoverInstancesInput: Swift.Equatable {
    /// The health status of the instances that you want to discover. This parameter is ignored for services that don't have a health check configured, and all instances are returned. HEALTHY Returns healthy instances. UNHEALTHY Returns unhealthy instances. ALL Returns all instances. HEALTHY_OR_ELSE_ALL Returns healthy instances, unless none are reporting a healthy state. In that case, return all instances. This is also called failing open.
    public var healthStatus: ServiceDiscoveryClientTypes.HealthStatusFilter?
    /// The maximum number of instances that you want Cloud Map to return in the response to a DiscoverInstances request. If you don't specify a value for MaxResults, Cloud Map returns up to 100 instances.
    public var maxResults: Swift.Int?
    /// The HttpName name of the namespace. It's found in the HttpProperties member of the Properties member of the namespace.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// Opportunistic filters to scope the results based on custom attributes. If there are instances that match both the filters specified in both the QueryParameters parameter and this parameter, all of these instances are returned. Otherwise, the filters are ignored, and only instances that match the filters that are specified in the QueryParameters parameter are returned.
    public var optionalParameters: [Swift.String:Swift.String]?
    /// Filters to scope the results based on custom attributes for the instance (for example, {version=v1, az=1a}). Only instances that match all the specified key-value pairs are returned.
    public var queryParameters: [Swift.String:Swift.String]?
    /// The name of the service that you specified when you registered the instance.
    /// This member is required.
    public var serviceName: Swift.String?

    public init (
        healthStatus: ServiceDiscoveryClientTypes.HealthStatusFilter? = nil,
        maxResults: Swift.Int? = nil,
        namespaceName: Swift.String? = nil,
        optionalParameters: [Swift.String:Swift.String]? = nil,
        queryParameters: [Swift.String:Swift.String]? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.healthStatus = healthStatus
        self.maxResults = maxResults
        self.namespaceName = namespaceName
        self.optionalParameters = optionalParameters
        self.queryParameters = queryParameters
        self.serviceName = serviceName
    }
}

struct DiscoverInstancesInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
    let serviceName: Swift.String?
    let maxResults: Swift.Int?
    let queryParameters: [Swift.String:Swift.String]?
    let optionalParameters: [Swift.String:Swift.String]?
    let healthStatus: ServiceDiscoveryClientTypes.HealthStatusFilter?
}

extension DiscoverInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthStatus = "HealthStatus"
        case maxResults = "MaxResults"
        case namespaceName = "NamespaceName"
        case optionalParameters = "OptionalParameters"
        case queryParameters = "QueryParameters"
        case serviceName = "ServiceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let queryParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .queryParameters)
        var queryParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let queryParametersContainer = queryParametersContainer {
            queryParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, attrvalue0) in queryParametersContainer {
                if let attrvalue0 = attrvalue0 {
                    queryParametersDecoded0?[key0] = attrvalue0
                }
            }
        }
        queryParameters = queryParametersDecoded0
        let optionalParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .optionalParameters)
        var optionalParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let optionalParametersContainer = optionalParametersContainer {
            optionalParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, attrvalue0) in optionalParametersContainer {
                if let attrvalue0 = attrvalue0 {
                    optionalParametersDecoded0?[key0] = attrvalue0
                }
            }
        }
        optionalParameters = optionalParametersDecoded0
        let healthStatusDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthStatusFilter.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
    }
}

extension DiscoverInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DiscoverInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestLimitExceeded" : self = .requestLimitExceeded(try RequestLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DiscoverInstancesOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case requestLimitExceeded(RequestLimitExceeded)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DiscoverInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DiscoverInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instances = output.instances
        } else {
            self.instances = nil
        }
    }
}

public struct DiscoverInstancesOutputResponse: Swift.Equatable {
    /// A complex type that contains one HttpInstanceSummary for each registered instance.
    public var instances: [ServiceDiscoveryClientTypes.HttpInstanceSummary]?

    public init (
        instances: [ServiceDiscoveryClientTypes.HttpInstanceSummary]? = nil
    )
    {
        self.instances = instances
    }
}

struct DiscoverInstancesOutputResponseBody: Swift.Equatable {
    let instances: [ServiceDiscoveryClientTypes.HttpInstanceSummary]?
}

extension DiscoverInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.HttpInstanceSummary?].self, forKey: .instances)
        var instancesDecoded0:[ServiceDiscoveryClientTypes.HttpInstanceSummary]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [ServiceDiscoveryClientTypes.HttpInstanceSummary]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
    }
}

extension ServiceDiscoveryClientTypes.DnsConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsRecords = "DnsRecords"
        case namespaceId = "NamespaceId"
        case routingPolicy = "RoutingPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsRecords = dnsRecords {
            var dnsRecordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsRecords)
            for dnsrecordlist0 in dnsRecords {
                try dnsRecordsContainer.encode(dnsrecordlist0)
            }
        }
        if let namespaceId = namespaceId {
            try encodeContainer.encode(namespaceId, forKey: .namespaceId)
        }
        if let routingPolicy = routingPolicy {
            try encodeContainer.encode(routingPolicy.rawValue, forKey: .routingPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
        let routingPolicyDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.RoutingPolicy.self, forKey: .routingPolicy)
        routingPolicy = routingPolicyDecoded
        let dnsRecordsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.DnsRecord?].self, forKey: .dnsRecords)
        var dnsRecordsDecoded0:[ServiceDiscoveryClientTypes.DnsRecord]? = nil
        if let dnsRecordsContainer = dnsRecordsContainer {
            dnsRecordsDecoded0 = [ServiceDiscoveryClientTypes.DnsRecord]()
            for structure0 in dnsRecordsContainer {
                if let structure0 = structure0 {
                    dnsRecordsDecoded0?.append(structure0)
                }
            }
        }
        dnsRecords = dnsRecordsDecoded0
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about the Amazon Route 53 DNS records that you want Cloud Map to create when you register an instance.
    public struct DnsConfig: Swift.Equatable {
        /// An array that contains one DnsRecord object for each Route 53 DNS record that you want Cloud Map to create when you register an instance.
        /// This member is required.
        public var dnsRecords: [ServiceDiscoveryClientTypes.DnsRecord]?
        /// The ID of the namespace to use for DNS configuration.
        @available(*, deprecated, message: "Top level attribute in request should be used to reference namespace-id")
        public var namespaceId: Swift.String?
        /// The routing policy that you want to apply to all Route 53 DNS records that Cloud Map creates when you register an instance and specify this service. If you want to use this service to register instances that create alias records, specify WEIGHTED for the routing policy. You can specify the following values: MULTIVALUE If you define a health check for the service and the health check is healthy, Route 53 returns the applicable value for up to eight instances. For example, suppose that the service includes configurations for one A record and a health check. You use the service to register 10 instances. Route 53 responds to DNS queries with IP addresses for up to eight healthy instances. If fewer than eight instances are healthy, Route 53 responds to every DNS query with the IP addresses for all of the healthy instances. If you don't define a health check for the service, Route 53 assumes that all instances are healthy and returns the values for up to eight instances. For more information about the multivalue routing policy, see [Multivalue Answer Routing](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-multivalue) in the Route 53 Developer Guide. WEIGHTED Route 53 returns the applicable value from one randomly selected instance from among the instances that you registered using the same service. Currently, all records have the same weight, so you can't route more or less traffic to any instances. For example, suppose that the service includes configurations for one A record and a health check. You use the service to register 10 instances. Route 53 responds to DNS queries with the IP address for one randomly selected instance from among the healthy instances. If no instances are healthy, Route 53 responds to DNS queries as if all of the instances were healthy. If you don't define a health check for the service, Route 53 assumes that all instances are healthy and returns the applicable value for one randomly selected instance. For more information about the weighted routing policy, see [Weighted Routing](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted) in the Route 53 Developer Guide.
        public var routingPolicy: ServiceDiscoveryClientTypes.RoutingPolicy?

        public init (
            dnsRecords: [ServiceDiscoveryClientTypes.DnsRecord]? = nil,
            namespaceId: Swift.String? = nil,
            routingPolicy: ServiceDiscoveryClientTypes.RoutingPolicy? = nil
        )
        {
            self.dnsRecords = dnsRecords
            self.namespaceId = namespaceId
            self.routingPolicy = routingPolicy
        }
    }

}

extension ServiceDiscoveryClientTypes.DnsConfigChange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsRecords = "DnsRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsRecords = dnsRecords {
            var dnsRecordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsRecords)
            for dnsrecordlist0 in dnsRecords {
                try dnsRecordsContainer.encode(dnsrecordlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnsRecordsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.DnsRecord?].self, forKey: .dnsRecords)
        var dnsRecordsDecoded0:[ServiceDiscoveryClientTypes.DnsRecord]? = nil
        if let dnsRecordsContainer = dnsRecordsContainer {
            dnsRecordsDecoded0 = [ServiceDiscoveryClientTypes.DnsRecord]()
            for structure0 in dnsRecordsContainer {
                if let structure0 = structure0 {
                    dnsRecordsDecoded0?.append(structure0)
                }
            }
        }
        dnsRecords = dnsRecordsDecoded0
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about changes to the Route 53 DNS records that Cloud Map creates when you register an instance.
    public struct DnsConfigChange: Swift.Equatable {
        /// An array that contains one DnsRecord object for each Route 53 record that you want Cloud Map to create when you register an instance.
        /// This member is required.
        public var dnsRecords: [ServiceDiscoveryClientTypes.DnsRecord]?

        public init (
            dnsRecords: [ServiceDiscoveryClientTypes.DnsRecord]? = nil
        )
        {
            self.dnsRecords = dnsRecords
        }
    }

}

extension ServiceDiscoveryClientTypes.DnsProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostedZoneId = "HostedZoneId"
        case sOA = "SOA"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostedZoneId = hostedZoneId {
            try encodeContainer.encode(hostedZoneId, forKey: .hostedZoneId)
        }
        if let sOA = sOA {
            try encodeContainer.encode(sOA, forKey: .sOA)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
        let sOADecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.SOA.self, forKey: .sOA)
        sOA = sOADecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains the ID for the Route 53 hosted zone that Cloud Map creates when you create a namespace.
    public struct DnsProperties: Swift.Equatable {
        /// The ID for the Route 53 hosted zone that Cloud Map creates when you create a namespace.
        public var hostedZoneId: Swift.String?
        /// Start of Authority (SOA) record for the hosted zone.
        public var sOA: ServiceDiscoveryClientTypes.SOA?

        public init (
            hostedZoneId: Swift.String? = nil,
            sOA: ServiceDiscoveryClientTypes.SOA? = nil
        )
        {
            self.hostedZoneId = hostedZoneId
            self.sOA = sOA
        }
    }

}

extension ServiceDiscoveryClientTypes.DnsRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tTL = "TTL"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tTL = tTL {
            try encodeContainer.encode(tTL, forKey: .tTL)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.RecordType.self, forKey: .type)
        type = typeDecoded
        let tTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tTL)
        tTL = tTLDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about the Route 53 DNS records that you want Cloud Map to create when you register an instance.
    public struct DnsRecord: Swift.Equatable {
        /// The amount of time, in seconds, that you want DNS resolvers to cache the settings for this record. Alias records don't include a TTL because Route 53 uses the TTL for the Amazon Web Services resource that an alias record routes traffic to. If you include the AWS_ALIAS_DNS_NAME attribute when you submit a [RegisterInstance](https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html) request, the TTL value is ignored. Always specify a TTL for the service; you can use a service to register instances that create either alias or non-alias records.
        /// This member is required.
        public var tTL: Swift.Int?
        /// The type of the resource, which indicates the type of value that Route 53 returns in response to DNS queries. You can specify values for Type in the following combinations:
        ///
        /// * A
        ///
        /// * AAAA
        ///
        /// * A and AAAA
        ///
        /// * SRV
        ///
        /// * CNAME
        ///
        ///
        /// If you want Cloud Map to create a Route 53 alias record when you register an instance, specify A or AAAA for Type. You specify other settings, such as the IP address for A and AAAA records, when you register an instance. For more information, see [RegisterInstance](https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html). The following values are supported: A Route 53 returns the IP address of the resource in IPv4 format, such as 192.0.2.44. AAAA Route 53 returns the IP address of the resource in IPv6 format, such as 2001:0db8:85a3:0000:0000:abcd:0001:2345. CNAME Route 53 returns the domain name of the resource, such as www.example.com. Note the following:
        ///
        /// * You specify the domain name that you want to route traffic to when you register an instance. For more information, see [Attributes](https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html#cloudmap-RegisterInstance-request-Attributes) in the topic [RegisterInstance](https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html).
        ///
        /// * You must specify WEIGHTED for the value of RoutingPolicy.
        ///
        /// * You can't specify both CNAME for Type and settings for HealthCheckConfig. If you do, the request will fail with an InvalidInput error.
        ///
        ///
        /// SRV Route 53 returns the value for an SRV record. The value for an SRV record uses the following values: priority weight port service-hostname Note the following about the values:
        ///
        /// * The values of priority and weight are both set to 1 and can't be changed.
        ///
        /// * The value of port comes from the value that you specify for the AWS_INSTANCE_PORT attribute when you submit a [RegisterInstance](https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html) request.
        ///
        /// * The value of service-hostname is a concatenation of the following values:
        ///
        /// * The value that you specify for InstanceId when you register an instance.
        ///
        /// * The name of the service.
        ///
        /// * The name of the namespace.
        ///
        ///
        /// For example, if the value of InstanceId is test, the name of the service is backend, and the name of the namespace is example.com, the value of service-hostname is the following: test.backend.example.com
        ///
        ///
        /// If you specify settings for an SRV record, note the following:
        ///
        /// * If you specify values for AWS_INSTANCE_IPV4, AWS_INSTANCE_IPV6, or both in the RegisterInstance request, Cloud Map automatically creates A and/or AAAA records that have the same name as the value of service-hostname in the SRV record. You can ignore these records.
        ///
        /// * If you're using a system that requires a specific SRV format, such as HAProxy, see the [Name](https://docs.aws.amazon.com/cloud-map/latest/api/API_CreateService.html#cloudmap-CreateService-request-Name) element in the documentation about CreateService for information about how to specify the correct name format.
        /// This member is required.
        public var type: ServiceDiscoveryClientTypes.RecordType?

        public init (
            tTL: Swift.Int? = nil,
            type: ServiceDiscoveryClientTypes.RecordType? = nil
        )
        {
            self.tTL = tTL
            self.type = type
        }
    }

}

extension DuplicateRequest {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DuplicateRequestBody = try responseDecoder.decode(responseBody: data)
            self.duplicateOperationId = output.duplicateOperationId
            self.message = output.message
        } else {
            self.duplicateOperationId = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation is already in progress.
public struct DuplicateRequest: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The ID of the operation that's already in progress.
    public var duplicateOperationId: Swift.String?
    public var message: Swift.String?

    public init (
        duplicateOperationId: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.duplicateOperationId = duplicateOperationId
        self.message = message
    }
}

struct DuplicateRequestBody: Swift.Equatable {
    let message: Swift.String?
    let duplicateOperationId: Swift.String?
}

extension DuplicateRequestBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duplicateOperationId = "DuplicateOperationId"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let duplicateOperationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .duplicateOperationId)
        duplicateOperationId = duplicateOperationIdDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    public enum FilterCondition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case between
        case eq
        case `in`
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterCondition] {
            return [
                .between,
                .eq,
                .in,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .eq: return "EQ"
            case .in: return "IN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterCondition(rawValue: rawValue) ?? FilterCondition.sdkUnknown(rawValue)
        }
    }
}

extension GetInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }
}

extension GetInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetInstanceInput: Swift.Equatable {
    /// The ID of the instance that you want to get information about.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The ID of the service that the instance is associated with.
    /// This member is required.
    public var serviceId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.serviceId = serviceId
    }
}

struct GetInstanceInputBody: Swift.Equatable {
    let serviceId: Swift.String?
    let instanceId: Swift.String?
}

extension GetInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension GetInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InstanceNotFound" : self = .instanceNotFound(try InstanceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInstanceOutputError: Swift.Error, Swift.Equatable {
    case instanceNotFound(InstanceNotFound)
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instance = output.instance
        } else {
            self.instance = nil
        }
    }
}

public struct GetInstanceOutputResponse: Swift.Equatable {
    /// A complex type that contains information about a specified instance.
    public var instance: ServiceDiscoveryClientTypes.Instance?

    public init (
        instance: ServiceDiscoveryClientTypes.Instance? = nil
    )
    {
        self.instance = instance
    }
}

struct GetInstanceOutputResponseBody: Swift.Equatable {
    let instance: ServiceDiscoveryClientTypes.Instance?
}

extension GetInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instance = "Instance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.Instance.self, forKey: .instance)
        instance = instanceDecoded
    }
}

extension GetInstancesHealthStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instances = instances {
            var instancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instances)
            for instanceidlist0 in instances {
                try instancesContainer.encode(instanceidlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }
}

extension GetInstancesHealthStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetInstancesHealthStatusInput: Swift.Equatable {
    /// An array that contains the IDs of all the instances that you want to get the health status for. If you omit Instances, Cloud Map returns the health status for all the instances that are associated with the specified service. To get the IDs for the instances that you've registered by using a specified service, submit a [ListInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_ListInstances.html) request.
    public var instances: [Swift.String]?
    /// The maximum number of instances that you want Cloud Map to return in the response to a GetInstancesHealthStatus request. If you don't specify a value for MaxResults, Cloud Map returns up to 100 instances.
    public var maxResults: Swift.Int?
    /// For the first GetInstancesHealthStatus request, omit this value. If more than MaxResults instances match the specified criteria, you can submit another GetInstancesHealthStatus request to get the next group of results. Specify the value of NextToken from the previous response in the next request.
    public var nextToken: Swift.String?
    /// The ID of the service that the instance is associated with.
    /// This member is required.
    public var serviceId: Swift.String?

    public init (
        instances: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.instances = instances
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceId = serviceId
    }
}

struct GetInstancesHealthStatusInputBody: Swift.Equatable {
    let serviceId: Swift.String?
    let instances: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension GetInstancesHealthStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let instancesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instances)
        var instancesDecoded0:[Swift.String]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [Swift.String]()
            for string0 in instancesContainer {
                if let string0 = string0 {
                    instancesDecoded0?.append(string0)
                }
            }
        }
        instances = instancesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetInstancesHealthStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInstancesHealthStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InstanceNotFound" : self = .instanceNotFound(try InstanceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInstancesHealthStatusOutputError: Swift.Error, Swift.Equatable {
    case instanceNotFound(InstanceNotFound)
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInstancesHealthStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetInstancesHealthStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.status = output.status
        } else {
            self.nextToken = nil
            self.status = nil
        }
    }
}

public struct GetInstancesHealthStatusOutputResponse: Swift.Equatable {
    /// If more than MaxResults instances match the specified criteria, you can submit another GetInstancesHealthStatus request to get the next group of results. Specify the value of NextToken from the previous response in the next request.
    public var nextToken: Swift.String?
    /// A complex type that contains the IDs and the health status of the instances that you specified in the GetInstancesHealthStatus request.
    public var status: [Swift.String:ServiceDiscoveryClientTypes.HealthStatus]?

    public init (
        nextToken: Swift.String? = nil,
        status: [Swift.String:ServiceDiscoveryClientTypes.HealthStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.status = status
    }
}

struct GetInstancesHealthStatusOutputResponseBody: Swift.Equatable {
    let status: [Swift.String:ServiceDiscoveryClientTypes.HealthStatus]?
    let nextToken: Swift.String?
}

extension GetInstancesHealthStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusContainer = try containerValues.decodeIfPresent([Swift.String: ServiceDiscoveryClientTypes.HealthStatus?].self, forKey: .status)
        var statusDecoded0: [Swift.String:ServiceDiscoveryClientTypes.HealthStatus]? = nil
        if let statusContainer = statusContainer {
            statusDecoded0 = [Swift.String:ServiceDiscoveryClientTypes.HealthStatus]()
            for (key0, healthstatus0) in statusContainer {
                if let healthstatus0 = healthstatus0 {
                    statusDecoded0?[key0] = healthstatus0
                }
            }
        }
        status = statusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension GetNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetNamespaceInput: Swift.Equatable {
    /// The ID of the namespace that you want to get information about.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetNamespaceInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension GetNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GetNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNamespaceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namespace = output.namespace
        } else {
            self.namespace = nil
        }
    }
}

public struct GetNamespaceOutputResponse: Swift.Equatable {
    /// A complex type that contains information about the specified namespace.
    public var namespace: ServiceDiscoveryClientTypes.Namespace?

    public init (
        namespace: ServiceDiscoveryClientTypes.Namespace? = nil
    )
    {
        self.namespace = namespace
    }
}

struct GetNamespaceOutputResponseBody: Swift.Equatable {
    let namespace: ServiceDiscoveryClientTypes.Namespace?
}

extension GetNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace = "Namespace"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.Namespace.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension GetOperationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operationId = operationId {
            try encodeContainer.encode(operationId, forKey: .operationId)
        }
    }
}

extension GetOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetOperationInput: Swift.Equatable {
    /// The ID of the operation that you want to get more information about.
    /// This member is required.
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct GetOperationInputBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension GetOperationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension GetOperationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOperationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotFound" : self = .operationNotFound(try OperationNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOperationOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case operationNotFound(OperationNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOperationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetOperationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operation = output.operation
        } else {
            self.operation = nil
        }
    }
}

public struct GetOperationOutputResponse: Swift.Equatable {
    /// A complex type that contains information about the operation.
    public var operation: ServiceDiscoveryClientTypes.Operation?

    public init (
        operation: ServiceDiscoveryClientTypes.Operation? = nil
    )
    {
        self.operation = operation
    }
}

struct GetOperationOutputResponseBody: Swift.Equatable {
    let operation: ServiceDiscoveryClientTypes.Operation?
}

extension GetOperationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operation = "Operation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.Operation.self, forKey: .operation)
        operation = operationDecoded
    }
}

extension GetServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension GetServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServiceInput: Swift.Equatable {
    /// The ID of the service that you want to get settings for.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetServiceInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension GetServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GetServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.service = output.service
        } else {
            self.service = nil
        }
    }
}

public struct GetServiceOutputResponse: Swift.Equatable {
    /// A complex type that contains information about the service.
    public var service: ServiceDiscoveryClientTypes.Service?

    public init (
        service: ServiceDiscoveryClientTypes.Service? = nil
    )
    {
        self.service = service
    }
}

struct GetServiceOutputResponseBody: Swift.Equatable {
    let service: ServiceDiscoveryClientTypes.Service?
}

extension GetServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
    }
}

extension ServiceDiscoveryClientTypes.HealthCheckConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureThreshold = "FailureThreshold"
        case resourcePath = "ResourcePath"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureThreshold = failureThreshold {
            try encodeContainer.encode(failureThreshold, forKey: .failureThreshold)
        }
        if let resourcePath = resourcePath {
            try encodeContainer.encode(resourcePath, forKey: .resourcePath)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckType.self, forKey: .type)
        type = typeDecoded
        let resourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourcePath)
        resourcePath = resourcePathDecoded
        let failureThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failureThreshold)
        failureThreshold = failureThresholdDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// Public DNS and HTTP namespaces only. A complex type that contains settings for an optional health check. If you specify settings for a health check, Cloud Map associates the health check with the records that you specify in DnsConfig. If you specify a health check configuration, you can specify either HealthCheckCustomConfig or HealthCheckConfig but not both. Health checks are basic Route 53 health checks that monitor an Amazon Web Services endpoint. For information about pricing for health checks, see [Amazon Route 53 Pricing](http://aws.amazon.com/route53/pricing/). Note the following about configuring health checks. A and AAAA records If DnsConfig includes configurations for both A and AAAA records, Cloud Map creates a health check that uses the IPv4 address to check the health of the resource. If the endpoint tthat's specified by the IPv4 address is unhealthy, Route 53 considers both the A and AAAA records to be unhealthy. CNAME records You can't specify settings for HealthCheckConfig when the DNSConfig includes CNAME for the value of Type. If you do, the CreateService request will fail with an InvalidInput error. Request interval A Route 53 health checker in each health-checking Amazon Web Services Region sends a health check request to an endpoint every 30 seconds. On average, your endpoint receives a health check request about every two seconds. However, health checkers don't coordinate with one another. Therefore, you might sometimes see several requests in one second that's followed by a few seconds with no health checks at all. Health checking regions Health checkers perform checks from all Route 53 health-checking Regions. For a list of the current Regions, see [Regions](https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-Regions). Alias records When you register an instance, if you include the AWS_ALIAS_DNS_NAME attribute, Cloud Map creates a Route 53 alias record. Note the following:
    ///
    /// * Route 53 automatically sets EvaluateTargetHealth to true for alias records. When EvaluateTargetHealth is true, the alias record inherits the health of the referenced Amazon Web Services resource. such as an ELB load balancer. For more information, see [EvaluateTargetHealth](https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html#Route53-Type-AliasTarget-EvaluateTargetHealth).
    ///
    /// * If you include HealthCheckConfig and then use the service to register an instance that creates an alias record, Route 53 doesn't create the health check.
    ///
    ///
    /// Charges for health checks Health checks are basic Route 53 health checks that monitor an Amazon Web Services endpoint. For information about pricing for health checks, see [Amazon Route 53 Pricing](http://aws.amazon.com/route53/pricing/).
    public struct HealthCheckConfig: Swift.Equatable {
        /// The number of consecutive health checks that an endpoint must pass or fail for Route 53 to change the current status of the endpoint from unhealthy to healthy or the other way around. For more information, see [How Route 53 Determines Whether an Endpoint Is Healthy](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html) in the Route 53 Developer Guide.
        public var failureThreshold: Swift.Int?
        /// The path that you want Route 53 to request when performing health checks. The path can be any value that your endpoint returns an HTTP status code of a 2xx or 3xx format for when the endpoint is healthy. An example file is /docs/route53-health-check.html. Route 53 automatically adds the DNS name for the service. If you don't specify a value for ResourcePath, the default value is /. If you specify TCP for Type, you must not specify a value for ResourcePath.
        public var resourcePath: Swift.String?
        /// The type of health check that you want to create, which indicates how Route 53 determines whether an endpoint is healthy. You can't change the value of Type after you create a health check. You can create the following types of health checks:
        ///
        /// * HTTP: Route 53 tries to establish a TCP connection. If successful, Route 53 submits an HTTP request and waits for an HTTP status code of 200 or greater and less than 400.
        ///
        /// * HTTPS: Route 53 tries to establish a TCP connection. If successful, Route 53 submits an HTTPS request and waits for an HTTP status code of 200 or greater and less than 400. If you specify HTTPS for the value of Type, the endpoint must support TLS v1.0 or later.
        ///
        /// * TCP: Route 53 tries to establish a TCP connection. If you specify TCP for Type, don't specify a value for ResourcePath.
        ///
        ///
        /// For more information, see [How Route 53 Determines Whether an Endpoint Is Healthy](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html) in the Route 53 Developer Guide.
        /// This member is required.
        public var type: ServiceDiscoveryClientTypes.HealthCheckType?

        public init (
            failureThreshold: Swift.Int? = nil,
            resourcePath: Swift.String? = nil,
            type: ServiceDiscoveryClientTypes.HealthCheckType? = nil
        )
        {
            self.failureThreshold = failureThreshold
            self.resourcePath = resourcePath
            self.type = type
        }
    }

}

extension ServiceDiscoveryClientTypes.HealthCheckCustomConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureThreshold = "FailureThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureThreshold = failureThreshold {
            try encodeContainer.encode(failureThreshold, forKey: .failureThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failureThreshold)
        failureThreshold = failureThresholdDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about an optional custom health check. A custom health check, which requires that you use a third-party health checker to evaluate the health of your resources, is useful in the following circumstances:
    ///
    /// * You can't use a health check that's defined by HealthCheckConfig because the resource isn't available over the internet. For example, you can use a custom health check when the instance is in an Amazon VPC. (To check the health of resources in a VPC, the health checker must also be in the VPC.)
    ///
    /// * You want to use a third-party health checker regardless of where your resources are located.
    ///
    ///
    /// If you specify a health check configuration, you can specify either HealthCheckCustomConfig or HealthCheckConfig but not both. To change the status of a custom health check, submit an UpdateInstanceCustomHealthStatus request. Cloud Map doesn't monitor the status of the resource, it just keeps a record of the status specified in the most recent UpdateInstanceCustomHealthStatus request. Here's how custom health checks work:
    ///
    /// * You create a service.
    ///
    /// * You register an instance.
    ///
    /// * You configure a third-party health checker to monitor the resource that's associated with the new instance. Cloud Map doesn't check the health of the resource directly.
    ///
    /// * The third-party health-checker determines that the resource is unhealthy and notifies your application.
    ///
    /// * Your application submits an UpdateInstanceCustomHealthStatus request.
    ///
    /// * Cloud Map waits for 30 seconds.
    ///
    /// * If another UpdateInstanceCustomHealthStatus request doesn't arrive during that time to change the status back to healthy, Cloud Map stops routing traffic to the resource.
    public struct HealthCheckCustomConfig: Swift.Equatable {
        /// This parameter is no longer supported and is always set to 1. Cloud Map waits for approximately 30 seconds after receiving an UpdateInstanceCustomHealthStatus request before changing the status of the service instance. The number of 30-second intervals that you want Cloud Map to wait after receiving an UpdateInstanceCustomHealthStatus request before it changes the health status of a service instance. Sending a second or subsequent UpdateInstanceCustomHealthStatus request with the same value before 30 seconds has passed doesn't accelerate the change. Cloud Map still waits 30 seconds after the first request to make the change.
        @available(*, deprecated, message: "Configurable FailureThreshold of HealthCheckCustomConfig is deprecated.  It will always have value 1.")
        public var failureThreshold: Swift.Int?

        public init (
            failureThreshold: Swift.Int? = nil
        )
        {
            self.failureThreshold = failureThreshold
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum HealthCheckType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http
        case https
        case tcp
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthCheckType] {
            return [
                .http,
                .https,
                .tcp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case .tcp: return "TCP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthCheckType(rawValue: rawValue) ?? HealthCheckType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes {
    public enum HealthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case unhealthy
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthStatus] {
            return [
                .healthy,
                .unhealthy,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthStatus(rawValue: rawValue) ?? HealthStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes {
    public enum HealthStatusFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case healthy
        case healthyOrElseAll
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthStatusFilter] {
            return [
                .all,
                .healthy,
                .healthyOrElseAll,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .healthy: return "HEALTHY"
            case .healthyOrElseAll: return "HEALTHY_OR_ELSE_ALL"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthStatusFilter(rawValue: rawValue) ?? HealthStatusFilter.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes.HttpInstanceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case healthStatus = "HealthStatus"
        case instanceId = "InstanceId"
        case namespaceName = "NamespaceName"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let healthStatus = healthStatus {
            try encodeContainer.encode(healthStatus.rawValue, forKey: .healthStatus)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let namespaceName = namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthStatus.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attrvalue0) in attributesContainer {
                if let attrvalue0 = attrvalue0 {
                    attributesDecoded0?[key0] = attrvalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ServiceDiscoveryClientTypes {
    /// In a response to a [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html) request, HttpInstanceSummary contains information about one instance that matches the values that you specified in the request.
    public struct HttpInstanceSummary: Swift.Equatable {
        /// If you included any attributes when you registered the instance, the values of those attributes.
        public var attributes: [Swift.String:Swift.String]?
        /// If you configured health checking in the service, the current health status of the service instance.
        public var healthStatus: ServiceDiscoveryClientTypes.HealthStatus?
        /// The ID of an instance that matches the values that you specified in the request.
        public var instanceId: Swift.String?
        /// The HttpName name of the namespace. It's found in the HttpProperties member of the Properties member of the namespace.
        public var namespaceName: Swift.String?
        /// The name of the service that you specified when you registered the instance.
        public var serviceName: Swift.String?

        public init (
            attributes: [Swift.String:Swift.String]? = nil,
            healthStatus: ServiceDiscoveryClientTypes.HealthStatus? = nil,
            instanceId: Swift.String? = nil,
            namespaceName: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.healthStatus = healthStatus
            self.instanceId = instanceId
            self.namespaceName = namespaceName
            self.serviceName = serviceName
        }
    }

}

extension ServiceDiscoveryClientTypes.HttpNamespaceChange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// Updated properties for the HTTP namespace.
    public struct HttpNamespaceChange: Swift.Equatable {
        /// An updated description for the HTTP namespace.
        /// This member is required.
        public var description: Swift.String?

        public init (
            description: Swift.String? = nil
        )
        {
            self.description = description
        }
    }

}

extension ServiceDiscoveryClientTypes.HttpProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpName = "HttpName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpName = httpName {
            try encodeContainer.encode(httpName, forKey: .httpName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpName)
        httpName = httpNameDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains the name of an HTTP namespace.
    public struct HttpProperties: Swift.Equatable {
        /// The name of an HTTP namespace.
        public var httpName: Swift.String?

        public init (
            httpName: Swift.String? = nil
        )
        {
            self.httpName = httpName
        }
    }

}

extension ServiceDiscoveryClientTypes.Instance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case creatorRequestId = "CreatorRequestId"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attrvalue0) in attributesContainer {
                if let attrvalue0 = attrvalue0 {
                    attributesDecoded0?[key0] = attrvalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about an instance that Cloud Map creates when you submit a RegisterInstance request.
    public struct Instance: Swift.Equatable {
        /// A string map that contains the following information for the service that you specify in ServiceId:
        ///
        /// * The attributes that apply to the records that are defined in the service.
        ///
        /// * For each attribute, the applicable value.
        ///
        ///
        /// Supported attribute keys include the following: AWS_ALIAS_DNS_NAME If you want Cloud Map to create a Route 53 alias record that routes traffic to an Elastic Load Balancing load balancer, specify the DNS name that's associated with the load balancer. For information about how to get the DNS name, see [AliasTarget->DNSName](https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html#Route53-Type-AliasTarget-DNSName) in the Route 53 API Reference. Note the following:
        ///
        /// * The configuration for the service that's specified by ServiceId must include settings for an A record, an AAAA record, or both.
        ///
        /// * In the service that's specified by ServiceId, the value of RoutingPolicy must be WEIGHTED.
        ///
        /// * If the service that's specified by ServiceId includes HealthCheckConfig settings, Cloud Map creates the health check, but it won't associate the health check with the alias record.
        ///
        /// * Auto naming currently doesn't support creating alias records that route traffic to Amazon Web Services resources other than ELB load balancers.
        ///
        /// * If you specify a value for AWS_ALIAS_DNS_NAME, don't specify values for any of the AWS_INSTANCE attributes.
        ///
        ///
        /// AWS_EC2_INSTANCE_ID HTTP namespaces only. The Amazon EC2 instance ID for the instance. The AWS_INSTANCE_IPV4 attribute contains the primary private IPv4 address. AWS_INIT_HEALTH_STATUS If the service configuration includes HealthCheckCustomConfig, you can optionally use AWS_INIT_HEALTH_STATUS to specify the initial status of the custom health check, HEALTHY or UNHEALTHY. If you don't specify a value for AWS_INIT_HEALTH_STATUS, the initial status is HEALTHY. AWS_INSTANCE_CNAME If the service configuration includes a CNAME record, the domain name that you want Route 53 to return in response to DNS queries (for example, example.com). This value is required if the service specified by ServiceId includes settings for an CNAME record. AWS_INSTANCE_IPV4 If the service configuration includes an A record, the IPv4 address that you want Route 53 to return in response to DNS queries (for example, 192.0.2.44). This value is required if the service specified by ServiceId includes settings for an A record. If the service includes settings for an SRV record, you must specify a value for AWS_INSTANCE_IPV4, AWS_INSTANCE_IPV6, or both. AWS_INSTANCE_IPV6 If the service configuration includes an AAAA record, the IPv6 address that you want Route 53 to return in response to DNS queries (for example, 2001:0db8:85a3:0000:0000:abcd:0001:2345). This value is required if the service specified by ServiceId includes settings for an AAAA record. If the service includes settings for an SRV record, you must specify a value for AWS_INSTANCE_IPV4, AWS_INSTANCE_IPV6, or both. AWS_INSTANCE_PORT If the service includes an SRV record, the value that you want Route 53 to return for the port. If the service includes HealthCheckConfig, the port on the endpoint that you want Route 53 to send requests to. This value is required if you specified settings for an SRV record or a Route 53 health check when you created the service.
        public var attributes: [Swift.String:Swift.String]?
        /// A unique string that identifies the request and that allows failed RegisterInstance requests to be retried without the risk of executing the operation twice. You must use a unique CreatorRequestId string every time you submit a RegisterInstance request if you're registering additional instances for the same namespace and service. CreatorRequestId can be any unique string (for example, a date/time stamp).
        public var creatorRequestId: Swift.String?
        /// An identifier that you want to associate with the instance. Note the following:
        ///
        /// * If the service that's specified by ServiceId includes settings for an SRV record, the value of InstanceId is automatically included as part of the value for the SRV record. For more information, see [DnsRecord > Type](https://docs.aws.amazon.com/cloud-map/latest/api/API_DnsRecord.html#cloudmap-Type-DnsRecord-Type).
        ///
        /// * You can use this value to update an existing instance.
        ///
        /// * To register a new instance, you must specify a value that's unique among instances that you register by using the same service.
        ///
        /// * If you specify an existing InstanceId and ServiceId, Cloud Map updates the existing DNS records. If there's also an existing health check, Cloud Map deletes the old health check and creates a new one. The health check isn't deleted immediately, so it will still appear for a while if you submit a ListHealthChecks request, for example.
        /// This member is required.
        public var id: Swift.String?

        public init (
            attributes: [Swift.String:Swift.String]? = nil,
            creatorRequestId: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.creatorRequestId = creatorRequestId
            self.id = id
        }
    }

}

extension InstanceNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InstanceNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// No instance exists with the specified ID, or the instance was recently registered, and information about the instance hasn't propagated yet.
public struct InstanceNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InstanceNotFoundBody: Swift.Equatable {
    let message: Swift.String?
}

extension InstanceNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceDiscoveryClientTypes.InstanceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attrvalue0) in attributesContainer {
                if let attrvalue0 = attrvalue0 {
                    attributesDecoded0?[key0] = attrvalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about the instances that you registered by using a specified service.
    public struct InstanceSummary: Swift.Equatable {
        /// A string map that contains the following information:
        ///
        /// * The attributes that are associated with the instance.
        ///
        /// * For each attribute, the applicable value.
        ///
        ///
        /// Supported attribute keys include the following: AWS_ALIAS_DNS_NAME For an alias record that routes traffic to an Elastic Load Balancing load balancer, the DNS name that's associated with the load balancer. AWS_EC2_INSTANCE_ID (HTTP namespaces only) The Amazon EC2 instance ID for the instance. When the AWS_EC2_INSTANCE_ID attribute is specified, then the AWS_INSTANCE_IPV4 attribute contains the primary private IPv4 address. AWS_INIT_HEALTH_STATUS If the service configuration includes HealthCheckCustomConfig, you can optionally use AWS_INIT_HEALTH_STATUS to specify the initial status of the custom health check, HEALTHY or UNHEALTHY. If you don't specify a value for AWS_INIT_HEALTH_STATUS, the initial status is HEALTHY. AWS_INSTANCE_CNAME For a CNAME record, the domain name that Route 53 returns in response to DNS queries (for example, example.com). AWS_INSTANCE_IPV4 For an A record, the IPv4 address that Route 53 returns in response to DNS queries (for example, 192.0.2.44). AWS_INSTANCE_IPV6 For an AAAA record, the IPv6 address that Route 53 returns in response to DNS queries (for example, 2001:0db8:85a3:0000:0000:abcd:0001:2345). AWS_INSTANCE_PORT For an SRV record, the value that Route 53 returns for the port. In addition, if the service includes HealthCheckConfig, the port on the endpoint that Route 53 sends requests to.
        public var attributes: [Swift.String:Swift.String]?
        /// The ID for an instance that you created by using a specified service.
        public var id: Swift.String?

        public init (
            attributes: [Swift.String:Swift.String]? = nil,
            id: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.id = id
        }
    }

}

extension InvalidInput {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more specified values aren't valid. For example, a required value might be missing, a numeric value might be outside the allowed range, or a string value might exceed length constraints.
public struct InvalidInput: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }
}

extension ListInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListInstancesInput: Swift.Equatable {
    /// The maximum number of instances that you want Cloud Map to return in the response to a ListInstances request. If you don't specify a value for MaxResults, Cloud Map returns up to 100 instances.
    public var maxResults: Swift.Int?
    /// For the first ListInstances request, omit this value. If more than MaxResults instances match the specified criteria, you can submit another ListInstances request to get the next group of results. Specify the value of NextToken from the previous response in the next request.
    public var nextToken: Swift.String?
    /// The ID of the service that you want to list instances for.
    /// This member is required.
    public var serviceId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceId = serviceId
    }
}

struct ListInstancesInputBody: Swift.Equatable {
    let serviceId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInstancesOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instances = output.instances
            self.nextToken = output.nextToken
        } else {
            self.instances = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstancesOutputResponse: Swift.Equatable {
    /// Summary information about the instances that are associated with the specified service.
    public var instances: [ServiceDiscoveryClientTypes.InstanceSummary]?
    /// If more than MaxResults instances match the specified criteria, you can submit another ListInstances request to get the next group of results. Specify the value of NextToken from the previous response in the next request.
    public var nextToken: Swift.String?

    public init (
        instances: [ServiceDiscoveryClientTypes.InstanceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instances = instances
        self.nextToken = nextToken
    }
}

struct ListInstancesOutputResponseBody: Swift.Equatable {
    let instances: [ServiceDiscoveryClientTypes.InstanceSummary]?
    let nextToken: Swift.String?
}

extension ListInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.InstanceSummary?].self, forKey: .instances)
        var instancesDecoded0:[ServiceDiscoveryClientTypes.InstanceSummary]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [ServiceDiscoveryClientTypes.InstanceSummary]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNamespacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for namespacefilters0 in filters {
                try filtersContainer.encode(namespacefilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListNamespacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListNamespacesInput: Swift.Equatable {
    /// A complex type that contains specifications for the namespaces that you want to list. If you specify more than one filter, a namespace must match all filters to be returned by ListNamespaces.
    public var filters: [ServiceDiscoveryClientTypes.NamespaceFilter]?
    /// The maximum number of namespaces that you want Cloud Map to return in the response to a ListNamespaces request. If you don't specify a value for MaxResults, Cloud Map returns up to 100 namespaces.
    public var maxResults: Swift.Int?
    /// For the first ListNamespaces request, omit this value. If the response contains NextToken, submit another ListNamespaces request to get the next group of results. Specify the value of NextToken from the previous response in the next request. Cloud Map gets MaxResults namespaces and then filters them based on the specified criteria. It's possible that no namespaces in the first MaxResults namespaces matched the specified criteria but that subsequent groups of MaxResults namespaces do contain namespaces that match the criteria.
    public var nextToken: Swift.String?

    public init (
        filters: [ServiceDiscoveryClientTypes.NamespaceFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNamespacesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ServiceDiscoveryClientTypes.NamespaceFilter]?
}

extension ListNamespacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.NamespaceFilter?].self, forKey: .filters)
        var filtersDecoded0:[ServiceDiscoveryClientTypes.NamespaceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ServiceDiscoveryClientTypes.NamespaceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListNamespacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNamespacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNamespacesOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNamespacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListNamespacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namespaces = output.namespaces
            self.nextToken = output.nextToken
        } else {
            self.namespaces = nil
            self.nextToken = nil
        }
    }
}

public struct ListNamespacesOutputResponse: Swift.Equatable {
    /// An array that contains one NamespaceSummary object for each namespace that matches the specified filter criteria.
    public var namespaces: [ServiceDiscoveryClientTypes.NamespaceSummary]?
    /// If the response contains NextToken, submit another ListNamespaces request to get the next group of results. Specify the value of NextToken from the previous response in the next request. Cloud Map gets MaxResults namespaces and then filters them based on the specified criteria. It's possible that no namespaces in the first MaxResults namespaces matched the specified criteria but that subsequent groups of MaxResults namespaces do contain namespaces that match the criteria.
    public var nextToken: Swift.String?

    public init (
        namespaces: [ServiceDiscoveryClientTypes.NamespaceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.namespaces = namespaces
        self.nextToken = nextToken
    }
}

struct ListNamespacesOutputResponseBody: Swift.Equatable {
    let namespaces: [ServiceDiscoveryClientTypes.NamespaceSummary]?
    let nextToken: Swift.String?
}

extension ListNamespacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaces = "Namespaces"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespacesContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.NamespaceSummary?].self, forKey: .namespaces)
        var namespacesDecoded0:[ServiceDiscoveryClientTypes.NamespaceSummary]? = nil
        if let namespacesContainer = namespacesContainer {
            namespacesDecoded0 = [ServiceDiscoveryClientTypes.NamespaceSummary]()
            for structure0 in namespacesContainer {
                if let structure0 = structure0 {
                    namespacesDecoded0?.append(structure0)
                }
            }
        }
        namespaces = namespacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOperationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for operationfilters0 in filters {
                try filtersContainer.encode(operationfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListOperationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListOperationsInput: Swift.Equatable {
    /// A complex type that contains specifications for the operations that you want to list, for example, operations that you started between a specified start date and end date. If you specify more than one filter, an operation must match all filters to be returned by ListOperations.
    public var filters: [ServiceDiscoveryClientTypes.OperationFilter]?
    /// The maximum number of items that you want Cloud Map to return in the response to a ListOperations request. If you don't specify a value for MaxResults, Cloud Map returns up to 100 operations.
    public var maxResults: Swift.Int?
    /// For the first ListOperations request, omit this value. If the response contains NextToken, submit another ListOperations request to get the next group of results. Specify the value of NextToken from the previous response in the next request. Cloud Map gets MaxResults operations and then filters them based on the specified criteria. It's possible that no operations in the first MaxResults operations matched the specified criteria but that subsequent groups of MaxResults operations do contain operations that match the criteria.
    public var nextToken: Swift.String?

    public init (
        filters: [ServiceDiscoveryClientTypes.OperationFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOperationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ServiceDiscoveryClientTypes.OperationFilter]?
}

extension ListOperationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.OperationFilter?].self, forKey: .filters)
        var filtersDecoded0:[ServiceDiscoveryClientTypes.OperationFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ServiceDiscoveryClientTypes.OperationFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListOperationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOperationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOperationsOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOperationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOperationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.operations = output.operations
        } else {
            self.nextToken = nil
            self.operations = nil
        }
    }
}

public struct ListOperationsOutputResponse: Swift.Equatable {
    /// If the response contains NextToken, submit another ListOperations request to get the next group of results. Specify the value of NextToken from the previous response in the next request. Cloud Map gets MaxResults operations and then filters them based on the specified criteria. It's possible that no operations in the first MaxResults operations matched the specified criteria but that subsequent groups of MaxResults operations do contain operations that match the criteria.
    public var nextToken: Swift.String?
    /// Summary information about the operations that match the specified criteria.
    public var operations: [ServiceDiscoveryClientTypes.OperationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        operations: [ServiceDiscoveryClientTypes.OperationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.operations = operations
    }
}

struct ListOperationsOutputResponseBody: Swift.Equatable {
    let operations: [ServiceDiscoveryClientTypes.OperationSummary]?
    let nextToken: Swift.String?
}

extension ListOperationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case operations = "Operations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.OperationSummary?].self, forKey: .operations)
        var operationsDecoded0:[ServiceDiscoveryClientTypes.OperationSummary]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [ServiceDiscoveryClientTypes.OperationSummary]()
            for structure0 in operationsContainer {
                if let structure0 = structure0 {
                    operationsDecoded0?.append(structure0)
                }
            }
        }
        operations = operationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServicesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for servicefilters0 in filters {
                try filtersContainer.encode(servicefilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListServicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServicesInput: Swift.Equatable {
    /// A complex type that contains specifications for the namespaces that you want to list services for. If you specify more than one filter, an operation must match all filters to be returned by ListServices.
    public var filters: [ServiceDiscoveryClientTypes.ServiceFilter]?
    /// The maximum number of services that you want Cloud Map to return in the response to a ListServices request. If you don't specify a value for MaxResults, Cloud Map returns up to 100 services.
    public var maxResults: Swift.Int?
    /// For the first ListServices request, omit this value. If the response contains NextToken, submit another ListServices request to get the next group of results. Specify the value of NextToken from the previous response in the next request. Cloud Map gets MaxResults services and then filters them based on the specified criteria. It's possible that no services in the first MaxResults services matched the specified criteria but that subsequent groups of MaxResults services do contain services that match the criteria.
    public var nextToken: Swift.String?

    public init (
        filters: [ServiceDiscoveryClientTypes.ServiceFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServicesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ServiceDiscoveryClientTypes.ServiceFilter]?
}

extension ListServicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.ServiceFilter?].self, forKey: .filters)
        var filtersDecoded0:[ServiceDiscoveryClientTypes.ServiceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ServiceDiscoveryClientTypes.ServiceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListServicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServicesOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.services = output.services
        } else {
            self.nextToken = nil
            self.services = nil
        }
    }
}

public struct ListServicesOutputResponse: Swift.Equatable {
    /// If the response contains NextToken, submit another ListServices request to get the next group of results. Specify the value of NextToken from the previous response in the next request. Cloud Map gets MaxResults services and then filters them based on the specified criteria. It's possible that no services in the first MaxResults services matched the specified criteria but that subsequent groups of MaxResults services do contain services that match the criteria.
    public var nextToken: Swift.String?
    /// An array that contains one ServiceSummary object for each service that matches the specified filter criteria.
    public var services: [ServiceDiscoveryClientTypes.ServiceSummary]?

    public init (
        nextToken: Swift.String? = nil,
        services: [ServiceDiscoveryClientTypes.ServiceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.services = services
    }
}

struct ListServicesOutputResponseBody: Swift.Equatable {
    let services: [ServiceDiscoveryClientTypes.ServiceSummary]?
    let nextToken: Swift.String?
}

extension ListServicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case services = "Services"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let servicesContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.ServiceSummary?].self, forKey: .services)
        var servicesDecoded0:[ServiceDiscoveryClientTypes.ServiceSummary]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [ServiceDiscoveryClientTypes.ServiceSummary]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags that are assigned to the resource.
    public var tags: [ServiceDiscoveryClientTypes.Tag]?

    public init (
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [ServiceDiscoveryClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ServiceDiscoveryClientTypes.Namespace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case properties = "Properties"
        case serviceCount = "ServiceCount"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
        if let serviceCount = serviceCount {
            try encodeContainer.encode(serviceCount, forKey: .serviceCount)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.NamespaceType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serviceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serviceCount)
        serviceCount = serviceCountDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.NamespaceProperties.self, forKey: .properties)
        properties = propertiesDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about a specified namespace.
    public struct Namespace: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that Cloud Map assigns to the namespace when you create it.
        public var arn: Swift.String?
        /// The date that the namespace was created, in Unix date/time format and Coordinated Universal Time (UTC). The value of CreateDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var createDate: ClientRuntime.Date?
        /// A unique string that identifies the request and that allows failed requests to be retried without the risk of running an operation twice.
        public var creatorRequestId: Swift.String?
        /// The description that you specify for the namespace when you create it.
        public var description: Swift.String?
        /// The ID of a namespace.
        public var id: Swift.String?
        /// The name of the namespace, such as example.com.
        public var name: Swift.String?
        /// A complex type that contains information that's specific to the type of the namespace.
        public var properties: ServiceDiscoveryClientTypes.NamespaceProperties?
        /// The number of services that are associated with the namespace.
        public var serviceCount: Swift.Int?
        /// The type of the namespace. The methods for discovering instances depends on the value that you specify: HTTP Instances can be discovered only programmatically, using the Cloud Map DiscoverInstances API. DNS_PUBLIC Instances can be discovered using public DNS queries and using the DiscoverInstances API. DNS_PRIVATE Instances can be discovered using DNS queries in VPCs and using the DiscoverInstances API.
        public var type: ServiceDiscoveryClientTypes.NamespaceType?

        public init (
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: ServiceDiscoveryClientTypes.NamespaceProperties? = nil,
            serviceCount: Swift.Int? = nil,
            type: ServiceDiscoveryClientTypes.NamespaceType? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.creatorRequestId = creatorRequestId
            self.description = description
            self.id = id
            self.name = name
            self.properties = properties
            self.serviceCount = serviceCount
            self.type = type
        }
    }

}

extension NamespaceAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NamespaceAlreadyExistsBody = try responseDecoder.decode(responseBody: data)
            self.creatorRequestId = output.creatorRequestId
            self.message = output.message
            self.namespaceId = output.namespaceId
        } else {
            self.creatorRequestId = nil
            self.message = nil
            self.namespaceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The namespace that you're trying to create already exists.
public struct NamespaceAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The CreatorRequestId that was used to create the namespace.
    public var creatorRequestId: Swift.String?
    public var message: Swift.String?
    /// The ID of the existing namespace.
    public var namespaceId: Swift.String?

    public init (
        creatorRequestId: Swift.String? = nil,
        message: Swift.String? = nil,
        namespaceId: Swift.String? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.message = message
        self.namespaceId = namespaceId
    }
}

struct NamespaceAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
    let creatorRequestId: Swift.String?
    let namespaceId: Swift.String?
}

extension NamespaceAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case message = "Message"
        case namespaceId = "NamespaceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let namespaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
    }
}

extension ServiceDiscoveryClientTypes.NamespaceFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition = "Condition"
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.NamespaceFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.FilterCondition.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that identifies the namespaces that you want to list. You can choose to list public or private namespaces.
    public struct NamespaceFilter: Swift.Equatable {
        /// The operator that you want to use to determine whether ListNamespaces returns a namespace. Valid values for condition include: EQ When you specify EQ for the condition, you can choose to list only public namespaces or private namespaces, but not both. EQ is the default condition and can be omitted. IN When you specify IN for the condition, you can choose to list public namespaces, private namespaces, or both. BETWEEN Not applicable
        public var condition: ServiceDiscoveryClientTypes.FilterCondition?
        /// Specify TYPE.
        /// This member is required.
        public var name: ServiceDiscoveryClientTypes.NamespaceFilterName?
        /// If you specify EQ for Condition, specify either DNS_PUBLIC or DNS_PRIVATE. If you specify IN for Condition, you can specify DNS_PUBLIC, DNS_PRIVATE, or both.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            condition: ServiceDiscoveryClientTypes.FilterCondition? = nil,
            name: ServiceDiscoveryClientTypes.NamespaceFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.values = values
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum NamespaceFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case type
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceFilterName] {
            return [
                .type,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .type: return "TYPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NamespaceFilterName(rawValue: rawValue) ?? NamespaceFilterName.sdkUnknown(rawValue)
        }
    }
}

extension NamespaceNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NamespaceNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// No namespace exists with the specified ID.
public struct NamespaceNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NamespaceNotFoundBody: Swift.Equatable {
    let message: Swift.String?
}

extension NamespaceNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceDiscoveryClientTypes.NamespaceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsProperties = "DnsProperties"
        case httpProperties = "HttpProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsProperties = dnsProperties {
            try encodeContainer.encode(dnsProperties, forKey: .dnsProperties)
        }
        if let httpProperties = httpProperties {
            try encodeContainer.encode(httpProperties, forKey: .httpProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnsPropertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.DnsProperties.self, forKey: .dnsProperties)
        dnsProperties = dnsPropertiesDecoded
        let httpPropertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HttpProperties.self, forKey: .httpProperties)
        httpProperties = httpPropertiesDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information that's specific to the namespace type.
    public struct NamespaceProperties: Swift.Equatable {
        /// A complex type that contains the ID for the Route 53 hosted zone that Cloud Map creates when you create a namespace.
        public var dnsProperties: ServiceDiscoveryClientTypes.DnsProperties?
        /// A complex type that contains the name of an HTTP namespace.
        public var httpProperties: ServiceDiscoveryClientTypes.HttpProperties?

        public init (
            dnsProperties: ServiceDiscoveryClientTypes.DnsProperties? = nil,
            httpProperties: ServiceDiscoveryClientTypes.HttpProperties? = nil
        )
        {
            self.dnsProperties = dnsProperties
            self.httpProperties = httpProperties
        }
    }

}

extension ServiceDiscoveryClientTypes.NamespaceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case properties = "Properties"
        case serviceCount = "ServiceCount"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
        if let serviceCount = serviceCount {
            try encodeContainer.encode(serviceCount, forKey: .serviceCount)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.NamespaceType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serviceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serviceCount)
        serviceCount = serviceCountDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.NamespaceProperties.self, forKey: .properties)
        properties = propertiesDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about a namespace.
    public struct NamespaceSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that Cloud Map assigns to the namespace when you create it.
        public var arn: Swift.String?
        /// The date and time that the namespace was created.
        public var createDate: ClientRuntime.Date?
        /// A description for the namespace.
        public var description: Swift.String?
        /// The ID of the namespace.
        public var id: Swift.String?
        /// The name of the namespace. When you create a namespace, Cloud Map automatically creates a Route 53 hosted zone that has the same name as the namespace.
        public var name: Swift.String?
        /// The properties of the namespace.
        public var properties: ServiceDiscoveryClientTypes.NamespaceProperties?
        /// The number of services that were created using the namespace.
        public var serviceCount: Swift.Int?
        /// The type of the namespace, either public or private.
        public var type: ServiceDiscoveryClientTypes.NamespaceType?

        public init (
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: ServiceDiscoveryClientTypes.NamespaceProperties? = nil,
            serviceCount: Swift.Int? = nil,
            type: ServiceDiscoveryClientTypes.NamespaceType? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.description = description
            self.id = id
            self.name = name
            self.properties = properties
            self.serviceCount = serviceCount
            self.type = type
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum NamespaceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dnsPrivate
        case dnsPublic
        case http
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceType] {
            return [
                .dnsPrivate,
                .dnsPublic,
                .http,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dnsPrivate: return "DNS_PRIVATE"
            case .dnsPublic: return "DNS_PUBLIC"
            case .http: return "HTTP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NamespaceType(rawValue: rawValue) ?? NamespaceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes.Operation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case id = "Id"
        case status = "Status"
        case targets = "Targets"
        case type = "Type"
        case updateDate = "UpdateDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, operationtargetsmap0) in targets {
                try targetsContainer.encode(operationtargetsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updateDate = updateDate {
            try encodeContainer.encode(updateDate.timeIntervalSince1970, forKey: .updateDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.OperationType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.OperationStatus.self, forKey: .status)
        status = statusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let updateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDate)
        updateDate = updateDateDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:Swift.String]()
            for (key0, resourceid0) in targetsContainer {
                if let resourceid0 = resourceid0 {
                    targetsDecoded0?[key0] = resourceid0
                }
            }
        }
        targets = targetsDecoded0
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about a specified operation.
    public struct Operation: Swift.Equatable {
        /// The date and time that the request was submitted, in Unix date/time format and Coordinated Universal Time (UTC). The value of CreateDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var createDate: ClientRuntime.Date?
        /// The code associated with ErrorMessage. Values for ErrorCode include the following:
        ///
        /// * ACCESS_DENIED
        ///
        /// * CANNOT_CREATE_HOSTED_ZONE
        ///
        /// * EXPIRED_TOKEN
        ///
        /// * HOSTED_ZONE_NOT_FOUND
        ///
        /// * INTERNAL_FAILURE
        ///
        /// * INVALID_CHANGE_BATCH
        ///
        /// * THROTTLED_REQUEST
        public var errorCode: Swift.String?
        /// If the value of Status is FAIL, the reason that the operation failed.
        public var errorMessage: Swift.String?
        /// The ID of the operation that you want to get information about.
        public var id: Swift.String?
        /// The status of the operation. Values include the following: SUBMITTED This is the initial state that occurs immediately after you submit a request. PENDING Cloud Map is performing the operation. SUCCESS The operation succeeded. FAIL The operation failed. For the failure reason, see ErrorMessage.
        public var status: ServiceDiscoveryClientTypes.OperationStatus?
        /// The name of the target entity that's associated with the operation: NAMESPACE The namespace ID is returned in the ResourceId property. SERVICE The service ID is returned in the ResourceId property. INSTANCE The instance ID is returned in the ResourceId property.
        public var targets: [Swift.String:Swift.String]?
        /// The name of the operation that's associated with the specified ID.
        public var type: ServiceDiscoveryClientTypes.OperationType?
        /// The date and time that the value of Status changed to the current value, in Unix date/time format and Coordinated Universal Time (UTC). The value of UpdateDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var updateDate: ClientRuntime.Date?

        public init (
            createDate: ClientRuntime.Date? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil,
            status: ServiceDiscoveryClientTypes.OperationStatus? = nil,
            targets: [Swift.String:Swift.String]? = nil,
            type: ServiceDiscoveryClientTypes.OperationType? = nil,
            updateDate: ClientRuntime.Date? = nil
        )
        {
            self.createDate = createDate
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
            self.status = status
            self.targets = targets
            self.type = type
            self.updateDate = updateDate
        }
    }

}

extension ServiceDiscoveryClientTypes.OperationFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition = "Condition"
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.OperationFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.FilterCondition.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that lets you select the operations that you want to list.
    public struct OperationFilter: Swift.Equatable {
        /// The operator that you want to use to determine whether an operation matches the specified value. Valid values for condition include:
        ///
        /// * EQ: When you specify EQ for the condition, you can specify only one value. EQ is supported for NAMESPACE_ID, SERVICE_ID, STATUS, and TYPE. EQ is the default condition and can be omitted.
        ///
        /// * IN: When you specify IN for the condition, you can specify a list of one or more values. IN is supported for STATUS and TYPE. An operation must match one of the specified values to be returned in the response.
        ///
        /// * BETWEEN: Specify a start date and an end date in Unix date/time format and Coordinated Universal Time (UTC). The start date must be the first value. BETWEEN is supported for UPDATE_DATE.
        public var condition: ServiceDiscoveryClientTypes.FilterCondition?
        /// Specify the operations that you want to get:
        ///
        /// * NAMESPACE_ID: Gets operations related to specified namespaces.
        ///
        /// * SERVICE_ID: Gets operations related to specified services.
        ///
        /// * STATUS: Gets operations based on the status of the operations: SUBMITTED, PENDING, SUCCEED, or FAIL.
        ///
        /// * TYPE: Gets specified types of operation.
        ///
        /// * UPDATE_DATE: Gets operations that changed status during a specified date/time range.
        /// This member is required.
        public var name: ServiceDiscoveryClientTypes.OperationFilterName?
        /// Specify values that are applicable to the value that you specify for Name:
        ///
        /// * NAMESPACE_ID: Specify one namespace ID.
        ///
        /// * SERVICE_ID: Specify one service ID.
        ///
        /// * STATUS: Specify one or more statuses: SUBMITTED, PENDING, SUCCEED, or FAIL.
        ///
        /// * TYPE: Specify one or more of the following types: CREATE_NAMESPACE, DELETE_NAMESPACE, UPDATE_SERVICE, REGISTER_INSTANCE, or DEREGISTER_INSTANCE.
        ///
        /// * UPDATE_DATE: Specify a start date and an end date in Unix date/time format and Coordinated Universal Time (UTC). The start date must be the first value.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            condition: ServiceDiscoveryClientTypes.FilterCondition? = nil,
            name: ServiceDiscoveryClientTypes.OperationFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.values = values
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum OperationFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case namespaceId
        case serviceId
        case status
        case type
        case updateDate
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationFilterName] {
            return [
                .namespaceId,
                .serviceId,
                .status,
                .type,
                .updateDate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .namespaceId: return "NAMESPACE_ID"
            case .serviceId: return "SERVICE_ID"
            case .status: return "STATUS"
            case .type: return "TYPE"
            case .updateDate: return "UPDATE_DATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationFilterName(rawValue: rawValue) ?? OperationFilterName.sdkUnknown(rawValue)
        }
    }
}

extension OperationNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OperationNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// No operation exists with the specified ID.
public struct OperationNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotFoundBody: Swift.Equatable {
    let message: Swift.String?
}

extension OperationNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    public enum OperationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fail
        case pending
        case submitted
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationStatus] {
            return [
                .fail,
                .pending,
                .submitted,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fail: return "FAIL"
            case .pending: return "PENDING"
            case .submitted: return "SUBMITTED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationStatus(rawValue: rawValue) ?? OperationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes.OperationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.OperationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about an operation that matches the criteria that you specified in a [ListOperations](https://docs.aws.amazon.com/cloud-map/latest/api/API_ListOperations.html) request.
    public struct OperationSummary: Swift.Equatable {
        /// The ID for an operation.
        public var id: Swift.String?
        /// The status of the operation. Values include the following:
        ///
        /// * SUBMITTED: This is the initial state immediately after you submit a request.
        ///
        /// * PENDING: Cloud Map is performing the operation.
        ///
        /// * SUCCESS: The operation succeeded.
        ///
        /// * FAIL: The operation failed. For the failure reason, see ErrorMessage.
        public var status: ServiceDiscoveryClientTypes.OperationStatus?

        public init (
            id: Swift.String? = nil,
            status: ServiceDiscoveryClientTypes.OperationStatus? = nil
        )
        {
            self.id = id
            self.status = status
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum OperationTargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case instance
        case namespace
        case service
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationTargetType] {
            return [
                .instance,
                .namespace,
                .service,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .instance: return "INSTANCE"
            case .namespace: return "NAMESPACE"
            case .service: return "SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationTargetType(rawValue: rawValue) ?? OperationTargetType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes {
    public enum OperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createNamespace
        case deleteNamespace
        case deregisterInstance
        case registerInstance
        case updateNamespace
        case updateService
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationType] {
            return [
                .createNamespace,
                .deleteNamespace,
                .deregisterInstance,
                .registerInstance,
                .updateNamespace,
                .updateService,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createNamespace: return "CREATE_NAMESPACE"
            case .deleteNamespace: return "DELETE_NAMESPACE"
            case .deregisterInstance: return "DEREGISTER_INSTANCE"
            case .registerInstance: return "REGISTER_INSTANCE"
            case .updateNamespace: return "UPDATE_NAMESPACE"
            case .updateService: return "UPDATE_SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationType(rawValue: rawValue) ?? OperationType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes.PrivateDnsNamespaceChange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case properties = "Properties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.PrivateDnsNamespacePropertiesChange.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// Updated properties for the private DNS namespace.
    public struct PrivateDnsNamespaceChange: Swift.Equatable {
        /// An updated description for the private DNS namespace.
        public var description: Swift.String?
        /// Properties to be updated in the private DNS namespace.
        public var properties: ServiceDiscoveryClientTypes.PrivateDnsNamespacePropertiesChange?

        public init (
            description: Swift.String? = nil,
            properties: ServiceDiscoveryClientTypes.PrivateDnsNamespacePropertiesChange? = nil
        )
        {
            self.description = description
            self.properties = properties
        }
    }

}

extension ServiceDiscoveryClientTypes.PrivateDnsNamespaceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsProperties = "DnsProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsProperties = dnsProperties {
            try encodeContainer.encode(dnsProperties, forKey: .dnsProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnsPropertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutable.self, forKey: .dnsProperties)
        dnsProperties = dnsPropertiesDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// DNS properties for the private DNS namespace.
    public struct PrivateDnsNamespaceProperties: Swift.Equatable {
        /// DNS properties for the private DNS namespace.
        /// This member is required.
        public var dnsProperties: ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutable?

        public init (
            dnsProperties: ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutable? = nil
        )
        {
            self.dnsProperties = dnsProperties
        }
    }

}

extension ServiceDiscoveryClientTypes.PrivateDnsNamespacePropertiesChange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsProperties = "DnsProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsProperties = dnsProperties {
            try encodeContainer.encode(dnsProperties, forKey: .dnsProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnsPropertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutableChange.self, forKey: .dnsProperties)
        dnsProperties = dnsPropertiesDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// Updated properties for the private DNS namespace.
    public struct PrivateDnsNamespacePropertiesChange: Swift.Equatable {
        /// Updated DNS properties for the private DNS namespace.
        /// This member is required.
        public var dnsProperties: ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutableChange?

        public init (
            dnsProperties: ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutableChange? = nil
        )
        {
            self.dnsProperties = dnsProperties
        }
    }

}

extension ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutable: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sOA = "SOA"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sOA = sOA {
            try encodeContainer.encode(sOA, forKey: .sOA)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sOADecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.SOA.self, forKey: .sOA)
        sOA = sOADecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// DNS properties for the private DNS namespace.
    public struct PrivateDnsPropertiesMutable: Swift.Equatable {
        /// Fields for the Start of Authority (SOA) record for the hosted zone for the private DNS namespace.
        /// This member is required.
        public var sOA: ServiceDiscoveryClientTypes.SOA?

        public init (
            sOA: ServiceDiscoveryClientTypes.SOA? = nil
        )
        {
            self.sOA = sOA
        }
    }

}

extension ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutableChange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sOA = "SOA"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sOA = sOA {
            try encodeContainer.encode(sOA, forKey: .sOA)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sOADecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.SOAChange.self, forKey: .sOA)
        sOA = sOADecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// Updated DNS properties for the private DNS namespace.
    public struct PrivateDnsPropertiesMutableChange: Swift.Equatable {
        /// Updated fields for the Start of Authority (SOA) record for the hosted zone for the private DNS namespace.
        /// This member is required.
        public var sOA: ServiceDiscoveryClientTypes.SOAChange?

        public init (
            sOA: ServiceDiscoveryClientTypes.SOAChange? = nil
        )
        {
            self.sOA = sOA
        }
    }

}

extension ServiceDiscoveryClientTypes.PublicDnsNamespaceChange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case properties = "Properties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.PublicDnsNamespacePropertiesChange.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// Updated properties for the public DNS namespace.
    public struct PublicDnsNamespaceChange: Swift.Equatable {
        /// An updated description for the public DNS namespace.
        public var description: Swift.String?
        /// Properties to be updated in the public DNS namespace.
        public var properties: ServiceDiscoveryClientTypes.PublicDnsNamespacePropertiesChange?

        public init (
            description: Swift.String? = nil,
            properties: ServiceDiscoveryClientTypes.PublicDnsNamespacePropertiesChange? = nil
        )
        {
            self.description = description
            self.properties = properties
        }
    }

}

extension ServiceDiscoveryClientTypes.PublicDnsNamespaceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsProperties = "DnsProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsProperties = dnsProperties {
            try encodeContainer.encode(dnsProperties, forKey: .dnsProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnsPropertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.PublicDnsPropertiesMutable.self, forKey: .dnsProperties)
        dnsProperties = dnsPropertiesDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// DNS properties for the public DNS namespace.
    public struct PublicDnsNamespaceProperties: Swift.Equatable {
        /// DNS properties for the public DNS namespace.
        /// This member is required.
        public var dnsProperties: ServiceDiscoveryClientTypes.PublicDnsPropertiesMutable?

        public init (
            dnsProperties: ServiceDiscoveryClientTypes.PublicDnsPropertiesMutable? = nil
        )
        {
            self.dnsProperties = dnsProperties
        }
    }

}

extension ServiceDiscoveryClientTypes.PublicDnsNamespacePropertiesChange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsProperties = "DnsProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsProperties = dnsProperties {
            try encodeContainer.encode(dnsProperties, forKey: .dnsProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnsPropertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.PublicDnsPropertiesMutableChange.self, forKey: .dnsProperties)
        dnsProperties = dnsPropertiesDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// Updated properties for the public DNS namespace.
    public struct PublicDnsNamespacePropertiesChange: Swift.Equatable {
        /// Updated DNS properties for the hosted zone for the public DNS namespace.
        /// This member is required.
        public var dnsProperties: ServiceDiscoveryClientTypes.PublicDnsPropertiesMutableChange?

        public init (
            dnsProperties: ServiceDiscoveryClientTypes.PublicDnsPropertiesMutableChange? = nil
        )
        {
            self.dnsProperties = dnsProperties
        }
    }

}

extension ServiceDiscoveryClientTypes.PublicDnsPropertiesMutable: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sOA = "SOA"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sOA = sOA {
            try encodeContainer.encode(sOA, forKey: .sOA)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sOADecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.SOA.self, forKey: .sOA)
        sOA = sOADecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// DNS properties for the public DNS namespace.
    public struct PublicDnsPropertiesMutable: Swift.Equatable {
        /// Start of Authority (SOA) record for the hosted zone for the public DNS namespace.
        /// This member is required.
        public var sOA: ServiceDiscoveryClientTypes.SOA?

        public init (
            sOA: ServiceDiscoveryClientTypes.SOA? = nil
        )
        {
            self.sOA = sOA
        }
    }

}

extension ServiceDiscoveryClientTypes.PublicDnsPropertiesMutableChange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sOA = "SOA"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sOA = sOA {
            try encodeContainer.encode(sOA, forKey: .sOA)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sOADecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.SOAChange.self, forKey: .sOA)
        sOA = sOADecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// Updated DNS properties for the public DNS namespace.
    public struct PublicDnsPropertiesMutableChange: Swift.Equatable {
        /// Updated fields for the Start of Authority (SOA) record for the hosted zone for the public DNS namespace.
        /// This member is required.
        public var sOA: ServiceDiscoveryClientTypes.SOAChange?

        public init (
            sOA: ServiceDiscoveryClientTypes.SOAChange? = nil
        )
        {
            self.sOA = sOA
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum RecordType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case a
        case aaaa
        case cname
        case srv
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordType] {
            return [
                .a,
                .aaaa,
                .cname,
                .srv,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .a: return "A"
            case .aaaa: return "AAAA"
            case .cname: return "CNAME"
            case .srv: return "SRV"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecordType(rawValue: rawValue) ?? RecordType.sdkUnknown(rawValue)
        }
    }
}

extension RegisterInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case creatorRequestId = "CreatorRequestId"
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }
}

extension RegisterInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterInstanceInput: Swift.Equatable {
    /// A string map that contains the following information for the service that you specify in ServiceId:
    ///
    /// * The attributes that apply to the records that are defined in the service.
    ///
    /// * For each attribute, the applicable value.
    ///
    ///
    /// Supported attribute keys include the following: AWS_ALIAS_DNS_NAME If you want Cloud Map to create an Amazon Route 53 alias record that routes traffic to an Elastic Load Balancing load balancer, specify the DNS name that's associated with the load balancer. For information about how to get the DNS name, see "DNSName" in the topic [AliasTarget](https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html) in the Route 53 API Reference. Note the following:
    ///
    /// * The configuration for the service that's specified by ServiceId must include settings for an A record, an AAAA record, or both.
    ///
    /// * In the service that's specified by ServiceId, the value of RoutingPolicy must be WEIGHTED.
    ///
    /// * If the service that's specified by ServiceId includes HealthCheckConfig settings, Cloud Map will create the Route 53 health check, but it doesn't associate the health check with the alias record.
    ///
    /// * Auto naming currently doesn't support creating alias records that route traffic to Amazon Web Services resources other than Elastic Load Balancing load balancers.
    ///
    /// * If you specify a value for AWS_ALIAS_DNS_NAME, don't specify values for any of the AWS_INSTANCE attributes.
    ///
    ///
    /// AWS_EC2_INSTANCE_ID HTTP namespaces only. The Amazon EC2 instance ID for the instance. If the AWS_EC2_INSTANCE_ID attribute is specified, then the only other attribute that can be specified is AWS_INIT_HEALTH_STATUS. When the AWS_EC2_INSTANCE_ID attribute is specified, then the AWS_INSTANCE_IPV4 attribute will be filled out with the primary private IPv4 address. AWS_INIT_HEALTH_STATUS If the service configuration includes HealthCheckCustomConfig, you can optionally use AWS_INIT_HEALTH_STATUS to specify the initial status of the custom health check, HEALTHY or UNHEALTHY. If you don't specify a value for AWS_INIT_HEALTH_STATUS, the initial status is HEALTHY. AWS_INSTANCE_CNAME If the service configuration includes a CNAME record, the domain name that you want Route 53 to return in response to DNS queries (for example, example.com). This value is required if the service specified by ServiceId includes settings for an CNAME record. AWS_INSTANCE_IPV4 If the service configuration includes an A record, the IPv4 address that you want Route 53 to return in response to DNS queries (for example, 192.0.2.44). This value is required if the service specified by ServiceId includes settings for an A record. If the service includes settings for an SRV record, you must specify a value for AWS_INSTANCE_IPV4, AWS_INSTANCE_IPV6, or both. AWS_INSTANCE_IPV6 If the service configuration includes an AAAA record, the IPv6 address that you want Route 53 to return in response to DNS queries (for example, 2001:0db8:85a3:0000:0000:abcd:0001:2345). This value is required if the service specified by ServiceId includes settings for an AAAA record. If the service includes settings for an SRV record, you must specify a value for AWS_INSTANCE_IPV4, AWS_INSTANCE_IPV6, or both. AWS_INSTANCE_PORT If the service includes an SRV record, the value that you want Route 53 to return for the port. If the service includes HealthCheckConfig, the port on the endpoint that you want Route 53 to send requests to. This value is required if you specified settings for an SRV record or a Route 53 health check when you created the service. Custom attributes You can add up to 30 custom attributes. For each key-value pair, the maximum length of the attribute name is 255 characters, and the maximum length of the attribute value is 1,024 characters. The total size of all provided attributes (sum of all keys and values) must not exceed 5,000 characters.
    /// This member is required.
    public var attributes: [Swift.String:Swift.String]?
    /// A unique string that identifies the request and that allows failed RegisterInstance requests to be retried without the risk of executing the operation twice. You must use a unique CreatorRequestId string every time you submit a RegisterInstance request if you're registering additional instances for the same namespace and service. CreatorRequestId can be any unique string (for example, a date/time stamp).
    public var creatorRequestId: Swift.String?
    /// An identifier that you want to associate with the instance. Note the following:
    ///
    /// * If the service that's specified by ServiceId includes settings for an SRV record, the value of InstanceId is automatically included as part of the value for the SRV record. For more information, see [DnsRecord > Type](https://docs.aws.amazon.com/cloud-map/latest/api/API_DnsRecord.html#cloudmap-Type-DnsRecord-Type).
    ///
    /// * You can use this value to update an existing instance.
    ///
    /// * To register a new instance, you must specify a value that's unique among instances that you register by using the same service.
    ///
    /// * If you specify an existing InstanceId and ServiceId, Cloud Map updates the existing DNS records, if any. If there's also an existing health check, Cloud Map deletes the old health check and creates a new one. The health check isn't deleted immediately, so it will still appear for a while if you submit a ListHealthChecks request, for example.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The ID of the service that you want to use for settings for the instance.
    /// This member is required.
    public var serviceId: Swift.String?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        creatorRequestId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.creatorRequestId = creatorRequestId
        self.instanceId = instanceId
        self.serviceId = serviceId
    }
}

struct RegisterInstanceInputBody: Swift.Equatable {
    let serviceId: Swift.String?
    let instanceId: Swift.String?
    let creatorRequestId: Swift.String?
    let attributes: [Swift.String:Swift.String]?
}

extension RegisterInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case creatorRequestId = "CreatorRequestId"
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attrvalue0) in attributesContainer {
                if let attrvalue0 = attrvalue0 {
                    attributesDecoded0?[key0] = attrvalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension RegisterInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceeded(try ResourceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterInstanceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case resourceInUse(ResourceInUse)
    case resourceLimitExceeded(ResourceLimitExceeded)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct RegisterInstanceOutputResponse: Swift.Equatable {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the operation, see [GetOperation](https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html).
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct RegisterInstanceOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension RegisterInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension RequestLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RequestLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation can't be completed because you've reached the quota for the number of requests. For more information, see [Cloud Map API request throttling quota](https://docs.aws.amazon.com/cloud-map/latest/dg/throttling.html) in the Cloud Map Developer Guide.
public struct RequestLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RequestLimitExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension RequestLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource can't be deleted because it contains other resources. For example, you can't delete a service that contains any instances.
public struct ResourceInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource can't be created because you've reached the quota on the number of resources.
public struct ResourceLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceLimitExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation can't be completed because the resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    public enum RoutingPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case multivalue
        case weighted
        case sdkUnknown(Swift.String)

        public static var allCases: [RoutingPolicy] {
            return [
                .multivalue,
                .weighted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .multivalue: return "MULTIVALUE"
            case .weighted: return "WEIGHTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RoutingPolicy(rawValue: rawValue) ?? RoutingPolicy.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes.SOA: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tTL = "TTL"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tTL = tTL {
            try encodeContainer.encode(tTL, forKey: .tTL)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tTL)
        tTL = tTLDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// Start of Authority (SOA) properties for a public or private DNS namespace.
    public struct SOA: Swift.Equatable {
        /// The time to live (TTL) for purposes of negative caching.
        /// This member is required.
        public var tTL: Swift.Int?

        public init (
            tTL: Swift.Int? = nil
        )
        {
            self.tTL = tTL
        }
    }

}

extension ServiceDiscoveryClientTypes.SOAChange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tTL = "TTL"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tTL = tTL {
            try encodeContainer.encode(tTL, forKey: .tTL)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tTL)
        tTL = tTLDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// Updated Start of Authority (SOA) properties for a public or private DNS namespace.
    public struct SOAChange: Swift.Equatable {
        /// The updated time to live (TTL) for purposes of negative caching.
        /// This member is required.
        public var tTL: Swift.Int?

        public init (
            tTL: Swift.Int? = nil
        )
        {
            self.tTL = tTL
        }
    }

}

extension ServiceDiscoveryClientTypes.Service: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case dnsConfig = "DnsConfig"
        case healthCheckConfig = "HealthCheckConfig"
        case healthCheckCustomConfig = "HealthCheckCustomConfig"
        case id = "Id"
        case instanceCount = "InstanceCount"
        case name = "Name"
        case namespaceId = "NamespaceId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dnsConfig = dnsConfig {
            try encodeContainer.encode(dnsConfig, forKey: .dnsConfig)
        }
        if let healthCheckConfig = healthCheckConfig {
            try encodeContainer.encode(healthCheckConfig, forKey: .healthCheckConfig)
        }
        if let healthCheckCustomConfig = healthCheckCustomConfig {
            try encodeContainer.encode(healthCheckCustomConfig, forKey: .healthCheckCustomConfig)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let instanceCount = instanceCount {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespaceId = namespaceId {
            try encodeContainer.encode(namespaceId, forKey: .namespaceId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let namespaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount)
        instanceCount = instanceCountDecoded
        let dnsConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.DnsConfig.self, forKey: .dnsConfig)
        dnsConfig = dnsConfigDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.ServiceType.self, forKey: .type)
        type = typeDecoded
        let healthCheckConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckConfig.self, forKey: .healthCheckConfig)
        healthCheckConfig = healthCheckConfigDecoded
        let healthCheckCustomConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckCustomConfig.self, forKey: .healthCheckCustomConfig)
        healthCheckCustomConfig = healthCheckCustomConfigDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about the specified service.
    public struct Service: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that Cloud Map assigns to the service when you create it.
        public var arn: Swift.String?
        /// The date and time that the service was created, in Unix format and Coordinated Universal Time (UTC). The value of CreateDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var createDate: ClientRuntime.Date?
        /// A unique string that identifies the request and that allows failed requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string (for example, a date/timestamp).
        public var creatorRequestId: Swift.String?
        /// The description of the service.
        public var description: Swift.String?
        /// A complex type that contains information about the Route 53 DNS records that you want Cloud Map to create when you register an instance.
        public var dnsConfig: ServiceDiscoveryClientTypes.DnsConfig?
        /// Public DNS and HTTP namespaces only. A complex type that contains settings for an optional health check. If you specify settings for a health check, Cloud Map associates the health check with the records that you specify in DnsConfig. For information about the charges for health checks, see [Amazon Route 53 Pricing](http://aws.amazon.com/route53/pricing/).
        public var healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig?
        /// A complex type that contains information about an optional custom health check. If you specify a health check configuration, you can specify either HealthCheckCustomConfig or HealthCheckConfig but not both.
        public var healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig?
        /// The ID that Cloud Map assigned to the service when you created it.
        public var id: Swift.String?
        /// The number of instances that are currently associated with the service. Instances that were previously associated with the service but that are deleted aren't included in the count. The count might not reflect pending registrations and deregistrations.
        public var instanceCount: Swift.Int?
        /// The name of the service.
        public var name: Swift.String?
        /// The ID of the namespace that was used to create the service.
        public var namespaceId: Swift.String?
        /// Describes the systems that can be used to discover the service instances. DNS_HTTP The service instances can be discovered using either DNS queries or the DiscoverInstances API operation. HTTP The service instances can only be discovered using the DiscoverInstances API operation. DNS Reserved.
        public var type: ServiceDiscoveryClientTypes.ServiceType?

        public init (
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            description: Swift.String? = nil,
            dnsConfig: ServiceDiscoveryClientTypes.DnsConfig? = nil,
            healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig? = nil,
            healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig? = nil,
            id: Swift.String? = nil,
            instanceCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            namespaceId: Swift.String? = nil,
            type: ServiceDiscoveryClientTypes.ServiceType? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.creatorRequestId = creatorRequestId
            self.description = description
            self.dnsConfig = dnsConfig
            self.healthCheckConfig = healthCheckConfig
            self.healthCheckCustomConfig = healthCheckCustomConfig
            self.id = id
            self.instanceCount = instanceCount
            self.name = name
            self.namespaceId = namespaceId
            self.type = type
        }
    }

}

extension ServiceAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceAlreadyExistsBody = try responseDecoder.decode(responseBody: data)
            self.creatorRequestId = output.creatorRequestId
            self.message = output.message
            self.serviceId = output.serviceId
        } else {
            self.creatorRequestId = nil
            self.message = nil
            self.serviceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service can't be created because a service with the same name already exists.
public struct ServiceAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The CreatorRequestId that was used to create the service.
    public var creatorRequestId: Swift.String?
    public var message: Swift.String?
    /// The ID of the existing service.
    public var serviceId: Swift.String?

    public init (
        creatorRequestId: Swift.String? = nil,
        message: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.message = message
        self.serviceId = serviceId
    }
}

struct ServiceAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
    let creatorRequestId: Swift.String?
    let serviceId: Swift.String?
}

extension ServiceAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case message = "Message"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
    }
}

extension ServiceDiscoveryClientTypes.ServiceChange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case dnsConfig = "DnsConfig"
        case healthCheckConfig = "HealthCheckConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dnsConfig = dnsConfig {
            try encodeContainer.encode(dnsConfig, forKey: .dnsConfig)
        }
        if let healthCheckConfig = healthCheckConfig {
            try encodeContainer.encode(healthCheckConfig, forKey: .healthCheckConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dnsConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.DnsConfigChange.self, forKey: .dnsConfig)
        dnsConfig = dnsConfigDecoded
        let healthCheckConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckConfig.self, forKey: .healthCheckConfig)
        healthCheckConfig = healthCheckConfigDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains changes to an existing service.
    public struct ServiceChange: Swift.Equatable {
        /// A description for the service.
        public var description: Swift.String?
        /// Information about the Route 53 DNS records that you want Cloud Map to create when you register an instance.
        public var dnsConfig: ServiceDiscoveryClientTypes.DnsConfigChange?
        /// Public DNS and HTTP namespaces only. Settings for an optional health check. If you specify settings for a health check, Cloud Map associates the health check with the records that you specify in DnsConfig.
        public var healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig?

        public init (
            description: Swift.String? = nil,
            dnsConfig: ServiceDiscoveryClientTypes.DnsConfigChange? = nil,
            healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig? = nil
        )
        {
            self.description = description
            self.dnsConfig = dnsConfig
            self.healthCheckConfig = healthCheckConfig
        }
    }

}

extension ServiceDiscoveryClientTypes.ServiceFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition = "Condition"
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.ServiceFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.FilterCondition.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that lets you specify the namespaces that you want to list services for.
    public struct ServiceFilter: Swift.Equatable {
        /// The operator that you want to use to determine whether a service is returned by ListServices. Valid values for Condition include the following:
        ///
        /// * EQ: When you specify EQ, specify one namespace ID for Values. EQ is the default condition and can be omitted.
        ///
        /// * IN: When you specify IN, specify a list of the IDs for the namespaces that you want ListServices to return a list of services for.
        ///
        /// * BETWEEN: Not applicable.
        public var condition: ServiceDiscoveryClientTypes.FilterCondition?
        /// Specify NAMESPACE_ID.
        /// This member is required.
        public var name: ServiceDiscoveryClientTypes.ServiceFilterName?
        /// The values that are applicable to the value that you specify for Condition to filter the list of services.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            condition: ServiceDiscoveryClientTypes.FilterCondition? = nil,
            name: ServiceDiscoveryClientTypes.ServiceFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.values = values
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum ServiceFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case namespaceId
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceFilterName] {
            return [
                .namespaceId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .namespaceId: return "NAMESPACE_ID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceFilterName(rawValue: rawValue) ?? ServiceFilterName.sdkUnknown(rawValue)
        }
    }
}

extension ServiceNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// No service exists with the specified ID.
public struct ServiceNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceNotFoundBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceDiscoveryClientTypes.ServiceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case description = "Description"
        case dnsConfig = "DnsConfig"
        case healthCheckConfig = "HealthCheckConfig"
        case healthCheckCustomConfig = "HealthCheckCustomConfig"
        case id = "Id"
        case instanceCount = "InstanceCount"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dnsConfig = dnsConfig {
            try encodeContainer.encode(dnsConfig, forKey: .dnsConfig)
        }
        if let healthCheckConfig = healthCheckConfig {
            try encodeContainer.encode(healthCheckConfig, forKey: .healthCheckConfig)
        }
        if let healthCheckCustomConfig = healthCheckCustomConfig {
            try encodeContainer.encode(healthCheckCustomConfig, forKey: .healthCheckCustomConfig)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let instanceCount = instanceCount {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.ServiceType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount)
        instanceCount = instanceCountDecoded
        let dnsConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.DnsConfig.self, forKey: .dnsConfig)
        dnsConfig = dnsConfigDecoded
        let healthCheckConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckConfig.self, forKey: .healthCheckConfig)
        healthCheckConfig = healthCheckConfigDecoded
        let healthCheckCustomConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckCustomConfig.self, forKey: .healthCheckCustomConfig)
        healthCheckCustomConfig = healthCheckCustomConfigDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about a specified service.
    public struct ServiceSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that Cloud Map assigns to the service when you create it.
        public var arn: Swift.String?
        /// The date and time that the service was created.
        public var createDate: ClientRuntime.Date?
        /// The description that you specify when you create the service.
        public var description: Swift.String?
        /// Information about the Route 53 DNS records that you want Cloud Map to create when you register an instance.
        public var dnsConfig: ServiceDiscoveryClientTypes.DnsConfig?
        /// Public DNS and HTTP namespaces only. Settings for an optional health check. If you specify settings for a health check, Cloud Map associates the health check with the records that you specify in DnsConfig.
        public var healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig?
        /// Information about an optional custom health check. A custom health check, which requires that you use a third-party health checker to evaluate the health of your resources, is useful in the following circumstances:
        ///
        /// * You can't use a health check that's defined by HealthCheckConfig because the resource isn't available over the internet. For example, you can use a custom health check when the instance is in an Amazon VPC. (To check the health of resources in a VPC, the health checker must also be in the VPC.)
        ///
        /// * You want to use a third-party health checker regardless of where your resources are located.
        ///
        ///
        /// If you specify a health check configuration, you can specify either HealthCheckCustomConfig or HealthCheckConfig but not both.
        public var healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig?
        /// The ID that Cloud Map assigned to the service when you created it.
        public var id: Swift.String?
        /// The number of instances that are currently associated with the service. Instances that were previously associated with the service but that are deleted aren't included in the count. The count might not reflect pending registrations and deregistrations.
        public var instanceCount: Swift.Int?
        /// The name of the service.
        public var name: Swift.String?
        /// Describes the systems that can be used to discover the service instances. DNS_HTTP The service instances can be discovered using either DNS queries or the DiscoverInstances API operation. HTTP The service instances can only be discovered using the DiscoverInstances API operation. DNS Reserved.
        public var type: ServiceDiscoveryClientTypes.ServiceType?

        public init (
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            dnsConfig: ServiceDiscoveryClientTypes.DnsConfig? = nil,
            healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig? = nil,
            healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig? = nil,
            id: Swift.String? = nil,
            instanceCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            type: ServiceDiscoveryClientTypes.ServiceType? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.description = description
            self.dnsConfig = dnsConfig
            self.healthCheckConfig = healthCheckConfig
            self.healthCheckCustomConfig = healthCheckCustomConfig
            self.id = id
            self.instanceCount = instanceCount
            self.name = name
            self.type = type
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum ServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dns
        case dnsHttp
        case http
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceType] {
            return [
                .dns,
                .dnsHttp,
                .http,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dns: return "DNS"
            case .dnsHttp: return "DNS_HTTP"
            case .http: return "HTTP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceType(rawValue: rawValue) ?? ServiceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes {
    public enum ServiceTypeOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceTypeOption] {
            return [
                .http,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceTypeOption(rawValue: rawValue) ?? ServiceTypeOption.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    /// A custom key-value pair that's associated with a resource.
    public struct Tag: Swift.Equatable {
        /// The key identifier, or name, of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The string value that's associated with the key of the tag. You can set the value of a tag to an empty string, but you can't set the value of a tag to null.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags to add to the specified resource. Specifying the tag key is required. You can set the value of a tag to an empty string, but you can't set the value of a tag to null.
    /// This member is required.
    public var tags: [ServiceDiscoveryClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [ServiceDiscoveryClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The list of tags on the resource is over the quota. The maximum number of tags that can be applied to a resource is 50.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The name of the resource.
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag keys to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateHttpNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case namespace = "Namespace"
        case updaterRequestId = "UpdaterRequestId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let updaterRequestId = updaterRequestId {
            try encodeContainer.encode(updaterRequestId, forKey: .updaterRequestId)
        }
    }
}

extension UpdateHttpNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateHttpNamespaceInput: Swift.Equatable {
    /// The ID of the namespace that you want to update.
    /// This member is required.
    public var id: Swift.String?
    /// Updated properties for the the HTTP namespace.
    /// This member is required.
    public var namespace: ServiceDiscoveryClientTypes.HttpNamespaceChange?
    /// A unique string that identifies the request and that allows failed UpdateHttpNamespace requests to be retried without the risk of running the operation twice. UpdaterRequestId can be any unique string (for example, a date/timestamp).
    public var updaterRequestId: Swift.String?

    public init (
        id: Swift.String? = nil,
        namespace: ServiceDiscoveryClientTypes.HttpNamespaceChange? = nil,
        updaterRequestId: Swift.String? = nil
    )
    {
        self.id = id
        self.namespace = namespace
        self.updaterRequestId = updaterRequestId
    }
}

struct UpdateHttpNamespaceInputBody: Swift.Equatable {
    let id: Swift.String?
    let updaterRequestId: Swift.String?
    let namespace: ServiceDiscoveryClientTypes.HttpNamespaceChange?
}

extension UpdateHttpNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case namespace = "Namespace"
        case updaterRequestId = "UpdaterRequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let updaterRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updaterRequestId)
        updaterRequestId = updaterRequestIdDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HttpNamespaceChange.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension UpdateHttpNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateHttpNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateHttpNamespaceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case resourceInUse(ResourceInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateHttpNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateHttpNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct UpdateHttpNamespaceOutputResponse: Swift.Equatable {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the operation, see [GetOperation](https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html).
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct UpdateHttpNamespaceOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension UpdateHttpNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension UpdateInstanceCustomHealthStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateInstanceCustomHealthStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateInstanceCustomHealthStatusInput: Swift.Equatable {
    /// The ID of the instance that you want to change the health status for.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The ID of the service that includes the configuration for the custom health check that you want to change the status for.
    /// This member is required.
    public var serviceId: Swift.String?
    /// The new status of the instance, HEALTHY or UNHEALTHY.
    /// This member is required.
    public var status: ServiceDiscoveryClientTypes.CustomHealthStatus?

    public init (
        instanceId: Swift.String? = nil,
        serviceId: Swift.String? = nil,
        status: ServiceDiscoveryClientTypes.CustomHealthStatus? = nil
    )
    {
        self.instanceId = instanceId
        self.serviceId = serviceId
        self.status = status
    }
}

struct UpdateInstanceCustomHealthStatusInputBody: Swift.Equatable {
    let serviceId: Swift.String?
    let instanceId: Swift.String?
    let status: ServiceDiscoveryClientTypes.CustomHealthStatus?
}

extension UpdateInstanceCustomHealthStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.CustomHealthStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateInstanceCustomHealthStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInstanceCustomHealthStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomHealthNotFound" : self = .customHealthNotFound(try CustomHealthNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceNotFound" : self = .instanceNotFound(try InstanceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateInstanceCustomHealthStatusOutputError: Swift.Error, Swift.Equatable {
    case customHealthNotFound(CustomHealthNotFound)
    case instanceNotFound(InstanceNotFound)
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInstanceCustomHealthStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateInstanceCustomHealthStatusOutputResponse: Swift.Equatable {

}

extension UpdatePrivateDnsNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case namespace = "Namespace"
        case updaterRequestId = "UpdaterRequestId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let updaterRequestId = updaterRequestId {
            try encodeContainer.encode(updaterRequestId, forKey: .updaterRequestId)
        }
    }
}

extension UpdatePrivateDnsNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePrivateDnsNamespaceInput: Swift.Equatable {
    /// The ID of the namespace that you want to update.
    /// This member is required.
    public var id: Swift.String?
    /// Updated properties for the private DNS namespace.
    /// This member is required.
    public var namespace: ServiceDiscoveryClientTypes.PrivateDnsNamespaceChange?
    /// A unique string that identifies the request and that allows failed UpdatePrivateDnsNamespace requests to be retried without the risk of running the operation twice. UpdaterRequestId can be any unique string (for example, a date/timestamp).
    public var updaterRequestId: Swift.String?

    public init (
        id: Swift.String? = nil,
        namespace: ServiceDiscoveryClientTypes.PrivateDnsNamespaceChange? = nil,
        updaterRequestId: Swift.String? = nil
    )
    {
        self.id = id
        self.namespace = namespace
        self.updaterRequestId = updaterRequestId
    }
}

struct UpdatePrivateDnsNamespaceInputBody: Swift.Equatable {
    let id: Swift.String?
    let updaterRequestId: Swift.String?
    let namespace: ServiceDiscoveryClientTypes.PrivateDnsNamespaceChange?
}

extension UpdatePrivateDnsNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case namespace = "Namespace"
        case updaterRequestId = "UpdaterRequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let updaterRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updaterRequestId)
        updaterRequestId = updaterRequestIdDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.PrivateDnsNamespaceChange.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension UpdatePrivateDnsNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePrivateDnsNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePrivateDnsNamespaceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case resourceInUse(ResourceInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePrivateDnsNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePrivateDnsNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct UpdatePrivateDnsNamespaceOutputResponse: Swift.Equatable {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the operation, see [GetOperation](https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html).
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct UpdatePrivateDnsNamespaceOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension UpdatePrivateDnsNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension UpdatePublicDnsNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case namespace = "Namespace"
        case updaterRequestId = "UpdaterRequestId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let updaterRequestId = updaterRequestId {
            try encodeContainer.encode(updaterRequestId, forKey: .updaterRequestId)
        }
    }
}

extension UpdatePublicDnsNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePublicDnsNamespaceInput: Swift.Equatable {
    /// The ID of the namespace being updated.
    /// This member is required.
    public var id: Swift.String?
    /// Updated properties for the public DNS namespace.
    /// This member is required.
    public var namespace: ServiceDiscoveryClientTypes.PublicDnsNamespaceChange?
    /// A unique string that identifies the request and that allows failed UpdatePublicDnsNamespace requests to be retried without the risk of running the operation twice. UpdaterRequestId can be any unique string (for example, a date/timestamp).
    public var updaterRequestId: Swift.String?

    public init (
        id: Swift.String? = nil,
        namespace: ServiceDiscoveryClientTypes.PublicDnsNamespaceChange? = nil,
        updaterRequestId: Swift.String? = nil
    )
    {
        self.id = id
        self.namespace = namespace
        self.updaterRequestId = updaterRequestId
    }
}

struct UpdatePublicDnsNamespaceInputBody: Swift.Equatable {
    let id: Swift.String?
    let updaterRequestId: Swift.String?
    let namespace: ServiceDiscoveryClientTypes.PublicDnsNamespaceChange?
}

extension UpdatePublicDnsNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case namespace = "Namespace"
        case updaterRequestId = "UpdaterRequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let updaterRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updaterRequestId)
        updaterRequestId = updaterRequestIdDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.PublicDnsNamespaceChange.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension UpdatePublicDnsNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePublicDnsNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePublicDnsNamespaceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case resourceInUse(ResourceInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePublicDnsNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePublicDnsNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct UpdatePublicDnsNamespaceOutputResponse: Swift.Equatable {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the operation, see [GetOperation](https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html).
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct UpdatePublicDnsNamespaceOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension UpdatePublicDnsNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension UpdateServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case service = "Service"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let service = service {
            try encodeContainer.encode(service, forKey: .service)
        }
    }
}

extension UpdateServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateServiceInput: Swift.Equatable {
    /// The ID of the service that you want to update.
    /// This member is required.
    public var id: Swift.String?
    /// A complex type that contains the new settings for the service.
    /// This member is required.
    public var service: ServiceDiscoveryClientTypes.ServiceChange?

    public init (
        id: Swift.String? = nil,
        service: ServiceDiscoveryClientTypes.ServiceChange? = nil
    )
    {
        self.id = id
        self.service = service
    }
}

struct UpdateServiceInputBody: Swift.Equatable {
    let id: Swift.String?
    let service: ServiceDiscoveryClientTypes.ServiceChange?
}

extension UpdateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.ServiceChange.self, forKey: .service)
        service = serviceDecoded
    }
}

extension UpdateServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct UpdateServiceOutputResponse: Swift.Equatable {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the operation, see [GetOperation](https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html).
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct UpdateServiceOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension UpdateServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}
