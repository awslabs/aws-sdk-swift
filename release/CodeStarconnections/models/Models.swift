// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Two conflicting operations have been made on the same resource.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Connection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionName = "ConnectionName"
        case connectionStatus = "ConnectionStatus"
        case hostArn = "HostArn"
        case ownerAccountId = "OwnerAccountId"
        case providerType = "ProviderType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let connectionStatus = connectionStatus {
            try encodeContainer.encode(connectionStatus.rawValue, forKey: .connectionStatus)
        }
        if let hostArn = hostArn {
            try encodeContainer.encode(hostArn, forKey: .hostArn)
        }
        if let ownerAccountId = ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(ConnectionStatus.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
        let hostArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostArn)
        hostArn = hostArnDecoded
    }
}

extension Connection: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Connection(connectionArn: \(String(describing: connectionArn)), connectionName: \(String(describing: connectionName)), connectionStatus: \(String(describing: connectionStatus)), hostArn: \(String(describing: hostArn)), ownerAccountId: \(String(describing: ownerAccountId)), providerType: \(String(describing: providerType)))"}
}

/// <p>A resource that is used to connect third-party source providers with services like AWS CodePipeline.</p>
///          <p>Note: A connection created through CloudFormation, the CLI, or the SDK is in `PENDING` status by default. You can make its status `AVAILABLE` by updating the
///       connection in the console.</p>
public struct Connection: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the connection. The ARN is used as the connection
    ///       reference when the connection is shared between AWS services.</p>
    ///          <note>
    ///             <p>The ARN is never reused if the connection is deleted.</p>
    ///          </note>
    public let connectionArn: String?
    /// <p>The name of the connection. Connection names must be unique in an AWS user account.</p>
    public let connectionName: String?
    /// <p>The current status of the connection. </p>
    public let connectionStatus: ConnectionStatus?
    /// <p>The Amazon Resource Name (ARN) of the host associated with the connection.</p>
    public let hostArn: String?
    /// <p>The identifier of the external provider where your third-party code repository is configured.
    ///       For Bitbucket, this is the account ID of the owner of the Bitbucket repository.</p>
    public let ownerAccountId: String?
    /// <p>The name of the external provider where your third-party code repository is
    ///       configured.</p>
    public let providerType: ProviderType?

    public init (
        connectionArn: String? = nil,
        connectionName: String? = nil,
        connectionStatus: ConnectionStatus? = nil,
        hostArn: String? = nil,
        ownerAccountId: String? = nil,
        providerType: ProviderType? = nil
    )
    {
        self.connectionArn = connectionArn
        self.connectionName = connectionName
        self.connectionStatus = connectionStatus
        self.hostArn = hostArn
        self.ownerAccountId = ownerAccountId
        self.providerType = providerType
    }
}

public enum ConnectionStatus {
    case available
    case error
    case pending
    case sdkUnknown(String)
}

extension ConnectionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionStatus] {
        return [
            .available,
            .error,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .error: return "ERROR"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
    }
}

public struct CreateConnectionInputBodyMiddleware: Middleware {
    public let id: String = "CreateConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionOutputError>
}

extension CreateConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectionInput(connectionName: \(String(describing: connectionName)), hostArn: \(String(describing: hostArn)), providerType: \(String(describing: providerType)), tags: \(String(describing: tags)))"}
}

extension CreateConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionName = "ConnectionName"
        case hostArn = "HostArn"
        case providerType = "ProviderType"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let hostArn = hostArn {
            try encodeContainer.encode(hostArn, forKey: .hostArn)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInput: Equatable {
    /// <p>The name of the connection to be created. The name must be unique in the calling AWS
    ///       account.</p>
    public let connectionName: String?
    /// <p>The Amazon Resource Name (ARN) of the host associated with the connection to be created.</p>
    public let hostArn: String?
    /// <p>The name of the external provider where your third-party code repository is
    ///       configured.</p>
    public let providerType: ProviderType?
    /// <p>The key-value pair to use when tagging the resource.</p>
    public let tags: [Tag]?

    public init (
        connectionName: String? = nil,
        hostArn: String? = nil,
        providerType: ProviderType? = nil,
        tags: [Tag]? = nil
    )
    {
        self.connectionName = connectionName
        self.hostArn = hostArn
        self.providerType = providerType
        self.tags = tags
    }
}

struct CreateConnectionInputBody: Equatable {
    public let providerType: ProviderType?
    public let connectionName: String?
    public let tags: [Tag]?
    public let hostArn: String?
}

extension CreateConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionName = "ConnectionName"
        case hostArn = "HostArn"
        case providerType = "ProviderType"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerTypeDecoded = try containerValues.decodeIfPresent(ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let hostArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostArn)
        hostArn = hostArnDecoded
    }
}

extension CreateConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectionOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectionOutputResponse(connectionArn: \(String(describing: connectionArn)), tags: \(String(describing: tags)))"}
}

extension CreateConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connectionArn = output.connectionArn
            self.tags = output.tags
        } else {
            self.connectionArn = nil
            self.tags = nil
        }
    }
}

public struct CreateConnectionOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the connection to be created. The ARN is used as the
    ///       connection reference when the connection is shared between AWS services.</p>
    ///          <note>
    ///             <p>The ARN is never reused if the connection is deleted.</p>
    ///          </note>
    public let connectionArn: String?
    /// <p>Specifies the tags applied to the resource.</p>
    public let tags: [Tag]?

    public init (
        connectionArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.connectionArn = connectionArn
        self.tags = tags
    }
}

struct CreateConnectionOutputResponseBody: Equatable {
    public let connectionArn: String?
    public let tags: [Tag]?
}

extension CreateConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateHostInputBodyMiddleware: Middleware {
    public let id: String = "CreateHostInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHostInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHostInput>
    public typealias MOutput = OperationOutput<CreateHostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHostOutputError>
}

extension CreateHostInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHostInput(name: \(String(describing: name)), providerEndpoint: \(String(describing: providerEndpoint)), providerType: \(String(describing: providerType)), tags: \(String(describing: tags)), vpcConfiguration: \(String(describing: vpcConfiguration)))"}
}

extension CreateHostInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case providerEndpoint = "ProviderEndpoint"
        case providerType = "ProviderType"
        case tags = "Tags"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let providerEndpoint = providerEndpoint {
            try encodeContainer.encode(providerEndpoint, forKey: .providerEndpoint)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let vpcConfiguration = vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }
}

public struct CreateHostInputHeadersMiddleware: Middleware {
    public let id: String = "CreateHostInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHostInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHostInput>
    public typealias MOutput = OperationOutput<CreateHostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHostOutputError>
}

public struct CreateHostInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateHostInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHostInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHostInput>
    public typealias MOutput = OperationOutput<CreateHostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHostOutputError>
}

public struct CreateHostInput: Equatable {
    /// <p>The name of the host to be created. The name must be unique in the calling AWS
    ///       account.</p>
    public let name: String?
    /// <p>The endpoint of the infrastructure to be represented by the host after it is
    ///       created.</p>
    public let providerEndpoint: String?
    /// <p>The name of the installed provider to be associated with your connection. The host
    ///       resource represents the infrastructure where your provider type is installed. The valid
    ///       provider type is GitHub Enterprise Server.</p>
    public let providerType: ProviderType?
    public let tags: [Tag]?
    /// <p>The VPC configuration to be provisioned for the host. A VPC must be configured and the
    ///       infrastructure to be represented by the host must already be connected to the VPC.</p>
    public let vpcConfiguration: VpcConfiguration?

    public init (
        name: String? = nil,
        providerEndpoint: String? = nil,
        providerType: ProviderType? = nil,
        tags: [Tag]? = nil,
        vpcConfiguration: VpcConfiguration? = nil
    )
    {
        self.name = name
        self.providerEndpoint = providerEndpoint
        self.providerType = providerType
        self.tags = tags
        self.vpcConfiguration = vpcConfiguration
    }
}

struct CreateHostInputBody: Equatable {
    public let name: String?
    public let providerType: ProviderType?
    public let providerEndpoint: String?
    public let vpcConfiguration: VpcConfiguration?
    public let tags: [Tag]?
}

extension CreateHostInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case providerEndpoint = "ProviderEndpoint"
        case providerType = "ProviderType"
        case tags = "Tags"
        case vpcConfiguration = "VpcConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let providerEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerEndpoint)
        providerEndpoint = providerEndpointDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateHostOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHostOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHostOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHostOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHostOutputResponse(hostArn: \(String(describing: hostArn)), tags: \(String(describing: tags)))"}
}

extension CreateHostOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateHostOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hostArn = output.hostArn
            self.tags = output.tags
        } else {
            self.hostArn = nil
            self.tags = nil
        }
    }
}

public struct CreateHostOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the host to be created.</p>
    public let hostArn: String?
    public let tags: [Tag]?

    public init (
        hostArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.hostArn = hostArn
        self.tags = tags
    }
}

struct CreateHostOutputResponseBody: Equatable {
    public let hostArn: String?
    public let tags: [Tag]?
}

extension CreateHostOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hostArn = "HostArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostArn)
        hostArn = hostArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct DeleteConnectionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionOutputError>
}

extension DeleteConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConnectionInput(connectionArn: \(String(describing: connectionArn)))"}
}

extension DeleteConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
    }
}

public struct DeleteConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the connection to be deleted.</p>
    ///          <note>
    ///             <p>The ARN is never reused if the connection is deleted.</p>
    ///          </note>
    public let connectionArn: String?

    public init (
        connectionArn: String? = nil
    )
    {
        self.connectionArn = connectionArn
    }
}

struct DeleteConnectionInputBody: Equatable {
    public let connectionArn: String?
}

extension DeleteConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
    }
}

extension DeleteConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectionOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConnectionOutputResponse()"}
}

extension DeleteConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConnectionOutputResponse: Equatable {

    public init() {}
}

struct DeleteConnectionOutputResponseBody: Equatable {
}

extension DeleteConnectionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteHostInputBodyMiddleware: Middleware {
    public let id: String = "DeleteHostInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHostInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHostInput>
    public typealias MOutput = OperationOutput<DeleteHostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHostOutputError>
}

extension DeleteHostInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteHostInput(hostArn: \(String(describing: hostArn)))"}
}

extension DeleteHostInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hostArn = "HostArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostArn = hostArn {
            try encodeContainer.encode(hostArn, forKey: .hostArn)
        }
    }
}

public struct DeleteHostInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteHostInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHostInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHostInput>
    public typealias MOutput = OperationOutput<DeleteHostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHostOutputError>
}

public struct DeleteHostInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteHostInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHostInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHostInput>
    public typealias MOutput = OperationOutput<DeleteHostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHostOutputError>
}

public struct DeleteHostInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the host to be deleted.</p>
    public let hostArn: String?

    public init (
        hostArn: String? = nil
    )
    {
        self.hostArn = hostArn
    }
}

struct DeleteHostInputBody: Equatable {
    public let hostArn: String?
}

extension DeleteHostInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hostArn = "HostArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostArn)
        hostArn = hostArnDecoded
    }
}

extension DeleteHostOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteHostOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteHostOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHostOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteHostOutputResponse()"}
}

extension DeleteHostOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteHostOutputResponse: Equatable {

    public init() {}
}

struct DeleteHostOutputResponseBody: Equatable {
}

extension DeleteHostOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct GetConnectionInputBodyMiddleware: Middleware {
    public let id: String = "GetConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectionInput>
    public typealias MOutput = OperationOutput<GetConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectionOutputError>
}

extension GetConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConnectionInput(connectionArn: \(String(describing: connectionArn)))"}
}

extension GetConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
    }
}

public struct GetConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "GetConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectionInput>
    public typealias MOutput = OperationOutput<GetConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectionOutputError>
}

public struct GetConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectionInput>
    public typealias MOutput = OperationOutput<GetConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectionOutputError>
}

public struct GetConnectionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of a connection.</p>
    public let connectionArn: String?

    public init (
        connectionArn: String? = nil
    )
    {
        self.connectionArn = connectionArn
    }
}

struct GetConnectionInputBody: Equatable {
    public let connectionArn: String?
}

extension GetConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
    }
}

extension GetConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConnectionOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConnectionOutputResponse(connection: \(String(describing: connection)))"}
}

extension GetConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetConnectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct GetConnectionOutputResponse: Equatable {
    /// <p>The connection details, such as status, owner, and provider type.</p>
    public let connection: Connection?

    public init (
        connection: Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct GetConnectionOutputResponseBody: Equatable {
    public let connection: Connection?
}

extension GetConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

public struct GetHostInputBodyMiddleware: Middleware {
    public let id: String = "GetHostInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetHostInput>,
                  next: H) -> Swift.Result<OperationOutput<GetHostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetHostInput>
    public typealias MOutput = OperationOutput<GetHostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetHostOutputError>
}

extension GetHostInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetHostInput(hostArn: \(String(describing: hostArn)))"}
}

extension GetHostInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hostArn = "HostArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostArn = hostArn {
            try encodeContainer.encode(hostArn, forKey: .hostArn)
        }
    }
}

public struct GetHostInputHeadersMiddleware: Middleware {
    public let id: String = "GetHostInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetHostInput>,
                  next: H) -> Swift.Result<OperationOutput<GetHostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetHostInput>
    public typealias MOutput = OperationOutput<GetHostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetHostOutputError>
}

public struct GetHostInputQueryItemMiddleware: Middleware {
    public let id: String = "GetHostInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetHostInput>,
                  next: H) -> Swift.Result<OperationOutput<GetHostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetHostInput>
    public typealias MOutput = OperationOutput<GetHostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetHostOutputError>
}

public struct GetHostInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the requested host.</p>
    public let hostArn: String?

    public init (
        hostArn: String? = nil
    )
    {
        self.hostArn = hostArn
    }
}

struct GetHostInputBody: Equatable {
    public let hostArn: String?
}

extension GetHostInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hostArn = "HostArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostArn)
        hostArn = hostArnDecoded
    }
}

extension GetHostOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetHostOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetHostOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetHostOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetHostOutputResponse(name: \(String(describing: name)), providerEndpoint: \(String(describing: providerEndpoint)), providerType: \(String(describing: providerType)), status: \(String(describing: status)), vpcConfiguration: \(String(describing: vpcConfiguration)))"}
}

extension GetHostOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetHostOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
            self.providerEndpoint = output.providerEndpoint
            self.providerType = output.providerType
            self.status = output.status
            self.vpcConfiguration = output.vpcConfiguration
        } else {
            self.name = nil
            self.providerEndpoint = nil
            self.providerType = nil
            self.status = nil
            self.vpcConfiguration = nil
        }
    }
}

public struct GetHostOutputResponse: Equatable {
    /// <p>The name of the requested host.</p>
    public let name: String?
    /// <p>The endpoint of the infrastructure represented by the requested host.</p>
    public let providerEndpoint: String?
    /// <p>The provider type of the requested host, such as GitHub Enterprise Server.</p>
    public let providerType: ProviderType?
    /// <p>The status of the requested host.</p>
    public let status: String?
    /// <p>The VPC configuration of the requested host.</p>
    public let vpcConfiguration: VpcConfiguration?

    public init (
        name: String? = nil,
        providerEndpoint: String? = nil,
        providerType: ProviderType? = nil,
        status: String? = nil,
        vpcConfiguration: VpcConfiguration? = nil
    )
    {
        self.name = name
        self.providerEndpoint = providerEndpoint
        self.providerType = providerType
        self.status = status
        self.vpcConfiguration = vpcConfiguration
    }
}

struct GetHostOutputResponseBody: Equatable {
    public let name: String?
    public let status: String?
    public let providerType: ProviderType?
    public let providerEndpoint: String?
    public let vpcConfiguration: VpcConfiguration?
}

extension GetHostOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case providerEndpoint = "ProviderEndpoint"
        case providerType = "ProviderType"
        case status = "Status"
        case vpcConfiguration = "VpcConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let providerEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerEndpoint)
        providerEndpoint = providerEndpointDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
    }
}

extension Host: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hostArn = "HostArn"
        case name = "Name"
        case providerEndpoint = "ProviderEndpoint"
        case providerType = "ProviderType"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostArn = hostArn {
            try encodeContainer.encode(hostArn, forKey: .hostArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let providerEndpoint = providerEndpoint {
            try encodeContainer.encode(providerEndpoint, forKey: .providerEndpoint)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let vpcConfiguration = vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let hostArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostArn)
        hostArn = hostArnDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let providerEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerEndpoint)
        providerEndpoint = providerEndpointDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension Host: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Host(hostArn: \(String(describing: hostArn)), name: \(String(describing: name)), providerEndpoint: \(String(describing: providerEndpoint)), providerType: \(String(describing: providerType)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)), vpcConfiguration: \(String(describing: vpcConfiguration)))"}
}

/// <p>A resource that represents the infrastructure where a third-party provider is installed.
///       The host is used when you create connections to an installed third-party provider type, such
///       as GitHub Enterprise Server. You create one host for all connections to that provider.</p>
///          <note>
///             <p>A host created through the CLI or the SDK is in `PENDING` status by
///         default. You can make its status `AVAILABLE` by setting up the host in the console.</p>
///          </note>
public struct Host: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the host.</p>
    public let hostArn: String?
    /// <p>The name of the host.</p>
    public let name: String?
    /// <p>The endpoint of the infrastructure where your provider type is installed.</p>
    public let providerEndpoint: String?
    /// <p>The name of the installed provider to be associated with your connection. The host
    ///       resource represents the infrastructure where your provider type is installed. The valid
    ///       provider type is GitHub Enterprise Server.</p>
    public let providerType: ProviderType?
    /// <p>The status of the host, such as PENDING, AVAILABLE, VPC_CONFIG_DELETING, VPC_CONFIG_INITIALIZING, and VPC_CONFIG_FAILED_INITIALIZATION.</p>
    public let status: String?
    /// <p>The status description for the host.</p>
    public let statusMessage: String?
    /// <p>The VPC configuration provisioned for the host.</p>
    public let vpcConfiguration: VpcConfiguration?

    public init (
        hostArn: String? = nil,
        name: String? = nil,
        providerEndpoint: String? = nil,
        providerType: ProviderType? = nil,
        status: String? = nil,
        statusMessage: String? = nil,
        vpcConfiguration: VpcConfiguration? = nil
    )
    {
        self.hostArn = hostArn
        self.name = name
        self.providerEndpoint = providerEndpoint
        self.providerType = providerType
        self.status = status
        self.statusMessage = statusMessage
        self.vpcConfiguration = vpcConfiguration
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exceeded the maximum limit for connections.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListConnectionsInputBodyMiddleware: Middleware {
    public let id: String = "ListConnectionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConnectionsInput>
    public typealias MOutput = OperationOutput<ListConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConnectionsOutputError>
}

extension ListConnectionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConnectionsInput(hostArnFilter: \(String(describing: hostArnFilter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), providerTypeFilter: \(String(describing: providerTypeFilter)))"}
}

extension ListConnectionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hostArnFilter = "HostArnFilter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case providerTypeFilter = "ProviderTypeFilter"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostArnFilter = hostArnFilter {
            try encodeContainer.encode(hostArnFilter, forKey: .hostArnFilter)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let providerTypeFilter = providerTypeFilter {
            try encodeContainer.encode(providerTypeFilter.rawValue, forKey: .providerTypeFilter)
        }
    }
}

public struct ListConnectionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListConnectionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConnectionsInput>
    public typealias MOutput = OperationOutput<ListConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConnectionsOutputError>
}

public struct ListConnectionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListConnectionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConnectionsInput>
    public typealias MOutput = OperationOutput<ListConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConnectionsOutputError>
}

public struct ListConnectionsInput: Equatable {
    /// <p>Filters the list of connections to those associated with a specified host.</p>
    public let hostArnFilter: String?
    /// <p>The maximum number of results to return in a single call. To retrieve the remaining
    ///       results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Int
    /// <p>The token that was returned from the previous <code>ListConnections</code> call, which
    ///       can be used to return the next set of connections in the list.</p>
    public let nextToken: String?
    /// <p>Filters the list of connections to those associated with a specified provider, such as
    ///       Bitbucket.</p>
    public let providerTypeFilter: ProviderType?

    public init (
        hostArnFilter: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        providerTypeFilter: ProviderType? = nil
    )
    {
        self.hostArnFilter = hostArnFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.providerTypeFilter = providerTypeFilter
    }
}

struct ListConnectionsInputBody: Equatable {
    public let providerTypeFilter: ProviderType?
    public let hostArnFilter: String?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListConnectionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hostArnFilter = "HostArnFilter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case providerTypeFilter = "ProviderTypeFilter"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerTypeFilterDecoded = try containerValues.decodeIfPresent(ProviderType.self, forKey: .providerTypeFilter)
        providerTypeFilter = providerTypeFilterDecoded
        let hostArnFilterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostArnFilter)
        hostArnFilter = hostArnFilterDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConnectionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConnectionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConnectionsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConnectionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConnectionsOutputResponse(connections: \(String(describing: connections)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConnectionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connections = output.connections
            self.nextToken = output.nextToken
        } else {
            self.connections = nil
            self.nextToken = nil
        }
    }
}

public struct ListConnectionsOutputResponse: Equatable {
    /// <p>A list of connections and the details for each connection, such as status, owner, and
    ///       provider type.</p>
    public let connections: [Connection]?
    /// <p>A token that can be used in the next <code>ListConnections</code> call. To view all
    ///       items in the list, continue to call this operation with each subsequent token until no more
    ///       <code>nextToken</code> values are returned.</p>
    public let nextToken: String?

    public init (
        connections: [Connection]? = nil,
        nextToken: String? = nil
    )
    {
        self.connections = connections
        self.nextToken = nextToken
    }
}

struct ListConnectionsOutputResponseBody: Equatable {
    public let connections: [Connection]?
    public let nextToken: String?
}

extension ListConnectionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connections = "Connections"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsContainer = try containerValues.decodeIfPresent([Connection?].self, forKey: .connections)
        var connectionsDecoded0:[Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListHostsInputBodyMiddleware: Middleware {
    public let id: String = "ListHostsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHostsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHostsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHostsInput>
    public typealias MOutput = OperationOutput<ListHostsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHostsOutputError>
}

extension ListHostsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListHostsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListHostsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListHostsInputHeadersMiddleware: Middleware {
    public let id: String = "ListHostsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHostsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHostsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHostsInput>
    public typealias MOutput = OperationOutput<ListHostsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHostsOutputError>
}

public struct ListHostsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListHostsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHostsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHostsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHostsInput>
    public typealias MOutput = OperationOutput<ListHostsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHostsOutputError>
}

public struct ListHostsInput: Equatable {
    /// <p>The maximum number of results to return in a single call. To retrieve the remaining
    ///       results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Int
    /// <p>The token that was returned from the previous <code>ListHosts</code> call, which can be
    ///       used to return the next set of hosts in the list.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListHostsInputBody: Equatable {
    public let maxResults: Int
    public let nextToken: String?
}

extension ListHostsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListHostsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHostsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListHostsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHostsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListHostsOutputResponse(hosts: \(String(describing: hosts)), nextToken: \(String(describing: nextToken)))"}
}

extension ListHostsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListHostsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hosts = output.hosts
            self.nextToken = output.nextToken
        } else {
            self.hosts = nil
            self.nextToken = nil
        }
    }
}

public struct ListHostsOutputResponse: Equatable {
    /// <p>A list of hosts and the details for each host, such as status, endpoint, and provider
    ///       type.</p>
    public let hosts: [Host]?
    /// <p>A token that can be used in the next <code>ListHosts</code> call. To view all items in the
    ///       list, continue to call this operation with each subsequent token until no more
    ///       <code>nextToken</code> values are returned.</p>
    public let nextToken: String?

    public init (
        hosts: [Host]? = nil,
        nextToken: String? = nil
    )
    {
        self.hosts = hosts
        self.nextToken = nextToken
    }
}

struct ListHostsOutputResponseBody: Equatable {
    public let hosts: [Host]?
    public let nextToken: String?
}

extension ListHostsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hosts = "Hosts"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostsContainer = try containerValues.decodeIfPresent([Host?].self, forKey: .hosts)
        var hostsDecoded0:[Host]? = nil
        if let hostsContainer = hostsContainer {
            hostsDecoded0 = [Host]()
            for structure0 in hostsContainer {
                if let structure0 = structure0 {
                    hostsDecoded0?.append(structure0)
                }
            }
        }
        hosts = hostsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource for which you want to get information about tags, if any.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A list of tag key and value pairs associated with the specified resource.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum ProviderType {
    case bitbucket
    case github
    case githubEnterpriseServer
    case sdkUnknown(String)
}

extension ProviderType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProviderType] {
        return [
            .bitbucket,
            .github,
            .githubEnterpriseServer,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bitbucket: return "Bitbucket"
        case .github: return "GitHub"
        case .githubEnterpriseServer: return "GitHubEnterpriseServer"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProviderType(rawValue: rawValue) ?? ProviderType.sdkUnknown(rawValue)
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Resource not found. Verify the connection resource ARN and try again.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceUnavailableException(message: \(String(describing: message)))"}
}

extension ResourceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Resource not found. Verify the ARN for the host resource and try again.</p>
public struct ResourceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ResourceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A tag is a key-value pair that is used to manage the resource.</p>
///          <p>This tag is available for use by AWS services that support tags.</p>
public struct Tag: Equatable {
    /// <p>The tag's key.</p>
    public let key: String?
    /// <p>The tag's value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource to which you want to add or update tags.</p>
    public let resourceArn: String?
    /// <p>The tags you want to modify or add to the resource.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UnsupportedOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedOperationException(message: \(String(describing: message)))"}
}

extension UnsupportedOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation is not supported. Check the connection status and try again.</p>
public struct UnsupportedOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource to remove tags from.</p>
    public let resourceArn: String?
    /// <p>The list of keys for the tags to be removed from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateHostInputBodyMiddleware: Middleware {
    public let id: String = "UpdateHostInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateHostInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateHostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateHostInput>
    public typealias MOutput = OperationOutput<UpdateHostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateHostOutputError>
}

extension UpdateHostInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateHostInput(hostArn: \(String(describing: hostArn)), providerEndpoint: \(String(describing: providerEndpoint)), vpcConfiguration: \(String(describing: vpcConfiguration)))"}
}

extension UpdateHostInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hostArn = "HostArn"
        case providerEndpoint = "ProviderEndpoint"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostArn = hostArn {
            try encodeContainer.encode(hostArn, forKey: .hostArn)
        }
        if let providerEndpoint = providerEndpoint {
            try encodeContainer.encode(providerEndpoint, forKey: .providerEndpoint)
        }
        if let vpcConfiguration = vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }
}

public struct UpdateHostInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateHostInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateHostInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateHostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateHostInput>
    public typealias MOutput = OperationOutput<UpdateHostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateHostOutputError>
}

public struct UpdateHostInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateHostInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateHostInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateHostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateHostInput>
    public typealias MOutput = OperationOutput<UpdateHostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateHostOutputError>
}

public struct UpdateHostInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the host to be updated.</p>
    public let hostArn: String?
    /// <p>The URL or endpoint of the host to be updated.</p>
    public let providerEndpoint: String?
    /// <p>The VPC configuration of the host to be updated. A VPC must be configured and the
    ///       infrastructure to be represented by the host must already be connected to the VPC.</p>
    public let vpcConfiguration: VpcConfiguration?

    public init (
        hostArn: String? = nil,
        providerEndpoint: String? = nil,
        vpcConfiguration: VpcConfiguration? = nil
    )
    {
        self.hostArn = hostArn
        self.providerEndpoint = providerEndpoint
        self.vpcConfiguration = vpcConfiguration
    }
}

struct UpdateHostInputBody: Equatable {
    public let hostArn: String?
    public let providerEndpoint: String?
    public let vpcConfiguration: VpcConfiguration?
}

extension UpdateHostInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hostArn = "HostArn"
        case providerEndpoint = "ProviderEndpoint"
        case vpcConfiguration = "VpcConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostArn)
        hostArn = hostArnDecoded
        let providerEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerEndpoint)
        providerEndpoint = providerEndpointDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
    }
}

extension UpdateHostOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateHostOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateHostOutputError: Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateHostOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateHostOutputResponse()"}
}

extension UpdateHostOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateHostOutputResponse: Equatable {

    public init() {}
}

struct UpdateHostOutputResponseBody: Equatable {
}

extension UpdateHostOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension VpcConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case tlsCertificate = "TlsCertificate"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let tlsCertificate = tlsCertificate {
            try encodeContainer.encode(tlsCertificate, forKey: .tlsCertificate)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let tlsCertificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tlsCertificate)
        tlsCertificate = tlsCertificateDecoded
    }
}

extension VpcConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcConfiguration(securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)), tlsCertificate: \(String(describing: tlsCertificate)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>The VPC configuration provisioned for the host.</p>
public struct VpcConfiguration: Equatable {
    /// <p>The ID of the security group or security groups associated with the Amazon VPC connected
    ///       to the infrastructure where your provider type is installed.</p>
    public let securityGroupIds: [String]?
    /// <p>The ID of the subnet or subnets associated with the Amazon VPC connected to the
    ///       infrastructure where your provider type is installed.</p>
    public let subnetIds: [String]?
    /// <p>The value of the Transport Layer Security (TLS) certificate associated with the infrastructure where your provider type is installed.</p>
    public let tlsCertificate: String?
    /// <p>The ID of the Amazon VPC connected to the infrastructure where your provider type is
    ///       installed.</p>
    public let vpcId: String?

    public init (
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil,
        tlsCertificate: String? = nil,
        vpcId: String? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tlsCertificate = tlsCertificate
        self.vpcId = vpcId
    }
}
