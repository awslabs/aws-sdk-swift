// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension Attribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case id = "Id"
        case relationshipScore = "RelationshipScore"
        case relationshipType = "RelationshipType"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let relationshipScore = relationshipScore {
            try encodeContainer.encode(relationshipScore, forKey: .relationshipScore)
        }
        if let relationshipType = relationshipType {
            try encodeContainer.encode(relationshipType.rawValue, forKey: .relationshipType)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for traitlist0 in traits {
                try traitsContainer.encode(traitlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(EntitySubType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .score)
        score = scoreDecoded
        let relationshipScoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .relationshipScore)
        relationshipScore = relationshipScoreDecoded
        let relationshipTypeDecoded = try containerValues.decodeIfPresent(RelationshipType.self, forKey: .relationshipType)
        relationshipType = relationshipTypeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .id)
        id = idDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(EntityType.self, forKey: .category)
        category = categoryDecoded
        let traitsContainer = try containerValues.decodeIfPresent([Trait?].self, forKey: .traits)
        var traitsDecoded0:[Trait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [Trait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
    }
}

extension Attribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Attribute(beginOffset: \(String(describing: beginOffset)), category: \(String(describing: category)), endOffset: \(String(describing: endOffset)), id: \(String(describing: id)), relationshipScore: \(String(describing: relationshipScore)), relationshipType: \(String(describing: relationshipType)), score: \(String(describing: score)), text: \(String(describing: text)), traits: \(String(describing: traits)), type: \(String(describing: type)))"}
}

/// <p> An extracted segment of the text that is an attribute of an entity, or otherwise related
///       to an entity, such as the dosage of a medication taken. It contains information about the
///       attribute such as id, begin and end offset within the input text, and the segment of the input
///       text. </p>
public struct Attribute: Equatable {
    /// <p> The 0-based character offset in the input text that shows where the attribute begins. The
    ///       offset returns the UTF-8 code point in the string. </p>
    public let beginOffset: Int?
    /// <p> The category of attribute. </p>
    public let category: EntityType?
    /// <p> The 0-based character offset in the input text that shows where the attribute ends. The
    ///       offset returns the UTF-8 code point in the string.</p>
    public let endOffset: Int?
    /// <p> The numeric identifier for this attribute. This is a monotonically increasing id unique
    ///       within this response rather than a global unique identifier. </p>
    public let id: Int?
    /// <p> The level of confidence that Amazon Comprehend Medical has that this attribute is correctly related to this
    ///       entity. </p>
    public let relationshipScore: Float?
    /// <p>The type of relationship between the entity and attribute. Type for the relationship is
    ///         <code>OVERLAP</code>, indicating that the entity occurred at the same time as the
    ///         <code>Date_Expression</code>. </p>
    public let relationshipType: RelationshipType?
    /// <p> The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized
    ///       as an attribute. </p>
    public let score: Float?
    /// <p> The segment of input text extracted as this attribute.</p>
    public let text: String?
    /// <p> Contextual information for this attribute. </p>
    public let traits: [Trait]?
    /// <p> The type of attribute. </p>
    public let type: EntitySubType?

    public init (
        beginOffset: Int? = nil,
        category: EntityType? = nil,
        endOffset: Int? = nil,
        id: Int? = nil,
        relationshipScore: Float? = nil,
        relationshipType: RelationshipType? = nil,
        score: Float? = nil,
        text: String? = nil,
        traits: [Trait]? = nil,
        type: EntitySubType? = nil
    )
    {
        self.beginOffset = beginOffset
        self.category = category
        self.endOffset = endOffset
        self.id = id
        self.relationshipScore = relationshipScore
        self.relationshipType = relationshipType
        self.score = score
        self.text = text
        self.traits = traits
        self.type = type
    }
}

public enum AttributeName {
    case diagnosis
    case negation
    case sign
    case symptom
    case sdkUnknown(String)
}

extension AttributeName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AttributeName] {
        return [
            .diagnosis,
            .negation,
            .sign,
            .symptom,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .diagnosis: return "DIAGNOSIS"
        case .negation: return "NEGATION"
        case .sign: return "SIGN"
        case .symptom: return "SYMPTOM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AttributeName(rawValue: rawValue) ?? AttributeName.sdkUnknown(rawValue)
    }
}

extension ComprehendMedicalAsyncJobFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case submitTimeAfter = "SubmitTimeAfter"
        case submitTimeBefore = "SubmitTimeBefore"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let submitTimeAfter = submitTimeAfter {
            try encodeContainer.encode(submitTimeAfter.timeIntervalSince1970, forKey: .submitTimeAfter)
        }
        if let submitTimeBefore = submitTimeBefore {
            try encodeContainer.encode(submitTimeBefore.timeIntervalSince1970, forKey: .submitTimeBefore)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeBefore)
        submitTimeBefore = submitTimeBeforeDecoded
        let submitTimeAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeAfter)
        submitTimeAfter = submitTimeAfterDecoded
    }
}

extension ComprehendMedicalAsyncJobFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComprehendMedicalAsyncJobFilter(jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), submitTimeAfter: \(String(describing: submitTimeAfter)), submitTimeBefore: \(String(describing: submitTimeBefore)))"}
}

/// <p>Provides information for filtering a list of detection jobs.</p>
public struct ComprehendMedicalAsyncJobFilter: Equatable {
    /// <p>Filters on the name of the job.</p>
    public let jobName: String?
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified
    ///       status.</p>
    public let jobStatus: JobStatus?
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing.
    ///       Returns only jobs submitted after the specified time. Jobs are returned in descending order,
    ///       newest to oldest.</p>
    public let submitTimeAfter: Date?
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing.
    ///       Returns only jobs submitted before the specified time. Jobs are returned in ascending order,
    ///       oldest to newest.</p>
    public let submitTimeBefore: Date?

    public init (
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        submitTimeAfter: Date? = nil,
        submitTimeBefore: Date? = nil
    )
    {
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.submitTimeAfter = submitTimeAfter
        self.submitTimeBefore = submitTimeBefore
    }
}

extension ComprehendMedicalAsyncJobProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case endTime = "EndTime"
        case expirationTime = "ExpirationTime"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case manifestFilePath = "ManifestFilePath"
        case message = "Message"
        case modelVersion = "ModelVersion"
        case outputDataConfig = "OutputDataConfig"
        case submitTime = "SubmitTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let expirationTime = expirationTime {
            try encodeContainer.encode(expirationTime.timeIntervalSince1970, forKey: .expirationTime)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let manifestFilePath = manifestFilePath {
            try encodeContainer.encode(manifestFilePath, forKey: .manifestFilePath)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let modelVersion = modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let manifestFilePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manifestFilePath)
        manifestFilePath = manifestFilePathDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

extension ComprehendMedicalAsyncJobProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComprehendMedicalAsyncJobProperties(dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), endTime: \(String(describing: endTime)), expirationTime: \(String(describing: expirationTime)), inputDataConfig: \(String(describing: inputDataConfig)), jobId: \(String(describing: jobId)), jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), kMSKey: \(String(describing: kMSKey)), languageCode: \(String(describing: languageCode)), manifestFilePath: \(String(describing: manifestFilePath)), message: \(String(describing: message)), modelVersion: \(String(describing: modelVersion)), outputDataConfig: \(String(describing: outputDataConfig)), submitTime: \(String(describing: submitTime)))"}
}

/// <p>Provides information about a detection job.</p>
public struct ComprehendMedicalAsyncJobProperties: Equatable {
    /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend Medical read access to your input data.</p>
    public let dataAccessRoleArn: String?
    /// <p>The time that the detection job completed.</p>
    public let endTime: Date?
    /// <p>The date and time that job metadata is deleted from the server. Output files in your S3
    ///       bucket will not be deleted. After the metadata is deleted, the job will no longer appear in
    ///       the results of the <code>ListEntitiesDetectionV2Job</code> or the
    ///         <code>ListPHIDetectionJobs</code> operation.</p>
    public let expirationTime: Date?
    /// <p>The input data configuration that you supplied when you created the detection job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The identifier assigned to the detection job.</p>
    public let jobId: String?
    /// <p>The name that you assigned to the detection job.</p>
    public let jobName: String?
    /// <p>The current status of the detection job. If the status is <code>FAILED</code>, the
    ///         <code>Message</code> field shows the reason for the failure.</p>
    public let jobStatus: JobStatus?
    /// <p>The AWS Key Management Service key, if any, used to encrypt the output files. </p>
    public let kMSKey: String?
    /// <p>The language code of the input documents.</p>
    public let languageCode: LanguageCode?
    /// <p>The path to the file that describes the results of a batch job.</p>
    public let manifestFilePath: String?
    /// <p>A description of the status of a job.</p>
    public let message: String?
    /// <p>The version of the model used to analyze the documents. The version number looks like
    ///       X.X.X. You can use this information to track the model used for a particular batch of
    ///       documents.</p>
    public let modelVersion: String?
    /// <p>The output data configuration that you supplied when you created the detection job.</p>
    public let outputDataConfig: OutputDataConfig?
    /// <p>The time that the detection job was submitted for processing.</p>
    public let submitTime: Date?

    public init (
        dataAccessRoleArn: String? = nil,
        endTime: Date? = nil,
        expirationTime: Date? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobId: String? = nil,
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        kMSKey: String? = nil,
        languageCode: LanguageCode? = nil,
        manifestFilePath: String? = nil,
        message: String? = nil,
        modelVersion: String? = nil,
        outputDataConfig: OutputDataConfig? = nil,
        submitTime: Date? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.endTime = endTime
        self.expirationTime = expirationTime
        self.inputDataConfig = inputDataConfig
        self.jobId = jobId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.kMSKey = kMSKey
        self.languageCode = languageCode
        self.manifestFilePath = manifestFilePath
        self.message = message
        self.modelVersion = modelVersion
        self.outputDataConfig = outputDataConfig
        self.submitTime = submitTime
    }
}

public struct DescribeEntitiesDetectionV2JobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEntitiesDetectionV2JobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEntitiesDetectionV2JobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEntitiesDetectionV2JobInput>
    public typealias MOutput = OperationOutput<DescribeEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEntitiesDetectionV2JobOutputError>
}

extension DescribeEntitiesDetectionV2JobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEntitiesDetectionV2JobInput(jobId: \(String(describing: jobId)))"}
}

extension DescribeEntitiesDetectionV2JobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeEntitiesDetectionV2JobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEntitiesDetectionV2JobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEntitiesDetectionV2JobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEntitiesDetectionV2JobInput>
    public typealias MOutput = OperationOutput<DescribeEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEntitiesDetectionV2JobOutputError>
}

public struct DescribeEntitiesDetectionV2JobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEntitiesDetectionV2JobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEntitiesDetectionV2JobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEntitiesDetectionV2JobInput>
    public typealias MOutput = OperationOutput<DescribeEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEntitiesDetectionV2JobOutputError>
}

public struct DescribeEntitiesDetectionV2JobInput: Equatable {
    /// <p>The identifier that Amazon Comprehend Medical generated for the job. The
    ///         <code>StartEntitiesDetectionV2Job</code> operation returns this identifier in its
    ///       response.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeEntitiesDetectionV2JobInputBody: Equatable {
    public let jobId: String?
}

extension DescribeEntitiesDetectionV2JobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeEntitiesDetectionV2JobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEntitiesDetectionV2JobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEntitiesDetectionV2JobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEntitiesDetectionV2JobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEntitiesDetectionV2JobOutputResponse(comprehendMedicalAsyncJobProperties: \(String(describing: comprehendMedicalAsyncJobProperties)))"}
}

extension DescribeEntitiesDetectionV2JobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEntitiesDetectionV2JobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.comprehendMedicalAsyncJobProperties = output.comprehendMedicalAsyncJobProperties
        } else {
            self.comprehendMedicalAsyncJobProperties = nil
        }
    }
}

public struct DescribeEntitiesDetectionV2JobOutputResponse: Equatable {
    /// <p>An object that contains the properties associated with a detection job.</p>
    public let comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties?

    public init (
        comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties? = nil
    )
    {
        self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
    }
}

struct DescribeEntitiesDetectionV2JobOutputResponseBody: Equatable {
    public let comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties?
}

extension DescribeEntitiesDetectionV2JobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesDecoded = try containerValues.decodeIfPresent(ComprehendMedicalAsyncJobProperties.self, forKey: .comprehendMedicalAsyncJobProperties)
        comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobPropertiesDecoded
    }
}

public struct DescribeICD10CMInferenceJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeICD10CMInferenceJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeICD10CMInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeICD10CMInferenceJobInput>
    public typealias MOutput = OperationOutput<DescribeICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeICD10CMInferenceJobOutputError>
}

extension DescribeICD10CMInferenceJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeICD10CMInferenceJobInput(jobId: \(String(describing: jobId)))"}
}

extension DescribeICD10CMInferenceJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeICD10CMInferenceJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeICD10CMInferenceJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeICD10CMInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeICD10CMInferenceJobInput>
    public typealias MOutput = OperationOutput<DescribeICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeICD10CMInferenceJobOutputError>
}

public struct DescribeICD10CMInferenceJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeICD10CMInferenceJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeICD10CMInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeICD10CMInferenceJobInput>
    public typealias MOutput = OperationOutput<DescribeICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeICD10CMInferenceJobOutputError>
}

public struct DescribeICD10CMInferenceJobInput: Equatable {
    /// <p>The identifier that Amazon Comprehend Medical generated for the job. <code>The
    ///         StartICD10CMInferenceJob</code> operation returns this identifier in its response.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeICD10CMInferenceJobInputBody: Equatable {
    public let jobId: String?
}

extension DescribeICD10CMInferenceJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeICD10CMInferenceJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeICD10CMInferenceJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeICD10CMInferenceJobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeICD10CMInferenceJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeICD10CMInferenceJobOutputResponse(comprehendMedicalAsyncJobProperties: \(String(describing: comprehendMedicalAsyncJobProperties)))"}
}

extension DescribeICD10CMInferenceJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeICD10CMInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.comprehendMedicalAsyncJobProperties = output.comprehendMedicalAsyncJobProperties
        } else {
            self.comprehendMedicalAsyncJobProperties = nil
        }
    }
}

public struct DescribeICD10CMInferenceJobOutputResponse: Equatable {
    /// <p>An object that contains the properties associated with a detection job.</p>
    public let comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties?

    public init (
        comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties? = nil
    )
    {
        self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
    }
}

struct DescribeICD10CMInferenceJobOutputResponseBody: Equatable {
    public let comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties?
}

extension DescribeICD10CMInferenceJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesDecoded = try containerValues.decodeIfPresent(ComprehendMedicalAsyncJobProperties.self, forKey: .comprehendMedicalAsyncJobProperties)
        comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobPropertiesDecoded
    }
}

public struct DescribePHIDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribePHIDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePHIDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePHIDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribePHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePHIDetectionJobOutputError>
}

extension DescribePHIDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePHIDetectionJobInput(jobId: \(String(describing: jobId)))"}
}

extension DescribePHIDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribePHIDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePHIDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePHIDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePHIDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribePHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePHIDetectionJobOutputError>
}

public struct DescribePHIDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePHIDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePHIDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePHIDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribePHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePHIDetectionJobOutputError>
}

public struct DescribePHIDetectionJobInput: Equatable {
    /// <p>The identifier that Amazon Comprehend Medical generated for the job. The <code>StartPHIDetectionJob</code>
    ///       operation returns this identifier in its response.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribePHIDetectionJobInputBody: Equatable {
    public let jobId: String?
}

extension DescribePHIDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribePHIDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePHIDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePHIDetectionJobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePHIDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePHIDetectionJobOutputResponse(comprehendMedicalAsyncJobProperties: \(String(describing: comprehendMedicalAsyncJobProperties)))"}
}

extension DescribePHIDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePHIDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.comprehendMedicalAsyncJobProperties = output.comprehendMedicalAsyncJobProperties
        } else {
            self.comprehendMedicalAsyncJobProperties = nil
        }
    }
}

public struct DescribePHIDetectionJobOutputResponse: Equatable {
    /// <p>An object that contains the properties associated with a detection job.</p>
    public let comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties?

    public init (
        comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties? = nil
    )
    {
        self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
    }
}

struct DescribePHIDetectionJobOutputResponseBody: Equatable {
    public let comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties?
}

extension DescribePHIDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesDecoded = try containerValues.decodeIfPresent(ComprehendMedicalAsyncJobProperties.self, forKey: .comprehendMedicalAsyncJobProperties)
        comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobPropertiesDecoded
    }
}

public struct DescribeRxNormInferenceJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRxNormInferenceJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRxNormInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRxNormInferenceJobInput>
    public typealias MOutput = OperationOutput<DescribeRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRxNormInferenceJobOutputError>
}

extension DescribeRxNormInferenceJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRxNormInferenceJobInput(jobId: \(String(describing: jobId)))"}
}

extension DescribeRxNormInferenceJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeRxNormInferenceJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRxNormInferenceJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRxNormInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRxNormInferenceJobInput>
    public typealias MOutput = OperationOutput<DescribeRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRxNormInferenceJobOutputError>
}

public struct DescribeRxNormInferenceJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRxNormInferenceJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRxNormInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRxNormInferenceJobInput>
    public typealias MOutput = OperationOutput<DescribeRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRxNormInferenceJobOutputError>
}

public struct DescribeRxNormInferenceJobInput: Equatable {
    /// <p>The identifier that Amazon Comprehend Medical generated for the job. The
    ///       StartRxNormInferenceJob operation returns this identifier in its response.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeRxNormInferenceJobInputBody: Equatable {
    public let jobId: String?
}

extension DescribeRxNormInferenceJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeRxNormInferenceJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRxNormInferenceJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRxNormInferenceJobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRxNormInferenceJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRxNormInferenceJobOutputResponse(comprehendMedicalAsyncJobProperties: \(String(describing: comprehendMedicalAsyncJobProperties)))"}
}

extension DescribeRxNormInferenceJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRxNormInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.comprehendMedicalAsyncJobProperties = output.comprehendMedicalAsyncJobProperties
        } else {
            self.comprehendMedicalAsyncJobProperties = nil
        }
    }
}

public struct DescribeRxNormInferenceJobOutputResponse: Equatable {
    /// <p>An object that contains the properties associated with a detection job.</p>
    public let comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties?

    public init (
        comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties? = nil
    )
    {
        self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
    }
}

struct DescribeRxNormInferenceJobOutputResponseBody: Equatable {
    public let comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties?
}

extension DescribeRxNormInferenceJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesDecoded = try containerValues.decodeIfPresent(ComprehendMedicalAsyncJobProperties.self, forKey: .comprehendMedicalAsyncJobProperties)
        comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobPropertiesDecoded
    }
}

public struct DetectEntitiesInputBodyMiddleware: Middleware {
    public let id: String = "DetectEntitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectEntitiesInput>
    public typealias MOutput = OperationOutput<DetectEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectEntitiesOutputError>
}

extension DetectEntitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectEntitiesInput(text: \(String(describing: text)))"}
}

extension DetectEntitiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct DetectEntitiesInputHeadersMiddleware: Middleware {
    public let id: String = "DetectEntitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectEntitiesInput>
    public typealias MOutput = OperationOutput<DetectEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectEntitiesOutputError>
}

public struct DetectEntitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "DetectEntitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectEntitiesInput>
    public typealias MOutput = OperationOutput<DetectEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectEntitiesOutputError>
}

public struct DetectEntitiesInput: Equatable {
    /// <p> A UTF-8 text string containing the clinical content being examined for entities. Each
    ///       string must contain fewer than 20,000 bytes of characters.</p>
    public let text: String?

    public init (
        text: String? = nil
    )
    {
        self.text = text
    }
}

struct DetectEntitiesInputBody: Equatable {
    public let text: String?
}

extension DetectEntitiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case text = "Text"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
    }
}

extension DetectEntitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectEntitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEncodingException" : self = .invalidEncodingException(try InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectEntitiesOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidEncodingException(InvalidEncodingException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectEntitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectEntitiesOutputResponse(entities: \(String(describing: entities)), modelVersion: \(String(describing: modelVersion)), paginationToken: \(String(describing: paginationToken)), unmappedAttributes: \(String(describing: unmappedAttributes)))"}
}

extension DetectEntitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DetectEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
            self.unmappedAttributes = output.unmappedAttributes
        } else {
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
            self.unmappedAttributes = nil
        }
    }
}

public struct DetectEntitiesOutputResponse: Equatable {
    /// <p> The collection of medical entities extracted from the input text and their associated
    ///       information. For each entity, the response provides the entity text, the entity category,
    ///       where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in the
    ///       detection and analysis. Attributes and traits of the entity are also returned.</p>
    public let entities: [Entity]?
    /// <p>The version of the model used to analyze the documents. The version number looks like
    ///       X.X.X. You can use this information to track the model used for a particular batch of
    ///       documents.</p>
    public let modelVersion: String?
    /// <p> If the result of the previous request to <code>DetectEntities</code> was truncated,
    ///       include the <code>PaginationToken</code> to fetch the next page of entities.</p>
    public let paginationToken: String?
    /// <p> Attributes extracted from the input text that we were unable to relate to an
    ///       entity.</p>
    public let unmappedAttributes: [UnmappedAttribute]?

    public init (
        entities: [Entity]? = nil,
        modelVersion: String? = nil,
        paginationToken: String? = nil,
        unmappedAttributes: [UnmappedAttribute]? = nil
    )
    {
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
        self.unmappedAttributes = unmappedAttributes
    }
}

struct DetectEntitiesOutputResponseBody: Equatable {
    public let entities: [Entity]?
    public let unmappedAttributes: [UnmappedAttribute]?
    public let paginationToken: String?
    public let modelVersion: String?
}

extension DetectEntitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
        case unmappedAttributes = "UnmappedAttributes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([Entity?].self, forKey: .entities)
        var entitiesDecoded0:[Entity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [Entity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let unmappedAttributesContainer = try containerValues.decodeIfPresent([UnmappedAttribute?].self, forKey: .unmappedAttributes)
        var unmappedAttributesDecoded0:[UnmappedAttribute]? = nil
        if let unmappedAttributesContainer = unmappedAttributesContainer {
            unmappedAttributesDecoded0 = [UnmappedAttribute]()
            for structure0 in unmappedAttributesContainer {
                if let structure0 = structure0 {
                    unmappedAttributesDecoded0?.append(structure0)
                }
            }
        }
        unmappedAttributes = unmappedAttributesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

public struct DetectEntitiesV2InputBodyMiddleware: Middleware {
    public let id: String = "DetectEntitiesV2InputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectEntitiesV2Input>,
                  next: H) -> Swift.Result<OperationOutput<DetectEntitiesV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectEntitiesV2Input>
    public typealias MOutput = OperationOutput<DetectEntitiesV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectEntitiesV2OutputError>
}

extension DetectEntitiesV2Input: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectEntitiesV2Input(text: \(String(describing: text)))"}
}

extension DetectEntitiesV2Input: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct DetectEntitiesV2InputHeadersMiddleware: Middleware {
    public let id: String = "DetectEntitiesV2InputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectEntitiesV2Input>,
                  next: H) -> Swift.Result<OperationOutput<DetectEntitiesV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectEntitiesV2Input>
    public typealias MOutput = OperationOutput<DetectEntitiesV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectEntitiesV2OutputError>
}

public struct DetectEntitiesV2InputQueryItemMiddleware: Middleware {
    public let id: String = "DetectEntitiesV2InputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectEntitiesV2Input>,
                  next: H) -> Swift.Result<OperationOutput<DetectEntitiesV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectEntitiesV2Input>
    public typealias MOutput = OperationOutput<DetectEntitiesV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectEntitiesV2OutputError>
}

public struct DetectEntitiesV2Input: Equatable {
    /// <p>A UTF-8 string containing the clinical content being examined for entities. Each string
    ///       must contain fewer than 20,000 bytes of characters.</p>
    public let text: String?

    public init (
        text: String? = nil
    )
    {
        self.text = text
    }
}

struct DetectEntitiesV2InputBody: Equatable {
    public let text: String?
}

extension DetectEntitiesV2InputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case text = "Text"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
    }
}

extension DetectEntitiesV2OutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectEntitiesV2OutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEncodingException" : self = .invalidEncodingException(try InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectEntitiesV2OutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidEncodingException(InvalidEncodingException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectEntitiesV2OutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectEntitiesV2OutputResponse(entities: \(String(describing: entities)), modelVersion: \(String(describing: modelVersion)), paginationToken: \(String(describing: paginationToken)), unmappedAttributes: \(String(describing: unmappedAttributes)))"}
}

extension DetectEntitiesV2OutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DetectEntitiesV2OutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
            self.unmappedAttributes = output.unmappedAttributes
        } else {
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
            self.unmappedAttributes = nil
        }
    }
}

public struct DetectEntitiesV2OutputResponse: Equatable {
    /// <p>The collection of medical entities extracted from the input text and their associated
    ///       information. For each entity, the response provides the entity text, the entity category,
    ///       where the entity text begins and ends, and the level of confidence in the detection and
    ///       analysis. Attributes and traits of the entity are also returned.</p>
    public let entities: [Entity]?
    /// <p>The version of the model used to analyze the documents. The version number looks like
    ///       X.X.X. You can use this information to track the model used for a particular batch of
    ///       documents.</p>
    public let modelVersion: String?
    /// <p>If the result to the <code>DetectEntitiesV2</code> operation was truncated, include the
    ///         <code>PaginationToken</code> to fetch the next page of entities.</p>
    public let paginationToken: String?
    /// <p>Attributes extracted from the input text that couldn't be related to an entity.</p>
    public let unmappedAttributes: [UnmappedAttribute]?

    public init (
        entities: [Entity]? = nil,
        modelVersion: String? = nil,
        paginationToken: String? = nil,
        unmappedAttributes: [UnmappedAttribute]? = nil
    )
    {
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
        self.unmappedAttributes = unmappedAttributes
    }
}

struct DetectEntitiesV2OutputResponseBody: Equatable {
    public let entities: [Entity]?
    public let unmappedAttributes: [UnmappedAttribute]?
    public let paginationToken: String?
    public let modelVersion: String?
}

extension DetectEntitiesV2OutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
        case unmappedAttributes = "UnmappedAttributes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([Entity?].self, forKey: .entities)
        var entitiesDecoded0:[Entity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [Entity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let unmappedAttributesContainer = try containerValues.decodeIfPresent([UnmappedAttribute?].self, forKey: .unmappedAttributes)
        var unmappedAttributesDecoded0:[UnmappedAttribute]? = nil
        if let unmappedAttributesContainer = unmappedAttributesContainer {
            unmappedAttributesDecoded0 = [UnmappedAttribute]()
            for structure0 in unmappedAttributesContainer {
                if let structure0 = structure0 {
                    unmappedAttributesDecoded0?.append(structure0)
                }
            }
        }
        unmappedAttributes = unmappedAttributesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

public struct DetectPHIInputBodyMiddleware: Middleware {
    public let id: String = "DetectPHIInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectPHIInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectPHIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectPHIInput>
    public typealias MOutput = OperationOutput<DetectPHIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectPHIOutputError>
}

extension DetectPHIInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectPHIInput(text: \(String(describing: text)))"}
}

extension DetectPHIInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct DetectPHIInputHeadersMiddleware: Middleware {
    public let id: String = "DetectPHIInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectPHIInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectPHIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectPHIInput>
    public typealias MOutput = OperationOutput<DetectPHIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectPHIOutputError>
}

public struct DetectPHIInputQueryItemMiddleware: Middleware {
    public let id: String = "DetectPHIInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectPHIInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectPHIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectPHIInput>
    public typealias MOutput = OperationOutput<DetectPHIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectPHIOutputError>
}

public struct DetectPHIInput: Equatable {
    /// <p> A UTF-8 text string containing the clinical content being examined for PHI entities. Each
    ///       string must contain fewer than 20,000 bytes of characters.</p>
    public let text: String?

    public init (
        text: String? = nil
    )
    {
        self.text = text
    }
}

struct DetectPHIInputBody: Equatable {
    public let text: String?
}

extension DetectPHIInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case text = "Text"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
    }
}

extension DetectPHIOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectPHIOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEncodingException" : self = .invalidEncodingException(try InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectPHIOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidEncodingException(InvalidEncodingException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectPHIOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectPHIOutputResponse(entities: \(String(describing: entities)), modelVersion: \(String(describing: modelVersion)), paginationToken: \(String(describing: paginationToken)))"}
}

extension DetectPHIOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DetectPHIOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
        } else {
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
        }
    }
}

public struct DetectPHIOutputResponse: Equatable {
    /// <p> The collection of PHI entities extracted from the input text and their associated
    ///       information. For each entity, the response provides the entity text, the entity category,
    ///       where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in its
    ///       detection. </p>
    public let entities: [Entity]?
    /// <p>The version of the model used to analyze the documents. The version number looks like
    ///       X.X.X. You can use this information to track the model used for a particular batch of
    ///       documents.</p>
    public let modelVersion: String?
    /// <p> If the result of the previous request to <code>DetectPHI</code> was truncated, include
    ///       the <code>PaginationToken</code> to fetch the next page of PHI entities. </p>
    public let paginationToken: String?

    public init (
        entities: [Entity]? = nil,
        modelVersion: String? = nil,
        paginationToken: String? = nil
    )
    {
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
    }
}

struct DetectPHIOutputResponseBody: Equatable {
    public let entities: [Entity]?
    public let paginationToken: String?
    public let modelVersion: String?
}

extension DetectPHIOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([Entity?].self, forKey: .entities)
        var entitiesDecoded0:[Entity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [Entity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

extension Entity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case id = "Id"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributelist0 in attributes {
                try attributesContainer.encode(attributelist0)
            }
        }
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for traitlist0 in traits {
                try traitsContainer.encode(traitlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .id)
        id = idDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .score)
        score = scoreDecoded
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(EntityType.self, forKey: .category)
        category = categoryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EntitySubType.self, forKey: .type)
        type = typeDecoded
        let traitsContainer = try containerValues.decodeIfPresent([Trait?].self, forKey: .traits)
        var traitsDecoded0:[Trait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [Trait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension Entity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Entity(attributes: \(String(describing: attributes)), beginOffset: \(String(describing: beginOffset)), category: \(String(describing: category)), endOffset: \(String(describing: endOffset)), id: \(String(describing: id)), score: \(String(describing: score)), text: \(String(describing: text)), traits: \(String(describing: traits)), type: \(String(describing: type)))"}
}

/// <p> Provides information about an extracted medical entity.</p>
public struct Entity: Equatable {
    /// <p> The extracted attributes that relate to this entity.</p>
    public let attributes: [Attribute]?
    /// <p> The 0-based character offset in the input text that shows where the entity begins. The
    ///       offset returns the UTF-8 code point in the string. </p>
    public let beginOffset: Int?
    /// <p> The category of the entity.</p>
    public let category: EntityType?
    /// <p> The 0-based character offset in the input text that shows where the entity ends. The
    ///       offset returns the UTF-8 code point in the string. </p>
    public let endOffset: Int?
    /// <p> The numeric identifier for the entity. This is a monotonically increasing id unique
    ///       within this response rather than a global unique identifier. </p>
    public let id: Int?
    /// <p>The level of confidence that Amazon Comprehend Medical has in the accuracy of the detection.</p>
    public let score: Float?
    /// <p> The segment of input text extracted as this entity.</p>
    public let text: String?
    /// <p>Contextual information for the entity.</p>
    public let traits: [Trait]?
    /// <p> Describes the specific type of entity with category of entities.</p>
    public let type: EntitySubType?

    public init (
        attributes: [Attribute]? = nil,
        beginOffset: Int? = nil,
        category: EntityType? = nil,
        endOffset: Int? = nil,
        id: Int? = nil,
        score: Float? = nil,
        text: String? = nil,
        traits: [Trait]? = nil,
        type: EntitySubType? = nil
    )
    {
        self.attributes = attributes
        self.beginOffset = beginOffset
        self.category = category
        self.endOffset = endOffset
        self.id = id
        self.score = score
        self.text = text
        self.traits = traits
        self.type = type
    }
}

public enum EntitySubType {
    case acuity
    case address
    case age
    case brandName
    case contactPoint
    case date
    case direction
    case dosage
    case duration
    case email
    case form
    case frequency
    case genericName
    case identifier
    case name
    case procedureName
    case profession
    case quality
    case quantity
    case rate
    case routeOrMode
    case strength
    case systemOrganSite
    case testName
    case testUnits
    case testValue
    case timeExpression
    case timeToDxName
    case timeToMedicationName
    case timeToProcedureName
    case timeToTestName
    case timeToTreatmentName
    case treatmentName
    case url
    case sdkUnknown(String)
}

extension EntitySubType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EntitySubType] {
        return [
            .acuity,
            .address,
            .age,
            .brandName,
            .contactPoint,
            .date,
            .direction,
            .dosage,
            .duration,
            .email,
            .form,
            .frequency,
            .genericName,
            .identifier,
            .name,
            .procedureName,
            .profession,
            .quality,
            .quantity,
            .rate,
            .routeOrMode,
            .strength,
            .systemOrganSite,
            .testName,
            .testUnits,
            .testValue,
            .timeExpression,
            .timeToDxName,
            .timeToMedicationName,
            .timeToProcedureName,
            .timeToTestName,
            .timeToTreatmentName,
            .treatmentName,
            .url,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .acuity: return "ACUITY"
        case .address: return "ADDRESS"
        case .age: return "AGE"
        case .brandName: return "BRAND_NAME"
        case .contactPoint: return "CONTACT_POINT"
        case .date: return "DATE"
        case .direction: return "DIRECTION"
        case .dosage: return "DOSAGE"
        case .duration: return "DURATION"
        case .email: return "EMAIL"
        case .form: return "FORM"
        case .frequency: return "FREQUENCY"
        case .genericName: return "GENERIC_NAME"
        case .identifier: return "IDENTIFIER"
        case .name: return "NAME"
        case .procedureName: return "PROCEDURE_NAME"
        case .profession: return "PROFESSION"
        case .quality: return "QUALITY"
        case .quantity: return "QUANTITY"
        case .rate: return "RATE"
        case .routeOrMode: return "ROUTE_OR_MODE"
        case .strength: return "STRENGTH"
        case .systemOrganSite: return "SYSTEM_ORGAN_SITE"
        case .testName: return "TEST_NAME"
        case .testUnits: return "TEST_UNITS"
        case .testValue: return "TEST_VALUE"
        case .timeExpression: return "TIME_EXPRESSION"
        case .timeToDxName: return "TIME_TO_DX_NAME"
        case .timeToMedicationName: return "TIME_TO_MEDICATION_NAME"
        case .timeToProcedureName: return "TIME_TO_PROCEDURE_NAME"
        case .timeToTestName: return "TIME_TO_TEST_NAME"
        case .timeToTreatmentName: return "TIME_TO_TREATMENT_NAME"
        case .treatmentName: return "TREATMENT_NAME"
        case .url: return "URL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EntitySubType(rawValue: rawValue) ?? EntitySubType.sdkUnknown(rawValue)
    }
}

public enum EntityType {
    case anatomy
    case medicalCondition
    case medication
    case protectedHealthInformation
    case testTreatmentProcedure
    case timeExpression
    case sdkUnknown(String)
}

extension EntityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EntityType] {
        return [
            .anatomy,
            .medicalCondition,
            .medication,
            .protectedHealthInformation,
            .testTreatmentProcedure,
            .timeExpression,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .anatomy: return "ANATOMY"
        case .medicalCondition: return "MEDICAL_CONDITION"
        case .medication: return "MEDICATION"
        case .protectedHealthInformation: return "PROTECTED_HEALTH_INFORMATION"
        case .testTreatmentProcedure: return "TEST_TREATMENT_PROCEDURE"
        case .timeExpression: return "TIME_EXPRESSION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EntityType(rawValue: rawValue) ?? EntityType.sdkUnknown(rawValue)
    }
}

extension ICD10CMAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case id = "Id"
        case relationshipScore = "RelationshipScore"
        case relationshipType = "RelationshipType"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let relationshipScore = relationshipScore {
            try encodeContainer.encode(relationshipScore, forKey: .relationshipScore)
        }
        if let relationshipType = relationshipType {
            try encodeContainer.encode(relationshipType.rawValue, forKey: .relationshipType)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for icd10cmtraitlist0 in traits {
                try traitsContainer.encode(icd10cmtraitlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ICD10CMAttributeType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .score)
        score = scoreDecoded
        let relationshipScoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .relationshipScore)
        relationshipScore = relationshipScoreDecoded
        let idDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .id)
        id = idDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let traitsContainer = try containerValues.decodeIfPresent([ICD10CMTrait?].self, forKey: .traits)
        var traitsDecoded0:[ICD10CMTrait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ICD10CMTrait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
        let categoryDecoded = try containerValues.decodeIfPresent(ICD10CMEntityType.self, forKey: .category)
        category = categoryDecoded
        let relationshipTypeDecoded = try containerValues.decodeIfPresent(ICD10CMRelationshipType.self, forKey: .relationshipType)
        relationshipType = relationshipTypeDecoded
    }
}

extension ICD10CMAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ICD10CMAttribute(beginOffset: \(String(describing: beginOffset)), category: \(String(describing: category)), endOffset: \(String(describing: endOffset)), id: \(String(describing: id)), relationshipScore: \(String(describing: relationshipScore)), relationshipType: \(String(describing: relationshipType)), score: \(String(describing: score)), text: \(String(describing: text)), traits: \(String(describing: traits)), type: \(String(describing: type)))"}
}

/// <p>The detected attributes that relate to an entity. This includes an extracted segment of
///       the text that is an attribute of an entity, or otherwise related to an entity. InferICD10CM
///       detects the following attributes: <code>Direction</code>, <code>System, Organ or Site</code>,
///       and <code>Acuity</code>.</p>
public struct ICD10CMAttribute: Equatable {
    /// <p>The 0-based character offset in the input text that shows where the attribute begins. The
    ///       offset returns the UTF-8 code point in the string.</p>
    public let beginOffset: Int?
    /// <p>The category of attribute. Can be either of <code>DX_NAME</code> or <code>TIME_EXPRESSION</code>.</p>
    public let category: ICD10CMEntityType?
    /// <p>The 0-based character offset in the input text that shows where the attribute ends. The
    ///       offset returns the UTF-8 code point in the string.</p>
    public let endOffset: Int?
    /// <p>The numeric identifier for this attribute. This is a monotonically increasing id unique
    ///       within this response rather than a global unique identifier.</p>
    public let id: Int?
    /// <p>The level of confidence that Amazon Comprehend Medical has that this attribute is
    ///       correctly related to this entity.</p>
    public let relationshipScore: Float?
    /// <p>The type of relationship between the entity and attribute. Type for the relationship can
    ///         be either of <code>OVERLAP</code> or <code>SYSTEM_ORGAN_SITE</code>.</p>
    public let relationshipType: ICD10CMRelationshipType?
    /// <p>The level of confidence that Amazon Comprehend Medical has that the segment of text is
    ///       correctly recognized as an attribute.</p>
    public let score: Float?
    /// <p>The segment of input text which contains the detected attribute.</p>
    public let text: String?
    /// <p>The contextual information for the attribute. The traits recognized by InferICD10CM are
    ///         <code>DIAGNOSIS</code>, <code>SIGN</code>, <code>SYMPTOM</code>, and
    ///       <code>NEGATION</code>.</p>
    public let traits: [ICD10CMTrait]?
    /// <p>The type of attribute. InferICD10CM detects entities of the type <code>DX_NAME</code>.
    ///     </p>
    public let type: ICD10CMAttributeType?

    public init (
        beginOffset: Int? = nil,
        category: ICD10CMEntityType? = nil,
        endOffset: Int? = nil,
        id: Int? = nil,
        relationshipScore: Float? = nil,
        relationshipType: ICD10CMRelationshipType? = nil,
        score: Float? = nil,
        text: String? = nil,
        traits: [ICD10CMTrait]? = nil,
        type: ICD10CMAttributeType? = nil
    )
    {
        self.beginOffset = beginOffset
        self.category = category
        self.endOffset = endOffset
        self.id = id
        self.relationshipScore = relationshipScore
        self.relationshipType = relationshipType
        self.score = score
        self.text = text
        self.traits = traits
        self.type = type
    }
}

public enum ICD10CMAttributeType {
    case acuity
    case direction
    case quality
    case quantity
    case systemOrganSite
    case timeExpression
    case timeToDxName
    case sdkUnknown(String)
}

extension ICD10CMAttributeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ICD10CMAttributeType] {
        return [
            .acuity,
            .direction,
            .quality,
            .quantity,
            .systemOrganSite,
            .timeExpression,
            .timeToDxName,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .acuity: return "ACUITY"
        case .direction: return "DIRECTION"
        case .quality: return "QUALITY"
        case .quantity: return "QUANTITY"
        case .systemOrganSite: return "SYSTEM_ORGAN_SITE"
        case .timeExpression: return "TIME_EXPRESSION"
        case .timeToDxName: return "TIME_TO_DX_NAME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ICD10CMAttributeType(rawValue: rawValue) ?? ICD10CMAttributeType.sdkUnknown(rawValue)
    }
}

extension ICD10CMConcept: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case description = "Description"
        case score = "Score"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ICD10CMConcept: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ICD10CMConcept(code: \(String(describing: code)), description: \(String(describing: description)), score: \(String(describing: score)))"}
}

/// <p> The ICD-10-CM concepts that the entity could refer to, along with a score indicating the
///       likelihood of the match.</p>
public struct ICD10CMConcept: Equatable {
    /// <p>The ICD-10-CM code that identifies the concept found in the knowledge base from the
    ///       Centers for Disease Control.</p>
    public let code: String?
    /// <p>The long description of the ICD-10-CM code in the ontology.</p>
    public let description: String?
    /// <p>The level of confidence that Amazon Comprehend Medical has that the entity is accurately
    ///       linked to an ICD-10-CM concept.</p>
    public let score: Float?

    public init (
        code: String? = nil,
        description: String? = nil,
        score: Float? = nil
    )
    {
        self.code = code
        self.description = description
        self.score = score
    }
}

extension ICD10CMEntity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case iCD10CMConcepts = "ICD10CMConcepts"
        case id = "Id"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for icd10cmattributelist0 in attributes {
                try attributesContainer.encode(icd10cmattributelist0)
            }
        }
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let iCD10CMConcepts = iCD10CMConcepts {
            var iCD10CMConceptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .iCD10CMConcepts)
            for icd10cmconceptlist0 in iCD10CMConcepts {
                try iCD10CMConceptsContainer.encode(icd10cmconceptlist0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for icd10cmtraitlist0 in traits {
                try traitsContainer.encode(icd10cmtraitlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .id)
        id = idDecoded
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(ICD10CMEntityCategory.self, forKey: .category)
        category = categoryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ICD10CMEntityType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .score)
        score = scoreDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let attributesContainer = try containerValues.decodeIfPresent([ICD10CMAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[ICD10CMAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [ICD10CMAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let traitsContainer = try containerValues.decodeIfPresent([ICD10CMTrait?].self, forKey: .traits)
        var traitsDecoded0:[ICD10CMTrait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ICD10CMTrait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
        let iCD10CMConceptsContainer = try containerValues.decodeIfPresent([ICD10CMConcept?].self, forKey: .iCD10CMConcepts)
        var iCD10CMConceptsDecoded0:[ICD10CMConcept]? = nil
        if let iCD10CMConceptsContainer = iCD10CMConceptsContainer {
            iCD10CMConceptsDecoded0 = [ICD10CMConcept]()
            for structure0 in iCD10CMConceptsContainer {
                if let structure0 = structure0 {
                    iCD10CMConceptsDecoded0?.append(structure0)
                }
            }
        }
        iCD10CMConcepts = iCD10CMConceptsDecoded0
    }
}

extension ICD10CMEntity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ICD10CMEntity(attributes: \(String(describing: attributes)), beginOffset: \(String(describing: beginOffset)), category: \(String(describing: category)), endOffset: \(String(describing: endOffset)), iCD10CMConcepts: \(String(describing: iCD10CMConcepts)), id: \(String(describing: id)), score: \(String(describing: score)), text: \(String(describing: text)), traits: \(String(describing: traits)), type: \(String(describing: type)))"}
}

/// <p>The collection of medical entities extracted from the input text and their associated
///       information. For each entity, the response provides the entity text, the entity category,
///       where the entity text begins and ends, and the level of confidence that Amazon Comprehend
///       Medical has in the detection and analysis. Attributes and traits of the entity are also
///       returned. </p>
public struct ICD10CMEntity: Equatable {
    /// <p>The detected attributes that relate to the entity. An extracted segment of the text that
    ///       is an attribute of an entity, or otherwise related to an entity, such as the nature of a
    ///       medical condition.</p>
    public let attributes: [ICD10CMAttribute]?
    /// <p>The 0-based character offset in the input text that shows where the entity begins. The
    ///       offset returns the UTF-8 code point in the string.</p>
    public let beginOffset: Int?
    /// <p> The category of the entity. InferICD10CM detects entities in the
    ///         <code>MEDICAL_CONDITION</code> category. </p>
    public let category: ICD10CMEntityCategory?
    /// <p>The 0-based character offset in the input text that shows where the entity ends. The
    ///       offset returns the UTF-8 code point in the string.</p>
    public let endOffset: Int?
    /// <p>The ICD-10-CM concepts that the entity could refer to, along with a score indicating the
    ///       likelihood of the match.</p>
    public let iCD10CMConcepts: [ICD10CMConcept]?
    /// <p>The numeric identifier for the entity. This is a monotonically increasing id unique within
    ///       this response rather than a global unique identifier.</p>
    public let id: Int?
    /// <p>The level of confidence that Amazon Comprehend Medical has in the accuracy of the
    ///       detection.</p>
    public let score: Float?
    /// <p>The segment of input text that is matched to the detected entity.</p>
    public let text: String?
    /// <p>Provides Contextual information for the entity. The traits recognized by InferICD10CM are
    ///         <code>DIAGNOSIS</code>, <code>SIGN</code>, <code>SYMPTOM</code>, and
    ///       <code>NEGATION.</code>
    ///          </p>
    public let traits: [ICD10CMTrait]?
    /// <p>Describes the specific type of entity with category of entities. InferICD10CM detects
    ///       entities of the type <code>DX_NAME</code> and <code>TIME_EXPRESSION</code>.</p>
    public let type: ICD10CMEntityType?

    public init (
        attributes: [ICD10CMAttribute]? = nil,
        beginOffset: Int? = nil,
        category: ICD10CMEntityCategory? = nil,
        endOffset: Int? = nil,
        iCD10CMConcepts: [ICD10CMConcept]? = nil,
        id: Int? = nil,
        score: Float? = nil,
        text: String? = nil,
        traits: [ICD10CMTrait]? = nil,
        type: ICD10CMEntityType? = nil
    )
    {
        self.attributes = attributes
        self.beginOffset = beginOffset
        self.category = category
        self.endOffset = endOffset
        self.iCD10CMConcepts = iCD10CMConcepts
        self.id = id
        self.score = score
        self.text = text
        self.traits = traits
        self.type = type
    }
}

public enum ICD10CMEntityCategory {
    case medicalCondition
    case sdkUnknown(String)
}

extension ICD10CMEntityCategory : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ICD10CMEntityCategory] {
        return [
            .medicalCondition,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .medicalCondition: return "MEDICAL_CONDITION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ICD10CMEntityCategory(rawValue: rawValue) ?? ICD10CMEntityCategory.sdkUnknown(rawValue)
    }
}

public enum ICD10CMEntityType {
    case dxName
    case timeExpression
    case sdkUnknown(String)
}

extension ICD10CMEntityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ICD10CMEntityType] {
        return [
            .dxName,
            .timeExpression,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dxName: return "DX_NAME"
        case .timeExpression: return "TIME_EXPRESSION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ICD10CMEntityType(rawValue: rawValue) ?? ICD10CMEntityType.sdkUnknown(rawValue)
    }
}

public enum ICD10CMRelationshipType {
    case overlap
    case systemOrganSite
    case sdkUnknown(String)
}

extension ICD10CMRelationshipType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ICD10CMRelationshipType] {
        return [
            .overlap,
            .systemOrganSite,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .overlap: return "OVERLAP"
        case .systemOrganSite: return "SYSTEM_ORGAN_SITE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ICD10CMRelationshipType(rawValue: rawValue) ?? ICD10CMRelationshipType.sdkUnknown(rawValue)
    }
}

extension ICD10CMTrait: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case score = "Score"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ICD10CMTraitName.self, forKey: .name)
        name = nameDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ICD10CMTrait: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ICD10CMTrait(name: \(String(describing: name)), score: \(String(describing: score)))"}
}

/// <p>Contextual information for the entity. The traits recognized by InferICD10CM are
///         <code>DIAGNOSIS</code>, <code>SIGN</code>, <code>SYMPTOM</code>, and
///       <code>NEGATION</code>.</p>
public struct ICD10CMTrait: Equatable {
    /// <p>Provides a name or contextual description about the trait.</p>
    public let name: ICD10CMTraitName?
    /// <p>The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized
    ///       as a trait.</p>
    public let score: Float?

    public init (
        name: ICD10CMTraitName? = nil,
        score: Float? = nil
    )
    {
        self.name = name
        self.score = score
    }
}

public enum ICD10CMTraitName {
    case diagnosis
    case negation
    case sign
    case symptom
    case sdkUnknown(String)
}

extension ICD10CMTraitName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ICD10CMTraitName] {
        return [
            .diagnosis,
            .negation,
            .sign,
            .symptom,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .diagnosis: return "DIAGNOSIS"
        case .negation: return "NEGATION"
        case .sign: return "SIGN"
        case .symptom: return "SYMPTOM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ICD10CMTraitName(rawValue: rawValue) ?? ICD10CMTraitName.sdkUnknown(rawValue)
    }
}

public struct InferICD10CMInputBodyMiddleware: Middleware {
    public let id: String = "InferICD10CMInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InferICD10CMInput>,
                  next: H) -> Swift.Result<OperationOutput<InferICD10CMOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InferICD10CMInput>
    public typealias MOutput = OperationOutput<InferICD10CMOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InferICD10CMOutputError>
}

extension InferICD10CMInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InferICD10CMInput(text: \(String(describing: text)))"}
}

extension InferICD10CMInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct InferICD10CMInputHeadersMiddleware: Middleware {
    public let id: String = "InferICD10CMInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InferICD10CMInput>,
                  next: H) -> Swift.Result<OperationOutput<InferICD10CMOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InferICD10CMInput>
    public typealias MOutput = OperationOutput<InferICD10CMOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InferICD10CMOutputError>
}

public struct InferICD10CMInputQueryItemMiddleware: Middleware {
    public let id: String = "InferICD10CMInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InferICD10CMInput>,
                  next: H) -> Swift.Result<OperationOutput<InferICD10CMOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InferICD10CMInput>
    public typealias MOutput = OperationOutput<InferICD10CMOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InferICD10CMOutputError>
}

public struct InferICD10CMInput: Equatable {
    /// <p>The input text used for analysis. The input for InferICD10CM is a string from 1 to 10000
    ///       characters.</p>
    public let text: String?

    public init (
        text: String? = nil
    )
    {
        self.text = text
    }
}

struct InferICD10CMInputBody: Equatable {
    public let text: String?
}

extension InferICD10CMInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case text = "Text"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
    }
}

extension InferICD10CMOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InferICD10CMOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEncodingException" : self = .invalidEncodingException(try InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InferICD10CMOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidEncodingException(InvalidEncodingException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InferICD10CMOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InferICD10CMOutputResponse(entities: \(String(describing: entities)), modelVersion: \(String(describing: modelVersion)), paginationToken: \(String(describing: paginationToken)))"}
}

extension InferICD10CMOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InferICD10CMOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
        } else {
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
        }
    }
}

public struct InferICD10CMOutputResponse: Equatable {
    /// <p>The medical conditions detected in the text linked to ICD-10-CM concepts. If the action is
    ///       successful, the service sends back an HTTP 200 response, as well as the entities
    ///       detected.</p>
    public let entities: [ICD10CMEntity]?
    /// <p>The version of the model used to analyze the documents, in the format
    ///         <i>n</i>.<i>n</i>.<i>n</i> You can use this
    ///       information to track the model used for a particular batch of documents.</p>
    public let modelVersion: String?
    /// <p>If the result of the previous request to <code>InferICD10CM</code> was truncated, include
    ///       the <code>PaginationToken</code> to fetch the next page of medical condition entities. </p>
    public let paginationToken: String?

    public init (
        entities: [ICD10CMEntity]? = nil,
        modelVersion: String? = nil,
        paginationToken: String? = nil
    )
    {
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
    }
}

struct InferICD10CMOutputResponseBody: Equatable {
    public let entities: [ICD10CMEntity]?
    public let paginationToken: String?
    public let modelVersion: String?
}

extension InferICD10CMOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([ICD10CMEntity?].self, forKey: .entities)
        var entitiesDecoded0:[ICD10CMEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [ICD10CMEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

public struct InferRxNormInputBodyMiddleware: Middleware {
    public let id: String = "InferRxNormInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InferRxNormInput>,
                  next: H) -> Swift.Result<OperationOutput<InferRxNormOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InferRxNormInput>
    public typealias MOutput = OperationOutput<InferRxNormOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InferRxNormOutputError>
}

extension InferRxNormInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InferRxNormInput(text: \(String(describing: text)))"}
}

extension InferRxNormInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct InferRxNormInputHeadersMiddleware: Middleware {
    public let id: String = "InferRxNormInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InferRxNormInput>,
                  next: H) -> Swift.Result<OperationOutput<InferRxNormOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InferRxNormInput>
    public typealias MOutput = OperationOutput<InferRxNormOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InferRxNormOutputError>
}

public struct InferRxNormInputQueryItemMiddleware: Middleware {
    public let id: String = "InferRxNormInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InferRxNormInput>,
                  next: H) -> Swift.Result<OperationOutput<InferRxNormOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InferRxNormInput>
    public typealias MOutput = OperationOutput<InferRxNormOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InferRxNormOutputError>
}

public struct InferRxNormInput: Equatable {
    /// <p>The input text used for analysis. The input for InferRxNorm is a string from 1 to 10000
    ///       characters.</p>
    public let text: String?

    public init (
        text: String? = nil
    )
    {
        self.text = text
    }
}

struct InferRxNormInputBody: Equatable {
    public let text: String?
}

extension InferRxNormInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case text = "Text"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
    }
}

extension InferRxNormOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InferRxNormOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEncodingException" : self = .invalidEncodingException(try InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InferRxNormOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidEncodingException(InvalidEncodingException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InferRxNormOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InferRxNormOutputResponse(entities: \(String(describing: entities)), modelVersion: \(String(describing: modelVersion)), paginationToken: \(String(describing: paginationToken)))"}
}

extension InferRxNormOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InferRxNormOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
        } else {
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
        }
    }
}

public struct InferRxNormOutputResponse: Equatable {
    /// <p>The medication entities detected in the text linked to RxNorm concepts. If the action is
    ///       successful, the service sends back an HTTP 200 response, as well as the entities
    ///       detected.</p>
    public let entities: [RxNormEntity]?
    /// <p>The version of the model used to analyze the documents, in the format
    ///         <i>n</i>.<i>n</i>.<i>n</i> You can use this
    ///       information to track the model used for a particular batch of documents.</p>
    public let modelVersion: String?
    /// <p>If the result of the previous request to <code>InferRxNorm</code> was truncated, include
    ///       the <code>PaginationToken</code> to fetch the next page of medication entities.</p>
    public let paginationToken: String?

    public init (
        entities: [RxNormEntity]? = nil,
        modelVersion: String? = nil,
        paginationToken: String? = nil
    )
    {
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
    }
}

struct InferRxNormOutputResponseBody: Equatable {
    public let entities: [RxNormEntity]?
    public let paginationToken: String?
    public let modelVersion: String?
}

extension InferRxNormOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([RxNormEntity?].self, forKey: .entities)
        var entitiesDecoded0:[RxNormEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [RxNormEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

extension InputDataConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
    }
}

extension InputDataConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputDataConfig(s3Bucket: \(String(describing: s3Bucket)), s3Key: \(String(describing: s3Key)))"}
}

/// <p>The input properties for an entities detection job. This includes the name of the S3
///       bucket and the path to the files to be analyzed. </p>
public struct InputDataConfig: Equatable {
    /// <p>The URI of the S3 bucket that contains the input data. The bucket must be in the same
    ///       region as the API endpoint that you are calling.</p>
    ///          <p>Each file in the document collection must be less than 40 KB. You can store a maximum of
    ///       30 GB in the bucket.</p>
    public let s3Bucket: String?
    /// <p>The path to the input data files in the S3 bucket.</p>
    public let s3Key: String?

    public init (
        s3Bucket: String? = nil,
        s3Key: String? = nil
    )
    {
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> An internal server error occurred. Retry your request. </p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEncodingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidEncodingException(message: \(String(describing: message)))"}
}

extension InvalidEncodingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidEncodingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> The input text was not in valid UTF-8 character encoding. Check your text then retry your
///       request.</p>
public struct InvalidEncodingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEncodingExceptionBody: Equatable {
    public let message: String?
}

extension InvalidEncodingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> The request that you made is invalid. Check your request to determine why it's invalid
///       and then retry the request.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum JobStatus {
    case completed
    case failed
    case inProgress
    case partialSuccess
    case stopped
    case stopRequested
    case submitted
    case sdkUnknown(String)
}

extension JobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobStatus] {
        return [
            .completed,
            .failed,
            .inProgress,
            .partialSuccess,
            .stopped,
            .stopRequested,
            .submitted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .partialSuccess: return "PARTIAL_SUCCESS"
        case .stopped: return "STOPPED"
        case .stopRequested: return "STOP_REQUESTED"
        case .submitted: return "SUBMITTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
    }
}

public enum LanguageCode {
    case en
    case sdkUnknown(String)
}

extension LanguageCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LanguageCode] {
        return [
            .en,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .en: return "en"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LanguageCode(rawValue: rawValue) ?? LanguageCode.sdkUnknown(rawValue)
    }
}

public struct ListEntitiesDetectionV2JobsInputBodyMiddleware: Middleware {
    public let id: String = "ListEntitiesDetectionV2JobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEntitiesDetectionV2JobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEntitiesDetectionV2JobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEntitiesDetectionV2JobsInput>
    public typealias MOutput = OperationOutput<ListEntitiesDetectionV2JobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEntitiesDetectionV2JobsOutputError>
}

extension ListEntitiesDetectionV2JobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEntitiesDetectionV2JobsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEntitiesDetectionV2JobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEntitiesDetectionV2JobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListEntitiesDetectionV2JobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEntitiesDetectionV2JobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEntitiesDetectionV2JobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEntitiesDetectionV2JobsInput>
    public typealias MOutput = OperationOutput<ListEntitiesDetectionV2JobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEntitiesDetectionV2JobsOutputError>
}

public struct ListEntitiesDetectionV2JobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEntitiesDetectionV2JobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEntitiesDetectionV2JobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEntitiesDetectionV2JobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEntitiesDetectionV2JobsInput>
    public typealias MOutput = OperationOutput<ListEntitiesDetectionV2JobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEntitiesDetectionV2JobsOutputError>
}

public struct ListEntitiesDetectionV2JobsInput: Equatable {
    /// <p>Filters the jobs that are returned. You can filter jobs based on their names, status, or
    ///       the date and time that they were submitted. You can only set one filter at a time.</p>
    public let filter: ComprehendMedicalAsyncJobFilter?
    /// <p>The maximum number of results to return in each page. The default is 100.</p>
    public let maxResults: Int?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        filter: ComprehendMedicalAsyncJobFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEntitiesDetectionV2JobsInputBody: Equatable {
    public let filter: ComprehendMedicalAsyncJobFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListEntitiesDetectionV2JobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ComprehendMedicalAsyncJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEntitiesDetectionV2JobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEntitiesDetectionV2JobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEntitiesDetectionV2JobsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEntitiesDetectionV2JobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEntitiesDetectionV2JobsOutputResponse(comprehendMedicalAsyncJobPropertiesList: \(String(describing: comprehendMedicalAsyncJobPropertiesList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEntitiesDetectionV2JobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEntitiesDetectionV2JobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.comprehendMedicalAsyncJobPropertiesList = output.comprehendMedicalAsyncJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.comprehendMedicalAsyncJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListEntitiesDetectionV2JobsOutputResponse: Equatable {
    /// <p>A list containing the properties of each job returned.</p>
    public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]? = nil,
        nextToken: String? = nil
    )
    {
        self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListEntitiesDetectionV2JobsOutputResponseBody: Equatable {
    public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]?
    public let nextToken: String?
}

extension ListEntitiesDetectionV2JobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesListContainer = try containerValues.decodeIfPresent([ComprehendMedicalAsyncJobProperties?].self, forKey: .comprehendMedicalAsyncJobPropertiesList)
        var comprehendMedicalAsyncJobPropertiesListDecoded0:[ComprehendMedicalAsyncJobProperties]? = nil
        if let comprehendMedicalAsyncJobPropertiesListContainer = comprehendMedicalAsyncJobPropertiesListContainer {
            comprehendMedicalAsyncJobPropertiesListDecoded0 = [ComprehendMedicalAsyncJobProperties]()
            for structure0 in comprehendMedicalAsyncJobPropertiesListContainer {
                if let structure0 = structure0 {
                    comprehendMedicalAsyncJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListICD10CMInferenceJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListICD10CMInferenceJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListICD10CMInferenceJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListICD10CMInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListICD10CMInferenceJobsInput>
    public typealias MOutput = OperationOutput<ListICD10CMInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListICD10CMInferenceJobsOutputError>
}

extension ListICD10CMInferenceJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListICD10CMInferenceJobsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListICD10CMInferenceJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListICD10CMInferenceJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListICD10CMInferenceJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListICD10CMInferenceJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListICD10CMInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListICD10CMInferenceJobsInput>
    public typealias MOutput = OperationOutput<ListICD10CMInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListICD10CMInferenceJobsOutputError>
}

public struct ListICD10CMInferenceJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListICD10CMInferenceJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListICD10CMInferenceJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListICD10CMInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListICD10CMInferenceJobsInput>
    public typealias MOutput = OperationOutput<ListICD10CMInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListICD10CMInferenceJobsOutputError>
}

public struct ListICD10CMInferenceJobsInput: Equatable {
    /// <p>Filters the jobs that are returned. You can filter jobs based on their names, status, or
    ///       the date and time that they were submitted. You can only set one filter at a time.</p>
    public let filter: ComprehendMedicalAsyncJobFilter?
    /// <p>The maximum number of results to return in each page. The default is 100.</p>
    public let maxResults: Int?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        filter: ComprehendMedicalAsyncJobFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListICD10CMInferenceJobsInputBody: Equatable {
    public let filter: ComprehendMedicalAsyncJobFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListICD10CMInferenceJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ComprehendMedicalAsyncJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListICD10CMInferenceJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListICD10CMInferenceJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListICD10CMInferenceJobsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListICD10CMInferenceJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListICD10CMInferenceJobsOutputResponse(comprehendMedicalAsyncJobPropertiesList: \(String(describing: comprehendMedicalAsyncJobPropertiesList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListICD10CMInferenceJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListICD10CMInferenceJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.comprehendMedicalAsyncJobPropertiesList = output.comprehendMedicalAsyncJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.comprehendMedicalAsyncJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListICD10CMInferenceJobsOutputResponse: Equatable {
    /// <p>A list containing the properties of each job that is returned.</p>
    public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]? = nil,
        nextToken: String? = nil
    )
    {
        self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListICD10CMInferenceJobsOutputResponseBody: Equatable {
    public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]?
    public let nextToken: String?
}

extension ListICD10CMInferenceJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesListContainer = try containerValues.decodeIfPresent([ComprehendMedicalAsyncJobProperties?].self, forKey: .comprehendMedicalAsyncJobPropertiesList)
        var comprehendMedicalAsyncJobPropertiesListDecoded0:[ComprehendMedicalAsyncJobProperties]? = nil
        if let comprehendMedicalAsyncJobPropertiesListContainer = comprehendMedicalAsyncJobPropertiesListContainer {
            comprehendMedicalAsyncJobPropertiesListDecoded0 = [ComprehendMedicalAsyncJobProperties]()
            for structure0 in comprehendMedicalAsyncJobPropertiesListContainer {
                if let structure0 = structure0 {
                    comprehendMedicalAsyncJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPHIDetectionJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListPHIDetectionJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPHIDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPHIDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPHIDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListPHIDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPHIDetectionJobsOutputError>
}

extension ListPHIDetectionJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPHIDetectionJobsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPHIDetectionJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPHIDetectionJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPHIDetectionJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPHIDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPHIDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPHIDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListPHIDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPHIDetectionJobsOutputError>
}

public struct ListPHIDetectionJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPHIDetectionJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPHIDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPHIDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPHIDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListPHIDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPHIDetectionJobsOutputError>
}

public struct ListPHIDetectionJobsInput: Equatable {
    /// <p>Filters the jobs that are returned. You can filter jobs based on their names, status, or
    ///       the date and time that they were submitted. You can only set one filter at a time.</p>
    public let filter: ComprehendMedicalAsyncJobFilter?
    /// <p>The maximum number of results to return in each page. The default is 100.</p>
    public let maxResults: Int?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        filter: ComprehendMedicalAsyncJobFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPHIDetectionJobsInputBody: Equatable {
    public let filter: ComprehendMedicalAsyncJobFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListPHIDetectionJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ComprehendMedicalAsyncJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPHIDetectionJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPHIDetectionJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPHIDetectionJobsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPHIDetectionJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPHIDetectionJobsOutputResponse(comprehendMedicalAsyncJobPropertiesList: \(String(describing: comprehendMedicalAsyncJobPropertiesList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPHIDetectionJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPHIDetectionJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.comprehendMedicalAsyncJobPropertiesList = output.comprehendMedicalAsyncJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.comprehendMedicalAsyncJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListPHIDetectionJobsOutputResponse: Equatable {
    /// <p>A list containing the properties of each job returned.</p>
    public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]? = nil,
        nextToken: String? = nil
    )
    {
        self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListPHIDetectionJobsOutputResponseBody: Equatable {
    public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]?
    public let nextToken: String?
}

extension ListPHIDetectionJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesListContainer = try containerValues.decodeIfPresent([ComprehendMedicalAsyncJobProperties?].self, forKey: .comprehendMedicalAsyncJobPropertiesList)
        var comprehendMedicalAsyncJobPropertiesListDecoded0:[ComprehendMedicalAsyncJobProperties]? = nil
        if let comprehendMedicalAsyncJobPropertiesListContainer = comprehendMedicalAsyncJobPropertiesListContainer {
            comprehendMedicalAsyncJobPropertiesListDecoded0 = [ComprehendMedicalAsyncJobProperties]()
            for structure0 in comprehendMedicalAsyncJobPropertiesListContainer {
                if let structure0 = structure0 {
                    comprehendMedicalAsyncJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRxNormInferenceJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListRxNormInferenceJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRxNormInferenceJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRxNormInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRxNormInferenceJobsInput>
    public typealias MOutput = OperationOutput<ListRxNormInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRxNormInferenceJobsOutputError>
}

extension ListRxNormInferenceJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRxNormInferenceJobsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListRxNormInferenceJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRxNormInferenceJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRxNormInferenceJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRxNormInferenceJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRxNormInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRxNormInferenceJobsInput>
    public typealias MOutput = OperationOutput<ListRxNormInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRxNormInferenceJobsOutputError>
}

public struct ListRxNormInferenceJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRxNormInferenceJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRxNormInferenceJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRxNormInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRxNormInferenceJobsInput>
    public typealias MOutput = OperationOutput<ListRxNormInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRxNormInferenceJobsOutputError>
}

public struct ListRxNormInferenceJobsInput: Equatable {
    /// <p>Filters the jobs that are returned. You can filter jobs based on their names, status, or
    ///       the date and time that they were submitted. You can only set one filter at a time.</p>
    public let filter: ComprehendMedicalAsyncJobFilter?
    /// <p>Identifies the next page of results to return.</p>
    public let maxResults: Int?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        filter: ComprehendMedicalAsyncJobFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRxNormInferenceJobsInputBody: Equatable {
    public let filter: ComprehendMedicalAsyncJobFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListRxNormInferenceJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ComprehendMedicalAsyncJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRxNormInferenceJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRxNormInferenceJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRxNormInferenceJobsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRxNormInferenceJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRxNormInferenceJobsOutputResponse(comprehendMedicalAsyncJobPropertiesList: \(String(describing: comprehendMedicalAsyncJobPropertiesList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListRxNormInferenceJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRxNormInferenceJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.comprehendMedicalAsyncJobPropertiesList = output.comprehendMedicalAsyncJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.comprehendMedicalAsyncJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListRxNormInferenceJobsOutputResponse: Equatable {
    /// <p>The maximum number of results to return in each page. The default is 100.</p>
    public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]? = nil,
        nextToken: String? = nil
    )
    {
        self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListRxNormInferenceJobsOutputResponseBody: Equatable {
    public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]?
    public let nextToken: String?
}

extension ListRxNormInferenceJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesListContainer = try containerValues.decodeIfPresent([ComprehendMedicalAsyncJobProperties?].self, forKey: .comprehendMedicalAsyncJobPropertiesList)
        var comprehendMedicalAsyncJobPropertiesListDecoded0:[ComprehendMedicalAsyncJobProperties]? = nil
        if let comprehendMedicalAsyncJobPropertiesListContainer = comprehendMedicalAsyncJobPropertiesListContainer {
            comprehendMedicalAsyncJobPropertiesListDecoded0 = [ComprehendMedicalAsyncJobProperties]()
            for structure0 in comprehendMedicalAsyncJobPropertiesListContainer {
                if let structure0 = structure0 {
                    comprehendMedicalAsyncJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension OutputDataConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
    }
}

extension OutputDataConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputDataConfig(s3Bucket: \(String(describing: s3Bucket)), s3Key: \(String(describing: s3Key)))"}
}

/// <p>The output properties for a detection job.</p>
public struct OutputDataConfig: Equatable {
    /// <p>When you use the <code>OutputDataConfig</code> object with asynchronous operations, you
    ///       specify the Amazon S3 location where you want to write the output data. The URI must be in the
    ///       same region as the API endpoint that you are calling. The location is used as the prefix for
    ///       the actual location of the output.</p>
    public let s3Bucket: String?
    /// <p>The path to the output data files in the S3 bucket. Amazon Comprehend Medical creates an output directory
    ///       using the job ID so that the output from one job does not overwrite the output of
    ///       another.</p>
    public let s3Key: String?

    public init (
        s3Bucket: String? = nil,
        s3Key: String? = nil
    )
    {
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
    }
}

public enum RelationshipType {
    case acuity
    case administeredVia
    case direction
    case dosage
    case duration
    case every
    case `for`
    case form
    case frequency
    case negative
    case overlap
    case rate
    case routeOrMode
    case strength
    case systemOrganSite
    case testUnits
    case testValue
    case withDosage
    case sdkUnknown(String)
}

extension RelationshipType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RelationshipType] {
        return [
            .acuity,
            .administeredVia,
            .direction,
            .dosage,
            .duration,
            .every,
            .for,
            .form,
            .frequency,
            .negative,
            .overlap,
            .rate,
            .routeOrMode,
            .strength,
            .systemOrganSite,
            .testUnits,
            .testValue,
            .withDosage,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .acuity: return "ACUITY"
        case .administeredVia: return "ADMINISTERED_VIA"
        case .direction: return "DIRECTION"
        case .dosage: return "DOSAGE"
        case .duration: return "DURATION"
        case .every: return "EVERY"
        case .for: return "FOR"
        case .form: return "FORM"
        case .frequency: return "FREQUENCY"
        case .negative: return "NEGATIVE"
        case .overlap: return "OVERLAP"
        case .rate: return "RATE"
        case .routeOrMode: return "ROUTE_OR_MODE"
        case .strength: return "STRENGTH"
        case .systemOrganSite: return "SYSTEM_ORGAN_SITE"
        case .testUnits: return "TEST_UNITS"
        case .testValue: return "TEST_VALUE"
        case .withDosage: return "WITH_DOSAGE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RelationshipType(rawValue: rawValue) ?? RelationshipType.sdkUnknown(rawValue)
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource identified by the specified Amazon Resource Name (ARN) was not found. Check
///       the ARN and try your request again.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RxNormAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case beginOffset = "BeginOffset"
        case endOffset = "EndOffset"
        case id = "Id"
        case relationshipScore = "RelationshipScore"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let relationshipScore = relationshipScore {
            try encodeContainer.encode(relationshipScore, forKey: .relationshipScore)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for rxnormtraitlist0 in traits {
                try traitsContainer.encode(rxnormtraitlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(RxNormAttributeType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .score)
        score = scoreDecoded
        let relationshipScoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .relationshipScore)
        relationshipScore = relationshipScoreDecoded
        let idDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .id)
        id = idDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let traitsContainer = try containerValues.decodeIfPresent([RxNormTrait?].self, forKey: .traits)
        var traitsDecoded0:[RxNormTrait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [RxNormTrait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
    }
}

extension RxNormAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RxNormAttribute(beginOffset: \(String(describing: beginOffset)), endOffset: \(String(describing: endOffset)), id: \(String(describing: id)), relationshipScore: \(String(describing: relationshipScore)), score: \(String(describing: score)), text: \(String(describing: text)), traits: \(String(describing: traits)), type: \(String(describing: type)))"}
}

/// <p>The extracted attributes that relate to this entity. The attributes recognized by
///       InferRxNorm are <code>DOSAGE</code>, <code>DURATION</code>, <code>FORM</code>,
///         <code>FREQUENCY</code>, <code>RATE</code>, <code>ROUTE_OR_MODE</code>.</p>
public struct RxNormAttribute: Equatable {
    /// <p>The 0-based character offset in the input text that shows where the attribute begins. The
    ///       offset returns the UTF-8 code point in the string.</p>
    public let beginOffset: Int?
    /// <p>The 0-based character offset in the input text that shows where the attribute ends. The
    ///       offset returns the UTF-8 code point in the string.</p>
    public let endOffset: Int?
    /// <p>The numeric identifier for this attribute. This is a monotonically increasing id unique
    ///       within this response rather than a global unique identifier.</p>
    public let id: Int?
    /// <p>The level of confidence that Amazon Comprehend Medical has that the attribute is
    ///       accurately linked to an entity.</p>
    public let relationshipScore: Float?
    /// <p>The level of confidence that Comprehend Medical has that the segment of text is correctly
    ///       recognized as an attribute.</p>
    public let score: Float?
    /// <p>The segment of input text which corresponds to the detected attribute.</p>
    public let text: String?
    /// <p>Contextual information for the attribute. InferRxNorm recognizes the trait
    ///         <code>NEGATION</code> for attributes, i.e. that the patient is not taking a specific dose or
    ///       form of a medication.</p>
    public let traits: [RxNormTrait]?
    /// <p>The type of attribute. The types of attributes recognized by InferRxNorm are
    ///         <code>BRAND_NAME</code> and <code>GENERIC_NAME</code>.</p>
    public let type: RxNormAttributeType?

    public init (
        beginOffset: Int? = nil,
        endOffset: Int? = nil,
        id: Int? = nil,
        relationshipScore: Float? = nil,
        score: Float? = nil,
        text: String? = nil,
        traits: [RxNormTrait]? = nil,
        type: RxNormAttributeType? = nil
    )
    {
        self.beginOffset = beginOffset
        self.endOffset = endOffset
        self.id = id
        self.relationshipScore = relationshipScore
        self.score = score
        self.text = text
        self.traits = traits
        self.type = type
    }
}

public enum RxNormAttributeType {
    case dosage
    case duration
    case form
    case frequency
    case rate
    case routeOrMode
    case strength
    case sdkUnknown(String)
}

extension RxNormAttributeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RxNormAttributeType] {
        return [
            .dosage,
            .duration,
            .form,
            .frequency,
            .rate,
            .routeOrMode,
            .strength,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dosage: return "DOSAGE"
        case .duration: return "DURATION"
        case .form: return "FORM"
        case .frequency: return "FREQUENCY"
        case .rate: return "RATE"
        case .routeOrMode: return "ROUTE_OR_MODE"
        case .strength: return "STRENGTH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RxNormAttributeType(rawValue: rawValue) ?? RxNormAttributeType.sdkUnknown(rawValue)
    }
}

extension RxNormConcept: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case description = "Description"
        case score = "Score"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension RxNormConcept: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RxNormConcept(code: \(String(describing: code)), description: \(String(describing: description)), score: \(String(describing: score)))"}
}

/// <p>The RxNorm concept that the entity could refer to, along with a score indicating the
///       likelihood of the match.</p>
public struct RxNormConcept: Equatable {
    /// <p>RxNorm concept ID, also known as the RxCUI.</p>
    public let code: String?
    /// <p>The description of the RxNorm concept.</p>
    public let description: String?
    /// <p>The level of confidence that Amazon Comprehend Medical has that the entity is accurately
    ///       linked to the reported RxNorm concept.</p>
    public let score: Float?

    public init (
        code: String? = nil,
        description: String? = nil,
        score: Float? = nil
    )
    {
        self.code = code
        self.description = description
        self.score = score
    }
}

extension RxNormEntity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case id = "Id"
        case rxNormConcepts = "RxNormConcepts"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for rxnormattributelist0 in attributes {
                try attributesContainer.encode(rxnormattributelist0)
            }
        }
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let rxNormConcepts = rxNormConcepts {
            var rxNormConceptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rxNormConcepts)
            for rxnormconceptlist0 in rxNormConcepts {
                try rxNormConceptsContainer.encode(rxnormconceptlist0)
            }
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for rxnormtraitlist0 in traits {
                try traitsContainer.encode(rxnormtraitlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .id)
        id = idDecoded
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(RxNormEntityCategory.self, forKey: .category)
        category = categoryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(RxNormEntityType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .score)
        score = scoreDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let attributesContainer = try containerValues.decodeIfPresent([RxNormAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[RxNormAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [RxNormAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let traitsContainer = try containerValues.decodeIfPresent([RxNormTrait?].self, forKey: .traits)
        var traitsDecoded0:[RxNormTrait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [RxNormTrait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
        let rxNormConceptsContainer = try containerValues.decodeIfPresent([RxNormConcept?].self, forKey: .rxNormConcepts)
        var rxNormConceptsDecoded0:[RxNormConcept]? = nil
        if let rxNormConceptsContainer = rxNormConceptsContainer {
            rxNormConceptsDecoded0 = [RxNormConcept]()
            for structure0 in rxNormConceptsContainer {
                if let structure0 = structure0 {
                    rxNormConceptsDecoded0?.append(structure0)
                }
            }
        }
        rxNormConcepts = rxNormConceptsDecoded0
    }
}

extension RxNormEntity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RxNormEntity(attributes: \(String(describing: attributes)), beginOffset: \(String(describing: beginOffset)), category: \(String(describing: category)), endOffset: \(String(describing: endOffset)), id: \(String(describing: id)), rxNormConcepts: \(String(describing: rxNormConcepts)), score: \(String(describing: score)), text: \(String(describing: text)), traits: \(String(describing: traits)), type: \(String(describing: type)))"}
}

/// <p>The collection of medical entities extracted from the input text and their associated
///       information. For each entity, the response provides the entity text, the entity category,
///       where the entity text begins and ends, and the level of confidence that Amazon Comprehend
///       Medical has in the detection and analysis. Attributes and traits of the entity are also
///       returned. </p>
public struct RxNormEntity: Equatable {
    /// <p>The extracted attributes that relate to the entity. The attributes recognized by
    ///       InferRxNorm are <code>DOSAGE</code>, <code>DURATION</code>, <code>FORM</code>,
    ///         <code>FREQUENCY</code>, <code>RATE</code>, <code>ROUTE_OR_MODE</code>, and
    ///         <code>STRENGTH</code>.</p>
    public let attributes: [RxNormAttribute]?
    /// <p>The 0-based character offset in the input text that shows where the entity begins. The
    ///       offset returns the UTF-8 code point in the string.</p>
    public let beginOffset: Int?
    /// <p>The category of the entity. The recognized categories are <code>GENERIC</code> or
    ///         <code>BRAND_NAME</code>.</p>
    public let category: RxNormEntityCategory?
    /// <p>The 0-based character offset in the input text that shows where the entity ends. The
    ///       offset returns the UTF-8 code point in the string.</p>
    public let endOffset: Int?
    /// <p>The numeric identifier for the entity. This is a monotonically increasing id unique within
    ///       this response rather than a global unique identifier.</p>
    public let id: Int?
    /// <p> The RxNorm concepts that the entity could refer to, along with a score indicating the
    ///       likelihood of the match.</p>
    public let rxNormConcepts: [RxNormConcept]?
    /// <p>The level of confidence that Amazon Comprehend Medical has in the accuracy of the detected
    ///       entity.</p>
    public let score: Float?
    /// <p>The segment of input text extracted from which the entity was detected.</p>
    public let text: String?
    /// <p> Contextual information for the entity.</p>
    public let traits: [RxNormTrait]?
    /// <p> Describes the specific type of entity. For InferRxNorm, the recognized entity type is
    ///         <code>MEDICATION</code>.</p>
    public let type: RxNormEntityType?

    public init (
        attributes: [RxNormAttribute]? = nil,
        beginOffset: Int? = nil,
        category: RxNormEntityCategory? = nil,
        endOffset: Int? = nil,
        id: Int? = nil,
        rxNormConcepts: [RxNormConcept]? = nil,
        score: Float? = nil,
        text: String? = nil,
        traits: [RxNormTrait]? = nil,
        type: RxNormEntityType? = nil
    )
    {
        self.attributes = attributes
        self.beginOffset = beginOffset
        self.category = category
        self.endOffset = endOffset
        self.id = id
        self.rxNormConcepts = rxNormConcepts
        self.score = score
        self.text = text
        self.traits = traits
        self.type = type
    }
}

public enum RxNormEntityCategory {
    case medication
    case sdkUnknown(String)
}

extension RxNormEntityCategory : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RxNormEntityCategory] {
        return [
            .medication,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .medication: return "MEDICATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RxNormEntityCategory(rawValue: rawValue) ?? RxNormEntityCategory.sdkUnknown(rawValue)
    }
}

public enum RxNormEntityType {
    case brandName
    case genericName
    case sdkUnknown(String)
}

extension RxNormEntityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RxNormEntityType] {
        return [
            .brandName,
            .genericName,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .brandName: return "BRAND_NAME"
        case .genericName: return "GENERIC_NAME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RxNormEntityType(rawValue: rawValue) ?? RxNormEntityType.sdkUnknown(rawValue)
    }
}

extension RxNormTrait: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case score = "Score"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(RxNormTraitName.self, forKey: .name)
        name = nameDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension RxNormTrait: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RxNormTrait(name: \(String(describing: name)), score: \(String(describing: score)))"}
}

/// <p>The contextual information for the entity. InferRxNorm recognizes the trait
///         <code>NEGATION</code>, which is any indication that the patient is not taking a medication.
///     </p>
public struct RxNormTrait: Equatable {
    /// <p>Provides a name or contextual description about the trait.</p>
    public let name: RxNormTraitName?
    /// <p>The level of confidence that Amazon Comprehend Medical has in the accuracy of the detected
    ///       trait.</p>
    public let score: Float?

    public init (
        name: RxNormTraitName? = nil,
        score: Float? = nil
    )
    {
        self.name = name
        self.score = score
    }
}

public enum RxNormTraitName {
    case negation
    case sdkUnknown(String)
}

extension RxNormTraitName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RxNormTraitName] {
        return [
            .negation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .negation: return "NEGATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RxNormTraitName(rawValue: rawValue) ?? RxNormTraitName.sdkUnknown(rawValue)
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> The Amazon Comprehend Medical service is temporarily unavailable. Please wait and then retry your request.
///     </p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartEntitiesDetectionV2JobInputBodyMiddleware: Middleware {
    public let id: String = "StartEntitiesDetectionV2JobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartEntitiesDetectionV2JobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartEntitiesDetectionV2JobInput>
    public typealias MOutput = OperationOutput<StartEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartEntitiesDetectionV2JobOutputError>
}

extension StartEntitiesDetectionV2JobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartEntitiesDetectionV2JobInput(clientRequestToken: \(String(describing: clientRequestToken)), dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), inputDataConfig: \(String(describing: inputDataConfig)), jobName: \(String(describing: jobName)), kMSKey: \(String(describing: kMSKey)), languageCode: \(String(describing: languageCode)), outputDataConfig: \(String(describing: outputDataConfig)))"}
}

extension StartEntitiesDetectionV2JobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

public struct StartEntitiesDetectionV2JobInputHeadersMiddleware: Middleware {
    public let id: String = "StartEntitiesDetectionV2JobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartEntitiesDetectionV2JobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartEntitiesDetectionV2JobInput>
    public typealias MOutput = OperationOutput<StartEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartEntitiesDetectionV2JobOutputError>
}

public struct StartEntitiesDetectionV2JobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartEntitiesDetectionV2JobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartEntitiesDetectionV2JobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartEntitiesDetectionV2JobInput>
    public typealias MOutput = OperationOutput<StartEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartEntitiesDetectionV2JobOutputError>
}

public struct StartEntitiesDetectionV2JobInput: Equatable {
    /// <p>A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical
    ///       generates one.</p>
    public var clientRequestToken: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that
    ///       grants Amazon Comprehend Medical read access to your input data. For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions-med.html#auth-role-permissions-med"> Role-Based Permissions Required for Asynchronous Operations</a>.</p>
    public let dataAccessRoleArn: String?
    /// <p>Specifies the format and location of the input data for the job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The identifier of the job.</p>
    public let jobName: String?
    /// <p>An AWS Key Management Service key to encrypt your output files. If you do not specify a
    ///       key, the files are written in plain text.</p>
    public let kMSKey: String?
    /// <p>The language of the input documents. All documents must be in the same language.</p>
    public let languageCode: LanguageCode?
    /// <p>Specifies where to send the output files.</p>
    public let outputDataConfig: OutputDataConfig?

    public init (
        clientRequestToken: String? = nil,
        dataAccessRoleArn: String? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobName: String? = nil,
        kMSKey: String? = nil,
        languageCode: LanguageCode? = nil,
        outputDataConfig: OutputDataConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.kMSKey = kMSKey
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
    }
}

struct StartEntitiesDetectionV2JobInputBody: Equatable {
    public let inputDataConfig: InputDataConfig?
    public let outputDataConfig: OutputDataConfig?
    public let dataAccessRoleArn: String?
    public let jobName: String?
    public let clientRequestToken: String?
    public let kMSKey: String?
    public let languageCode: LanguageCode?
}

extension StartEntitiesDetectionV2JobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension StartEntitiesDetectionV2JobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartEntitiesDetectionV2JobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartEntitiesDetectionV2JobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartEntitiesDetectionV2JobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartEntitiesDetectionV2JobOutputResponse(jobId: \(String(describing: jobId)))"}
}

extension StartEntitiesDetectionV2JobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartEntitiesDetectionV2JobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartEntitiesDetectionV2JobOutputResponse: Equatable {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
    ///       the <code>DescribeEntitiesDetectionV2Job</code> operation.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartEntitiesDetectionV2JobOutputResponseBody: Equatable {
    public let jobId: String?
}

extension StartEntitiesDetectionV2JobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct StartICD10CMInferenceJobInputBodyMiddleware: Middleware {
    public let id: String = "StartICD10CMInferenceJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartICD10CMInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartICD10CMInferenceJobInput>
    public typealias MOutput = OperationOutput<StartICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartICD10CMInferenceJobOutputError>
}

extension StartICD10CMInferenceJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartICD10CMInferenceJobInput(clientRequestToken: \(String(describing: clientRequestToken)), dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), inputDataConfig: \(String(describing: inputDataConfig)), jobName: \(String(describing: jobName)), kMSKey: \(String(describing: kMSKey)), languageCode: \(String(describing: languageCode)), outputDataConfig: \(String(describing: outputDataConfig)))"}
}

extension StartICD10CMInferenceJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

public struct StartICD10CMInferenceJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartICD10CMInferenceJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartICD10CMInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartICD10CMInferenceJobInput>
    public typealias MOutput = OperationOutput<StartICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartICD10CMInferenceJobOutputError>
}

public struct StartICD10CMInferenceJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartICD10CMInferenceJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartICD10CMInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartICD10CMInferenceJobInput>
    public typealias MOutput = OperationOutput<StartICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartICD10CMInferenceJobOutputError>
}

public struct StartICD10CMInferenceJobInput: Equatable {
    /// <p>A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical
    ///       generates one.</p>
    public var clientRequestToken: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that
    ///       grants Amazon Comprehend Medical read access to your input data. For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions-med.html#auth-role-permissions-med"> Role-Based Permissions Required for Asynchronous Operations</a>.</p>
    public let dataAccessRoleArn: String?
    /// <p>Specifies the format and location of the input data for the job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The identifier of the job.</p>
    public let jobName: String?
    /// <p>An AWS Key Management Service key to encrypt your output files. If you do not specify a
    ///       key, the files are written in plain text.</p>
    public let kMSKey: String?
    /// <p>The language of the input documents. All documents must be in the same language.</p>
    public let languageCode: LanguageCode?
    /// <p>Specifies where to send the output files.</p>
    public let outputDataConfig: OutputDataConfig?

    public init (
        clientRequestToken: String? = nil,
        dataAccessRoleArn: String? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobName: String? = nil,
        kMSKey: String? = nil,
        languageCode: LanguageCode? = nil,
        outputDataConfig: OutputDataConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.kMSKey = kMSKey
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
    }
}

struct StartICD10CMInferenceJobInputBody: Equatable {
    public let inputDataConfig: InputDataConfig?
    public let outputDataConfig: OutputDataConfig?
    public let dataAccessRoleArn: String?
    public let jobName: String?
    public let clientRequestToken: String?
    public let kMSKey: String?
    public let languageCode: LanguageCode?
}

extension StartICD10CMInferenceJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension StartICD10CMInferenceJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartICD10CMInferenceJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartICD10CMInferenceJobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartICD10CMInferenceJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartICD10CMInferenceJobOutputResponse(jobId: \(String(describing: jobId)))"}
}

extension StartICD10CMInferenceJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartICD10CMInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartICD10CMInferenceJobOutputResponse: Equatable {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
    ///       the <code>StartICD10CMInferenceJob</code> operation.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartICD10CMInferenceJobOutputResponseBody: Equatable {
    public let jobId: String?
}

extension StartICD10CMInferenceJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct StartPHIDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "StartPHIDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartPHIDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartPHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartPHIDetectionJobInput>
    public typealias MOutput = OperationOutput<StartPHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartPHIDetectionJobOutputError>
}

extension StartPHIDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartPHIDetectionJobInput(clientRequestToken: \(String(describing: clientRequestToken)), dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), inputDataConfig: \(String(describing: inputDataConfig)), jobName: \(String(describing: jobName)), kMSKey: \(String(describing: kMSKey)), languageCode: \(String(describing: languageCode)), outputDataConfig: \(String(describing: outputDataConfig)))"}
}

extension StartPHIDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

public struct StartPHIDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartPHIDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartPHIDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartPHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartPHIDetectionJobInput>
    public typealias MOutput = OperationOutput<StartPHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartPHIDetectionJobOutputError>
}

public struct StartPHIDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartPHIDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartPHIDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartPHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartPHIDetectionJobInput>
    public typealias MOutput = OperationOutput<StartPHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartPHIDetectionJobOutputError>
}

public struct StartPHIDetectionJobInput: Equatable {
    /// <p>A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical
    ///       generates one.</p>
    public var clientRequestToken: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that
    ///       grants Amazon Comprehend Medical read access to your input data. For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions-med.html#auth-role-permissions-med"> Role-Based Permissions Required for Asynchronous Operations</a>.</p>
    public let dataAccessRoleArn: String?
    /// <p>Specifies the format and location of the input data for the job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The identifier of the job.</p>
    public let jobName: String?
    /// <p>An AWS Key Management Service key to encrypt your output files. If you do not specify a
    ///       key, the files are written in plain text.</p>
    public let kMSKey: String?
    /// <p>The language of the input documents. All documents must be in the same language.</p>
    public let languageCode: LanguageCode?
    /// <p>Specifies where to send the output files.</p>
    public let outputDataConfig: OutputDataConfig?

    public init (
        clientRequestToken: String? = nil,
        dataAccessRoleArn: String? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobName: String? = nil,
        kMSKey: String? = nil,
        languageCode: LanguageCode? = nil,
        outputDataConfig: OutputDataConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.kMSKey = kMSKey
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
    }
}

struct StartPHIDetectionJobInputBody: Equatable {
    public let inputDataConfig: InputDataConfig?
    public let outputDataConfig: OutputDataConfig?
    public let dataAccessRoleArn: String?
    public let jobName: String?
    public let clientRequestToken: String?
    public let kMSKey: String?
    public let languageCode: LanguageCode?
}

extension StartPHIDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension StartPHIDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartPHIDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartPHIDetectionJobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartPHIDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartPHIDetectionJobOutputResponse(jobId: \(String(describing: jobId)))"}
}

extension StartPHIDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartPHIDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartPHIDetectionJobOutputResponse: Equatable {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
    ///       the <code>DescribePHIDetectionJob</code> operation.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartPHIDetectionJobOutputResponseBody: Equatable {
    public let jobId: String?
}

extension StartPHIDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct StartRxNormInferenceJobInputBodyMiddleware: Middleware {
    public let id: String = "StartRxNormInferenceJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartRxNormInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartRxNormInferenceJobInput>
    public typealias MOutput = OperationOutput<StartRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartRxNormInferenceJobOutputError>
}

extension StartRxNormInferenceJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartRxNormInferenceJobInput(clientRequestToken: \(String(describing: clientRequestToken)), dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), inputDataConfig: \(String(describing: inputDataConfig)), jobName: \(String(describing: jobName)), kMSKey: \(String(describing: kMSKey)), languageCode: \(String(describing: languageCode)), outputDataConfig: \(String(describing: outputDataConfig)))"}
}

extension StartRxNormInferenceJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

public struct StartRxNormInferenceJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartRxNormInferenceJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartRxNormInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartRxNormInferenceJobInput>
    public typealias MOutput = OperationOutput<StartRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartRxNormInferenceJobOutputError>
}

public struct StartRxNormInferenceJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartRxNormInferenceJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartRxNormInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartRxNormInferenceJobInput>
    public typealias MOutput = OperationOutput<StartRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartRxNormInferenceJobOutputError>
}

public struct StartRxNormInferenceJobInput: Equatable {
    /// <p>A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical
    ///       generates one.</p>
    public var clientRequestToken: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that
    ///       grants Amazon Comprehend Medical read access to your input data. For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions-med.html#auth-role-permissions-med"> Role-Based Permissions Required for Asynchronous Operations</a>.</p>
    public let dataAccessRoleArn: String?
    /// <p>Specifies the format and location of the input data for the job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The identifier of the job.</p>
    public let jobName: String?
    /// <p>An AWS Key Management Service key to encrypt your output files. If you do not specify a
    ///       key, the files are written in plain text.</p>
    public let kMSKey: String?
    /// <p>The language of the input documents. All documents must be in the same language.</p>
    public let languageCode: LanguageCode?
    /// <p>Specifies where to send the output files.</p>
    public let outputDataConfig: OutputDataConfig?

    public init (
        clientRequestToken: String? = nil,
        dataAccessRoleArn: String? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobName: String? = nil,
        kMSKey: String? = nil,
        languageCode: LanguageCode? = nil,
        outputDataConfig: OutputDataConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.kMSKey = kMSKey
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
    }
}

struct StartRxNormInferenceJobInputBody: Equatable {
    public let inputDataConfig: InputDataConfig?
    public let outputDataConfig: OutputDataConfig?
    public let dataAccessRoleArn: String?
    public let jobName: String?
    public let clientRequestToken: String?
    public let kMSKey: String?
    public let languageCode: LanguageCode?
}

extension StartRxNormInferenceJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension StartRxNormInferenceJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartRxNormInferenceJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartRxNormInferenceJobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartRxNormInferenceJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartRxNormInferenceJobOutputResponse(jobId: \(String(describing: jobId)))"}
}

extension StartRxNormInferenceJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartRxNormInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartRxNormInferenceJobOutputResponse: Equatable {
    /// <p>The identifier of the job.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartRxNormInferenceJobOutputResponseBody: Equatable {
    public let jobId: String?
}

extension StartRxNormInferenceJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct StopEntitiesDetectionV2JobInputBodyMiddleware: Middleware {
    public let id: String = "StopEntitiesDetectionV2JobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopEntitiesDetectionV2JobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopEntitiesDetectionV2JobInput>
    public typealias MOutput = OperationOutput<StopEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopEntitiesDetectionV2JobOutputError>
}

extension StopEntitiesDetectionV2JobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopEntitiesDetectionV2JobInput(jobId: \(String(describing: jobId)))"}
}

extension StopEntitiesDetectionV2JobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct StopEntitiesDetectionV2JobInputHeadersMiddleware: Middleware {
    public let id: String = "StopEntitiesDetectionV2JobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopEntitiesDetectionV2JobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopEntitiesDetectionV2JobInput>
    public typealias MOutput = OperationOutput<StopEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopEntitiesDetectionV2JobOutputError>
}

public struct StopEntitiesDetectionV2JobInputQueryItemMiddleware: Middleware {
    public let id: String = "StopEntitiesDetectionV2JobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopEntitiesDetectionV2JobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopEntitiesDetectionV2JobInput>
    public typealias MOutput = OperationOutput<StopEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopEntitiesDetectionV2JobOutputError>
}

public struct StopEntitiesDetectionV2JobInput: Equatable {
    /// <p>The identifier of the medical entities job to stop.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopEntitiesDetectionV2JobInputBody: Equatable {
    public let jobId: String?
}

extension StopEntitiesDetectionV2JobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopEntitiesDetectionV2JobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopEntitiesDetectionV2JobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopEntitiesDetectionV2JobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopEntitiesDetectionV2JobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopEntitiesDetectionV2JobOutputResponse(jobId: \(String(describing: jobId)))"}
}

extension StopEntitiesDetectionV2JobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopEntitiesDetectionV2JobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StopEntitiesDetectionV2JobOutputResponse: Equatable {
    /// <p>The identifier of the medical entities detection job that was stopped.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopEntitiesDetectionV2JobOutputResponseBody: Equatable {
    public let jobId: String?
}

extension StopEntitiesDetectionV2JobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct StopICD10CMInferenceJobInputBodyMiddleware: Middleware {
    public let id: String = "StopICD10CMInferenceJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopICD10CMInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopICD10CMInferenceJobInput>
    public typealias MOutput = OperationOutput<StopICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopICD10CMInferenceJobOutputError>
}

extension StopICD10CMInferenceJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopICD10CMInferenceJobInput(jobId: \(String(describing: jobId)))"}
}

extension StopICD10CMInferenceJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct StopICD10CMInferenceJobInputHeadersMiddleware: Middleware {
    public let id: String = "StopICD10CMInferenceJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopICD10CMInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopICD10CMInferenceJobInput>
    public typealias MOutput = OperationOutput<StopICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopICD10CMInferenceJobOutputError>
}

public struct StopICD10CMInferenceJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StopICD10CMInferenceJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopICD10CMInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopICD10CMInferenceJobInput>
    public typealias MOutput = OperationOutput<StopICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopICD10CMInferenceJobOutputError>
}

public struct StopICD10CMInferenceJobInput: Equatable {
    /// <p>The identifier of the job.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopICD10CMInferenceJobInputBody: Equatable {
    public let jobId: String?
}

extension StopICD10CMInferenceJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopICD10CMInferenceJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopICD10CMInferenceJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopICD10CMInferenceJobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopICD10CMInferenceJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopICD10CMInferenceJobOutputResponse(jobId: \(String(describing: jobId)))"}
}

extension StopICD10CMInferenceJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopICD10CMInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StopICD10CMInferenceJobOutputResponse: Equatable {
    /// <p>The identifier generated for the job. To get the status of job, use this identifier with
    ///       the <code>DescribeICD10CMInferenceJob</code> operation.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopICD10CMInferenceJobOutputResponseBody: Equatable {
    public let jobId: String?
}

extension StopICD10CMInferenceJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct StopPHIDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "StopPHIDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopPHIDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopPHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopPHIDetectionJobInput>
    public typealias MOutput = OperationOutput<StopPHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopPHIDetectionJobOutputError>
}

extension StopPHIDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopPHIDetectionJobInput(jobId: \(String(describing: jobId)))"}
}

extension StopPHIDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct StopPHIDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "StopPHIDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopPHIDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopPHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopPHIDetectionJobInput>
    public typealias MOutput = OperationOutput<StopPHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopPHIDetectionJobOutputError>
}

public struct StopPHIDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StopPHIDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopPHIDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopPHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopPHIDetectionJobInput>
    public typealias MOutput = OperationOutput<StopPHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopPHIDetectionJobOutputError>
}

public struct StopPHIDetectionJobInput: Equatable {
    /// <p>The identifier of the PHI detection job to stop.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopPHIDetectionJobInputBody: Equatable {
    public let jobId: String?
}

extension StopPHIDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopPHIDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopPHIDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopPHIDetectionJobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopPHIDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopPHIDetectionJobOutputResponse(jobId: \(String(describing: jobId)))"}
}

extension StopPHIDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopPHIDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StopPHIDetectionJobOutputResponse: Equatable {
    /// <p>The identifier of the PHI detection job that was stopped.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopPHIDetectionJobOutputResponseBody: Equatable {
    public let jobId: String?
}

extension StopPHIDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct StopRxNormInferenceJobInputBodyMiddleware: Middleware {
    public let id: String = "StopRxNormInferenceJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopRxNormInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopRxNormInferenceJobInput>
    public typealias MOutput = OperationOutput<StopRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopRxNormInferenceJobOutputError>
}

extension StopRxNormInferenceJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopRxNormInferenceJobInput(jobId: \(String(describing: jobId)))"}
}

extension StopRxNormInferenceJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct StopRxNormInferenceJobInputHeadersMiddleware: Middleware {
    public let id: String = "StopRxNormInferenceJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopRxNormInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopRxNormInferenceJobInput>
    public typealias MOutput = OperationOutput<StopRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopRxNormInferenceJobOutputError>
}

public struct StopRxNormInferenceJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StopRxNormInferenceJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopRxNormInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopRxNormInferenceJobInput>
    public typealias MOutput = OperationOutput<StopRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopRxNormInferenceJobOutputError>
}

public struct StopRxNormInferenceJobInput: Equatable {
    /// <p>The identifier of the job.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopRxNormInferenceJobInputBody: Equatable {
    public let jobId: String?
}

extension StopRxNormInferenceJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopRxNormInferenceJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopRxNormInferenceJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopRxNormInferenceJobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopRxNormInferenceJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopRxNormInferenceJobOutputResponse(jobId: \(String(describing: jobId)))"}
}

extension StopRxNormInferenceJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopRxNormInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StopRxNormInferenceJobOutputResponse: Equatable {
    /// <p>The identifier generated for the job. To get the status of job, use this identifier with
    ///       the <code>DescribeRxNormInferenceJob</code> operation.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopRxNormInferenceJobOutputResponseBody: Equatable {
    public let jobId: String?
}

extension StopRxNormInferenceJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension TextSizeLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TextSizeLimitExceededException(message: \(String(describing: message)))"}
}

extension TextSizeLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TextSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> The size of the text you submitted exceeds the size limit. Reduce the size of the text or
///       use a smaller document and then retry your request. </p>
public struct TextSizeLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TextSizeLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension TextSizeLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> You have made too many requests within a short period of time. Wait for a short time and
///       then try your request again. Contact customer support for more information about a service
///       limit increase. </p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Trait: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case score = "Score"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(AttributeName.self, forKey: .name)
        name = nameDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension Trait: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Trait(name: \(String(describing: name)), score: \(String(describing: score)))"}
}

/// <p> Provides contextual information about the extracted entity. </p>
public struct Trait: Equatable {
    /// <p> Provides a name or contextual description about the trait. </p>
    public let name: AttributeName?
    /// <p> The level of confidence that Amazon Comprehend Medical has in the accuracy of this trait.</p>
    public let score: Float?

    public init (
        name: AttributeName? = nil,
        score: Float? = nil
    )
    {
        self.name = name
        self.score = score
    }
}

extension UnmappedAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(EntityType.self, forKey: .type)
        type = typeDecoded
        let attributeDecoded = try containerValues.decodeIfPresent(Attribute.self, forKey: .attribute)
        attribute = attributeDecoded
    }
}

extension UnmappedAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnmappedAttribute(attribute: \(String(describing: attribute)), type: \(String(describing: type)))"}
}

/// <p> An attribute that we extracted, but were unable to relate to an entity. </p>
public struct UnmappedAttribute: Equatable {
    /// <p> The specific attribute that has been extracted but not mapped to an entity. </p>
    public let attribute: Attribute?
    /// <p> The type of the attribute, could be one of the following values: "MEDICATION",
    ///       "MEDICAL_CONDITION", "ANATOMY", "TEST_AND_TREATMENT_PROCEDURE" or
    ///       "PROTECTED_HEALTH_INFORMATION". </p>
    public let type: EntityType?

    public init (
        attribute: Attribute? = nil,
        type: EntityType? = nil
    )
    {
        self.attribute = attribute
        self.type = type
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The filter that you specified for the operation is invalid. Check the filter values that
///       you entered and try your request again.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
