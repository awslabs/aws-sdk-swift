// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request has the same name as another active human loop but has different input data. You cannot start two
///     human loops with the same name and different input data.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ContentClassifier {
    case freeOfAdultContent
    case freeOfPersonallyIdentifiableInformation
    case sdkUnknown(String)
}

extension ContentClassifier : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ContentClassifier] {
        return [
            .freeOfAdultContent,
            .freeOfPersonallyIdentifiableInformation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .freeOfAdultContent: return "FreeOfAdultContent"
        case .freeOfPersonallyIdentifiableInformation: return "FreeOfPersonallyIdentifiableInformation"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ContentClassifier(rawValue: rawValue) ?? ContentClassifier.sdkUnknown(rawValue)
    }
}

extension DeleteHumanLoopInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteHumanLoopInput(humanLoopName: \(String(describing: humanLoopName)))"}
}

extension DeleteHumanLoopInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteHumanLoopInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteHumanLoopInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHumanLoopInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHumanLoopOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHumanLoopInput>
    public typealias MOutput = OperationOutput<DeleteHumanLoopOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHumanLoopOutputError>
}

public struct DeleteHumanLoopInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteHumanLoopInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHumanLoopInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHumanLoopOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHumanLoopInput>
    public typealias MOutput = OperationOutput<DeleteHumanLoopOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHumanLoopOutputError>
}

public struct DeleteHumanLoopInput: Equatable {
    /// <p>The name of the human loop that you want to delete.</p>
    public let humanLoopName: String?

    public init (
        humanLoopName: String? = nil
    )
    {
        self.humanLoopName = humanLoopName
    }
}

struct DeleteHumanLoopInputBody: Equatable {
}

extension DeleteHumanLoopInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteHumanLoopOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteHumanLoopOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteHumanLoopOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHumanLoopOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteHumanLoopOutputResponse()"}
}

extension DeleteHumanLoopOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteHumanLoopOutputResponse: Equatable {

    public init() {}
}

struct DeleteHumanLoopOutputResponseBody: Equatable {
}

extension DeleteHumanLoopOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeHumanLoopInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHumanLoopInput(humanLoopName: \(String(describing: humanLoopName)))"}
}

extension DescribeHumanLoopInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeHumanLoopInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeHumanLoopInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHumanLoopInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHumanLoopOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHumanLoopInput>
    public typealias MOutput = OperationOutput<DescribeHumanLoopOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHumanLoopOutputError>
}

public struct DescribeHumanLoopInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeHumanLoopInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHumanLoopInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHumanLoopOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHumanLoopInput>
    public typealias MOutput = OperationOutput<DescribeHumanLoopOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHumanLoopOutputError>
}

public struct DescribeHumanLoopInput: Equatable {
    /// <p>The name of the human loop that you want information about.</p>
    public let humanLoopName: String?

    public init (
        humanLoopName: String? = nil
    )
    {
        self.humanLoopName = humanLoopName
    }
}

struct DescribeHumanLoopInputBody: Equatable {
}

extension DescribeHumanLoopInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeHumanLoopOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHumanLoopOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeHumanLoopOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHumanLoopOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHumanLoopOutputResponse(creationTime: \(String(describing: creationTime)), failureCode: \(String(describing: failureCode)), failureReason: \(String(describing: failureReason)), flowDefinitionArn: \(String(describing: flowDefinitionArn)), humanLoopArn: \(String(describing: humanLoopArn)), humanLoopName: \(String(describing: humanLoopName)), humanLoopOutput: \(String(describing: humanLoopOutput)), humanLoopStatus: \(String(describing: humanLoopStatus)))"}
}

extension DescribeHumanLoopOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeHumanLoopOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationTime = output.creationTime
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.flowDefinitionArn = output.flowDefinitionArn
            self.humanLoopArn = output.humanLoopArn
            self.humanLoopName = output.humanLoopName
            self.humanLoopOutput = output.humanLoopOutput
            self.humanLoopStatus = output.humanLoopStatus
        } else {
            self.creationTime = nil
            self.failureCode = nil
            self.failureReason = nil
            self.flowDefinitionArn = nil
            self.humanLoopArn = nil
            self.humanLoopName = nil
            self.humanLoopOutput = nil
            self.humanLoopStatus = nil
        }
    }
}

public struct DescribeHumanLoopOutputResponse: Equatable {
    /// <p>The creation time when Amazon Augmented AI created the human loop.</p>
    public let creationTime: Date?
    /// <p>A failure code that identifies the type of failure.</p>
    ///          <p>Possible values: <code>ValidationError</code>, <code>Expired</code>,
    ///         <code>InternalError</code>
    ///          </p>
    public let failureCode: String?
    /// <p>The reason why a human loop failed. The failure reason is returned when the status of the
    ///       human loop is <code>Failed</code>.</p>
    public let failureReason: String?
    /// <p>The Amazon Resource Name (ARN) of the flow definition.</p>
    public let flowDefinitionArn: String?
    /// <p>The Amazon Resource Name (ARN) of the human loop.</p>
    public let humanLoopArn: String?
    /// <p>The name of the human loop. The name must be lowercase, unique within the Region in your
    ///       account, and can have up to 63 characters. Valid characters: a-z, 0-9, and - (hyphen).</p>
    public let humanLoopName: String?
    /// <p>An object that contains information about the output of the human loop.</p>
    public let humanLoopOutput: HumanLoopOutput?
    /// <p>The status of the human loop. </p>
    public let humanLoopStatus: HumanLoopStatus?

    public init (
        creationTime: Date? = nil,
        failureCode: String? = nil,
        failureReason: String? = nil,
        flowDefinitionArn: String? = nil,
        humanLoopArn: String? = nil,
        humanLoopName: String? = nil,
        humanLoopOutput: HumanLoopOutput? = nil,
        humanLoopStatus: HumanLoopStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.flowDefinitionArn = flowDefinitionArn
        self.humanLoopArn = humanLoopArn
        self.humanLoopName = humanLoopName
        self.humanLoopOutput = humanLoopOutput
        self.humanLoopStatus = humanLoopStatus
    }
}

struct DescribeHumanLoopOutputResponseBody: Equatable {
    public let creationTime: Date?
    public let failureReason: String?
    public let failureCode: String?
    public let humanLoopStatus: HumanLoopStatus?
    public let humanLoopName: String?
    public let humanLoopArn: String?
    public let flowDefinitionArn: String?
    public let humanLoopOutput: HumanLoopOutput?
}

extension DescribeHumanLoopOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case failureCode = "FailureCode"
        case failureReason = "FailureReason"
        case flowDefinitionArn = "FlowDefinitionArn"
        case humanLoopArn = "HumanLoopArn"
        case humanLoopName = "HumanLoopName"
        case humanLoopOutput = "HumanLoopOutput"
        case humanLoopStatus = "HumanLoopStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let humanLoopStatusDecoded = try containerValues.decodeIfPresent(HumanLoopStatus.self, forKey: .humanLoopStatus)
        humanLoopStatus = humanLoopStatusDecoded
        let humanLoopNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .humanLoopName)
        humanLoopName = humanLoopNameDecoded
        let humanLoopArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .humanLoopArn)
        humanLoopArn = humanLoopArnDecoded
        let flowDefinitionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowDefinitionArn)
        flowDefinitionArn = flowDefinitionArnDecoded
        let humanLoopOutputDecoded = try containerValues.decodeIfPresent(HumanLoopOutput.self, forKey: .humanLoopOutput)
        humanLoopOutput = humanLoopOutputDecoded
    }
}

extension HumanLoopDataAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentClassifiers = "ContentClassifiers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentClassifiers = contentClassifiers {
            var contentClassifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contentClassifiers)
            for contentclassifiers0 in contentClassifiers {
                try contentClassifiersContainer.encode(contentclassifiers0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentClassifiersContainer = try containerValues.decodeIfPresent([ContentClassifier?].self, forKey: .contentClassifiers)
        var contentClassifiersDecoded0:[ContentClassifier]? = nil
        if let contentClassifiersContainer = contentClassifiersContainer {
            contentClassifiersDecoded0 = [ContentClassifier]()
            for string0 in contentClassifiersContainer {
                if let string0 = string0 {
                    contentClassifiersDecoded0?.append(string0)
                }
            }
        }
        contentClassifiers = contentClassifiersDecoded0
    }
}

extension HumanLoopDataAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HumanLoopDataAttributes(contentClassifiers: \(String(describing: contentClassifiers)))"}
}

/// <p>Attributes of the data specified by the customer. Use these to describe the data to be labeled.</p>
public struct HumanLoopDataAttributes: Equatable {
    /// <p>Declares that your content is free of personally identifiable information or adult content.</p>
    ///          <p>Amazon SageMaker can restrict the Amazon Mechanical Turk workers who can view your task based on this information.</p>
    public let contentClassifiers: [ContentClassifier]?

    public init (
        contentClassifiers: [ContentClassifier]? = nil
    )
    {
        self.contentClassifiers = contentClassifiers
    }
}

extension HumanLoopInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputContent = "InputContent"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputContent = inputContent {
            try encodeContainer.encode(inputContent, forKey: .inputContent)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputContent)
        inputContent = inputContentDecoded
    }
}

extension HumanLoopInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HumanLoopInput(inputContent: \(String(describing: inputContent)))"}
}

/// <p>An object containing the human loop input in JSON format.</p>
public struct HumanLoopInput: Equatable {
    /// <p>Serialized input from the human loop. The input must be a string representation of a file in JSON format.</p>
    public let inputContent: String?

    public init (
        inputContent: String? = nil
    )
    {
        self.inputContent = inputContent
    }
}

extension HumanLoopOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case outputS3Uri = "OutputS3Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputS3Uri = outputS3Uri {
            try encodeContainer.encode(outputS3Uri, forKey: .outputS3Uri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputS3UriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3Uri)
        outputS3Uri = outputS3UriDecoded
    }
}

extension HumanLoopOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HumanLoopOutput(outputS3Uri: \(String(describing: outputS3Uri)))"}
}

/// <p>Information about where the human output will be stored.</p>
public struct HumanLoopOutput: Equatable {
    /// <p>The location of the Amazon S3 object where Amazon Augmented AI stores your human loop output.</p>
    public let outputS3Uri: String?

    public init (
        outputS3Uri: String? = nil
    )
    {
        self.outputS3Uri = outputS3Uri
    }
}

public enum HumanLoopStatus {
    case completed
    case failed
    case inProgress
    case stopped
    case stopping
    case sdkUnknown(String)
}

extension HumanLoopStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HumanLoopStatus] {
        return [
            .completed,
            .failed,
            .inProgress,
            .stopped,
            .stopping,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "Completed"
        case .failed: return "Failed"
        case .inProgress: return "InProgress"
        case .stopped: return "Stopped"
        case .stopping: return "Stopping"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HumanLoopStatus(rawValue: rawValue) ?? HumanLoopStatus.sdkUnknown(rawValue)
    }
}

extension HumanLoopSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case failureReason = "FailureReason"
        case flowDefinitionArn = "FlowDefinitionArn"
        case humanLoopName = "HumanLoopName"
        case humanLoopStatus = "HumanLoopStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let flowDefinitionArn = flowDefinitionArn {
            try encodeContainer.encode(flowDefinitionArn, forKey: .flowDefinitionArn)
        }
        if let humanLoopName = humanLoopName {
            try encodeContainer.encode(humanLoopName, forKey: .humanLoopName)
        }
        if let humanLoopStatus = humanLoopStatus {
            try encodeContainer.encode(humanLoopStatus.rawValue, forKey: .humanLoopStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .humanLoopName)
        humanLoopName = humanLoopNameDecoded
        let humanLoopStatusDecoded = try containerValues.decodeIfPresent(HumanLoopStatus.self, forKey: .humanLoopStatus)
        humanLoopStatus = humanLoopStatusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let flowDefinitionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowDefinitionArn)
        flowDefinitionArn = flowDefinitionArnDecoded
    }
}

extension HumanLoopSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HumanLoopSummary(creationTime: \(String(describing: creationTime)), failureReason: \(String(describing: failureReason)), flowDefinitionArn: \(String(describing: flowDefinitionArn)), humanLoopName: \(String(describing: humanLoopName)), humanLoopStatus: \(String(describing: humanLoopStatus)))"}
}

/// <p>Summary information about the human loop.</p>
public struct HumanLoopSummary: Equatable {
    /// <p>When Amazon Augmented AI created the human loop.</p>
    public let creationTime: Date?
    /// <p>The reason why the human loop failed. A failure reason is returned when the status of the
    ///       human loop is <code>Failed</code>.</p>
    public let failureReason: String?
    /// <p>The Amazon Resource Name (ARN) of the flow definition used to configure the human
    ///       loop.</p>
    public let flowDefinitionArn: String?
    /// <p>The name of the human loop.</p>
    public let humanLoopName: String?
    /// <p>The status of the human loop. </p>
    public let humanLoopStatus: HumanLoopStatus?

    public init (
        creationTime: Date? = nil,
        failureReason: String? = nil,
        flowDefinitionArn: String? = nil,
        humanLoopName: String? = nil,
        humanLoopStatus: HumanLoopStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.failureReason = failureReason
        self.flowDefinitionArn = flowDefinitionArn
        self.humanLoopName = humanLoopName
        self.humanLoopStatus = humanLoopStatus
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>We couldn't process your request because of an issue with the server. Try again
///       later.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListHumanLoopsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListHumanLoopsInput(creationTimeAfter: \(String(describing: creationTimeAfter)), creationTimeBefore: \(String(describing: creationTimeBefore)), flowDefinitionArn: \(String(describing: flowDefinitionArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortOrder: \(String(describing: sortOrder)))"}
}

extension ListHumanLoopsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListHumanLoopsInputHeadersMiddleware: Middleware {
    public let id: String = "ListHumanLoopsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHumanLoopsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHumanLoopsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHumanLoopsInput>
    public typealias MOutput = OperationOutput<ListHumanLoopsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHumanLoopsOutputError>
}

public struct ListHumanLoopsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListHumanLoopsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHumanLoopsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHumanLoopsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let flowDefinitionArn = input.operationInput.flowDefinitionArn {
            let flowDefinitionArnQueryItem = URLQueryItem(name: "FlowDefinitionArn".urlPercentEncoding(), value: String(flowDefinitionArn).urlPercentEncoding())
            input.builder.withQueryItem(flowDefinitionArnQueryItem)
        }
        if let creationTimeBefore = input.operationInput.creationTimeBefore {
            let creationTimeBeforeQueryItem = URLQueryItem(name: "CreationTimeBefore".urlPercentEncoding(), value: String(creationTimeBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(creationTimeBeforeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let sortOrder = input.operationInput.sortOrder {
            let sortOrderQueryItem = URLQueryItem(name: "SortOrder".urlPercentEncoding(), value: String(sortOrder.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(sortOrderQueryItem)
        }
        if let creationTimeAfter = input.operationInput.creationTimeAfter {
            let creationTimeAfterQueryItem = URLQueryItem(name: "CreationTimeAfter".urlPercentEncoding(), value: String(creationTimeAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(creationTimeAfterQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHumanLoopsInput>
    public typealias MOutput = OperationOutput<ListHumanLoopsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHumanLoopsOutputError>
}

public struct ListHumanLoopsInput: Equatable {
    /// <p>(Optional) The timestamp of the date when you want the human loops to begin in ISO 8601 format. For example, <code>2020-02-24</code>.</p>
    public let creationTimeAfter: Date?
    /// <p>(Optional) The timestamp of the date before which you want the human loops to begin in ISO 8601 format. For example, <code>2020-02-24</code>.</p>
    public let creationTimeBefore: Date?
    /// <p>The Amazon Resource Name (ARN) of a flow definition.</p>
    public let flowDefinitionArn: String?
    /// <p>The total number of items to return. If the total number of available items is more than
    ///       the value specified in <code>MaxResults</code>, then a <code>NextToken</code> is returned in
    ///       the output. You can use this token to display the next page of results. </p>
    public let maxResults: Int
    /// <p>A token to display the next page of results.</p>
    public let nextToken: String?
    /// <p>Optional. The order for displaying results. Valid values: <code>Ascending</code> and
    ///         <code>Descending</code>.</p>
    public let sortOrder: SortOrder?

    public init (
        creationTimeAfter: Date? = nil,
        creationTimeBefore: Date? = nil,
        flowDefinitionArn: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        sortOrder: SortOrder? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.flowDefinitionArn = flowDefinitionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortOrder = sortOrder
    }
}

struct ListHumanLoopsInputBody: Equatable {
}

extension ListHumanLoopsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListHumanLoopsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHumanLoopsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListHumanLoopsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHumanLoopsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListHumanLoopsOutputResponse(humanLoopSummaries: \(String(describing: humanLoopSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListHumanLoopsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListHumanLoopsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.humanLoopSummaries = output.humanLoopSummaries
            self.nextToken = output.nextToken
        } else {
            self.humanLoopSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListHumanLoopsOutputResponse: Equatable {
    /// <p>An array of objects that contain information about the human loops.</p>
    public let humanLoopSummaries: [HumanLoopSummary]?
    /// <p>A token to display the next page of results.</p>
    public let nextToken: String?

    public init (
        humanLoopSummaries: [HumanLoopSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.humanLoopSummaries = humanLoopSummaries
        self.nextToken = nextToken
    }
}

struct ListHumanLoopsOutputResponseBody: Equatable {
    public let humanLoopSummaries: [HumanLoopSummary]?
    public let nextToken: String?
}

extension ListHumanLoopsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case humanLoopSummaries = "HumanLoopSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopSummariesContainer = try containerValues.decodeIfPresent([HumanLoopSummary?].self, forKey: .humanLoopSummaries)
        var humanLoopSummariesDecoded0:[HumanLoopSummary]? = nil
        if let humanLoopSummariesContainer = humanLoopSummariesContainer {
            humanLoopSummariesDecoded0 = [HumanLoopSummary]()
            for structure0 in humanLoopSummariesContainer {
                if let structure0 = structure0 {
                    humanLoopSummariesDecoded0?.append(structure0)
                }
            }
        }
        humanLoopSummaries = humanLoopSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>We couldn't find the requested resource. Check that your resources exists and were created
///       in the same AWS Region as your request, and try your request again. </p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You exceeded your service quota. Service quotas, also referred to as limits, are the
///       maximum number of service resources or operations for your AWS account. For a list of
///       Amazon A2I service quotes, see <a href="https://docs.aws.amazon.com/general/latest/gr/a2i.html">Amazon Augmented AI Service Quotes</a>. Delete some resources or request an increase in your
///       service quota. You can request a quota increase using Service Quotas or the AWS Support
///       Center. To request an increase, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html">AWS Service Quotas</a> in the
///         <i>AWS General Reference</i>.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum SortOrder {
    case ascending
    case descending
    case sdkUnknown(String)
}

extension SortOrder : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SortOrder] {
        return [
            .ascending,
            .descending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ascending: return "Ascending"
        case .descending: return "Descending"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
    }
}

public struct StartHumanLoopInputBodyMiddleware: Middleware {
    public let id: String = "StartHumanLoopInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartHumanLoopInput>,
                  next: H) -> Swift.Result<OperationOutput<StartHumanLoopOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartHumanLoopInput>
    public typealias MOutput = OperationOutput<StartHumanLoopOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartHumanLoopOutputError>
}

extension StartHumanLoopInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartHumanLoopInput(dataAttributes: \(String(describing: dataAttributes)), flowDefinitionArn: \(String(describing: flowDefinitionArn)), humanLoopInput: \(String(describing: humanLoopInput)), humanLoopName: \(String(describing: humanLoopName)))"}
}

extension StartHumanLoopInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataAttributes = "DataAttributes"
        case flowDefinitionArn = "FlowDefinitionArn"
        case humanLoopInput = "HumanLoopInput"
        case humanLoopName = "HumanLoopName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAttributes = dataAttributes {
            try encodeContainer.encode(dataAttributes, forKey: .dataAttributes)
        }
        if let flowDefinitionArn = flowDefinitionArn {
            try encodeContainer.encode(flowDefinitionArn, forKey: .flowDefinitionArn)
        }
        if let humanLoopInput = humanLoopInput {
            try encodeContainer.encode(humanLoopInput, forKey: .humanLoopInput)
        }
        if let humanLoopName = humanLoopName {
            try encodeContainer.encode(humanLoopName, forKey: .humanLoopName)
        }
    }
}

public struct StartHumanLoopInputHeadersMiddleware: Middleware {
    public let id: String = "StartHumanLoopInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartHumanLoopInput>,
                  next: H) -> Swift.Result<OperationOutput<StartHumanLoopOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartHumanLoopInput>
    public typealias MOutput = OperationOutput<StartHumanLoopOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartHumanLoopOutputError>
}

public struct StartHumanLoopInputQueryItemMiddleware: Middleware {
    public let id: String = "StartHumanLoopInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartHumanLoopInput>,
                  next: H) -> Swift.Result<OperationOutput<StartHumanLoopOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartHumanLoopInput>
    public typealias MOutput = OperationOutput<StartHumanLoopOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartHumanLoopOutputError>
}

public struct StartHumanLoopInput: Equatable {
    /// <p>Attributes of the specified data. Use <code>DataAttributes</code> to specify if your data
    ///       is free of personally identifiable information and/or free of adult content.</p>
    public let dataAttributes: HumanLoopDataAttributes?
    /// <p>The Amazon Resource Name (ARN) of the flow definition associated with this human
    ///       loop.</p>
    public let flowDefinitionArn: String?
    /// <p>An object that contains information about the human loop.</p>
    public let humanLoopInput: HumanLoopInput?
    /// <p>The name of the human loop.</p>
    public let humanLoopName: String?

    public init (
        dataAttributes: HumanLoopDataAttributes? = nil,
        flowDefinitionArn: String? = nil,
        humanLoopInput: HumanLoopInput? = nil,
        humanLoopName: String? = nil
    )
    {
        self.dataAttributes = dataAttributes
        self.flowDefinitionArn = flowDefinitionArn
        self.humanLoopInput = humanLoopInput
        self.humanLoopName = humanLoopName
    }
}

struct StartHumanLoopInputBody: Equatable {
    public let humanLoopName: String?
    public let flowDefinitionArn: String?
    public let humanLoopInput: HumanLoopInput?
    public let dataAttributes: HumanLoopDataAttributes?
}

extension StartHumanLoopInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataAttributes = "DataAttributes"
        case flowDefinitionArn = "FlowDefinitionArn"
        case humanLoopInput = "HumanLoopInput"
        case humanLoopName = "HumanLoopName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .humanLoopName)
        humanLoopName = humanLoopNameDecoded
        let flowDefinitionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowDefinitionArn)
        flowDefinitionArn = flowDefinitionArnDecoded
        let humanLoopInputDecoded = try containerValues.decodeIfPresent(HumanLoopInput.self, forKey: .humanLoopInput)
        humanLoopInput = humanLoopInputDecoded
        let dataAttributesDecoded = try containerValues.decodeIfPresent(HumanLoopDataAttributes.self, forKey: .dataAttributes)
        dataAttributes = dataAttributesDecoded
    }
}

extension StartHumanLoopOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartHumanLoopOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartHumanLoopOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartHumanLoopOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartHumanLoopOutputResponse(humanLoopArn: \(String(describing: humanLoopArn)))"}
}

extension StartHumanLoopOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartHumanLoopOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.humanLoopArn = output.humanLoopArn
        } else {
            self.humanLoopArn = nil
        }
    }
}

public struct StartHumanLoopOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the human loop.</p>
    public let humanLoopArn: String?

    public init (
        humanLoopArn: String? = nil
    )
    {
        self.humanLoopArn = humanLoopArn
    }
}

struct StartHumanLoopOutputResponseBody: Equatable {
    public let humanLoopArn: String?
}

extension StartHumanLoopOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case humanLoopArn = "HumanLoopArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .humanLoopArn)
        humanLoopArn = humanLoopArnDecoded
    }
}

public struct StopHumanLoopInputBodyMiddleware: Middleware {
    public let id: String = "StopHumanLoopInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopHumanLoopInput>,
                  next: H) -> Swift.Result<OperationOutput<StopHumanLoopOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopHumanLoopInput>
    public typealias MOutput = OperationOutput<StopHumanLoopOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopHumanLoopOutputError>
}

extension StopHumanLoopInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopHumanLoopInput(humanLoopName: \(String(describing: humanLoopName)))"}
}

extension StopHumanLoopInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case humanLoopName = "HumanLoopName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let humanLoopName = humanLoopName {
            try encodeContainer.encode(humanLoopName, forKey: .humanLoopName)
        }
    }
}

public struct StopHumanLoopInputHeadersMiddleware: Middleware {
    public let id: String = "StopHumanLoopInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopHumanLoopInput>,
                  next: H) -> Swift.Result<OperationOutput<StopHumanLoopOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopHumanLoopInput>
    public typealias MOutput = OperationOutput<StopHumanLoopOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopHumanLoopOutputError>
}

public struct StopHumanLoopInputQueryItemMiddleware: Middleware {
    public let id: String = "StopHumanLoopInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopHumanLoopInput>,
                  next: H) -> Swift.Result<OperationOutput<StopHumanLoopOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopHumanLoopInput>
    public typealias MOutput = OperationOutput<StopHumanLoopOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopHumanLoopOutputError>
}

public struct StopHumanLoopInput: Equatable {
    /// <p>The name of the human loop that you want to stop.</p>
    public let humanLoopName: String?

    public init (
        humanLoopName: String? = nil
    )
    {
        self.humanLoopName = humanLoopName
    }
}

struct StopHumanLoopInputBody: Equatable {
    public let humanLoopName: String?
}

extension StopHumanLoopInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case humanLoopName = "HumanLoopName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .humanLoopName)
        humanLoopName = humanLoopNameDecoded
    }
}

extension StopHumanLoopOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopHumanLoopOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopHumanLoopOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopHumanLoopOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopHumanLoopOutputResponse()"}
}

extension StopHumanLoopOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopHumanLoopOutputResponse: Equatable {

    public init() {}
}

struct StopHumanLoopOutputResponseBody: Equatable {
}

extension StopHumanLoopOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You exceeded
///       the
///       maximum number of requests.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The
///       request isn't valid. Check the syntax and try again.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
