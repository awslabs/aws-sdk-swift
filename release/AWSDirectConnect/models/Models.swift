// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AcceptDirectConnectGatewayAssociationProposalInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedGatewayOwnerAccount
        case directConnectGatewayId
        case overrideAllowedPrefixesToDirectConnectGateway
        case proposalId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedGatewayOwnerAccount = self.associatedGatewayOwnerAccount {
            try encodeContainer.encode(associatedGatewayOwnerAccount, forKey: .associatedGatewayOwnerAccount)
        }
        if let directConnectGatewayId = self.directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let overrideAllowedPrefixesToDirectConnectGateway = overrideAllowedPrefixesToDirectConnectGateway {
            var overrideAllowedPrefixesToDirectConnectGatewayContainer = encodeContainer.nestedUnkeyedContainer(forKey: .overrideAllowedPrefixesToDirectConnectGateway)
            for routefilterprefix0 in overrideAllowedPrefixesToDirectConnectGateway {
                try overrideAllowedPrefixesToDirectConnectGatewayContainer.encode(routefilterprefix0)
            }
        }
        if let proposalId = self.proposalId {
            try encodeContainer.encode(proposalId, forKey: .proposalId)
        }
    }
}

extension AcceptDirectConnectGatewayAssociationProposalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AcceptDirectConnectGatewayAssociationProposalInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that owns the virtual private gateway or transit gateway.
    /// This member is required.
    public var associatedGatewayOwnerAccount: Swift.String?
    /// The ID of the Direct Connect gateway.
    /// This member is required.
    public var directConnectGatewayId: Swift.String?
    /// Overrides the Amazon VPC prefixes advertised to the Direct Connect gateway. For information about how to set the prefixes, see [Allowed Prefixes](https://docs.aws.amazon.com/directconnect/latest/UserGuide/multi-account-associate-vgw.html#allowed-prefixes) in the Direct Connect User Guide.
    public var overrideAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?
    /// The ID of the request proposal.
    /// This member is required.
    public var proposalId: Swift.String?

    public init (
        associatedGatewayOwnerAccount: Swift.String? = nil,
        directConnectGatewayId: Swift.String? = nil,
        overrideAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
        proposalId: Swift.String? = nil
    )
    {
        self.associatedGatewayOwnerAccount = associatedGatewayOwnerAccount
        self.directConnectGatewayId = directConnectGatewayId
        self.overrideAllowedPrefixesToDirectConnectGateway = overrideAllowedPrefixesToDirectConnectGateway
        self.proposalId = proposalId
    }
}

struct AcceptDirectConnectGatewayAssociationProposalInputBody: Swift.Equatable {
    let directConnectGatewayId: Swift.String?
    let proposalId: Swift.String?
    let associatedGatewayOwnerAccount: Swift.String?
    let overrideAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?
}

extension AcceptDirectConnectGatewayAssociationProposalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedGatewayOwnerAccount
        case directConnectGatewayId
        case overrideAllowedPrefixesToDirectConnectGateway
        case proposalId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let proposalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proposalId)
        proposalId = proposalIdDecoded
        let associatedGatewayOwnerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedGatewayOwnerAccount)
        associatedGatewayOwnerAccount = associatedGatewayOwnerAccountDecoded
        let overrideAllowedPrefixesToDirectConnectGatewayContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.RouteFilterPrefix?].self, forKey: .overrideAllowedPrefixesToDirectConnectGateway)
        var overrideAllowedPrefixesToDirectConnectGatewayDecoded0:[DirectConnectClientTypes.RouteFilterPrefix]? = nil
        if let overrideAllowedPrefixesToDirectConnectGatewayContainer = overrideAllowedPrefixesToDirectConnectGatewayContainer {
            overrideAllowedPrefixesToDirectConnectGatewayDecoded0 = [DirectConnectClientTypes.RouteFilterPrefix]()
            for structure0 in overrideAllowedPrefixesToDirectConnectGatewayContainer {
                if let structure0 = structure0 {
                    overrideAllowedPrefixesToDirectConnectGatewayDecoded0?.append(structure0)
                }
            }
        }
        overrideAllowedPrefixesToDirectConnectGateway = overrideAllowedPrefixesToDirectConnectGatewayDecoded0
    }
}

extension AcceptDirectConnectGatewayAssociationProposalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptDirectConnectGatewayAssociationProposalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AcceptDirectConnectGatewayAssociationProposalOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptDirectConnectGatewayAssociationProposalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AcceptDirectConnectGatewayAssociationProposalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGatewayAssociation = output.directConnectGatewayAssociation
        } else {
            self.directConnectGatewayAssociation = nil
        }
    }
}

public struct AcceptDirectConnectGatewayAssociationProposalOutputResponse: Swift.Equatable {
    /// Information about an association between a Direct Connect gateway and a virtual private gateway or transit gateway.
    public var directConnectGatewayAssociation: DirectConnectClientTypes.DirectConnectGatewayAssociation?

    public init (
        directConnectGatewayAssociation: DirectConnectClientTypes.DirectConnectGatewayAssociation? = nil
    )
    {
        self.directConnectGatewayAssociation = directConnectGatewayAssociation
    }
}

struct AcceptDirectConnectGatewayAssociationProposalOutputResponseBody: Swift.Equatable {
    let directConnectGatewayAssociation: DirectConnectClientTypes.DirectConnectGatewayAssociation?
}

extension AcceptDirectConnectGatewayAssociationProposalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayAssociation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayAssociationDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.DirectConnectGatewayAssociation.self, forKey: .directConnectGatewayAssociation)
        directConnectGatewayAssociation = directConnectGatewayAssociationDecoded
    }
}

extension DirectConnectClientTypes {
    public enum AddressFamily: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ipv4
        case ipv6
        case sdkUnknown(Swift.String)

        public static var allCases: [AddressFamily] {
            return [
                .ipv4,
                .ipv6,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ipv4: return "ipv4"
            case .ipv6: return "ipv6"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AddressFamily(rawValue: rawValue) ?? AddressFamily.sdkUnknown(rawValue)
        }
    }
}

extension AllocateConnectionOnInterconnectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth
        case connectionName
        case interconnectId
        case ownerAccount
        case vlan
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = self.bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let connectionName = self.connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let interconnectId = self.interconnectId {
            try encodeContainer.encode(interconnectId, forKey: .interconnectId)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if vlan != 0 {
            try encodeContainer.encode(vlan, forKey: .vlan)
        }
    }
}

extension AllocateConnectionOnInterconnectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AllocateConnectionOnInterconnectInput: Swift.Equatable {
    /// The bandwidth of the connection. The possible values are 50Mbps, 100Mbps, 200Mbps, 300Mbps, 400Mbps, 500Mbps, 1Gbps, 2Gbps, 5Gbps, and 10Gbps. Note that only those Direct Connect Partners who have met specific requirements are allowed to create a 1Gbps, 2Gbps, 5Gbps or 10Gbps hosted connection.
    /// This member is required.
    public var bandwidth: Swift.String?
    /// The name of the provisioned connection.
    /// This member is required.
    public var connectionName: Swift.String?
    /// The ID of the interconnect on which the connection will be provisioned.
    /// This member is required.
    public var interconnectId: Swift.String?
    /// The ID of the Amazon Web Services account of the customer for whom the connection will be provisioned.
    /// This member is required.
    public var ownerAccount: Swift.String?
    /// The dedicated VLAN provisioned to the connection.
    /// This member is required.
    public var vlan: Swift.Int

    public init (
        bandwidth: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        interconnectId: Swift.String? = nil,
        ownerAccount: Swift.String? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.bandwidth = bandwidth
        self.connectionName = connectionName
        self.interconnectId = interconnectId
        self.ownerAccount = ownerAccount
        self.vlan = vlan
    }
}

struct AllocateConnectionOnInterconnectInputBody: Swift.Equatable {
    let bandwidth: Swift.String?
    let connectionName: Swift.String?
    let ownerAccount: Swift.String?
    let interconnectId: Swift.String?
    let vlan: Swift.Int
}

extension AllocateConnectionOnInterconnectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth
        case connectionName
        case interconnectId
        case ownerAccount
        case vlan
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bandwidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let interconnectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interconnectId)
        interconnectId = interconnectIdDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
    }
}

extension AllocateConnectionOnInterconnectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AllocateConnectionOnInterconnectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AllocateConnectionOnInterconnectOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AllocateConnectionOnInterconnectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AllocateConnectionOnInterconnectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.awsLogicalDeviceId = output.awsLogicalDeviceId
            self.bandwidth = output.bandwidth
            self.connectionId = output.connectionId
            self.connectionName = output.connectionName
            self.connectionState = output.connectionState
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.loaIssueTime = output.loaIssueTime
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.ownerAccount = output.ownerAccount
            self.partnerName = output.partnerName
            self.portEncryptionStatus = output.portEncryptionStatus
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
            self.vlan = output.vlan
        } else {
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.awsLogicalDeviceId = nil
            self.bandwidth = nil
            self.connectionId = nil
            self.connectionName = nil
            self.connectionState = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.loaIssueTime = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.ownerAccount = nil
            self.partnerName = nil
            self.portEncryptionStatus = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
            self.vlan = 0
        }
    }
}

/// Information about an Direct Connect connection.
public struct AllocateConnectionOnInterconnectOutputResponse: Swift.Equatable {
    /// The Direct Connect endpoint on which the physical connection terminates.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The bandwidth of the connection.
    public var bandwidth: Swift.String?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The name of the connection.
    public var connectionName: Swift.String?
    /// The state of the connection. The following are the possible values:
    ///
    /// * ordering: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.
    ///
    /// * requested: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The connection has been approved and is being initialized.
    ///
    /// * available: The network link is up and the connection is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The connection is being deleted.
    ///
    /// * deleted: The connection has been deleted.
    ///
    /// * rejected: A hosted connection in the ordering state enters the rejected state if it is deleted by the customer.
    ///
    /// * unknown: The state of the connection is not available.
    public var connectionState: DirectConnectClientTypes.ConnectionState?
    /// The MAC Security (MACsec) connection encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames (9001 MTU) are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The time of the most recent call to [DescribeLoa] for this connection.
    public var loaIssueTime: ClientRuntime.Date?
    /// The location of the connection.
    public var location: Swift.String?
    /// Indicates whether the connection supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the connection.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The ID of the Amazon Web Services account that owns the connection.
    public var ownerAccount: Swift.String?
    /// The name of the Direct Connect service provider associated with the connection.
    public var partnerName: Swift.String?
    /// The MAC Security (MACsec) port link status of the connection. The valid values are Encryption Up, which means that there is an active Connection Key Name, or Encryption Down.
    public var portEncryptionStatus: Swift.String?
    /// The name of the service provider associated with the connection.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the connection.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init (
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bandwidth: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        connectionState: DirectConnectClientTypes.ConnectionState? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        loaIssueTime: ClientRuntime.Date? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        ownerAccount: Swift.String? = nil,
        partnerName: Swift.String? = nil,
        portEncryptionStatus: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

struct AllocateConnectionOnInterconnectOutputResponseBody: Swift.Equatable {
    let ownerAccount: Swift.String?
    let connectionId: Swift.String?
    let connectionName: Swift.String?
    let connectionState: DirectConnectClientTypes.ConnectionState?
    let region: Swift.String?
    let location: Swift.String?
    let bandwidth: Swift.String?
    let vlan: Swift.Int
    let partnerName: Swift.String?
    let loaIssueTime: ClientRuntime.Date?
    let lagId: Swift.String?
    let awsDevice: Swift.String?
    let jumboFrameCapable: Swift.Bool?
    let awsDeviceV2: Swift.String?
    let awsLogicalDeviceId: Swift.String?
    let hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    let tags: [DirectConnectClientTypes.Tag]?
    let providerName: Swift.String?
    let macSecCapable: Swift.Bool?
    let portEncryptionStatus: Swift.String?
    let encryptionMode: Swift.String?
    let macSecKeys: [DirectConnectClientTypes.MacSecKey]?
}

extension AllocateConnectionOnInterconnectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsDevice
        case awsDeviceV2
        case awsLogicalDeviceId
        case bandwidth
        case connectionId
        case connectionName
        case connectionState
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case macSecCapable
        case macSecKeys
        case ownerAccount
        case partnerName
        case portEncryptionStatus
        case providerName
        case region
        case tags
        case vlan
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
        let loaIssueTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let portEncryptionStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portEncryptionStatus)
        portEncryptionStatus = portEncryptionStatusDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[DirectConnectClientTypes.MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [DirectConnectClientTypes.MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

extension AllocateHostedConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth
        case connectionId
        case connectionName
        case ownerAccount
        case tags
        case vlan
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = self.bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionName = self.connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if vlan != 0 {
            try encodeContainer.encode(vlan, forKey: .vlan)
        }
    }
}

extension AllocateHostedConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AllocateHostedConnectionInput: Swift.Equatable {
    /// The bandwidth of the connection. The possible values are 50Mbps, 100Mbps, 200Mbps, 300Mbps, 400Mbps, 500Mbps, 1Gbps, 2Gbps, 5Gbps, and 10Gbps. Note that only those Direct Connect Partners who have met specific requirements are allowed to create a 1Gbps, 2Gbps, 5Gbps or 10Gbps hosted connection.
    /// This member is required.
    public var bandwidth: Swift.String?
    /// The ID of the interconnect or LAG.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The name of the hosted connection.
    /// This member is required.
    public var connectionName: Swift.String?
    /// The ID of the Amazon Web Services account ID of the customer for the connection.
    /// This member is required.
    public var ownerAccount: Swift.String?
    /// The tags associated with the connection.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The dedicated VLAN provisioned to the hosted connection.
    /// This member is required.
    public var vlan: Swift.Int

    public init (
        bandwidth: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        ownerAccount: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.ownerAccount = ownerAccount
        self.tags = tags
        self.vlan = vlan
    }
}

struct AllocateHostedConnectionInputBody: Swift.Equatable {
    let connectionId: Swift.String?
    let ownerAccount: Swift.String?
    let bandwidth: Swift.String?
    let connectionName: Swift.String?
    let vlan: Swift.Int
    let tags: [DirectConnectClientTypes.Tag]?
}

extension AllocateHostedConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth
        case connectionId
        case connectionName
        case ownerAccount
        case tags
        case vlan
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AllocateHostedConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AllocateHostedConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AllocateHostedConnectionOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AllocateHostedConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AllocateHostedConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.awsLogicalDeviceId = output.awsLogicalDeviceId
            self.bandwidth = output.bandwidth
            self.connectionId = output.connectionId
            self.connectionName = output.connectionName
            self.connectionState = output.connectionState
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.loaIssueTime = output.loaIssueTime
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.ownerAccount = output.ownerAccount
            self.partnerName = output.partnerName
            self.portEncryptionStatus = output.portEncryptionStatus
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
            self.vlan = output.vlan
        } else {
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.awsLogicalDeviceId = nil
            self.bandwidth = nil
            self.connectionId = nil
            self.connectionName = nil
            self.connectionState = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.loaIssueTime = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.ownerAccount = nil
            self.partnerName = nil
            self.portEncryptionStatus = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
            self.vlan = 0
        }
    }
}

/// Information about an Direct Connect connection.
public struct AllocateHostedConnectionOutputResponse: Swift.Equatable {
    /// The Direct Connect endpoint on which the physical connection terminates.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The bandwidth of the connection.
    public var bandwidth: Swift.String?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The name of the connection.
    public var connectionName: Swift.String?
    /// The state of the connection. The following are the possible values:
    ///
    /// * ordering: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.
    ///
    /// * requested: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The connection has been approved and is being initialized.
    ///
    /// * available: The network link is up and the connection is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The connection is being deleted.
    ///
    /// * deleted: The connection has been deleted.
    ///
    /// * rejected: A hosted connection in the ordering state enters the rejected state if it is deleted by the customer.
    ///
    /// * unknown: The state of the connection is not available.
    public var connectionState: DirectConnectClientTypes.ConnectionState?
    /// The MAC Security (MACsec) connection encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames (9001 MTU) are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The time of the most recent call to [DescribeLoa] for this connection.
    public var loaIssueTime: ClientRuntime.Date?
    /// The location of the connection.
    public var location: Swift.String?
    /// Indicates whether the connection supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the connection.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The ID of the Amazon Web Services account that owns the connection.
    public var ownerAccount: Swift.String?
    /// The name of the Direct Connect service provider associated with the connection.
    public var partnerName: Swift.String?
    /// The MAC Security (MACsec) port link status of the connection. The valid values are Encryption Up, which means that there is an active Connection Key Name, or Encryption Down.
    public var portEncryptionStatus: Swift.String?
    /// The name of the service provider associated with the connection.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the connection.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init (
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bandwidth: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        connectionState: DirectConnectClientTypes.ConnectionState? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        loaIssueTime: ClientRuntime.Date? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        ownerAccount: Swift.String? = nil,
        partnerName: Swift.String? = nil,
        portEncryptionStatus: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

struct AllocateHostedConnectionOutputResponseBody: Swift.Equatable {
    let ownerAccount: Swift.String?
    let connectionId: Swift.String?
    let connectionName: Swift.String?
    let connectionState: DirectConnectClientTypes.ConnectionState?
    let region: Swift.String?
    let location: Swift.String?
    let bandwidth: Swift.String?
    let vlan: Swift.Int
    let partnerName: Swift.String?
    let loaIssueTime: ClientRuntime.Date?
    let lagId: Swift.String?
    let awsDevice: Swift.String?
    let jumboFrameCapable: Swift.Bool?
    let awsDeviceV2: Swift.String?
    let awsLogicalDeviceId: Swift.String?
    let hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    let tags: [DirectConnectClientTypes.Tag]?
    let providerName: Swift.String?
    let macSecCapable: Swift.Bool?
    let portEncryptionStatus: Swift.String?
    let encryptionMode: Swift.String?
    let macSecKeys: [DirectConnectClientTypes.MacSecKey]?
}

extension AllocateHostedConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsDevice
        case awsDeviceV2
        case awsLogicalDeviceId
        case bandwidth
        case connectionId
        case connectionName
        case connectionState
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case macSecCapable
        case macSecKeys
        case ownerAccount
        case partnerName
        case portEncryptionStatus
        case providerName
        case region
        case tags
        case vlan
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
        let loaIssueTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let portEncryptionStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portEncryptionStatus)
        portEncryptionStatus = portEncryptionStatusDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[DirectConnectClientTypes.MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [DirectConnectClientTypes.MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

extension AllocatePrivateVirtualInterfaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case newPrivateVirtualInterfaceAllocation
        case ownerAccount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let newPrivateVirtualInterfaceAllocation = self.newPrivateVirtualInterfaceAllocation {
            try encodeContainer.encode(newPrivateVirtualInterfaceAllocation, forKey: .newPrivateVirtualInterfaceAllocation)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
    }
}

extension AllocatePrivateVirtualInterfaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AllocatePrivateVirtualInterfaceInput: Swift.Equatable {
    /// The ID of the connection on which the private virtual interface is provisioned.
    /// This member is required.
    public var connectionId: Swift.String?
    /// Information about the private virtual interface.
    /// This member is required.
    public var newPrivateVirtualInterfaceAllocation: DirectConnectClientTypes.NewPrivateVirtualInterfaceAllocation?
    /// The ID of the Amazon Web Services account that owns the virtual private interface.
    /// This member is required.
    public var ownerAccount: Swift.String?

    public init (
        connectionId: Swift.String? = nil,
        newPrivateVirtualInterfaceAllocation: DirectConnectClientTypes.NewPrivateVirtualInterfaceAllocation? = nil,
        ownerAccount: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.newPrivateVirtualInterfaceAllocation = newPrivateVirtualInterfaceAllocation
        self.ownerAccount = ownerAccount
    }
}

struct AllocatePrivateVirtualInterfaceInputBody: Swift.Equatable {
    let connectionId: Swift.String?
    let ownerAccount: Swift.String?
    let newPrivateVirtualInterfaceAllocation: DirectConnectClientTypes.NewPrivateVirtualInterfaceAllocation?
}

extension AllocatePrivateVirtualInterfaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case newPrivateVirtualInterfaceAllocation
        case ownerAccount
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let newPrivateVirtualInterfaceAllocationDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.NewPrivateVirtualInterfaceAllocation.self, forKey: .newPrivateVirtualInterfaceAllocation)
        newPrivateVirtualInterfaceAllocation = newPrivateVirtualInterfaceAllocationDecoded
    }
}

extension AllocatePrivateVirtualInterfaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AllocatePrivateVirtualInterfaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AllocatePrivateVirtualInterfaceOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AllocatePrivateVirtualInterfaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AllocatePrivateVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addressFamily = output.addressFamily
            self.amazonAddress = output.amazonAddress
            self.amazonSideAsn = output.amazonSideAsn
            self.asn = output.asn
            self.authKey = output.authKey
            self.awsDeviceV2 = output.awsDeviceV2
            self.awsLogicalDeviceId = output.awsLogicalDeviceId
            self.bgpPeers = output.bgpPeers
            self.connectionId = output.connectionId
            self.customerAddress = output.customerAddress
            self.customerRouterConfig = output.customerRouterConfig
            self.directConnectGatewayId = output.directConnectGatewayId
            self.jumboFrameCapable = output.jumboFrameCapable
            self.location = output.location
            self.mtu = output.mtu
            self.ownerAccount = output.ownerAccount
            self.region = output.region
            self.routeFilterPrefixes = output.routeFilterPrefixes
            self.siteLinkEnabled = output.siteLinkEnabled
            self.tags = output.tags
            self.virtualGatewayId = output.virtualGatewayId
            self.virtualInterfaceId = output.virtualInterfaceId
            self.virtualInterfaceName = output.virtualInterfaceName
            self.virtualInterfaceState = output.virtualInterfaceState
            self.virtualInterfaceType = output.virtualInterfaceType
            self.vlan = output.vlan
        } else {
            self.addressFamily = nil
            self.amazonAddress = nil
            self.amazonSideAsn = nil
            self.asn = 0
            self.authKey = nil
            self.awsDeviceV2 = nil
            self.awsLogicalDeviceId = nil
            self.bgpPeers = nil
            self.connectionId = nil
            self.customerAddress = nil
            self.customerRouterConfig = nil
            self.directConnectGatewayId = nil
            self.jumboFrameCapable = nil
            self.location = nil
            self.mtu = nil
            self.ownerAccount = nil
            self.region = nil
            self.routeFilterPrefixes = nil
            self.siteLinkEnabled = nil
            self.tags = nil
            self.virtualGatewayId = nil
            self.virtualInterfaceId = nil
            self.virtualInterfaceName = nil
            self.virtualInterfaceState = nil
            self.virtualInterfaceType = nil
            self.vlan = 0
        }
    }
}

/// Information about a virtual interface.
public struct AllocatePrivateVirtualInterfaceOutputResponse: Swift.Equatable {
    /// The address family for the BGP peer.
    public var addressFamily: DirectConnectClientTypes.AddressFamily?
    /// The IP address assigned to the Amazon interface.
    public var amazonAddress: Swift.String?
    /// The autonomous system number (ASN) for the Amazon side of the connection.
    public var amazonSideAsn: Swift.Int?
    /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
    public var asn: Swift.Int
    /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
    public var authKey: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The BGP peers configured on this virtual interface.
    public var bgpPeers: [DirectConnectClientTypes.BGPPeer]?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The IP address assigned to the customer interface.
    public var customerAddress: Swift.String?
    /// The customer router configuration.
    public var customerRouterConfig: Swift.String?
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// Indicates whether jumbo frames (9001 MTU) are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The location of the connection.
    public var location: Swift.String?
    /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.
    public var mtu: Swift.Int?
    /// The ID of the Amazon Web Services account that owns the virtual interface.
    public var ownerAccount: Swift.String?
    /// The Amazon Web Services Region where the virtual interface is located.
    public var region: Swift.String?
    /// The routes to be advertised to the Amazon Web Services network in this Region. Applies to public virtual interfaces.
    public var routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
    /// Indicates whether SiteLink is enabled.
    public var siteLinkEnabled: Swift.Bool?
    /// The tags associated with the virtual interface.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the virtual private gateway. Applies only to private virtual interfaces.
    public var virtualGatewayId: Swift.String?
    /// The ID of the virtual interface.
    public var virtualInterfaceId: Swift.String?
    /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
    public var virtualInterfaceName: Swift.String?
    /// The state of the virtual interface. The following are the possible values:
    ///
    /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
    ///
    /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
    ///
    /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
    ///
    /// * available: A virtual interface that is able to forward traffic.
    ///
    /// * down: A virtual interface that is BGP down.
    ///
    /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
    ///
    /// * deleted: A virtual interface that cannot forward traffic.
    ///
    /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
    ///
    /// * unknown: The state of the virtual interface is not available.
    public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
    /// The type of virtual interface. The possible values are private and public.
    public var virtualInterfaceType: Swift.String?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init (
        addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
        amazonAddress: Swift.String? = nil,
        amazonSideAsn: Swift.Int? = nil,
        asn: Swift.Int = 0,
        authKey: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bgpPeers: [DirectConnectClientTypes.BGPPeer]? = nil,
        connectionId: Swift.String? = nil,
        customerAddress: Swift.String? = nil,
        customerRouterConfig: Swift.String? = nil,
        directConnectGatewayId: Swift.String? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        location: Swift.String? = nil,
        mtu: Swift.Int? = nil,
        ownerAccount: Swift.String? = nil,
        region: Swift.String? = nil,
        routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
        siteLinkEnabled: Swift.Bool? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        virtualGatewayId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil,
        virtualInterfaceName: Swift.String? = nil,
        virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil,
        virtualInterfaceType: Swift.String? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.amazonSideAsn = amazonSideAsn
        self.asn = asn
        self.authKey = authKey
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bgpPeers = bgpPeers
        self.connectionId = connectionId
        self.customerAddress = customerAddress
        self.customerRouterConfig = customerRouterConfig
        self.directConnectGatewayId = directConnectGatewayId
        self.jumboFrameCapable = jumboFrameCapable
        self.location = location
        self.mtu = mtu
        self.ownerAccount = ownerAccount
        self.region = region
        self.routeFilterPrefixes = routeFilterPrefixes
        self.siteLinkEnabled = siteLinkEnabled
        self.tags = tags
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
        self.virtualInterfaceState = virtualInterfaceState
        self.virtualInterfaceType = virtualInterfaceType
        self.vlan = vlan
    }
}

struct AllocatePrivateVirtualInterfaceOutputResponseBody: Swift.Equatable {
    let ownerAccount: Swift.String?
    let virtualInterfaceId: Swift.String?
    let location: Swift.String?
    let connectionId: Swift.String?
    let virtualInterfaceType: Swift.String?
    let virtualInterfaceName: Swift.String?
    let vlan: Swift.Int
    let asn: Swift.Int
    let amazonSideAsn: Swift.Int?
    let authKey: Swift.String?
    let amazonAddress: Swift.String?
    let customerAddress: Swift.String?
    let addressFamily: DirectConnectClientTypes.AddressFamily?
    let virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
    let customerRouterConfig: Swift.String?
    let mtu: Swift.Int?
    let jumboFrameCapable: Swift.Bool?
    let virtualGatewayId: Swift.String?
    let directConnectGatewayId: Swift.String?
    let routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
    let bgpPeers: [DirectConnectClientTypes.BGPPeer]?
    let region: Swift.String?
    let awsDeviceV2: Swift.String?
    let awsLogicalDeviceId: Swift.String?
    let tags: [DirectConnectClientTypes.Tag]?
    let siteLinkEnabled: Swift.Bool?
}

extension AllocatePrivateVirtualInterfaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressFamily
        case amazonAddress
        case amazonSideAsn
        case asn
        case authKey
        case awsDeviceV2
        case awsLogicalDeviceId
        case bgpPeers
        case connectionId
        case customerAddress
        case customerRouterConfig
        case directConnectGatewayId
        case jumboFrameCapable
        case location
        case mtu
        case ownerAccount
        case region
        case routeFilterPrefixes
        case siteLinkEnabled
        case tags
        case virtualGatewayId
        case virtualInterfaceId
        case virtualInterfaceName
        case virtualInterfaceState
        case virtualInterfaceType
        case vlan
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let virtualInterfaceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceType)
        virtualInterfaceType = virtualInterfaceTypeDecoded
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn) ?? 0
        asn = asnDecoded
        let amazonSideAsnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .amazonSideAsn)
        amazonSideAsn = amazonSideAsnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
        let customerRouterConfigDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerRouterConfig)
        customerRouterConfig = customerRouterConfigDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let routeFilterPrefixesContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.RouteFilterPrefix?].self, forKey: .routeFilterPrefixes)
        var routeFilterPrefixesDecoded0:[DirectConnectClientTypes.RouteFilterPrefix]? = nil
        if let routeFilterPrefixesContainer = routeFilterPrefixesContainer {
            routeFilterPrefixesDecoded0 = [DirectConnectClientTypes.RouteFilterPrefix]()
            for structure0 in routeFilterPrefixesContainer {
                if let structure0 = structure0 {
                    routeFilterPrefixesDecoded0?.append(structure0)
                }
            }
        }
        routeFilterPrefixes = routeFilterPrefixesDecoded0
        let bgpPeersContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.BGPPeer?].self, forKey: .bgpPeers)
        var bgpPeersDecoded0:[DirectConnectClientTypes.BGPPeer]? = nil
        if let bgpPeersContainer = bgpPeersContainer {
            bgpPeersDecoded0 = [DirectConnectClientTypes.BGPPeer]()
            for structure0 in bgpPeersContainer {
                if let structure0 = structure0 {
                    bgpPeersDecoded0?.append(structure0)
                }
            }
        }
        bgpPeers = bgpPeersDecoded0
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let siteLinkEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .siteLinkEnabled)
        siteLinkEnabled = siteLinkEnabledDecoded
    }
}

extension AllocatePublicVirtualInterfaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case newPublicVirtualInterfaceAllocation
        case ownerAccount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let newPublicVirtualInterfaceAllocation = self.newPublicVirtualInterfaceAllocation {
            try encodeContainer.encode(newPublicVirtualInterfaceAllocation, forKey: .newPublicVirtualInterfaceAllocation)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
    }
}

extension AllocatePublicVirtualInterfaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AllocatePublicVirtualInterfaceInput: Swift.Equatable {
    /// The ID of the connection on which the public virtual interface is provisioned.
    /// This member is required.
    public var connectionId: Swift.String?
    /// Information about the public virtual interface.
    /// This member is required.
    public var newPublicVirtualInterfaceAllocation: DirectConnectClientTypes.NewPublicVirtualInterfaceAllocation?
    /// The ID of the Amazon Web Services account that owns the public virtual interface.
    /// This member is required.
    public var ownerAccount: Swift.String?

    public init (
        connectionId: Swift.String? = nil,
        newPublicVirtualInterfaceAllocation: DirectConnectClientTypes.NewPublicVirtualInterfaceAllocation? = nil,
        ownerAccount: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.newPublicVirtualInterfaceAllocation = newPublicVirtualInterfaceAllocation
        self.ownerAccount = ownerAccount
    }
}

struct AllocatePublicVirtualInterfaceInputBody: Swift.Equatable {
    let connectionId: Swift.String?
    let ownerAccount: Swift.String?
    let newPublicVirtualInterfaceAllocation: DirectConnectClientTypes.NewPublicVirtualInterfaceAllocation?
}

extension AllocatePublicVirtualInterfaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case newPublicVirtualInterfaceAllocation
        case ownerAccount
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let newPublicVirtualInterfaceAllocationDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.NewPublicVirtualInterfaceAllocation.self, forKey: .newPublicVirtualInterfaceAllocation)
        newPublicVirtualInterfaceAllocation = newPublicVirtualInterfaceAllocationDecoded
    }
}

extension AllocatePublicVirtualInterfaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AllocatePublicVirtualInterfaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AllocatePublicVirtualInterfaceOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AllocatePublicVirtualInterfaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AllocatePublicVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addressFamily = output.addressFamily
            self.amazonAddress = output.amazonAddress
            self.amazonSideAsn = output.amazonSideAsn
            self.asn = output.asn
            self.authKey = output.authKey
            self.awsDeviceV2 = output.awsDeviceV2
            self.awsLogicalDeviceId = output.awsLogicalDeviceId
            self.bgpPeers = output.bgpPeers
            self.connectionId = output.connectionId
            self.customerAddress = output.customerAddress
            self.customerRouterConfig = output.customerRouterConfig
            self.directConnectGatewayId = output.directConnectGatewayId
            self.jumboFrameCapable = output.jumboFrameCapable
            self.location = output.location
            self.mtu = output.mtu
            self.ownerAccount = output.ownerAccount
            self.region = output.region
            self.routeFilterPrefixes = output.routeFilterPrefixes
            self.siteLinkEnabled = output.siteLinkEnabled
            self.tags = output.tags
            self.virtualGatewayId = output.virtualGatewayId
            self.virtualInterfaceId = output.virtualInterfaceId
            self.virtualInterfaceName = output.virtualInterfaceName
            self.virtualInterfaceState = output.virtualInterfaceState
            self.virtualInterfaceType = output.virtualInterfaceType
            self.vlan = output.vlan
        } else {
            self.addressFamily = nil
            self.amazonAddress = nil
            self.amazonSideAsn = nil
            self.asn = 0
            self.authKey = nil
            self.awsDeviceV2 = nil
            self.awsLogicalDeviceId = nil
            self.bgpPeers = nil
            self.connectionId = nil
            self.customerAddress = nil
            self.customerRouterConfig = nil
            self.directConnectGatewayId = nil
            self.jumboFrameCapable = nil
            self.location = nil
            self.mtu = nil
            self.ownerAccount = nil
            self.region = nil
            self.routeFilterPrefixes = nil
            self.siteLinkEnabled = nil
            self.tags = nil
            self.virtualGatewayId = nil
            self.virtualInterfaceId = nil
            self.virtualInterfaceName = nil
            self.virtualInterfaceState = nil
            self.virtualInterfaceType = nil
            self.vlan = 0
        }
    }
}

/// Information about a virtual interface.
public struct AllocatePublicVirtualInterfaceOutputResponse: Swift.Equatable {
    /// The address family for the BGP peer.
    public var addressFamily: DirectConnectClientTypes.AddressFamily?
    /// The IP address assigned to the Amazon interface.
    public var amazonAddress: Swift.String?
    /// The autonomous system number (ASN) for the Amazon side of the connection.
    public var amazonSideAsn: Swift.Int?
    /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
    public var asn: Swift.Int
    /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
    public var authKey: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The BGP peers configured on this virtual interface.
    public var bgpPeers: [DirectConnectClientTypes.BGPPeer]?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The IP address assigned to the customer interface.
    public var customerAddress: Swift.String?
    /// The customer router configuration.
    public var customerRouterConfig: Swift.String?
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// Indicates whether jumbo frames (9001 MTU) are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The location of the connection.
    public var location: Swift.String?
    /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.
    public var mtu: Swift.Int?
    /// The ID of the Amazon Web Services account that owns the virtual interface.
    public var ownerAccount: Swift.String?
    /// The Amazon Web Services Region where the virtual interface is located.
    public var region: Swift.String?
    /// The routes to be advertised to the Amazon Web Services network in this Region. Applies to public virtual interfaces.
    public var routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
    /// Indicates whether SiteLink is enabled.
    public var siteLinkEnabled: Swift.Bool?
    /// The tags associated with the virtual interface.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the virtual private gateway. Applies only to private virtual interfaces.
    public var virtualGatewayId: Swift.String?
    /// The ID of the virtual interface.
    public var virtualInterfaceId: Swift.String?
    /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
    public var virtualInterfaceName: Swift.String?
    /// The state of the virtual interface. The following are the possible values:
    ///
    /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
    ///
    /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
    ///
    /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
    ///
    /// * available: A virtual interface that is able to forward traffic.
    ///
    /// * down: A virtual interface that is BGP down.
    ///
    /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
    ///
    /// * deleted: A virtual interface that cannot forward traffic.
    ///
    /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
    ///
    /// * unknown: The state of the virtual interface is not available.
    public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
    /// The type of virtual interface. The possible values are private and public.
    public var virtualInterfaceType: Swift.String?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init (
        addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
        amazonAddress: Swift.String? = nil,
        amazonSideAsn: Swift.Int? = nil,
        asn: Swift.Int = 0,
        authKey: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bgpPeers: [DirectConnectClientTypes.BGPPeer]? = nil,
        connectionId: Swift.String? = nil,
        customerAddress: Swift.String? = nil,
        customerRouterConfig: Swift.String? = nil,
        directConnectGatewayId: Swift.String? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        location: Swift.String? = nil,
        mtu: Swift.Int? = nil,
        ownerAccount: Swift.String? = nil,
        region: Swift.String? = nil,
        routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
        siteLinkEnabled: Swift.Bool? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        virtualGatewayId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil,
        virtualInterfaceName: Swift.String? = nil,
        virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil,
        virtualInterfaceType: Swift.String? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.amazonSideAsn = amazonSideAsn
        self.asn = asn
        self.authKey = authKey
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bgpPeers = bgpPeers
        self.connectionId = connectionId
        self.customerAddress = customerAddress
        self.customerRouterConfig = customerRouterConfig
        self.directConnectGatewayId = directConnectGatewayId
        self.jumboFrameCapable = jumboFrameCapable
        self.location = location
        self.mtu = mtu
        self.ownerAccount = ownerAccount
        self.region = region
        self.routeFilterPrefixes = routeFilterPrefixes
        self.siteLinkEnabled = siteLinkEnabled
        self.tags = tags
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
        self.virtualInterfaceState = virtualInterfaceState
        self.virtualInterfaceType = virtualInterfaceType
        self.vlan = vlan
    }
}

struct AllocatePublicVirtualInterfaceOutputResponseBody: Swift.Equatable {
    let ownerAccount: Swift.String?
    let virtualInterfaceId: Swift.String?
    let location: Swift.String?
    let connectionId: Swift.String?
    let virtualInterfaceType: Swift.String?
    let virtualInterfaceName: Swift.String?
    let vlan: Swift.Int
    let asn: Swift.Int
    let amazonSideAsn: Swift.Int?
    let authKey: Swift.String?
    let amazonAddress: Swift.String?
    let customerAddress: Swift.String?
    let addressFamily: DirectConnectClientTypes.AddressFamily?
    let virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
    let customerRouterConfig: Swift.String?
    let mtu: Swift.Int?
    let jumboFrameCapable: Swift.Bool?
    let virtualGatewayId: Swift.String?
    let directConnectGatewayId: Swift.String?
    let routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
    let bgpPeers: [DirectConnectClientTypes.BGPPeer]?
    let region: Swift.String?
    let awsDeviceV2: Swift.String?
    let awsLogicalDeviceId: Swift.String?
    let tags: [DirectConnectClientTypes.Tag]?
    let siteLinkEnabled: Swift.Bool?
}

extension AllocatePublicVirtualInterfaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressFamily
        case amazonAddress
        case amazonSideAsn
        case asn
        case authKey
        case awsDeviceV2
        case awsLogicalDeviceId
        case bgpPeers
        case connectionId
        case customerAddress
        case customerRouterConfig
        case directConnectGatewayId
        case jumboFrameCapable
        case location
        case mtu
        case ownerAccount
        case region
        case routeFilterPrefixes
        case siteLinkEnabled
        case tags
        case virtualGatewayId
        case virtualInterfaceId
        case virtualInterfaceName
        case virtualInterfaceState
        case virtualInterfaceType
        case vlan
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let virtualInterfaceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceType)
        virtualInterfaceType = virtualInterfaceTypeDecoded
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn) ?? 0
        asn = asnDecoded
        let amazonSideAsnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .amazonSideAsn)
        amazonSideAsn = amazonSideAsnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
        let customerRouterConfigDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerRouterConfig)
        customerRouterConfig = customerRouterConfigDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let routeFilterPrefixesContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.RouteFilterPrefix?].self, forKey: .routeFilterPrefixes)
        var routeFilterPrefixesDecoded0:[DirectConnectClientTypes.RouteFilterPrefix]? = nil
        if let routeFilterPrefixesContainer = routeFilterPrefixesContainer {
            routeFilterPrefixesDecoded0 = [DirectConnectClientTypes.RouteFilterPrefix]()
            for structure0 in routeFilterPrefixesContainer {
                if let structure0 = structure0 {
                    routeFilterPrefixesDecoded0?.append(structure0)
                }
            }
        }
        routeFilterPrefixes = routeFilterPrefixesDecoded0
        let bgpPeersContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.BGPPeer?].self, forKey: .bgpPeers)
        var bgpPeersDecoded0:[DirectConnectClientTypes.BGPPeer]? = nil
        if let bgpPeersContainer = bgpPeersContainer {
            bgpPeersDecoded0 = [DirectConnectClientTypes.BGPPeer]()
            for structure0 in bgpPeersContainer {
                if let structure0 = structure0 {
                    bgpPeersDecoded0?.append(structure0)
                }
            }
        }
        bgpPeers = bgpPeersDecoded0
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let siteLinkEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .siteLinkEnabled)
        siteLinkEnabled = siteLinkEnabledDecoded
    }
}

extension AllocateTransitVirtualInterfaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case newTransitVirtualInterfaceAllocation
        case ownerAccount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let newTransitVirtualInterfaceAllocation = self.newTransitVirtualInterfaceAllocation {
            try encodeContainer.encode(newTransitVirtualInterfaceAllocation, forKey: .newTransitVirtualInterfaceAllocation)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
    }
}

extension AllocateTransitVirtualInterfaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AllocateTransitVirtualInterfaceInput: Swift.Equatable {
    /// The ID of the connection on which the transit virtual interface is provisioned.
    /// This member is required.
    public var connectionId: Swift.String?
    /// Information about the transit virtual interface.
    /// This member is required.
    public var newTransitVirtualInterfaceAllocation: DirectConnectClientTypes.NewTransitVirtualInterfaceAllocation?
    /// The ID of the Amazon Web Services account that owns the transit virtual interface.
    /// This member is required.
    public var ownerAccount: Swift.String?

    public init (
        connectionId: Swift.String? = nil,
        newTransitVirtualInterfaceAllocation: DirectConnectClientTypes.NewTransitVirtualInterfaceAllocation? = nil,
        ownerAccount: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.newTransitVirtualInterfaceAllocation = newTransitVirtualInterfaceAllocation
        self.ownerAccount = ownerAccount
    }
}

struct AllocateTransitVirtualInterfaceInputBody: Swift.Equatable {
    let connectionId: Swift.String?
    let ownerAccount: Swift.String?
    let newTransitVirtualInterfaceAllocation: DirectConnectClientTypes.NewTransitVirtualInterfaceAllocation?
}

extension AllocateTransitVirtualInterfaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case newTransitVirtualInterfaceAllocation
        case ownerAccount
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let newTransitVirtualInterfaceAllocationDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.NewTransitVirtualInterfaceAllocation.self, forKey: .newTransitVirtualInterfaceAllocation)
        newTransitVirtualInterfaceAllocation = newTransitVirtualInterfaceAllocationDecoded
    }
}

extension AllocateTransitVirtualInterfaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AllocateTransitVirtualInterfaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AllocateTransitVirtualInterfaceOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AllocateTransitVirtualInterfaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AllocateTransitVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterface = output.virtualInterface
        } else {
            self.virtualInterface = nil
        }
    }
}

public struct AllocateTransitVirtualInterfaceOutputResponse: Swift.Equatable {
    /// Information about a virtual interface.
    public var virtualInterface: DirectConnectClientTypes.VirtualInterface?

    public init (
        virtualInterface: DirectConnectClientTypes.VirtualInterface? = nil
    )
    {
        self.virtualInterface = virtualInterface
    }
}

struct AllocateTransitVirtualInterfaceOutputResponseBody: Swift.Equatable {
    let virtualInterface: DirectConnectClientTypes.VirtualInterface?
}

extension AllocateTransitVirtualInterfaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualInterface
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.VirtualInterface.self, forKey: .virtualInterface)
        virtualInterface = virtualInterfaceDecoded
    }
}

extension AssociateConnectionWithLagInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case lagId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let lagId = self.lagId {
            try encodeContainer.encode(lagId, forKey: .lagId)
        }
    }
}

extension AssociateConnectionWithLagInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateConnectionWithLagInput: Swift.Equatable {
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The ID of the LAG with which to associate the connection.
    /// This member is required.
    public var lagId: Swift.String?

    public init (
        connectionId: Swift.String? = nil,
        lagId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.lagId = lagId
    }
}

struct AssociateConnectionWithLagInputBody: Swift.Equatable {
    let connectionId: Swift.String?
    let lagId: Swift.String?
}

extension AssociateConnectionWithLagInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case lagId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
    }
}

extension AssociateConnectionWithLagOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateConnectionWithLagOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateConnectionWithLagOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateConnectionWithLagOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateConnectionWithLagOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.awsLogicalDeviceId = output.awsLogicalDeviceId
            self.bandwidth = output.bandwidth
            self.connectionId = output.connectionId
            self.connectionName = output.connectionName
            self.connectionState = output.connectionState
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.loaIssueTime = output.loaIssueTime
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.ownerAccount = output.ownerAccount
            self.partnerName = output.partnerName
            self.portEncryptionStatus = output.portEncryptionStatus
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
            self.vlan = output.vlan
        } else {
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.awsLogicalDeviceId = nil
            self.bandwidth = nil
            self.connectionId = nil
            self.connectionName = nil
            self.connectionState = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.loaIssueTime = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.ownerAccount = nil
            self.partnerName = nil
            self.portEncryptionStatus = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
            self.vlan = 0
        }
    }
}

/// Information about an Direct Connect connection.
public struct AssociateConnectionWithLagOutputResponse: Swift.Equatable {
    /// The Direct Connect endpoint on which the physical connection terminates.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The bandwidth of the connection.
    public var bandwidth: Swift.String?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The name of the connection.
    public var connectionName: Swift.String?
    /// The state of the connection. The following are the possible values:
    ///
    /// * ordering: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.
    ///
    /// * requested: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The connection has been approved and is being initialized.
    ///
    /// * available: The network link is up and the connection is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The connection is being deleted.
    ///
    /// * deleted: The connection has been deleted.
    ///
    /// * rejected: A hosted connection in the ordering state enters the rejected state if it is deleted by the customer.
    ///
    /// * unknown: The state of the connection is not available.
    public var connectionState: DirectConnectClientTypes.ConnectionState?
    /// The MAC Security (MACsec) connection encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames (9001 MTU) are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The time of the most recent call to [DescribeLoa] for this connection.
    public var loaIssueTime: ClientRuntime.Date?
    /// The location of the connection.
    public var location: Swift.String?
    /// Indicates whether the connection supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the connection.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The ID of the Amazon Web Services account that owns the connection.
    public var ownerAccount: Swift.String?
    /// The name of the Direct Connect service provider associated with the connection.
    public var partnerName: Swift.String?
    /// The MAC Security (MACsec) port link status of the connection. The valid values are Encryption Up, which means that there is an active Connection Key Name, or Encryption Down.
    public var portEncryptionStatus: Swift.String?
    /// The name of the service provider associated with the connection.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the connection.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init (
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bandwidth: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        connectionState: DirectConnectClientTypes.ConnectionState? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        loaIssueTime: ClientRuntime.Date? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        ownerAccount: Swift.String? = nil,
        partnerName: Swift.String? = nil,
        portEncryptionStatus: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

struct AssociateConnectionWithLagOutputResponseBody: Swift.Equatable {
    let ownerAccount: Swift.String?
    let connectionId: Swift.String?
    let connectionName: Swift.String?
    let connectionState: DirectConnectClientTypes.ConnectionState?
    let region: Swift.String?
    let location: Swift.String?
    let bandwidth: Swift.String?
    let vlan: Swift.Int
    let partnerName: Swift.String?
    let loaIssueTime: ClientRuntime.Date?
    let lagId: Swift.String?
    let awsDevice: Swift.String?
    let jumboFrameCapable: Swift.Bool?
    let awsDeviceV2: Swift.String?
    let awsLogicalDeviceId: Swift.String?
    let hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    let tags: [DirectConnectClientTypes.Tag]?
    let providerName: Swift.String?
    let macSecCapable: Swift.Bool?
    let portEncryptionStatus: Swift.String?
    let encryptionMode: Swift.String?
    let macSecKeys: [DirectConnectClientTypes.MacSecKey]?
}

extension AssociateConnectionWithLagOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsDevice
        case awsDeviceV2
        case awsLogicalDeviceId
        case bandwidth
        case connectionId
        case connectionName
        case connectionState
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case macSecCapable
        case macSecKeys
        case ownerAccount
        case partnerName
        case portEncryptionStatus
        case providerName
        case region
        case tags
        case vlan
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
        let loaIssueTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let portEncryptionStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portEncryptionStatus)
        portEncryptionStatus = portEncryptionStatusDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[DirectConnectClientTypes.MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [DirectConnectClientTypes.MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

extension AssociateHostedConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case parentConnectionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let parentConnectionId = self.parentConnectionId {
            try encodeContainer.encode(parentConnectionId, forKey: .parentConnectionId)
        }
    }
}

extension AssociateHostedConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateHostedConnectionInput: Swift.Equatable {
    /// The ID of the hosted connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The ID of the interconnect or the LAG.
    /// This member is required.
    public var parentConnectionId: Swift.String?

    public init (
        connectionId: Swift.String? = nil,
        parentConnectionId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.parentConnectionId = parentConnectionId
    }
}

struct AssociateHostedConnectionInputBody: Swift.Equatable {
    let connectionId: Swift.String?
    let parentConnectionId: Swift.String?
}

extension AssociateHostedConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case parentConnectionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let parentConnectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentConnectionId)
        parentConnectionId = parentConnectionIdDecoded
    }
}

extension AssociateHostedConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateHostedConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateHostedConnectionOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateHostedConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateHostedConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.awsLogicalDeviceId = output.awsLogicalDeviceId
            self.bandwidth = output.bandwidth
            self.connectionId = output.connectionId
            self.connectionName = output.connectionName
            self.connectionState = output.connectionState
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.loaIssueTime = output.loaIssueTime
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.ownerAccount = output.ownerAccount
            self.partnerName = output.partnerName
            self.portEncryptionStatus = output.portEncryptionStatus
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
            self.vlan = output.vlan
        } else {
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.awsLogicalDeviceId = nil
            self.bandwidth = nil
            self.connectionId = nil
            self.connectionName = nil
            self.connectionState = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.loaIssueTime = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.ownerAccount = nil
            self.partnerName = nil
            self.portEncryptionStatus = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
            self.vlan = 0
        }
    }
}

/// Information about an Direct Connect connection.
public struct AssociateHostedConnectionOutputResponse: Swift.Equatable {
    /// The Direct Connect endpoint on which the physical connection terminates.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The bandwidth of the connection.
    public var bandwidth: Swift.String?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The name of the connection.
    public var connectionName: Swift.String?
    /// The state of the connection. The following are the possible values:
    ///
    /// * ordering: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.
    ///
    /// * requested: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The connection has been approved and is being initialized.
    ///
    /// * available: The network link is up and the connection is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The connection is being deleted.
    ///
    /// * deleted: The connection has been deleted.
    ///
    /// * rejected: A hosted connection in the ordering state enters the rejected state if it is deleted by the customer.
    ///
    /// * unknown: The state of the connection is not available.
    public var connectionState: DirectConnectClientTypes.ConnectionState?
    /// The MAC Security (MACsec) connection encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames (9001 MTU) are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The time of the most recent call to [DescribeLoa] for this connection.
    public var loaIssueTime: ClientRuntime.Date?
    /// The location of the connection.
    public var location: Swift.String?
    /// Indicates whether the connection supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the connection.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The ID of the Amazon Web Services account that owns the connection.
    public var ownerAccount: Swift.String?
    /// The name of the Direct Connect service provider associated with the connection.
    public var partnerName: Swift.String?
    /// The MAC Security (MACsec) port link status of the connection. The valid values are Encryption Up, which means that there is an active Connection Key Name, or Encryption Down.
    public var portEncryptionStatus: Swift.String?
    /// The name of the service provider associated with the connection.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the connection.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init (
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bandwidth: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        connectionState: DirectConnectClientTypes.ConnectionState? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        loaIssueTime: ClientRuntime.Date? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        ownerAccount: Swift.String? = nil,
        partnerName: Swift.String? = nil,
        portEncryptionStatus: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

struct AssociateHostedConnectionOutputResponseBody: Swift.Equatable {
    let ownerAccount: Swift.String?
    let connectionId: Swift.String?
    let connectionName: Swift.String?
    let connectionState: DirectConnectClientTypes.ConnectionState?
    let region: Swift.String?
    let location: Swift.String?
    let bandwidth: Swift.String?
    let vlan: Swift.Int
    let partnerName: Swift.String?
    let loaIssueTime: ClientRuntime.Date?
    let lagId: Swift.String?
    let awsDevice: Swift.String?
    let jumboFrameCapable: Swift.Bool?
    let awsDeviceV2: Swift.String?
    let awsLogicalDeviceId: Swift.String?
    let hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    let tags: [DirectConnectClientTypes.Tag]?
    let providerName: Swift.String?
    let macSecCapable: Swift.Bool?
    let portEncryptionStatus: Swift.String?
    let encryptionMode: Swift.String?
    let macSecKeys: [DirectConnectClientTypes.MacSecKey]?
}

extension AssociateHostedConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsDevice
        case awsDeviceV2
        case awsLogicalDeviceId
        case bandwidth
        case connectionId
        case connectionName
        case connectionState
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case macSecCapable
        case macSecKeys
        case ownerAccount
        case partnerName
        case portEncryptionStatus
        case providerName
        case region
        case tags
        case vlan
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
        let loaIssueTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let portEncryptionStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portEncryptionStatus)
        portEncryptionStatus = portEncryptionStatusDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[DirectConnectClientTypes.MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [DirectConnectClientTypes.MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

extension AssociateMacSecKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cak
        case ckn
        case connectionId
        case secretARN
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cak = self.cak {
            try encodeContainer.encode(cak, forKey: .cak)
        }
        if let ckn = self.ckn {
            try encodeContainer.encode(ckn, forKey: .ckn)
        }
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let secretARN = self.secretARN {
            try encodeContainer.encode(secretARN, forKey: .secretARN)
        }
    }
}

extension AssociateMacSecKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateMacSecKeyInput: Swift.Equatable {
    /// The MAC Security (MACsec) CAK to associate with the dedicated connection. You can create the CKN/CAK pair using an industry standard tool. The valid values are 64 hexadecimal characters (0-9, A-E). If you use this request parameter, you must use the ckn request parameter and not use the secretARN request parameter.
    public var cak: Swift.String?
    /// The MAC Security (MACsec) CKN to associate with the dedicated connection. You can create the CKN/CAK pair using an industry standard tool. The valid values are 64 hexadecimal characters (0-9, A-E). If you use this request parameter, you must use the cak request parameter and not use the secretARN request parameter.
    public var ckn: Swift.String?
    /// The ID of the dedicated connection (dxcon-xxxx), or the ID of the LAG (dxlag-xxxx). You can use [DescribeConnections] or [DescribeLags] to retrieve connection ID.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the MAC Security (MACsec) secret key to associate with the dedicated connection. You can use [DescribeConnections] or [DescribeLags] to retrieve the MAC Security (MACsec) secret key. If you use this request parameter, you do not use the ckn and cak request parameters.
    public var secretARN: Swift.String?

    public init (
        cak: Swift.String? = nil,
        ckn: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        secretARN: Swift.String? = nil
    )
    {
        self.cak = cak
        self.ckn = ckn
        self.connectionId = connectionId
        self.secretARN = secretARN
    }
}

struct AssociateMacSecKeyInputBody: Swift.Equatable {
    let connectionId: Swift.String?
    let secretARN: Swift.String?
    let ckn: Swift.String?
    let cak: Swift.String?
}

extension AssociateMacSecKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cak
        case ckn
        case connectionId
        case secretARN
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let secretARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretARN)
        secretARN = secretARNDecoded
        let cknDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ckn)
        ckn = cknDecoded
        let cakDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cak)
        cak = cakDecoded
    }
}

extension AssociateMacSecKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateMacSecKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateMacSecKeyOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateMacSecKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateMacSecKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionId = output.connectionId
            self.macSecKeys = output.macSecKeys
        } else {
            self.connectionId = nil
            self.macSecKeys = nil
        }
    }
}

public struct AssociateMacSecKeyOutputResponse: Swift.Equatable {
    /// The ID of the dedicated connection (dxcon-xxxx), or the ID of the LAG (dxlag-xxxx).
    public var connectionId: Swift.String?
    /// The MAC Security (MACsec) security keys associated with the dedicated connection.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?

    public init (
        connectionId: Swift.String? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil
    )
    {
        self.connectionId = connectionId
        self.macSecKeys = macSecKeys
    }
}

struct AssociateMacSecKeyOutputResponseBody: Swift.Equatable {
    let connectionId: Swift.String?
    let macSecKeys: [DirectConnectClientTypes.MacSecKey]?
}

extension AssociateMacSecKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case macSecKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[DirectConnectClientTypes.MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [DirectConnectClientTypes.MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

extension AssociateVirtualInterfaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case virtualInterfaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let virtualInterfaceId = self.virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

extension AssociateVirtualInterfaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateVirtualInterfaceInput: Swift.Equatable {
    /// The ID of the LAG or connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The ID of the virtual interface.
    /// This member is required.
    public var virtualInterfaceId: Swift.String?

    public init (
        connectionId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct AssociateVirtualInterfaceInputBody: Swift.Equatable {
    let virtualInterfaceId: Swift.String?
    let connectionId: Swift.String?
}

extension AssociateVirtualInterfaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case virtualInterfaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
    }
}

extension AssociateVirtualInterfaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateVirtualInterfaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateVirtualInterfaceOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateVirtualInterfaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addressFamily = output.addressFamily
            self.amazonAddress = output.amazonAddress
            self.amazonSideAsn = output.amazonSideAsn
            self.asn = output.asn
            self.authKey = output.authKey
            self.awsDeviceV2 = output.awsDeviceV2
            self.awsLogicalDeviceId = output.awsLogicalDeviceId
            self.bgpPeers = output.bgpPeers
            self.connectionId = output.connectionId
            self.customerAddress = output.customerAddress
            self.customerRouterConfig = output.customerRouterConfig
            self.directConnectGatewayId = output.directConnectGatewayId
            self.jumboFrameCapable = output.jumboFrameCapable
            self.location = output.location
            self.mtu = output.mtu
            self.ownerAccount = output.ownerAccount
            self.region = output.region
            self.routeFilterPrefixes = output.routeFilterPrefixes
            self.siteLinkEnabled = output.siteLinkEnabled
            self.tags = output.tags
            self.virtualGatewayId = output.virtualGatewayId
            self.virtualInterfaceId = output.virtualInterfaceId
            self.virtualInterfaceName = output.virtualInterfaceName
            self.virtualInterfaceState = output.virtualInterfaceState
            self.virtualInterfaceType = output.virtualInterfaceType
            self.vlan = output.vlan
        } else {
            self.addressFamily = nil
            self.amazonAddress = nil
            self.amazonSideAsn = nil
            self.asn = 0
            self.authKey = nil
            self.awsDeviceV2 = nil
            self.awsLogicalDeviceId = nil
            self.bgpPeers = nil
            self.connectionId = nil
            self.customerAddress = nil
            self.customerRouterConfig = nil
            self.directConnectGatewayId = nil
            self.jumboFrameCapable = nil
            self.location = nil
            self.mtu = nil
            self.ownerAccount = nil
            self.region = nil
            self.routeFilterPrefixes = nil
            self.siteLinkEnabled = nil
            self.tags = nil
            self.virtualGatewayId = nil
            self.virtualInterfaceId = nil
            self.virtualInterfaceName = nil
            self.virtualInterfaceState = nil
            self.virtualInterfaceType = nil
            self.vlan = 0
        }
    }
}

/// Information about a virtual interface.
public struct AssociateVirtualInterfaceOutputResponse: Swift.Equatable {
    /// The address family for the BGP peer.
    public var addressFamily: DirectConnectClientTypes.AddressFamily?
    /// The IP address assigned to the Amazon interface.
    public var amazonAddress: Swift.String?
    /// The autonomous system number (ASN) for the Amazon side of the connection.
    public var amazonSideAsn: Swift.Int?
    /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
    public var asn: Swift.Int
    /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
    public var authKey: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The BGP peers configured on this virtual interface.
    public var bgpPeers: [DirectConnectClientTypes.BGPPeer]?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The IP address assigned to the customer interface.
    public var customerAddress: Swift.String?
    /// The customer router configuration.
    public var customerRouterConfig: Swift.String?
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// Indicates whether jumbo frames (9001 MTU) are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The location of the connection.
    public var location: Swift.String?
    /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.
    public var mtu: Swift.Int?
    /// The ID of the Amazon Web Services account that owns the virtual interface.
    public var ownerAccount: Swift.String?
    /// The Amazon Web Services Region where the virtual interface is located.
    public var region: Swift.String?
    /// The routes to be advertised to the Amazon Web Services network in this Region. Applies to public virtual interfaces.
    public var routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
    /// Indicates whether SiteLink is enabled.
    public var siteLinkEnabled: Swift.Bool?
    /// The tags associated with the virtual interface.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the virtual private gateway. Applies only to private virtual interfaces.
    public var virtualGatewayId: Swift.String?
    /// The ID of the virtual interface.
    public var virtualInterfaceId: Swift.String?
    /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
    public var virtualInterfaceName: Swift.String?
    /// The state of the virtual interface. The following are the possible values:
    ///
    /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
    ///
    /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
    ///
    /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
    ///
    /// * available: A virtual interface that is able to forward traffic.
    ///
    /// * down: A virtual interface that is BGP down.
    ///
    /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
    ///
    /// * deleted: A virtual interface that cannot forward traffic.
    ///
    /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
    ///
    /// * unknown: The state of the virtual interface is not available.
    public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
    /// The type of virtual interface. The possible values are private and public.
    public var virtualInterfaceType: Swift.String?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init (
        addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
        amazonAddress: Swift.String? = nil,
        amazonSideAsn: Swift.Int? = nil,
        asn: Swift.Int = 0,
        authKey: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bgpPeers: [DirectConnectClientTypes.BGPPeer]? = nil,
        connectionId: Swift.String? = nil,
        customerAddress: Swift.String? = nil,
        customerRouterConfig: Swift.String? = nil,
        directConnectGatewayId: Swift.String? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        location: Swift.String? = nil,
        mtu: Swift.Int? = nil,
        ownerAccount: Swift.String? = nil,
        region: Swift.String? = nil,
        routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
        siteLinkEnabled: Swift.Bool? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        virtualGatewayId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil,
        virtualInterfaceName: Swift.String? = nil,
        virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil,
        virtualInterfaceType: Swift.String? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.amazonSideAsn = amazonSideAsn
        self.asn = asn
        self.authKey = authKey
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bgpPeers = bgpPeers
        self.connectionId = connectionId
        self.customerAddress = customerAddress
        self.customerRouterConfig = customerRouterConfig
        self.directConnectGatewayId = directConnectGatewayId
        self.jumboFrameCapable = jumboFrameCapable
        self.location = location
        self.mtu = mtu
        self.ownerAccount = ownerAccount
        self.region = region
        self.routeFilterPrefixes = routeFilterPrefixes
        self.siteLinkEnabled = siteLinkEnabled
        self.tags = tags
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
        self.virtualInterfaceState = virtualInterfaceState
        self.virtualInterfaceType = virtualInterfaceType
        self.vlan = vlan
    }
}

struct AssociateVirtualInterfaceOutputResponseBody: Swift.Equatable {
    let ownerAccount: Swift.String?
    let virtualInterfaceId: Swift.String?
    let location: Swift.String?
    let connectionId: Swift.String?
    let virtualInterfaceType: Swift.String?
    let virtualInterfaceName: Swift.String?
    let vlan: Swift.Int
    let asn: Swift.Int
    let amazonSideAsn: Swift.Int?
    let authKey: Swift.String?
    let amazonAddress: Swift.String?
    let customerAddress: Swift.String?
    let addressFamily: DirectConnectClientTypes.AddressFamily?
    let virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
    let customerRouterConfig: Swift.String?
    let mtu: Swift.Int?
    let jumboFrameCapable: Swift.Bool?
    let virtualGatewayId: Swift.String?
    let directConnectGatewayId: Swift.String?
    let routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
    let bgpPeers: [DirectConnectClientTypes.BGPPeer]?
    let region: Swift.String?
    let awsDeviceV2: Swift.String?
    let awsLogicalDeviceId: Swift.String?
    let tags: [DirectConnectClientTypes.Tag]?
    let siteLinkEnabled: Swift.Bool?
}

extension AssociateVirtualInterfaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressFamily
        case amazonAddress
        case amazonSideAsn
        case asn
        case authKey
        case awsDeviceV2
        case awsLogicalDeviceId
        case bgpPeers
        case connectionId
        case customerAddress
        case customerRouterConfig
        case directConnectGatewayId
        case jumboFrameCapable
        case location
        case mtu
        case ownerAccount
        case region
        case routeFilterPrefixes
        case siteLinkEnabled
        case tags
        case virtualGatewayId
        case virtualInterfaceId
        case virtualInterfaceName
        case virtualInterfaceState
        case virtualInterfaceType
        case vlan
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let virtualInterfaceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceType)
        virtualInterfaceType = virtualInterfaceTypeDecoded
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn) ?? 0
        asn = asnDecoded
        let amazonSideAsnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .amazonSideAsn)
        amazonSideAsn = amazonSideAsnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
        let customerRouterConfigDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerRouterConfig)
        customerRouterConfig = customerRouterConfigDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let routeFilterPrefixesContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.RouteFilterPrefix?].self, forKey: .routeFilterPrefixes)
        var routeFilterPrefixesDecoded0:[DirectConnectClientTypes.RouteFilterPrefix]? = nil
        if let routeFilterPrefixesContainer = routeFilterPrefixesContainer {
            routeFilterPrefixesDecoded0 = [DirectConnectClientTypes.RouteFilterPrefix]()
            for structure0 in routeFilterPrefixesContainer {
                if let structure0 = structure0 {
                    routeFilterPrefixesDecoded0?.append(structure0)
                }
            }
        }
        routeFilterPrefixes = routeFilterPrefixesDecoded0
        let bgpPeersContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.BGPPeer?].self, forKey: .bgpPeers)
        var bgpPeersDecoded0:[DirectConnectClientTypes.BGPPeer]? = nil
        if let bgpPeersContainer = bgpPeersContainer {
            bgpPeersDecoded0 = [DirectConnectClientTypes.BGPPeer]()
            for structure0 in bgpPeersContainer {
                if let structure0 = structure0 {
                    bgpPeersDecoded0?.append(structure0)
                }
            }
        }
        bgpPeers = bgpPeersDecoded0
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let siteLinkEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .siteLinkEnabled)
        siteLinkEnabled = siteLinkEnabledDecoded
    }
}

extension DirectConnectClientTypes.AssociatedGateway: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case ownerAccount
        case region
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.GatewayType.self, forKey: .type)
        type = typeDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
    }
}

extension DirectConnectClientTypes {
    /// Information about the associated gateway.
    public struct AssociatedGateway: Swift.Equatable {
        /// The ID of the associated gateway.
        public var id: Swift.String?
        /// The ID of the Amazon Web Services account that owns the associated virtual private gateway or transit gateway.
        public var ownerAccount: Swift.String?
        /// The Region where the associated gateway is located.
        public var region: Swift.String?
        /// The type of associated gateway.
        public var type: DirectConnectClientTypes.GatewayType?

        public init (
            id: Swift.String? = nil,
            ownerAccount: Swift.String? = nil,
            region: Swift.String? = nil,
            type: DirectConnectClientTypes.GatewayType? = nil
        )
        {
            self.id = id
            self.ownerAccount = ownerAccount
            self.region = region
            self.type = type
        }
    }

}

extension DirectConnectClientTypes.BGPPeer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressFamily
        case amazonAddress
        case asn
        case authKey
        case awsDeviceV2
        case awsLogicalDeviceId
        case bgpPeerId
        case bgpPeerState
        case bgpStatus
        case customerAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressFamily = self.addressFamily {
            try encodeContainer.encode(addressFamily.rawValue, forKey: .addressFamily)
        }
        if let amazonAddress = self.amazonAddress {
            try encodeContainer.encode(amazonAddress, forKey: .amazonAddress)
        }
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let authKey = self.authKey {
            try encodeContainer.encode(authKey, forKey: .authKey)
        }
        if let awsDeviceV2 = self.awsDeviceV2 {
            try encodeContainer.encode(awsDeviceV2, forKey: .awsDeviceV2)
        }
        if let awsLogicalDeviceId = self.awsLogicalDeviceId {
            try encodeContainer.encode(awsLogicalDeviceId, forKey: .awsLogicalDeviceId)
        }
        if let bgpPeerId = self.bgpPeerId {
            try encodeContainer.encode(bgpPeerId, forKey: .bgpPeerId)
        }
        if let bgpPeerState = self.bgpPeerState {
            try encodeContainer.encode(bgpPeerState.rawValue, forKey: .bgpPeerState)
        }
        if let bgpStatus = self.bgpStatus {
            try encodeContainer.encode(bgpStatus.rawValue, forKey: .bgpStatus)
        }
        if let customerAddress = self.customerAddress {
            try encodeContainer.encode(customerAddress, forKey: .customerAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bgpPeerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bgpPeerId)
        bgpPeerId = bgpPeerIdDecoded
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn) ?? 0
        asn = asnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let bgpPeerStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.BGPPeerState.self, forKey: .bgpPeerState)
        bgpPeerState = bgpPeerStateDecoded
        let bgpStatusDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.BGPStatus.self, forKey: .bgpStatus)
        bgpStatus = bgpStatusDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
    }
}

extension DirectConnectClientTypes {
    /// Information about a BGP peer.
    public struct BGPPeer: Swift.Equatable {
        /// The address family for the BGP peer.
        public var addressFamily: DirectConnectClientTypes.AddressFamily?
        /// The IP address assigned to the Amazon interface.
        public var amazonAddress: Swift.String?
        /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.
        public var asn: Swift.Int
        /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
        public var authKey: Swift.String?
        /// The Direct Connect endpoint that terminates the BGP peer.
        public var awsDeviceV2: Swift.String?
        /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
        public var awsLogicalDeviceId: Swift.String?
        /// The ID of the BGP peer.
        public var bgpPeerId: Swift.String?
        /// The state of the BGP peer. The following are the possible values:
        ///
        /// * verifying: The BGP peering addresses or ASN require validation before the BGP peer can be created. This state applies only to public virtual interfaces.
        ///
        /// * pending: The BGP peer is created, and remains in this state until it is ready to be established.
        ///
        /// * available: The BGP peer is ready to be established.
        ///
        /// * deleting: The BGP peer is being deleted.
        ///
        /// * deleted: The BGP peer is deleted and cannot be established.
        public var bgpPeerState: DirectConnectClientTypes.BGPPeerState?
        /// The status of the BGP peer. The following are the possible values:
        ///
        /// * up: The BGP peer is established. This state does not indicate the state of the routing function. Ensure that you are receiving routes over the BGP session.
        ///
        /// * down: The BGP peer is down.
        ///
        /// * unknown: The BGP peer status is not available.
        public var bgpStatus: DirectConnectClientTypes.BGPStatus?
        /// The IP address assigned to the customer interface.
        public var customerAddress: Swift.String?

        public init (
            addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
            amazonAddress: Swift.String? = nil,
            asn: Swift.Int = 0,
            authKey: Swift.String? = nil,
            awsDeviceV2: Swift.String? = nil,
            awsLogicalDeviceId: Swift.String? = nil,
            bgpPeerId: Swift.String? = nil,
            bgpPeerState: DirectConnectClientTypes.BGPPeerState? = nil,
            bgpStatus: DirectConnectClientTypes.BGPStatus? = nil,
            customerAddress: Swift.String? = nil
        )
        {
            self.addressFamily = addressFamily
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.authKey = authKey
            self.awsDeviceV2 = awsDeviceV2
            self.awsLogicalDeviceId = awsLogicalDeviceId
            self.bgpPeerId = bgpPeerId
            self.bgpPeerState = bgpPeerState
            self.bgpStatus = bgpStatus
            self.customerAddress = customerAddress
        }
    }

}

extension DirectConnectClientTypes {
    public enum BGPPeerState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case pending
        case verifying
        case sdkUnknown(Swift.String)

        public static var allCases: [BGPPeerState] {
            return [
                .available,
                .deleted,
                .deleting,
                .pending,
                .verifying,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .deleted: return "deleted"
            case .deleting: return "deleting"
            case .pending: return "pending"
            case .verifying: return "verifying"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BGPPeerState(rawValue: rawValue) ?? BGPPeerState.sdkUnknown(rawValue)
        }
    }
}

extension DirectConnectClientTypes {
    public enum BGPStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case down
        case unknown
        case up
        case sdkUnknown(Swift.String)

        public static var allCases: [BGPStatus] {
            return [
                .down,
                .unknown,
                .up,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .down: return "down"
            case .unknown: return "unknown"
            case .up: return "up"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BGPStatus(rawValue: rawValue) ?? BGPStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConfirmConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
    }
}

extension ConfirmConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ConfirmConnectionInput: Swift.Equatable {
    /// The ID of the hosted connection.
    /// This member is required.
    public var connectionId: Swift.String?

    public init (
        connectionId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

struct ConfirmConnectionInputBody: Swift.Equatable {
    let connectionId: Swift.String?
}

extension ConfirmConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
    }
}

extension ConfirmConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfirmConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ConfirmConnectionOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfirmConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConfirmConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionState = output.connectionState
        } else {
            self.connectionState = nil
        }
    }
}

public struct ConfirmConnectionOutputResponse: Swift.Equatable {
    /// The state of the connection. The following are the possible values:
    ///
    /// * ordering: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.
    ///
    /// * requested: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The connection has been approved and is being initialized.
    ///
    /// * available: The network link is up and the connection is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The connection is being deleted.
    ///
    /// * deleted: The connection has been deleted.
    ///
    /// * rejected: A hosted connection in the ordering state enters the rejected state if it is deleted by the customer.
    ///
    /// * unknown: The state of the connection is not available.
    public var connectionState: DirectConnectClientTypes.ConnectionState?

    public init (
        connectionState: DirectConnectClientTypes.ConnectionState? = nil
    )
    {
        self.connectionState = connectionState
    }
}

struct ConfirmConnectionOutputResponseBody: Swift.Equatable {
    let connectionState: DirectConnectClientTypes.ConnectionState?
}

extension ConfirmConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
    }
}

extension ConfirmCustomerAgreementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agreementName = self.agreementName {
            try encodeContainer.encode(agreementName, forKey: .agreementName)
        }
    }
}

extension ConfirmCustomerAgreementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ConfirmCustomerAgreementInput: Swift.Equatable {
    /// The name of the customer agreement.
    public var agreementName: Swift.String?

    public init (
        agreementName: Swift.String? = nil
    )
    {
        self.agreementName = agreementName
    }
}

struct ConfirmCustomerAgreementInputBody: Swift.Equatable {
    let agreementName: Swift.String?
}

extension ConfirmCustomerAgreementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agreementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementName)
        agreementName = agreementNameDecoded
    }
}

extension ConfirmCustomerAgreementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfirmCustomerAgreementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ConfirmCustomerAgreementOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfirmCustomerAgreementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConfirmCustomerAgreementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct ConfirmCustomerAgreementOutputResponse: Swift.Equatable {
    /// The status of the customer agreement when the connection was created. This will be either signed or unsigned.
    public var status: Swift.String?

    public init (
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct ConfirmCustomerAgreementOutputResponseBody: Swift.Equatable {
    let status: Swift.String?
}

extension ConfirmCustomerAgreementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension ConfirmPrivateVirtualInterfaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayId
        case virtualGatewayId
        case virtualInterfaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directConnectGatewayId = self.directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let virtualGatewayId = self.virtualGatewayId {
            try encodeContainer.encode(virtualGatewayId, forKey: .virtualGatewayId)
        }
        if let virtualInterfaceId = self.virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

extension ConfirmPrivateVirtualInterfaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ConfirmPrivateVirtualInterfaceInput: Swift.Equatable {
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// The ID of the virtual private gateway.
    public var virtualGatewayId: Swift.String?
    /// The ID of the virtual interface.
    /// This member is required.
    public var virtualInterfaceId: Swift.String?

    public init (
        directConnectGatewayId: Swift.String? = nil,
        virtualGatewayId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.directConnectGatewayId = directConnectGatewayId
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct ConfirmPrivateVirtualInterfaceInputBody: Swift.Equatable {
    let virtualInterfaceId: Swift.String?
    let virtualGatewayId: Swift.String?
    let directConnectGatewayId: Swift.String?
}

extension ConfirmPrivateVirtualInterfaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayId
        case virtualGatewayId
        case virtualInterfaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
    }
}

extension ConfirmPrivateVirtualInterfaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfirmPrivateVirtualInterfaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ConfirmPrivateVirtualInterfaceOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfirmPrivateVirtualInterfaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConfirmPrivateVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterfaceState = output.virtualInterfaceState
        } else {
            self.virtualInterfaceState = nil
        }
    }
}

public struct ConfirmPrivateVirtualInterfaceOutputResponse: Swift.Equatable {
    /// The state of the virtual interface. The following are the possible values:
    ///
    /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
    ///
    /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
    ///
    /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
    ///
    /// * available: A virtual interface that is able to forward traffic.
    ///
    /// * down: A virtual interface that is BGP down.
    ///
    /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
    ///
    /// * deleted: A virtual interface that cannot forward traffic.
    ///
    /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
    ///
    /// * unknown: The state of the virtual interface is not available.
    public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?

    public init (
        virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil
    )
    {
        self.virtualInterfaceState = virtualInterfaceState
    }
}

struct ConfirmPrivateVirtualInterfaceOutputResponseBody: Swift.Equatable {
    let virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
}

extension ConfirmPrivateVirtualInterfaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualInterfaceState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
    }
}

extension ConfirmPublicVirtualInterfaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualInterfaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let virtualInterfaceId = self.virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

extension ConfirmPublicVirtualInterfaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ConfirmPublicVirtualInterfaceInput: Swift.Equatable {
    /// The ID of the virtual interface.
    /// This member is required.
    public var virtualInterfaceId: Swift.String?

    public init (
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct ConfirmPublicVirtualInterfaceInputBody: Swift.Equatable {
    let virtualInterfaceId: Swift.String?
}

extension ConfirmPublicVirtualInterfaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualInterfaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
    }
}

extension ConfirmPublicVirtualInterfaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfirmPublicVirtualInterfaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ConfirmPublicVirtualInterfaceOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfirmPublicVirtualInterfaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConfirmPublicVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterfaceState = output.virtualInterfaceState
        } else {
            self.virtualInterfaceState = nil
        }
    }
}

public struct ConfirmPublicVirtualInterfaceOutputResponse: Swift.Equatable {
    /// The state of the virtual interface. The following are the possible values:
    ///
    /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
    ///
    /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
    ///
    /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
    ///
    /// * available: A virtual interface that is able to forward traffic.
    ///
    /// * down: A virtual interface that is BGP down.
    ///
    /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
    ///
    /// * deleted: A virtual interface that cannot forward traffic.
    ///
    /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
    ///
    /// * unknown: The state of the virtual interface is not available.
    public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?

    public init (
        virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil
    )
    {
        self.virtualInterfaceState = virtualInterfaceState
    }
}

struct ConfirmPublicVirtualInterfaceOutputResponseBody: Swift.Equatable {
    let virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
}

extension ConfirmPublicVirtualInterfaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualInterfaceState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
    }
}

extension ConfirmTransitVirtualInterfaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayId
        case virtualInterfaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directConnectGatewayId = self.directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let virtualInterfaceId = self.virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

extension ConfirmTransitVirtualInterfaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ConfirmTransitVirtualInterfaceInput: Swift.Equatable {
    /// The ID of the Direct Connect gateway.
    /// This member is required.
    public var directConnectGatewayId: Swift.String?
    /// The ID of the virtual interface.
    /// This member is required.
    public var virtualInterfaceId: Swift.String?

    public init (
        directConnectGatewayId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.directConnectGatewayId = directConnectGatewayId
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct ConfirmTransitVirtualInterfaceInputBody: Swift.Equatable {
    let virtualInterfaceId: Swift.String?
    let directConnectGatewayId: Swift.String?
}

extension ConfirmTransitVirtualInterfaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayId
        case virtualInterfaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
    }
}

extension ConfirmTransitVirtualInterfaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfirmTransitVirtualInterfaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ConfirmTransitVirtualInterfaceOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfirmTransitVirtualInterfaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConfirmTransitVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterfaceState = output.virtualInterfaceState
        } else {
            self.virtualInterfaceState = nil
        }
    }
}

public struct ConfirmTransitVirtualInterfaceOutputResponse: Swift.Equatable {
    /// The state of the virtual interface. The following are the possible values:
    ///
    /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
    ///
    /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
    ///
    /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
    ///
    /// * available: A virtual interface that is able to forward traffic.
    ///
    /// * down: A virtual interface that is BGP down.
    ///
    /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
    ///
    /// * deleted: A virtual interface that cannot forward traffic.
    ///
    /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
    ///
    /// * unknown: The state of the virtual interface is not available.
    public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?

    public init (
        virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil
    )
    {
        self.virtualInterfaceState = virtualInterfaceState
    }
}

struct ConfirmTransitVirtualInterfaceOutputResponseBody: Swift.Equatable {
    let virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
}

extension ConfirmTransitVirtualInterfaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualInterfaceState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
    }
}

extension DirectConnectClientTypes.Connection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsDevice
        case awsDeviceV2
        case awsLogicalDeviceId
        case bandwidth
        case connectionId
        case connectionName
        case connectionState
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case macSecCapable
        case macSecKeys
        case ownerAccount
        case partnerName
        case portEncryptionStatus
        case providerName
        case region
        case tags
        case vlan
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsDevice = self.awsDevice {
            try encodeContainer.encode(awsDevice, forKey: .awsDevice)
        }
        if let awsDeviceV2 = self.awsDeviceV2 {
            try encodeContainer.encode(awsDeviceV2, forKey: .awsDeviceV2)
        }
        if let awsLogicalDeviceId = self.awsLogicalDeviceId {
            try encodeContainer.encode(awsLogicalDeviceId, forKey: .awsLogicalDeviceId)
        }
        if let bandwidth = self.bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionName = self.connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let connectionState = self.connectionState {
            try encodeContainer.encode(connectionState.rawValue, forKey: .connectionState)
        }
        if let encryptionMode = self.encryptionMode {
            try encodeContainer.encode(encryptionMode, forKey: .encryptionMode)
        }
        if let hasLogicalRedundancy = self.hasLogicalRedundancy {
            try encodeContainer.encode(hasLogicalRedundancy.rawValue, forKey: .hasLogicalRedundancy)
        }
        if let jumboFrameCapable = self.jumboFrameCapable {
            try encodeContainer.encode(jumboFrameCapable, forKey: .jumboFrameCapable)
        }
        if let lagId = self.lagId {
            try encodeContainer.encode(lagId, forKey: .lagId)
        }
        if let loaIssueTime = self.loaIssueTime {
            try encodeContainer.encodeTimestamp(loaIssueTime, format: .epochSeconds, forKey: .loaIssueTime)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let macSecCapable = self.macSecCapable {
            try encodeContainer.encode(macSecCapable, forKey: .macSecCapable)
        }
        if let macSecKeys = macSecKeys {
            var macSecKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .macSecKeys)
            for macseckey0 in macSecKeys {
                try macSecKeysContainer.encode(macseckey0)
            }
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let partnerName = self.partnerName {
            try encodeContainer.encode(partnerName, forKey: .partnerName)
        }
        if let portEncryptionStatus = self.portEncryptionStatus {
            try encodeContainer.encode(portEncryptionStatus, forKey: .portEncryptionStatus)
        }
        if let providerName = self.providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if vlan != 0 {
            try encodeContainer.encode(vlan, forKey: .vlan)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
        let loaIssueTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let portEncryptionStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portEncryptionStatus)
        portEncryptionStatus = portEncryptionStatusDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[DirectConnectClientTypes.MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [DirectConnectClientTypes.MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

extension DirectConnectClientTypes {
    /// Information about an Direct Connect connection.
    public struct Connection: Swift.Equatable {
        /// The Direct Connect endpoint on which the physical connection terminates.
        @available(*, deprecated)
        public var awsDevice: Swift.String?
        /// The Direct Connect endpoint that terminates the physical connection.
        public var awsDeviceV2: Swift.String?
        /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
        public var awsLogicalDeviceId: Swift.String?
        /// The bandwidth of the connection.
        public var bandwidth: Swift.String?
        /// The ID of the connection.
        public var connectionId: Swift.String?
        /// The name of the connection.
        public var connectionName: Swift.String?
        /// The state of the connection. The following are the possible values:
        ///
        /// * ordering: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.
        ///
        /// * requested: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
        ///
        /// * pending: The connection has been approved and is being initialized.
        ///
        /// * available: The network link is up and the connection is ready for use.
        ///
        /// * down: The network link is down.
        ///
        /// * deleting: The connection is being deleted.
        ///
        /// * deleted: The connection has been deleted.
        ///
        /// * rejected: A hosted connection in the ordering state enters the rejected state if it is deleted by the customer.
        ///
        /// * unknown: The state of the connection is not available.
        public var connectionState: DirectConnectClientTypes.ConnectionState?
        /// The MAC Security (MACsec) connection encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
        public var encryptionMode: Swift.String?
        /// Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).
        public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
        /// Indicates whether jumbo frames (9001 MTU) are supported.
        public var jumboFrameCapable: Swift.Bool?
        /// The ID of the LAG.
        public var lagId: Swift.String?
        /// The time of the most recent call to [DescribeLoa] for this connection.
        public var loaIssueTime: ClientRuntime.Date?
        /// The location of the connection.
        public var location: Swift.String?
        /// Indicates whether the connection supports MAC Security (MACsec).
        public var macSecCapable: Swift.Bool?
        /// The MAC Security (MACsec) security keys associated with the connection.
        public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
        /// The ID of the Amazon Web Services account that owns the connection.
        public var ownerAccount: Swift.String?
        /// The name of the Direct Connect service provider associated with the connection.
        public var partnerName: Swift.String?
        /// The MAC Security (MACsec) port link status of the connection. The valid values are Encryption Up, which means that there is an active Connection Key Name, or Encryption Down.
        public var portEncryptionStatus: Swift.String?
        /// The name of the service provider associated with the connection.
        public var providerName: Swift.String?
        /// The Amazon Web Services Region where the connection is located.
        public var region: Swift.String?
        /// The tags associated with the connection.
        public var tags: [DirectConnectClientTypes.Tag]?
        /// The ID of the VLAN.
        public var vlan: Swift.Int

        public init (
            awsDevice: Swift.String? = nil,
            awsDeviceV2: Swift.String? = nil,
            awsLogicalDeviceId: Swift.String? = nil,
            bandwidth: Swift.String? = nil,
            connectionId: Swift.String? = nil,
            connectionName: Swift.String? = nil,
            connectionState: DirectConnectClientTypes.ConnectionState? = nil,
            encryptionMode: Swift.String? = nil,
            hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
            jumboFrameCapable: Swift.Bool? = nil,
            lagId: Swift.String? = nil,
            loaIssueTime: ClientRuntime.Date? = nil,
            location: Swift.String? = nil,
            macSecCapable: Swift.Bool? = nil,
            macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
            ownerAccount: Swift.String? = nil,
            partnerName: Swift.String? = nil,
            portEncryptionStatus: Swift.String? = nil,
            providerName: Swift.String? = nil,
            region: Swift.String? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil,
            vlan: Swift.Int = 0
        )
        {
            self.awsDevice = awsDevice
            self.awsDeviceV2 = awsDeviceV2
            self.awsLogicalDeviceId = awsLogicalDeviceId
            self.bandwidth = bandwidth
            self.connectionId = connectionId
            self.connectionName = connectionName
            self.connectionState = connectionState
            self.encryptionMode = encryptionMode
            self.hasLogicalRedundancy = hasLogicalRedundancy
            self.jumboFrameCapable = jumboFrameCapable
            self.lagId = lagId
            self.loaIssueTime = loaIssueTime
            self.location = location
            self.macSecCapable = macSecCapable
            self.macSecKeys = macSecKeys
            self.ownerAccount = ownerAccount
            self.partnerName = partnerName
            self.portEncryptionStatus = portEncryptionStatus
            self.providerName = providerName
            self.region = region
            self.tags = tags
            self.vlan = vlan
        }
    }

}

extension DirectConnectClientTypes {
    public enum ConnectionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case down
        case ordering
        case pending
        case rejected
        case requested
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionState] {
            return [
                .available,
                .deleted,
                .deleting,
                .down,
                .ordering,
                .pending,
                .rejected,
                .requested,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .deleted: return "deleted"
            case .deleting: return "deleting"
            case .down: return "down"
            case .ordering: return "ordering"
            case .pending: return "pending"
            case .rejected: return "rejected"
            case .requested: return "requested"
            case .unknown: return "unknown"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionState(rawValue: rawValue) ?? ConnectionState.sdkUnknown(rawValue)
        }
    }
}

extension CreateBGPPeerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newBGPPeer
        case virtualInterfaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let newBGPPeer = self.newBGPPeer {
            try encodeContainer.encode(newBGPPeer, forKey: .newBGPPeer)
        }
        if let virtualInterfaceId = self.virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

extension CreateBGPPeerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateBGPPeerInput: Swift.Equatable {
    /// Information about the BGP peer.
    public var newBGPPeer: DirectConnectClientTypes.NewBGPPeer?
    /// The ID of the virtual interface.
    public var virtualInterfaceId: Swift.String?

    public init (
        newBGPPeer: DirectConnectClientTypes.NewBGPPeer? = nil,
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.newBGPPeer = newBGPPeer
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct CreateBGPPeerInputBody: Swift.Equatable {
    let virtualInterfaceId: Swift.String?
    let newBGPPeer: DirectConnectClientTypes.NewBGPPeer?
}

extension CreateBGPPeerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newBGPPeer
        case virtualInterfaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let newBGPPeerDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.NewBGPPeer.self, forKey: .newBGPPeer)
        newBGPPeer = newBGPPeerDecoded
    }
}

extension CreateBGPPeerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBGPPeerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateBGPPeerOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBGPPeerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateBGPPeerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterface = output.virtualInterface
        } else {
            self.virtualInterface = nil
        }
    }
}

public struct CreateBGPPeerOutputResponse: Swift.Equatable {
    /// The virtual interface.
    public var virtualInterface: DirectConnectClientTypes.VirtualInterface?

    public init (
        virtualInterface: DirectConnectClientTypes.VirtualInterface? = nil
    )
    {
        self.virtualInterface = virtualInterface
    }
}

struct CreateBGPPeerOutputResponseBody: Swift.Equatable {
    let virtualInterface: DirectConnectClientTypes.VirtualInterface?
}

extension CreateBGPPeerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualInterface
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.VirtualInterface.self, forKey: .virtualInterface)
        virtualInterface = virtualInterfaceDecoded
    }
}

extension CreateConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth
        case connectionName
        case lagId
        case location
        case providerName
        case requestMACSec
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = self.bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let connectionName = self.connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let lagId = self.lagId {
            try encodeContainer.encode(lagId, forKey: .lagId)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let providerName = self.providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let requestMACSec = self.requestMACSec {
            try encodeContainer.encode(requestMACSec, forKey: .requestMACSec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateConnectionInput: Swift.Equatable {
    /// The bandwidth of the connection.
    /// This member is required.
    public var bandwidth: Swift.String?
    /// The name of the connection.
    /// This member is required.
    public var connectionName: Swift.String?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The location of the connection.
    /// This member is required.
    public var location: Swift.String?
    /// The name of the service provider associated with the requested connection.
    public var providerName: Swift.String?
    /// Indicates whether you want the connection to support MAC Security (MACsec). MAC Security (MACsec) is only available on dedicated connections. For information about MAC Security (MACsec) prerequisties, see [MACsec prerequisties](https://docs.aws.amazon.com/directconnect/latest/UserGuide/direct-connect-mac-sec-getting-started.html#mac-sec-prerequisites) in the Direct Connect User Guide.
    public var requestMACSec: Swift.Bool?
    /// The tags to associate with the lag.
    public var tags: [DirectConnectClientTypes.Tag]?

    public init (
        bandwidth: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        lagId: Swift.String? = nil,
        location: Swift.String? = nil,
        providerName: Swift.String? = nil,
        requestMACSec: Swift.Bool? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil
    )
    {
        self.bandwidth = bandwidth
        self.connectionName = connectionName
        self.lagId = lagId
        self.location = location
        self.providerName = providerName
        self.requestMACSec = requestMACSec
        self.tags = tags
    }
}

struct CreateConnectionInputBody: Swift.Equatable {
    let location: Swift.String?
    let bandwidth: Swift.String?
    let connectionName: Swift.String?
    let lagId: Swift.String?
    let tags: [DirectConnectClientTypes.Tag]?
    let providerName: Swift.String?
    let requestMACSec: Swift.Bool?
}

extension CreateConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth
        case connectionName
        case lagId
        case location
        case providerName
        case requestMACSec
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let requestMACSecDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requestMACSec)
        requestMACSec = requestMACSecDecoded
    }
}

extension CreateConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateConnectionOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.awsLogicalDeviceId = output.awsLogicalDeviceId
            self.bandwidth = output.bandwidth
            self.connectionId = output.connectionId
            self.connectionName = output.connectionName
            self.connectionState = output.connectionState
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.loaIssueTime = output.loaIssueTime
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.ownerAccount = output.ownerAccount
            self.partnerName = output.partnerName
            self.portEncryptionStatus = output.portEncryptionStatus
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
            self.vlan = output.vlan
        } else {
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.awsLogicalDeviceId = nil
            self.bandwidth = nil
            self.connectionId = nil
            self.connectionName = nil
            self.connectionState = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.loaIssueTime = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.ownerAccount = nil
            self.partnerName = nil
            self.portEncryptionStatus = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
            self.vlan = 0
        }
    }
}

/// Information about an Direct Connect connection.
public struct CreateConnectionOutputResponse: Swift.Equatable {
    /// The Direct Connect endpoint on which the physical connection terminates.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The bandwidth of the connection.
    public var bandwidth: Swift.String?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The name of the connection.
    public var connectionName: Swift.String?
    /// The state of the connection. The following are the possible values:
    ///
    /// * ordering: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.
    ///
    /// * requested: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The connection has been approved and is being initialized.
    ///
    /// * available: The network link is up and the connection is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The connection is being deleted.
    ///
    /// * deleted: The connection has been deleted.
    ///
    /// * rejected: A hosted connection in the ordering state enters the rejected state if it is deleted by the customer.
    ///
    /// * unknown: The state of the connection is not available.
    public var connectionState: DirectConnectClientTypes.ConnectionState?
    /// The MAC Security (MACsec) connection encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames (9001 MTU) are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The time of the most recent call to [DescribeLoa] for this connection.
    public var loaIssueTime: ClientRuntime.Date?
    /// The location of the connection.
    public var location: Swift.String?
    /// Indicates whether the connection supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the connection.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The ID of the Amazon Web Services account that owns the connection.
    public var ownerAccount: Swift.String?
    /// The name of the Direct Connect service provider associated with the connection.
    public var partnerName: Swift.String?
    /// The MAC Security (MACsec) port link status of the connection. The valid values are Encryption Up, which means that there is an active Connection Key Name, or Encryption Down.
    public var portEncryptionStatus: Swift.String?
    /// The name of the service provider associated with the connection.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the connection.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init (
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bandwidth: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        connectionState: DirectConnectClientTypes.ConnectionState? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        loaIssueTime: ClientRuntime.Date? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        ownerAccount: Swift.String? = nil,
        partnerName: Swift.String? = nil,
        portEncryptionStatus: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

struct CreateConnectionOutputResponseBody: Swift.Equatable {
    let ownerAccount: Swift.String?
    let connectionId: Swift.String?
    let connectionName: Swift.String?
    let connectionState: DirectConnectClientTypes.ConnectionState?
    let region: Swift.String?
    let location: Swift.String?
    let bandwidth: Swift.String?
    let vlan: Swift.Int
    let partnerName: Swift.String?
    let loaIssueTime: ClientRuntime.Date?
    let lagId: Swift.String?
    let awsDevice: Swift.String?
    let jumboFrameCapable: Swift.Bool?
    let awsDeviceV2: Swift.String?
    let awsLogicalDeviceId: Swift.String?
    let hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    let tags: [DirectConnectClientTypes.Tag]?
    let providerName: Swift.String?
    let macSecCapable: Swift.Bool?
    let portEncryptionStatus: Swift.String?
    let encryptionMode: Swift.String?
    let macSecKeys: [DirectConnectClientTypes.MacSecKey]?
}

extension CreateConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsDevice
        case awsDeviceV2
        case awsLogicalDeviceId
        case bandwidth
        case connectionId
        case connectionName
        case connectionState
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case macSecCapable
        case macSecKeys
        case ownerAccount
        case partnerName
        case portEncryptionStatus
        case providerName
        case region
        case tags
        case vlan
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
        let loaIssueTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let portEncryptionStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portEncryptionStatus)
        portEncryptionStatus = portEncryptionStatusDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[DirectConnectClientTypes.MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [DirectConnectClientTypes.MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

extension CreateDirectConnectGatewayAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addAllowedPrefixesToDirectConnectGateway
        case directConnectGatewayId
        case gatewayId
        case virtualGatewayId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGateway {
            var addAllowedPrefixesToDirectConnectGatewayContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addAllowedPrefixesToDirectConnectGateway)
            for routefilterprefix0 in addAllowedPrefixesToDirectConnectGateway {
                try addAllowedPrefixesToDirectConnectGatewayContainer.encode(routefilterprefix0)
            }
        }
        if let directConnectGatewayId = self.directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let gatewayId = self.gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let virtualGatewayId = self.virtualGatewayId {
            try encodeContainer.encode(virtualGatewayId, forKey: .virtualGatewayId)
        }
    }
}

extension CreateDirectConnectGatewayAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDirectConnectGatewayAssociationInput: Swift.Equatable {
    /// The Amazon VPC prefixes to advertise to the Direct Connect gateway This parameter is required when you create an association to a transit gateway. For information about how to set the prefixes, see [Allowed Prefixes](https://docs.aws.amazon.com/directconnect/latest/UserGuide/multi-account-associate-vgw.html#allowed-prefixes) in the Direct Connect User Guide.
    public var addAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?
    /// The ID of the Direct Connect gateway.
    /// This member is required.
    public var directConnectGatewayId: Swift.String?
    /// The ID of the virtual private gateway or transit gateway.
    public var gatewayId: Swift.String?
    /// The ID of the virtual private gateway.
    public var virtualGatewayId: Swift.String?

    public init (
        addAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
        directConnectGatewayId: Swift.String? = nil,
        gatewayId: Swift.String? = nil,
        virtualGatewayId: Swift.String? = nil
    )
    {
        self.addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGateway
        self.directConnectGatewayId = directConnectGatewayId
        self.gatewayId = gatewayId
        self.virtualGatewayId = virtualGatewayId
    }
}

struct CreateDirectConnectGatewayAssociationInputBody: Swift.Equatable {
    let directConnectGatewayId: Swift.String?
    let gatewayId: Swift.String?
    let addAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?
    let virtualGatewayId: Swift.String?
}

extension CreateDirectConnectGatewayAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addAllowedPrefixesToDirectConnectGateway
        case directConnectGatewayId
        case gatewayId
        case virtualGatewayId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let addAllowedPrefixesToDirectConnectGatewayContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.RouteFilterPrefix?].self, forKey: .addAllowedPrefixesToDirectConnectGateway)
        var addAllowedPrefixesToDirectConnectGatewayDecoded0:[DirectConnectClientTypes.RouteFilterPrefix]? = nil
        if let addAllowedPrefixesToDirectConnectGatewayContainer = addAllowedPrefixesToDirectConnectGatewayContainer {
            addAllowedPrefixesToDirectConnectGatewayDecoded0 = [DirectConnectClientTypes.RouteFilterPrefix]()
            for structure0 in addAllowedPrefixesToDirectConnectGatewayContainer {
                if let structure0 = structure0 {
                    addAllowedPrefixesToDirectConnectGatewayDecoded0?.append(structure0)
                }
            }
        }
        addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGatewayDecoded0
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
    }
}

extension CreateDirectConnectGatewayAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDirectConnectGatewayAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDirectConnectGatewayAssociationOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDirectConnectGatewayAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDirectConnectGatewayAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGatewayAssociation = output.directConnectGatewayAssociation
        } else {
            self.directConnectGatewayAssociation = nil
        }
    }
}

public struct CreateDirectConnectGatewayAssociationOutputResponse: Swift.Equatable {
    /// The association to be created.
    public var directConnectGatewayAssociation: DirectConnectClientTypes.DirectConnectGatewayAssociation?

    public init (
        directConnectGatewayAssociation: DirectConnectClientTypes.DirectConnectGatewayAssociation? = nil
    )
    {
        self.directConnectGatewayAssociation = directConnectGatewayAssociation
    }
}

struct CreateDirectConnectGatewayAssociationOutputResponseBody: Swift.Equatable {
    let directConnectGatewayAssociation: DirectConnectClientTypes.DirectConnectGatewayAssociation?
}

extension CreateDirectConnectGatewayAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayAssociation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayAssociationDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.DirectConnectGatewayAssociation.self, forKey: .directConnectGatewayAssociation)
        directConnectGatewayAssociation = directConnectGatewayAssociationDecoded
    }
}

extension CreateDirectConnectGatewayAssociationProposalInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addAllowedPrefixesToDirectConnectGateway
        case directConnectGatewayId
        case directConnectGatewayOwnerAccount
        case gatewayId
        case removeAllowedPrefixesToDirectConnectGateway
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGateway {
            var addAllowedPrefixesToDirectConnectGatewayContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addAllowedPrefixesToDirectConnectGateway)
            for routefilterprefix0 in addAllowedPrefixesToDirectConnectGateway {
                try addAllowedPrefixesToDirectConnectGatewayContainer.encode(routefilterprefix0)
            }
        }
        if let directConnectGatewayId = self.directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let directConnectGatewayOwnerAccount = self.directConnectGatewayOwnerAccount {
            try encodeContainer.encode(directConnectGatewayOwnerAccount, forKey: .directConnectGatewayOwnerAccount)
        }
        if let gatewayId = self.gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let removeAllowedPrefixesToDirectConnectGateway = removeAllowedPrefixesToDirectConnectGateway {
            var removeAllowedPrefixesToDirectConnectGatewayContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeAllowedPrefixesToDirectConnectGateway)
            for routefilterprefix0 in removeAllowedPrefixesToDirectConnectGateway {
                try removeAllowedPrefixesToDirectConnectGatewayContainer.encode(routefilterprefix0)
            }
        }
    }
}

extension CreateDirectConnectGatewayAssociationProposalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDirectConnectGatewayAssociationProposalInput: Swift.Equatable {
    /// The Amazon VPC prefixes to advertise to the Direct Connect gateway.
    public var addAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?
    /// The ID of the Direct Connect gateway.
    /// This member is required.
    public var directConnectGatewayId: Swift.String?
    /// The ID of the Amazon Web Services account that owns the Direct Connect gateway.
    /// This member is required.
    public var directConnectGatewayOwnerAccount: Swift.String?
    /// The ID of the virtual private gateway or transit gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The Amazon VPC prefixes to no longer advertise to the Direct Connect gateway.
    public var removeAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?

    public init (
        addAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
        directConnectGatewayId: Swift.String? = nil,
        directConnectGatewayOwnerAccount: Swift.String? = nil,
        gatewayId: Swift.String? = nil,
        removeAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]? = nil
    )
    {
        self.addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGateway
        self.directConnectGatewayId = directConnectGatewayId
        self.directConnectGatewayOwnerAccount = directConnectGatewayOwnerAccount
        self.gatewayId = gatewayId
        self.removeAllowedPrefixesToDirectConnectGateway = removeAllowedPrefixesToDirectConnectGateway
    }
}

struct CreateDirectConnectGatewayAssociationProposalInputBody: Swift.Equatable {
    let directConnectGatewayId: Swift.String?
    let directConnectGatewayOwnerAccount: Swift.String?
    let gatewayId: Swift.String?
    let addAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?
    let removeAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?
}

extension CreateDirectConnectGatewayAssociationProposalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addAllowedPrefixesToDirectConnectGateway
        case directConnectGatewayId
        case directConnectGatewayOwnerAccount
        case gatewayId
        case removeAllowedPrefixesToDirectConnectGateway
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let directConnectGatewayOwnerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayOwnerAccount)
        directConnectGatewayOwnerAccount = directConnectGatewayOwnerAccountDecoded
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let addAllowedPrefixesToDirectConnectGatewayContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.RouteFilterPrefix?].self, forKey: .addAllowedPrefixesToDirectConnectGateway)
        var addAllowedPrefixesToDirectConnectGatewayDecoded0:[DirectConnectClientTypes.RouteFilterPrefix]? = nil
        if let addAllowedPrefixesToDirectConnectGatewayContainer = addAllowedPrefixesToDirectConnectGatewayContainer {
            addAllowedPrefixesToDirectConnectGatewayDecoded0 = [DirectConnectClientTypes.RouteFilterPrefix]()
            for structure0 in addAllowedPrefixesToDirectConnectGatewayContainer {
                if let structure0 = structure0 {
                    addAllowedPrefixesToDirectConnectGatewayDecoded0?.append(structure0)
                }
            }
        }
        addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGatewayDecoded0
        let removeAllowedPrefixesToDirectConnectGatewayContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.RouteFilterPrefix?].self, forKey: .removeAllowedPrefixesToDirectConnectGateway)
        var removeAllowedPrefixesToDirectConnectGatewayDecoded0:[DirectConnectClientTypes.RouteFilterPrefix]? = nil
        if let removeAllowedPrefixesToDirectConnectGatewayContainer = removeAllowedPrefixesToDirectConnectGatewayContainer {
            removeAllowedPrefixesToDirectConnectGatewayDecoded0 = [DirectConnectClientTypes.RouteFilterPrefix]()
            for structure0 in removeAllowedPrefixesToDirectConnectGatewayContainer {
                if let structure0 = structure0 {
                    removeAllowedPrefixesToDirectConnectGatewayDecoded0?.append(structure0)
                }
            }
        }
        removeAllowedPrefixesToDirectConnectGateway = removeAllowedPrefixesToDirectConnectGatewayDecoded0
    }
}

extension CreateDirectConnectGatewayAssociationProposalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDirectConnectGatewayAssociationProposalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDirectConnectGatewayAssociationProposalOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDirectConnectGatewayAssociationProposalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDirectConnectGatewayAssociationProposalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGatewayAssociationProposal = output.directConnectGatewayAssociationProposal
        } else {
            self.directConnectGatewayAssociationProposal = nil
        }
    }
}

public struct CreateDirectConnectGatewayAssociationProposalOutputResponse: Swift.Equatable {
    /// Information about the Direct Connect gateway proposal.
    public var directConnectGatewayAssociationProposal: DirectConnectClientTypes.DirectConnectGatewayAssociationProposal?

    public init (
        directConnectGatewayAssociationProposal: DirectConnectClientTypes.DirectConnectGatewayAssociationProposal? = nil
    )
    {
        self.directConnectGatewayAssociationProposal = directConnectGatewayAssociationProposal
    }
}

struct CreateDirectConnectGatewayAssociationProposalOutputResponseBody: Swift.Equatable {
    let directConnectGatewayAssociationProposal: DirectConnectClientTypes.DirectConnectGatewayAssociationProposal?
}

extension CreateDirectConnectGatewayAssociationProposalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayAssociationProposal
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayAssociationProposalDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.DirectConnectGatewayAssociationProposal.self, forKey: .directConnectGatewayAssociationProposal)
        directConnectGatewayAssociationProposal = directConnectGatewayAssociationProposalDecoded
    }
}

extension CreateDirectConnectGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonSideAsn
        case directConnectGatewayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonSideAsn = self.amazonSideAsn {
            try encodeContainer.encode(amazonSideAsn, forKey: .amazonSideAsn)
        }
        if let directConnectGatewayName = self.directConnectGatewayName {
            try encodeContainer.encode(directConnectGatewayName, forKey: .directConnectGatewayName)
        }
    }
}

extension CreateDirectConnectGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDirectConnectGatewayInput: Swift.Equatable {
    /// The autonomous system number (ASN) for Border Gateway Protocol (BGP) to be configured on the Amazon side of the connection. The ASN must be in the private range of 64,512 to 65,534 or 4,200,000,000 to 4,294,967,294. The default is 64512.
    public var amazonSideAsn: Swift.Int?
    /// The name of the Direct Connect gateway.
    /// This member is required.
    public var directConnectGatewayName: Swift.String?

    public init (
        amazonSideAsn: Swift.Int? = nil,
        directConnectGatewayName: Swift.String? = nil
    )
    {
        self.amazonSideAsn = amazonSideAsn
        self.directConnectGatewayName = directConnectGatewayName
    }
}

struct CreateDirectConnectGatewayInputBody: Swift.Equatable {
    let directConnectGatewayName: Swift.String?
    let amazonSideAsn: Swift.Int?
}

extension CreateDirectConnectGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonSideAsn
        case directConnectGatewayName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayName)
        directConnectGatewayName = directConnectGatewayNameDecoded
        let amazonSideAsnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .amazonSideAsn)
        amazonSideAsn = amazonSideAsnDecoded
    }
}

extension CreateDirectConnectGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDirectConnectGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDirectConnectGatewayOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDirectConnectGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDirectConnectGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGateway = output.directConnectGateway
        } else {
            self.directConnectGateway = nil
        }
    }
}

public struct CreateDirectConnectGatewayOutputResponse: Swift.Equatable {
    /// The Direct Connect gateway.
    public var directConnectGateway: DirectConnectClientTypes.DirectConnectGateway?

    public init (
        directConnectGateway: DirectConnectClientTypes.DirectConnectGateway? = nil
    )
    {
        self.directConnectGateway = directConnectGateway
    }
}

struct CreateDirectConnectGatewayOutputResponseBody: Swift.Equatable {
    let directConnectGateway: DirectConnectClientTypes.DirectConnectGateway?
}

extension CreateDirectConnectGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGateway
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.DirectConnectGateway.self, forKey: .directConnectGateway)
        directConnectGateway = directConnectGatewayDecoded
    }
}

extension CreateInterconnectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth
        case interconnectName
        case lagId
        case location
        case providerName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = self.bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let interconnectName = self.interconnectName {
            try encodeContainer.encode(interconnectName, forKey: .interconnectName)
        }
        if let lagId = self.lagId {
            try encodeContainer.encode(lagId, forKey: .lagId)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let providerName = self.providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateInterconnectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateInterconnectInput: Swift.Equatable {
    /// The port bandwidth, in Gbps. The possible values are 1 and 10.
    /// This member is required.
    public var bandwidth: Swift.String?
    /// The name of the interconnect.
    /// This member is required.
    public var interconnectName: Swift.String?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The location of the interconnect.
    /// This member is required.
    public var location: Swift.String?
    /// The name of the service provider associated with the interconnect.
    public var providerName: Swift.String?
    /// The tags to associate with the interconnect.
    public var tags: [DirectConnectClientTypes.Tag]?

    public init (
        bandwidth: Swift.String? = nil,
        interconnectName: Swift.String? = nil,
        lagId: Swift.String? = nil,
        location: Swift.String? = nil,
        providerName: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil
    )
    {
        self.bandwidth = bandwidth
        self.interconnectName = interconnectName
        self.lagId = lagId
        self.location = location
        self.providerName = providerName
        self.tags = tags
    }
}

struct CreateInterconnectInputBody: Swift.Equatable {
    let interconnectName: Swift.String?
    let bandwidth: Swift.String?
    let location: Swift.String?
    let lagId: Swift.String?
    let tags: [DirectConnectClientTypes.Tag]?
    let providerName: Swift.String?
}

extension CreateInterconnectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth
        case interconnectName
        case lagId
        case location
        case providerName
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interconnectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interconnectName)
        interconnectName = interconnectNameDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
    }
}

extension CreateInterconnectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInterconnectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateInterconnectOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInterconnectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateInterconnectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.awsLogicalDeviceId = output.awsLogicalDeviceId
            self.bandwidth = output.bandwidth
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.interconnectId = output.interconnectId
            self.interconnectName = output.interconnectName
            self.interconnectState = output.interconnectState
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.loaIssueTime = output.loaIssueTime
            self.location = output.location
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
        } else {
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.awsLogicalDeviceId = nil
            self.bandwidth = nil
            self.hasLogicalRedundancy = nil
            self.interconnectId = nil
            self.interconnectName = nil
            self.interconnectState = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.loaIssueTime = nil
            self.location = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
        }
    }
}

/// Information about an interconnect.
public struct CreateInterconnectOutputResponse: Swift.Equatable {
    /// The Direct Connect endpoint on which the physical connection terminates.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The bandwidth of the connection.
    public var bandwidth: Swift.String?
    /// Indicates whether the interconnect supports a secondary BGP in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// The ID of the interconnect.
    public var interconnectId: Swift.String?
    /// The name of the interconnect.
    public var interconnectName: Swift.String?
    /// The state of the interconnect. The following are the possible values:
    ///
    /// * requested: The initial state of an interconnect. The interconnect stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The interconnect is approved, and is being initialized.
    ///
    /// * available: The network link is up, and the interconnect is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The interconnect is being deleted.
    ///
    /// * deleted: The interconnect is deleted.
    ///
    /// * unknown: The state of the interconnect is not available.
    public var interconnectState: DirectConnectClientTypes.InterconnectState?
    /// Indicates whether jumbo frames (9001 MTU) are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The time of the most recent call to [DescribeLoa] for this connection.
    public var loaIssueTime: ClientRuntime.Date?
    /// The location of the connection.
    public var location: Swift.String?
    /// The name of the service provider associated with the interconnect.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the interconnect.
    public var tags: [DirectConnectClientTypes.Tag]?

    public init (
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bandwidth: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        interconnectId: Swift.String? = nil,
        interconnectName: Swift.String? = nil,
        interconnectState: DirectConnectClientTypes.InterconnectState? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        loaIssueTime: ClientRuntime.Date? = nil,
        location: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bandwidth = bandwidth
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.interconnectId = interconnectId
        self.interconnectName = interconnectName
        self.interconnectState = interconnectState
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.providerName = providerName
        self.region = region
        self.tags = tags
    }
}

struct CreateInterconnectOutputResponseBody: Swift.Equatable {
    let interconnectId: Swift.String?
    let interconnectName: Swift.String?
    let interconnectState: DirectConnectClientTypes.InterconnectState?
    let region: Swift.String?
    let location: Swift.String?
    let bandwidth: Swift.String?
    let loaIssueTime: ClientRuntime.Date?
    let lagId: Swift.String?
    let awsDevice: Swift.String?
    let jumboFrameCapable: Swift.Bool?
    let awsDeviceV2: Swift.String?
    let awsLogicalDeviceId: Swift.String?
    let hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    let tags: [DirectConnectClientTypes.Tag]?
    let providerName: Swift.String?
}

extension CreateInterconnectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsDevice
        case awsDeviceV2
        case awsLogicalDeviceId
        case bandwidth
        case hasLogicalRedundancy
        case interconnectId
        case interconnectName
        case interconnectState
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case providerName
        case region
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interconnectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interconnectId)
        interconnectId = interconnectIdDecoded
        let interconnectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interconnectName)
        interconnectName = interconnectNameDecoded
        let interconnectStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.InterconnectState.self, forKey: .interconnectState)
        interconnectState = interconnectStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let loaIssueTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
    }
}

extension CreateLagInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childConnectionTags
        case connectionId
        case connectionsBandwidth
        case lagName
        case location
        case numberOfConnections
        case providerName
        case requestMACSec
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childConnectionTags = childConnectionTags {
            var childConnectionTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .childConnectionTags)
            for tag0 in childConnectionTags {
                try childConnectionTagsContainer.encode(tag0)
            }
        }
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionsBandwidth = self.connectionsBandwidth {
            try encodeContainer.encode(connectionsBandwidth, forKey: .connectionsBandwidth)
        }
        if let lagName = self.lagName {
            try encodeContainer.encode(lagName, forKey: .lagName)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if numberOfConnections != 0 {
            try encodeContainer.encode(numberOfConnections, forKey: .numberOfConnections)
        }
        if let providerName = self.providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let requestMACSec = self.requestMACSec {
            try encodeContainer.encode(requestMACSec, forKey: .requestMACSec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateLagInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateLagInput: Swift.Equatable {
    /// The tags to associate with the automtically created LAGs.
    public var childConnectionTags: [DirectConnectClientTypes.Tag]?
    /// The ID of an existing dedicated connection to migrate to the LAG.
    public var connectionId: Swift.String?
    /// The bandwidth of the individual physical dedicated connections bundled by the LAG. The possible values are 1Gbps and 10Gbps.
    /// This member is required.
    public var connectionsBandwidth: Swift.String?
    /// The name of the LAG.
    /// This member is required.
    public var lagName: Swift.String?
    /// The location for the LAG.
    /// This member is required.
    public var location: Swift.String?
    /// The number of physical dedicated connections initially provisioned and bundled by the LAG.
    /// This member is required.
    public var numberOfConnections: Swift.Int
    /// The name of the service provider associated with the LAG.
    public var providerName: Swift.String?
    /// Indicates whether the connection will support MAC Security (MACsec). All connections in the LAG must be capable of supporting MAC Security (MACsec). For information about MAC Security (MACsec) prerequisties, see [MACsec prerequisties](https://docs.aws.amazon.com/directconnect/latest/UserGuide/direct-connect-mac-sec-getting-started.html#mac-sec-prerequisites) in the Direct Connect User Guide.
    public var requestMACSec: Swift.Bool?
    /// The tags to associate with the LAG.
    public var tags: [DirectConnectClientTypes.Tag]?

    public init (
        childConnectionTags: [DirectConnectClientTypes.Tag]? = nil,
        connectionId: Swift.String? = nil,
        connectionsBandwidth: Swift.String? = nil,
        lagName: Swift.String? = nil,
        location: Swift.String? = nil,
        numberOfConnections: Swift.Int = 0,
        providerName: Swift.String? = nil,
        requestMACSec: Swift.Bool? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil
    )
    {
        self.childConnectionTags = childConnectionTags
        self.connectionId = connectionId
        self.connectionsBandwidth = connectionsBandwidth
        self.lagName = lagName
        self.location = location
        self.numberOfConnections = numberOfConnections
        self.providerName = providerName
        self.requestMACSec = requestMACSec
        self.tags = tags
    }
}

struct CreateLagInputBody: Swift.Equatable {
    let numberOfConnections: Swift.Int
    let location: Swift.String?
    let connectionsBandwidth: Swift.String?
    let lagName: Swift.String?
    let connectionId: Swift.String?
    let tags: [DirectConnectClientTypes.Tag]?
    let childConnectionTags: [DirectConnectClientTypes.Tag]?
    let providerName: Swift.String?
    let requestMACSec: Swift.Bool?
}

extension CreateLagInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childConnectionTags
        case connectionId
        case connectionsBandwidth
        case lagName
        case location
        case numberOfConnections
        case providerName
        case requestMACSec
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfConnectionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfConnections) ?? 0
        numberOfConnections = numberOfConnectionsDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let connectionsBandwidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionsBandwidth)
        connectionsBandwidth = connectionsBandwidthDecoded
        let lagNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagName)
        lagName = lagNameDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let childConnectionTagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .childConnectionTags)
        var childConnectionTagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let childConnectionTagsContainer = childConnectionTagsContainer {
            childConnectionTagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in childConnectionTagsContainer {
                if let structure0 = structure0 {
                    childConnectionTagsDecoded0?.append(structure0)
                }
            }
        }
        childConnectionTags = childConnectionTagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let requestMACSecDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requestMACSec)
        requestMACSec = requestMACSecDecoded
    }
}

extension CreateLagOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLagOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateLagOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLagOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateLagOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allowsHostedConnections = output.allowsHostedConnections
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.awsLogicalDeviceId = output.awsLogicalDeviceId
            self.connections = output.connections
            self.connectionsBandwidth = output.connectionsBandwidth
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.lagName = output.lagName
            self.lagState = output.lagState
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.minimumLinks = output.minimumLinks
            self.numberOfConnections = output.numberOfConnections
            self.ownerAccount = output.ownerAccount
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
        } else {
            self.allowsHostedConnections = false
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.awsLogicalDeviceId = nil
            self.connections = nil
            self.connectionsBandwidth = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.lagName = nil
            self.lagState = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.minimumLinks = 0
            self.numberOfConnections = 0
            self.ownerAccount = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
        }
    }
}

/// Information about a link aggregation group (LAG).
public struct CreateLagOutputResponse: Swift.Equatable {
    /// Indicates whether the LAG can host other connections.
    public var allowsHostedConnections: Swift.Bool
    /// The Direct Connect endpoint that hosts the LAG.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that hosts the LAG.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The connections bundled by the LAG.
    public var connections: [DirectConnectClientTypes.Connection]?
    /// The individual bandwidth of the physical connections bundled by the LAG. The possible values are 1Gbps and 10Gbps.
    public var connectionsBandwidth: Swift.String?
    /// The LAG MAC Security (MACsec) encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the LAG supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames (9001 MTU) are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The name of the LAG.
    public var lagName: Swift.String?
    /// The state of the LAG. The following are the possible values:
    ///
    /// * requested: The initial state of a LAG. The LAG stays in the requested state until the Letter of Authorization (LOA) is available.
    ///
    /// * pending: The LAG has been approved and is being initialized.
    ///
    /// * available: The network link is established and the LAG is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The LAG is being deleted.
    ///
    /// * deleted: The LAG is deleted.
    ///
    /// * unknown: The state of the LAG is not available.
    public var lagState: DirectConnectClientTypes.LagState?
    /// The location of the LAG.
    public var location: Swift.String?
    /// Indicates whether the LAG supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the LAG.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The minimum number of physical dedicated connections that must be operational for the LAG itself to be operational.
    public var minimumLinks: Swift.Int
    /// The number of physical dedicated connections bundled by the LAG, up to a maximum of 10.
    public var numberOfConnections: Swift.Int
    /// The ID of the Amazon Web Services account that owns the LAG.
    public var ownerAccount: Swift.String?
    /// The name of the service provider associated with the LAG.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the LAG.
    public var tags: [DirectConnectClientTypes.Tag]?

    public init (
        allowsHostedConnections: Swift.Bool = false,
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        connections: [DirectConnectClientTypes.Connection]? = nil,
        connectionsBandwidth: Swift.String? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        lagName: Swift.String? = nil,
        lagState: DirectConnectClientTypes.LagState? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        minimumLinks: Swift.Int = 0,
        numberOfConnections: Swift.Int = 0,
        ownerAccount: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil
    )
    {
        self.allowsHostedConnections = allowsHostedConnections
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.connections = connections
        self.connectionsBandwidth = connectionsBandwidth
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.lagName = lagName
        self.lagState = lagState
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.minimumLinks = minimumLinks
        self.numberOfConnections = numberOfConnections
        self.ownerAccount = ownerAccount
        self.providerName = providerName
        self.region = region
        self.tags = tags
    }
}

struct CreateLagOutputResponseBody: Swift.Equatable {
    let connectionsBandwidth: Swift.String?
    let numberOfConnections: Swift.Int
    let lagId: Swift.String?
    let ownerAccount: Swift.String?
    let lagName: Swift.String?
    let lagState: DirectConnectClientTypes.LagState?
    let location: Swift.String?
    let region: Swift.String?
    let minimumLinks: Swift.Int
    let awsDevice: Swift.String?
    let awsDeviceV2: Swift.String?
    let awsLogicalDeviceId: Swift.String?
    let connections: [DirectConnectClientTypes.Connection]?
    let allowsHostedConnections: Swift.Bool
    let jumboFrameCapable: Swift.Bool?
    let hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    let tags: [DirectConnectClientTypes.Tag]?
    let providerName: Swift.String?
    let macSecCapable: Swift.Bool?
    let encryptionMode: Swift.String?
    let macSecKeys: [DirectConnectClientTypes.MacSecKey]?
}

extension CreateLagOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowsHostedConnections
        case awsDevice
        case awsDeviceV2
        case awsLogicalDeviceId
        case connections
        case connectionsBandwidth
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case lagName
        case lagState
        case location
        case macSecCapable
        case macSecKeys
        case minimumLinks
        case numberOfConnections
        case ownerAccount
        case providerName
        case region
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsBandwidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionsBandwidth)
        connectionsBandwidth = connectionsBandwidthDecoded
        let numberOfConnectionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfConnections) ?? 0
        numberOfConnections = numberOfConnectionsDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let lagNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagName)
        lagName = lagNameDecoded
        let lagStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.LagState.self, forKey: .lagState)
        lagState = lagStateDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let minimumLinksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumLinks) ?? 0
        minimumLinks = minimumLinksDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let connectionsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Connection?].self, forKey: .connections)
        var connectionsDecoded0:[DirectConnectClientTypes.Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [DirectConnectClientTypes.Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
        let allowsHostedConnectionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowsHostedConnections) ?? false
        allowsHostedConnections = allowsHostedConnectionsDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[DirectConnectClientTypes.MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [DirectConnectClientTypes.MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

extension CreatePrivateVirtualInterfaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case newPrivateVirtualInterface
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let newPrivateVirtualInterface = self.newPrivateVirtualInterface {
            try encodeContainer.encode(newPrivateVirtualInterface, forKey: .newPrivateVirtualInterface)
        }
    }
}

extension CreatePrivateVirtualInterfaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePrivateVirtualInterfaceInput: Swift.Equatable {
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// Information about the private virtual interface.
    /// This member is required.
    public var newPrivateVirtualInterface: DirectConnectClientTypes.NewPrivateVirtualInterface?

    public init (
        connectionId: Swift.String? = nil,
        newPrivateVirtualInterface: DirectConnectClientTypes.NewPrivateVirtualInterface? = nil
    )
    {
        self.connectionId = connectionId
        self.newPrivateVirtualInterface = newPrivateVirtualInterface
    }
}

struct CreatePrivateVirtualInterfaceInputBody: Swift.Equatable {
    let connectionId: Swift.String?
    let newPrivateVirtualInterface: DirectConnectClientTypes.NewPrivateVirtualInterface?
}

extension CreatePrivateVirtualInterfaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case newPrivateVirtualInterface
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let newPrivateVirtualInterfaceDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.NewPrivateVirtualInterface.self, forKey: .newPrivateVirtualInterface)
        newPrivateVirtualInterface = newPrivateVirtualInterfaceDecoded
    }
}

extension CreatePrivateVirtualInterfaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePrivateVirtualInterfaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePrivateVirtualInterfaceOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePrivateVirtualInterfaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePrivateVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addressFamily = output.addressFamily
            self.amazonAddress = output.amazonAddress
            self.amazonSideAsn = output.amazonSideAsn
            self.asn = output.asn
            self.authKey = output.authKey
            self.awsDeviceV2 = output.awsDeviceV2
            self.awsLogicalDeviceId = output.awsLogicalDeviceId
            self.bgpPeers = output.bgpPeers
            self.connectionId = output.connectionId
            self.customerAddress = output.customerAddress
            self.customerRouterConfig = output.customerRouterConfig
            self.directConnectGatewayId = output.directConnectGatewayId
            self.jumboFrameCapable = output.jumboFrameCapable
            self.location = output.location
            self.mtu = output.mtu
            self.ownerAccount = output.ownerAccount
            self.region = output.region
            self.routeFilterPrefixes = output.routeFilterPrefixes
            self.siteLinkEnabled = output.siteLinkEnabled
            self.tags = output.tags
            self.virtualGatewayId = output.virtualGatewayId
            self.virtualInterfaceId = output.virtualInterfaceId
            self.virtualInterfaceName = output.virtualInterfaceName
            self.virtualInterfaceState = output.virtualInterfaceState
            self.virtualInterfaceType = output.virtualInterfaceType
            self.vlan = output.vlan
        } else {
            self.addressFamily = nil
            self.amazonAddress = nil
            self.amazonSideAsn = nil
            self.asn = 0
            self.authKey = nil
            self.awsDeviceV2 = nil
            self.awsLogicalDeviceId = nil
            self.bgpPeers = nil
            self.connectionId = nil
            self.customerAddress = nil
            self.customerRouterConfig = nil
            self.directConnectGatewayId = nil
            self.jumboFrameCapable = nil
            self.location = nil
            self.mtu = nil
            self.ownerAccount = nil
            self.region = nil
            self.routeFilterPrefixes = nil
            self.siteLinkEnabled = nil
            self.tags = nil
            self.virtualGatewayId = nil
            self.virtualInterfaceId = nil
            self.virtualInterfaceName = nil
            self.virtualInterfaceState = nil
            self.virtualInterfaceType = nil
            self.vlan = 0
        }
    }
}

/// Information about a virtual interface.
public struct CreatePrivateVirtualInterfaceOutputResponse: Swift.Equatable {
    /// The address family for the BGP peer.
    public var addressFamily: DirectConnectClientTypes.AddressFamily?
    /// The IP address assigned to the Amazon interface.
    public var amazonAddress: Swift.String?
    /// The autonomous system number (ASN) for the Amazon side of the connection.
    public var amazonSideAsn: Swift.Int?
    /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
    public var asn: Swift.Int
    /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
    public var authKey: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The BGP peers configured on this virtual interface.
    public var bgpPeers: [DirectConnectClientTypes.BGPPeer]?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The IP address assigned to the customer interface.
    public var customerAddress: Swift.String?
    /// The customer router configuration.
    public var customerRouterConfig: Swift.String?
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// Indicates whether jumbo frames (9001 MTU) are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The location of the connection.
    public var location: Swift.String?
    /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.
    public var mtu: Swift.Int?
    /// The ID of the Amazon Web Services account that owns the virtual interface.
    public var ownerAccount: Swift.String?
    /// The Amazon Web Services Region where the virtual interface is located.
    public var region: Swift.String?
    /// The routes to be advertised to the Amazon Web Services network in this Region. Applies to public virtual interfaces.
    public var routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
    /// Indicates whether SiteLink is enabled.
    public var siteLinkEnabled: Swift.Bool?
    /// The tags associated with the virtual interface.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the virtual private gateway. Applies only to private virtual interfaces.
    public var virtualGatewayId: Swift.String?
    /// The ID of the virtual interface.
    public var virtualInterfaceId: Swift.String?
    /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
    public var virtualInterfaceName: Swift.String?
    /// The state of the virtual interface. The following are the possible values:
    ///
    /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
    ///
    /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
    ///
    /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
    ///
    /// * available: A virtual interface that is able to forward traffic.
    ///
    /// * down: A virtual interface that is BGP down.
    ///
    /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
    ///
    /// * deleted: A virtual interface that cannot forward traffic.
    ///
    /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
    ///
    /// * unknown: The state of the virtual interface is not available.
    public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
    /// The type of virtual interface. The possible values are private and public.
    public var virtualInterfaceType: Swift.String?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init (
        addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
        amazonAddress: Swift.String? = nil,
        amazonSideAsn: Swift.Int? = nil,
        asn: Swift.Int = 0,
        authKey: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bgpPeers: [DirectConnectClientTypes.BGPPeer]? = nil,
        connectionId: Swift.String? = nil,
        customerAddress: Swift.String? = nil,
        customerRouterConfig: Swift.String? = nil,
        directConnectGatewayId: Swift.String? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        location: Swift.String? = nil,
        mtu: Swift.Int? = nil,
        ownerAccount: Swift.String? = nil,
        region: Swift.String? = nil,
        routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
        siteLinkEnabled: Swift.Bool? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        virtualGatewayId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil,
        virtualInterfaceName: Swift.String? = nil,
        virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil,
        virtualInterfaceType: Swift.String? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.amazonSideAsn = amazonSideAsn
        self.asn = asn
        self.authKey = authKey
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bgpPeers = bgpPeers
        self.connectionId = connectionId
        self.customerAddress = customerAddress
        self.customerRouterConfig = customerRouterConfig
        self.directConnectGatewayId = directConnectGatewayId
        self.jumboFrameCapable = jumboFrameCapable
        self.location = location
        self.mtu = mtu
        self.ownerAccount = ownerAccount
        self.region = region
        self.routeFilterPrefixes = routeFilterPrefixes
        self.siteLinkEnabled = siteLinkEnabled
        self.tags = tags
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
        self.virtualInterfaceState = virtualInterfaceState
        self.virtualInterfaceType = virtualInterfaceType
        self.vlan = vlan
    }
}

struct CreatePrivateVirtualInterfaceOutputResponseBody: Swift.Equatable {
    let ownerAccount: Swift.String?
    let virtualInterfaceId: Swift.String?
    let location: Swift.String?
    let connectionId: Swift.String?
    let virtualInterfaceType: Swift.String?
    let virtualInterfaceName: Swift.String?
    let vlan: Swift.Int
    let asn: Swift.Int
    let amazonSideAsn: Swift.Int?
    let authKey: Swift.String?
    let amazonAddress: Swift.String?
    let customerAddress: Swift.String?
    let addressFamily: DirectConnectClientTypes.AddressFamily?
    let virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
    let customerRouterConfig: Swift.String?
    let mtu: Swift.Int?
    let jumboFrameCapable: Swift.Bool?
    let virtualGatewayId: Swift.String?
    let directConnectGatewayId: Swift.String?
    let routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
    let bgpPeers: [DirectConnectClientTypes.BGPPeer]?
    let region: Swift.String?
    let awsDeviceV2: Swift.String?
    let awsLogicalDeviceId: Swift.String?
    let tags: [DirectConnectClientTypes.Tag]?
    let siteLinkEnabled: Swift.Bool?
}

extension CreatePrivateVirtualInterfaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressFamily
        case amazonAddress
        case amazonSideAsn
        case asn
        case authKey
        case awsDeviceV2
        case awsLogicalDeviceId
        case bgpPeers
        case connectionId
        case customerAddress
        case customerRouterConfig
        case directConnectGatewayId
        case jumboFrameCapable
        case location
        case mtu
        case ownerAccount
        case region
        case routeFilterPrefixes
        case siteLinkEnabled
        case tags
        case virtualGatewayId
        case virtualInterfaceId
        case virtualInterfaceName
        case virtualInterfaceState
        case virtualInterfaceType
        case vlan
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let virtualInterfaceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceType)
        virtualInterfaceType = virtualInterfaceTypeDecoded
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn) ?? 0
        asn = asnDecoded
        let amazonSideAsnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .amazonSideAsn)
        amazonSideAsn = amazonSideAsnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
        let customerRouterConfigDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerRouterConfig)
        customerRouterConfig = customerRouterConfigDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let routeFilterPrefixesContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.RouteFilterPrefix?].self, forKey: .routeFilterPrefixes)
        var routeFilterPrefixesDecoded0:[DirectConnectClientTypes.RouteFilterPrefix]? = nil
        if let routeFilterPrefixesContainer = routeFilterPrefixesContainer {
            routeFilterPrefixesDecoded0 = [DirectConnectClientTypes.RouteFilterPrefix]()
            for structure0 in routeFilterPrefixesContainer {
                if let structure0 = structure0 {
                    routeFilterPrefixesDecoded0?.append(structure0)
                }
            }
        }
        routeFilterPrefixes = routeFilterPrefixesDecoded0
        let bgpPeersContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.BGPPeer?].self, forKey: .bgpPeers)
        var bgpPeersDecoded0:[DirectConnectClientTypes.BGPPeer]? = nil
        if let bgpPeersContainer = bgpPeersContainer {
            bgpPeersDecoded0 = [DirectConnectClientTypes.BGPPeer]()
            for structure0 in bgpPeersContainer {
                if let structure0 = structure0 {
                    bgpPeersDecoded0?.append(structure0)
                }
            }
        }
        bgpPeers = bgpPeersDecoded0
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let siteLinkEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .siteLinkEnabled)
        siteLinkEnabled = siteLinkEnabledDecoded
    }
}

extension CreatePublicVirtualInterfaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case newPublicVirtualInterface
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let newPublicVirtualInterface = self.newPublicVirtualInterface {
            try encodeContainer.encode(newPublicVirtualInterface, forKey: .newPublicVirtualInterface)
        }
    }
}

extension CreatePublicVirtualInterfaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePublicVirtualInterfaceInput: Swift.Equatable {
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// Information about the public virtual interface.
    /// This member is required.
    public var newPublicVirtualInterface: DirectConnectClientTypes.NewPublicVirtualInterface?

    public init (
        connectionId: Swift.String? = nil,
        newPublicVirtualInterface: DirectConnectClientTypes.NewPublicVirtualInterface? = nil
    )
    {
        self.connectionId = connectionId
        self.newPublicVirtualInterface = newPublicVirtualInterface
    }
}

struct CreatePublicVirtualInterfaceInputBody: Swift.Equatable {
    let connectionId: Swift.String?
    let newPublicVirtualInterface: DirectConnectClientTypes.NewPublicVirtualInterface?
}

extension CreatePublicVirtualInterfaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case newPublicVirtualInterface
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let newPublicVirtualInterfaceDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.NewPublicVirtualInterface.self, forKey: .newPublicVirtualInterface)
        newPublicVirtualInterface = newPublicVirtualInterfaceDecoded
    }
}

extension CreatePublicVirtualInterfaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePublicVirtualInterfaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePublicVirtualInterfaceOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePublicVirtualInterfaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePublicVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addressFamily = output.addressFamily
            self.amazonAddress = output.amazonAddress
            self.amazonSideAsn = output.amazonSideAsn
            self.asn = output.asn
            self.authKey = output.authKey
            self.awsDeviceV2 = output.awsDeviceV2
            self.awsLogicalDeviceId = output.awsLogicalDeviceId
            self.bgpPeers = output.bgpPeers
            self.connectionId = output.connectionId
            self.customerAddress = output.customerAddress
            self.customerRouterConfig = output.customerRouterConfig
            self.directConnectGatewayId = output.directConnectGatewayId
            self.jumboFrameCapable = output.jumboFrameCapable
            self.location = output.location
            self.mtu = output.mtu
            self.ownerAccount = output.ownerAccount
            self.region = output.region
            self.routeFilterPrefixes = output.routeFilterPrefixes
            self.siteLinkEnabled = output.siteLinkEnabled
            self.tags = output.tags
            self.virtualGatewayId = output.virtualGatewayId
            self.virtualInterfaceId = output.virtualInterfaceId
            self.virtualInterfaceName = output.virtualInterfaceName
            self.virtualInterfaceState = output.virtualInterfaceState
            self.virtualInterfaceType = output.virtualInterfaceType
            self.vlan = output.vlan
        } else {
            self.addressFamily = nil
            self.amazonAddress = nil
            self.amazonSideAsn = nil
            self.asn = 0
            self.authKey = nil
            self.awsDeviceV2 = nil
            self.awsLogicalDeviceId = nil
            self.bgpPeers = nil
            self.connectionId = nil
            self.customerAddress = nil
            self.customerRouterConfig = nil
            self.directConnectGatewayId = nil
            self.jumboFrameCapable = nil
            self.location = nil
            self.mtu = nil
            self.ownerAccount = nil
            self.region = nil
            self.routeFilterPrefixes = nil
            self.siteLinkEnabled = nil
            self.tags = nil
            self.virtualGatewayId = nil
            self.virtualInterfaceId = nil
            self.virtualInterfaceName = nil
            self.virtualInterfaceState = nil
            self.virtualInterfaceType = nil
            self.vlan = 0
        }
    }
}

/// Information about a virtual interface.
public struct CreatePublicVirtualInterfaceOutputResponse: Swift.Equatable {
    /// The address family for the BGP peer.
    public var addressFamily: DirectConnectClientTypes.AddressFamily?
    /// The IP address assigned to the Amazon interface.
    public var amazonAddress: Swift.String?
    /// The autonomous system number (ASN) for the Amazon side of the connection.
    public var amazonSideAsn: Swift.Int?
    /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
    public var asn: Swift.Int
    /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
    public var authKey: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The BGP peers configured on this virtual interface.
    public var bgpPeers: [DirectConnectClientTypes.BGPPeer]?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The IP address assigned to the customer interface.
    public var customerAddress: Swift.String?
    /// The customer router configuration.
    public var customerRouterConfig: Swift.String?
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// Indicates whether jumbo frames (9001 MTU) are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The location of the connection.
    public var location: Swift.String?
    /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.
    public var mtu: Swift.Int?
    /// The ID of the Amazon Web Services account that owns the virtual interface.
    public var ownerAccount: Swift.String?
    /// The Amazon Web Services Region where the virtual interface is located.
    public var region: Swift.String?
    /// The routes to be advertised to the Amazon Web Services network in this Region. Applies to public virtual interfaces.
    public var routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
    /// Indicates whether SiteLink is enabled.
    public var siteLinkEnabled: Swift.Bool?
    /// The tags associated with the virtual interface.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the virtual private gateway. Applies only to private virtual interfaces.
    public var virtualGatewayId: Swift.String?
    /// The ID of the virtual interface.
    public var virtualInterfaceId: Swift.String?
    /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
    public var virtualInterfaceName: Swift.String?
    /// The state of the virtual interface. The following are the possible values:
    ///
    /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
    ///
    /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
    ///
    /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
    ///
    /// * available: A virtual interface that is able to forward traffic.
    ///
    /// * down: A virtual interface that is BGP down.
    ///
    /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
    ///
    /// * deleted: A virtual interface that cannot forward traffic.
    ///
    /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
    ///
    /// * unknown: The state of the virtual interface is not available.
    public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
    /// The type of virtual interface. The possible values are private and public.
    public var virtualInterfaceType: Swift.String?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init (
        addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
        amazonAddress: Swift.String? = nil,
        amazonSideAsn: Swift.Int? = nil,
        asn: Swift.Int = 0,
        authKey: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bgpPeers: [DirectConnectClientTypes.BGPPeer]? = nil,
        connectionId: Swift.String? = nil,
        customerAddress: Swift.String? = nil,
        customerRouterConfig: Swift.String? = nil,
        directConnectGatewayId: Swift.String? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        location: Swift.String? = nil,
        mtu: Swift.Int? = nil,
        ownerAccount: Swift.String? = nil,
        region: Swift.String? = nil,
        routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
        siteLinkEnabled: Swift.Bool? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        virtualGatewayId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil,
        virtualInterfaceName: Swift.String? = nil,
        virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil,
        virtualInterfaceType: Swift.String? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.amazonSideAsn = amazonSideAsn
        self.asn = asn
        self.authKey = authKey
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bgpPeers = bgpPeers
        self.connectionId = connectionId
        self.customerAddress = customerAddress
        self.customerRouterConfig = customerRouterConfig
        self.directConnectGatewayId = directConnectGatewayId
        self.jumboFrameCapable = jumboFrameCapable
        self.location = location
        self.mtu = mtu
        self.ownerAccount = ownerAccount
        self.region = region
        self.routeFilterPrefixes = routeFilterPrefixes
        self.siteLinkEnabled = siteLinkEnabled
        self.tags = tags
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
        self.virtualInterfaceState = virtualInterfaceState
        self.virtualInterfaceType = virtualInterfaceType
        self.vlan = vlan
    }
}

struct CreatePublicVirtualInterfaceOutputResponseBody: Swift.Equatable {
    let ownerAccount: Swift.String?
    let virtualInterfaceId: Swift.String?
    let location: Swift.String?
    let connectionId: Swift.String?
    let virtualInterfaceType: Swift.String?
    let virtualInterfaceName: Swift.String?
    let vlan: Swift.Int
    let asn: Swift.Int
    let amazonSideAsn: Swift.Int?
    let authKey: Swift.String?
    let amazonAddress: Swift.String?
    let customerAddress: Swift.String?
    let addressFamily: DirectConnectClientTypes.AddressFamily?
    let virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
    let customerRouterConfig: Swift.String?
    let mtu: Swift.Int?
    let jumboFrameCapable: Swift.Bool?
    let virtualGatewayId: Swift.String?
    let directConnectGatewayId: Swift.String?
    let routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
    let bgpPeers: [DirectConnectClientTypes.BGPPeer]?
    let region: Swift.String?
    let awsDeviceV2: Swift.String?
    let awsLogicalDeviceId: Swift.String?
    let tags: [DirectConnectClientTypes.Tag]?
    let siteLinkEnabled: Swift.Bool?
}

extension CreatePublicVirtualInterfaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressFamily
        case amazonAddress
        case amazonSideAsn
        case asn
        case authKey
        case awsDeviceV2
        case awsLogicalDeviceId
        case bgpPeers
        case connectionId
        case customerAddress
        case customerRouterConfig
        case directConnectGatewayId
        case jumboFrameCapable
        case location
        case mtu
        case ownerAccount
        case region
        case routeFilterPrefixes
        case siteLinkEnabled
        case tags
        case virtualGatewayId
        case virtualInterfaceId
        case virtualInterfaceName
        case virtualInterfaceState
        case virtualInterfaceType
        case vlan
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let virtualInterfaceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceType)
        virtualInterfaceType = virtualInterfaceTypeDecoded
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn) ?? 0
        asn = asnDecoded
        let amazonSideAsnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .amazonSideAsn)
        amazonSideAsn = amazonSideAsnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
        let customerRouterConfigDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerRouterConfig)
        customerRouterConfig = customerRouterConfigDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let routeFilterPrefixesContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.RouteFilterPrefix?].self, forKey: .routeFilterPrefixes)
        var routeFilterPrefixesDecoded0:[DirectConnectClientTypes.RouteFilterPrefix]? = nil
        if let routeFilterPrefixesContainer = routeFilterPrefixesContainer {
            routeFilterPrefixesDecoded0 = [DirectConnectClientTypes.RouteFilterPrefix]()
            for structure0 in routeFilterPrefixesContainer {
                if let structure0 = structure0 {
                    routeFilterPrefixesDecoded0?.append(structure0)
                }
            }
        }
        routeFilterPrefixes = routeFilterPrefixesDecoded0
        let bgpPeersContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.BGPPeer?].self, forKey: .bgpPeers)
        var bgpPeersDecoded0:[DirectConnectClientTypes.BGPPeer]? = nil
        if let bgpPeersContainer = bgpPeersContainer {
            bgpPeersDecoded0 = [DirectConnectClientTypes.BGPPeer]()
            for structure0 in bgpPeersContainer {
                if let structure0 = structure0 {
                    bgpPeersDecoded0?.append(structure0)
                }
            }
        }
        bgpPeers = bgpPeersDecoded0
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let siteLinkEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .siteLinkEnabled)
        siteLinkEnabled = siteLinkEnabledDecoded
    }
}

extension CreateTransitVirtualInterfaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case newTransitVirtualInterface
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let newTransitVirtualInterface = self.newTransitVirtualInterface {
            try encodeContainer.encode(newTransitVirtualInterface, forKey: .newTransitVirtualInterface)
        }
    }
}

extension CreateTransitVirtualInterfaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateTransitVirtualInterfaceInput: Swift.Equatable {
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// Information about the transit virtual interface.
    /// This member is required.
    public var newTransitVirtualInterface: DirectConnectClientTypes.NewTransitVirtualInterface?

    public init (
        connectionId: Swift.String? = nil,
        newTransitVirtualInterface: DirectConnectClientTypes.NewTransitVirtualInterface? = nil
    )
    {
        self.connectionId = connectionId
        self.newTransitVirtualInterface = newTransitVirtualInterface
    }
}

struct CreateTransitVirtualInterfaceInputBody: Swift.Equatable {
    let connectionId: Swift.String?
    let newTransitVirtualInterface: DirectConnectClientTypes.NewTransitVirtualInterface?
}

extension CreateTransitVirtualInterfaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case newTransitVirtualInterface
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let newTransitVirtualInterfaceDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.NewTransitVirtualInterface.self, forKey: .newTransitVirtualInterface)
        newTransitVirtualInterface = newTransitVirtualInterfaceDecoded
    }
}

extension CreateTransitVirtualInterfaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTransitVirtualInterfaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTransitVirtualInterfaceOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTransitVirtualInterfaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateTransitVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterface = output.virtualInterface
        } else {
            self.virtualInterface = nil
        }
    }
}

public struct CreateTransitVirtualInterfaceOutputResponse: Swift.Equatable {
    /// Information about a virtual interface.
    public var virtualInterface: DirectConnectClientTypes.VirtualInterface?

    public init (
        virtualInterface: DirectConnectClientTypes.VirtualInterface? = nil
    )
    {
        self.virtualInterface = virtualInterface
    }
}

struct CreateTransitVirtualInterfaceOutputResponseBody: Swift.Equatable {
    let virtualInterface: DirectConnectClientTypes.VirtualInterface?
}

extension CreateTransitVirtualInterfaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualInterface
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.VirtualInterface.self, forKey: .virtualInterface)
        virtualInterface = virtualInterfaceDecoded
    }
}

extension DirectConnectClientTypes.CustomerAgreement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementName
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agreementName = self.agreementName {
            try encodeContainer.encode(agreementName, forKey: .agreementName)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agreementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementName)
        agreementName = agreementNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DirectConnectClientTypes {
    /// The name and status of a customer agreement.
    public struct CustomerAgreement: Swift.Equatable {
        /// The name of the agreement.
        public var agreementName: Swift.String?
        /// The status of the customer agreement. This will be either signed or unsigned
        public var status: Swift.String?

        public init (
            agreementName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.agreementName = agreementName
            self.status = status
        }
    }

}

extension DeleteBGPPeerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asn
        case bgpPeerId
        case customerAddress
        case virtualInterfaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let bgpPeerId = self.bgpPeerId {
            try encodeContainer.encode(bgpPeerId, forKey: .bgpPeerId)
        }
        if let customerAddress = self.customerAddress {
            try encodeContainer.encode(customerAddress, forKey: .customerAddress)
        }
        if let virtualInterfaceId = self.virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

extension DeleteBGPPeerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteBGPPeerInput: Swift.Equatable {
    /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.
    public var asn: Swift.Int
    /// The ID of the BGP peer.
    public var bgpPeerId: Swift.String?
    /// The IP address assigned to the customer interface.
    public var customerAddress: Swift.String?
    /// The ID of the virtual interface.
    public var virtualInterfaceId: Swift.String?

    public init (
        asn: Swift.Int = 0,
        bgpPeerId: Swift.String? = nil,
        customerAddress: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.asn = asn
        self.bgpPeerId = bgpPeerId
        self.customerAddress = customerAddress
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct DeleteBGPPeerInputBody: Swift.Equatable {
    let virtualInterfaceId: Swift.String?
    let asn: Swift.Int
    let customerAddress: Swift.String?
    let bgpPeerId: Swift.String?
}

extension DeleteBGPPeerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asn
        case bgpPeerId
        case customerAddress
        case virtualInterfaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn) ?? 0
        asn = asnDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let bgpPeerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bgpPeerId)
        bgpPeerId = bgpPeerIdDecoded
    }
}

extension DeleteBGPPeerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBGPPeerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteBGPPeerOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBGPPeerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteBGPPeerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterface = output.virtualInterface
        } else {
            self.virtualInterface = nil
        }
    }
}

public struct DeleteBGPPeerOutputResponse: Swift.Equatable {
    /// The virtual interface.
    public var virtualInterface: DirectConnectClientTypes.VirtualInterface?

    public init (
        virtualInterface: DirectConnectClientTypes.VirtualInterface? = nil
    )
    {
        self.virtualInterface = virtualInterface
    }
}

struct DeleteBGPPeerOutputResponseBody: Swift.Equatable {
    let virtualInterface: DirectConnectClientTypes.VirtualInterface?
}

extension DeleteBGPPeerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualInterface
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.VirtualInterface.self, forKey: .virtualInterface)
        virtualInterface = virtualInterfaceDecoded
    }
}

extension DeleteConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
    }
}

extension DeleteConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteConnectionInput: Swift.Equatable {
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?

    public init (
        connectionId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

struct DeleteConnectionInputBody: Swift.Equatable {
    let connectionId: Swift.String?
}

extension DeleteConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
    }
}

extension DeleteConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteConnectionOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.awsLogicalDeviceId = output.awsLogicalDeviceId
            self.bandwidth = output.bandwidth
            self.connectionId = output.connectionId
            self.connectionName = output.connectionName
            self.connectionState = output.connectionState
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.loaIssueTime = output.loaIssueTime
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.ownerAccount = output.ownerAccount
            self.partnerName = output.partnerName
            self.portEncryptionStatus = output.portEncryptionStatus
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
            self.vlan = output.vlan
        } else {
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.awsLogicalDeviceId = nil
            self.bandwidth = nil
            self.connectionId = nil
            self.connectionName = nil
            self.connectionState = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.loaIssueTime = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.ownerAccount = nil
            self.partnerName = nil
            self.portEncryptionStatus = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
            self.vlan = 0
        }
    }
}

/// Information about an Direct Connect connection.
public struct DeleteConnectionOutputResponse: Swift.Equatable {
    /// The Direct Connect endpoint on which the physical connection terminates.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The bandwidth of the connection.
    public var bandwidth: Swift.String?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The name of the connection.
    public var connectionName: Swift.String?
    /// The state of the connection. The following are the possible values:
    ///
    /// * ordering: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.
    ///
    /// * requested: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The connection has been approved and is being initialized.
    ///
    /// * available: The network link is up and the connection is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The connection is being deleted.
    ///
    /// * deleted: The connection has been deleted.
    ///
    /// * rejected: A hosted connection in the ordering state enters the rejected state if it is deleted by the customer.
    ///
    /// * unknown: The state of the connection is not available.
    public var connectionState: DirectConnectClientTypes.ConnectionState?
    /// The MAC Security (MACsec) connection encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames (9001 MTU) are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The time of the most recent call to [DescribeLoa] for this connection.
    public var loaIssueTime: ClientRuntime.Date?
    /// The location of the connection.
    public var location: Swift.String?
    /// Indicates whether the connection supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the connection.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The ID of the Amazon Web Services account that owns the connection.
    public var ownerAccount: Swift.String?
    /// The name of the Direct Connect service provider associated with the connection.
    public var partnerName: Swift.String?
    /// The MAC Security (MACsec) port link status of the connection. The valid values are Encryption Up, which means that there is an active Connection Key Name, or Encryption Down.
    public var portEncryptionStatus: Swift.String?
    /// The name of the service provider associated with the connection.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the connection.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init (
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bandwidth: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        connectionState: DirectConnectClientTypes.ConnectionState? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        loaIssueTime: ClientRuntime.Date? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        ownerAccount: Swift.String? = nil,
        partnerName: Swift.String? = nil,
        portEncryptionStatus: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

struct DeleteConnectionOutputResponseBody: Swift.Equatable {
    let ownerAccount: Swift.String?
    let connectionId: Swift.String?
    let connectionName: Swift.String?
    let connectionState: DirectConnectClientTypes.ConnectionState?
    let region: Swift.String?
    let location: Swift.String?
    let bandwidth: Swift.String?
    let vlan: Swift.Int
    let partnerName: Swift.String?
    let loaIssueTime: ClientRuntime.Date?
    let lagId: Swift.String?
    let awsDevice: Swift.String?
    let jumboFrameCapable: Swift.Bool?
    let awsDeviceV2: Swift.String?
    let awsLogicalDeviceId: Swift.String?
    let hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    let tags: [DirectConnectClientTypes.Tag]?
    let providerName: Swift.String?
    let macSecCapable: Swift.Bool?
    let portEncryptionStatus: Swift.String?
    let encryptionMode: Swift.String?
    let macSecKeys: [DirectConnectClientTypes.MacSecKey]?
}

extension DeleteConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsDevice
        case awsDeviceV2
        case awsLogicalDeviceId
        case bandwidth
        case connectionId
        case connectionName
        case connectionState
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case macSecCapable
        case macSecKeys
        case ownerAccount
        case partnerName
        case portEncryptionStatus
        case providerName
        case region
        case tags
        case vlan
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
        let loaIssueTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let portEncryptionStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portEncryptionStatus)
        portEncryptionStatus = portEncryptionStatusDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[DirectConnectClientTypes.MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [DirectConnectClientTypes.MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

extension DeleteDirectConnectGatewayAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId
        case directConnectGatewayId
        case virtualGatewayId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = self.associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let directConnectGatewayId = self.directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let virtualGatewayId = self.virtualGatewayId {
            try encodeContainer.encode(virtualGatewayId, forKey: .virtualGatewayId)
        }
    }
}

extension DeleteDirectConnectGatewayAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDirectConnectGatewayAssociationInput: Swift.Equatable {
    /// The ID of the Direct Connect gateway association.
    public var associationId: Swift.String?
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// The ID of the virtual private gateway.
    public var virtualGatewayId: Swift.String?

    public init (
        associationId: Swift.String? = nil,
        directConnectGatewayId: Swift.String? = nil,
        virtualGatewayId: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.directConnectGatewayId = directConnectGatewayId
        self.virtualGatewayId = virtualGatewayId
    }
}

struct DeleteDirectConnectGatewayAssociationInputBody: Swift.Equatable {
    let associationId: Swift.String?
    let directConnectGatewayId: Swift.String?
    let virtualGatewayId: Swift.String?
}

extension DeleteDirectConnectGatewayAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId
        case directConnectGatewayId
        case virtualGatewayId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
    }
}

extension DeleteDirectConnectGatewayAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDirectConnectGatewayAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDirectConnectGatewayAssociationOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDirectConnectGatewayAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteDirectConnectGatewayAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGatewayAssociation = output.directConnectGatewayAssociation
        } else {
            self.directConnectGatewayAssociation = nil
        }
    }
}

public struct DeleteDirectConnectGatewayAssociationOutputResponse: Swift.Equatable {
    /// Information about the deleted association.
    public var directConnectGatewayAssociation: DirectConnectClientTypes.DirectConnectGatewayAssociation?

    public init (
        directConnectGatewayAssociation: DirectConnectClientTypes.DirectConnectGatewayAssociation? = nil
    )
    {
        self.directConnectGatewayAssociation = directConnectGatewayAssociation
    }
}

struct DeleteDirectConnectGatewayAssociationOutputResponseBody: Swift.Equatable {
    let directConnectGatewayAssociation: DirectConnectClientTypes.DirectConnectGatewayAssociation?
}

extension DeleteDirectConnectGatewayAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayAssociation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayAssociationDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.DirectConnectGatewayAssociation.self, forKey: .directConnectGatewayAssociation)
        directConnectGatewayAssociation = directConnectGatewayAssociationDecoded
    }
}

extension DeleteDirectConnectGatewayAssociationProposalInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proposalId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let proposalId = self.proposalId {
            try encodeContainer.encode(proposalId, forKey: .proposalId)
        }
    }
}

extension DeleteDirectConnectGatewayAssociationProposalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDirectConnectGatewayAssociationProposalInput: Swift.Equatable {
    /// The ID of the proposal.
    /// This member is required.
    public var proposalId: Swift.String?

    public init (
        proposalId: Swift.String? = nil
    )
    {
        self.proposalId = proposalId
    }
}

struct DeleteDirectConnectGatewayAssociationProposalInputBody: Swift.Equatable {
    let proposalId: Swift.String?
}

extension DeleteDirectConnectGatewayAssociationProposalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proposalId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proposalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proposalId)
        proposalId = proposalIdDecoded
    }
}

extension DeleteDirectConnectGatewayAssociationProposalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDirectConnectGatewayAssociationProposalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDirectConnectGatewayAssociationProposalOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDirectConnectGatewayAssociationProposalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteDirectConnectGatewayAssociationProposalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGatewayAssociationProposal = output.directConnectGatewayAssociationProposal
        } else {
            self.directConnectGatewayAssociationProposal = nil
        }
    }
}

public struct DeleteDirectConnectGatewayAssociationProposalOutputResponse: Swift.Equatable {
    /// The ID of the associated gateway.
    public var directConnectGatewayAssociationProposal: DirectConnectClientTypes.DirectConnectGatewayAssociationProposal?

    public init (
        directConnectGatewayAssociationProposal: DirectConnectClientTypes.DirectConnectGatewayAssociationProposal? = nil
    )
    {
        self.directConnectGatewayAssociationProposal = directConnectGatewayAssociationProposal
    }
}

struct DeleteDirectConnectGatewayAssociationProposalOutputResponseBody: Swift.Equatable {
    let directConnectGatewayAssociationProposal: DirectConnectClientTypes.DirectConnectGatewayAssociationProposal?
}

extension DeleteDirectConnectGatewayAssociationProposalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayAssociationProposal
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayAssociationProposalDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.DirectConnectGatewayAssociationProposal.self, forKey: .directConnectGatewayAssociationProposal)
        directConnectGatewayAssociationProposal = directConnectGatewayAssociationProposalDecoded
    }
}

extension DeleteDirectConnectGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directConnectGatewayId = self.directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
    }
}

extension DeleteDirectConnectGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDirectConnectGatewayInput: Swift.Equatable {
    /// The ID of the Direct Connect gateway.
    /// This member is required.
    public var directConnectGatewayId: Swift.String?

    public init (
        directConnectGatewayId: Swift.String? = nil
    )
    {
        self.directConnectGatewayId = directConnectGatewayId
    }
}

struct DeleteDirectConnectGatewayInputBody: Swift.Equatable {
    let directConnectGatewayId: Swift.String?
}

extension DeleteDirectConnectGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
    }
}

extension DeleteDirectConnectGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDirectConnectGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDirectConnectGatewayOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDirectConnectGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteDirectConnectGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGateway = output.directConnectGateway
        } else {
            self.directConnectGateway = nil
        }
    }
}

public struct DeleteDirectConnectGatewayOutputResponse: Swift.Equatable {
    /// The Direct Connect gateway.
    public var directConnectGateway: DirectConnectClientTypes.DirectConnectGateway?

    public init (
        directConnectGateway: DirectConnectClientTypes.DirectConnectGateway? = nil
    )
    {
        self.directConnectGateway = directConnectGateway
    }
}

struct DeleteDirectConnectGatewayOutputResponseBody: Swift.Equatable {
    let directConnectGateway: DirectConnectClientTypes.DirectConnectGateway?
}

extension DeleteDirectConnectGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGateway
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.DirectConnectGateway.self, forKey: .directConnectGateway)
        directConnectGateway = directConnectGatewayDecoded
    }
}

extension DeleteInterconnectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interconnectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interconnectId = self.interconnectId {
            try encodeContainer.encode(interconnectId, forKey: .interconnectId)
        }
    }
}

extension DeleteInterconnectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteInterconnectInput: Swift.Equatable {
    /// The ID of the interconnect.
    /// This member is required.
    public var interconnectId: Swift.String?

    public init (
        interconnectId: Swift.String? = nil
    )
    {
        self.interconnectId = interconnectId
    }
}

struct DeleteInterconnectInputBody: Swift.Equatable {
    let interconnectId: Swift.String?
}

extension DeleteInterconnectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interconnectId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interconnectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interconnectId)
        interconnectId = interconnectIdDecoded
    }
}

extension DeleteInterconnectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInterconnectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteInterconnectOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInterconnectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteInterconnectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.interconnectState = output.interconnectState
        } else {
            self.interconnectState = nil
        }
    }
}

public struct DeleteInterconnectOutputResponse: Swift.Equatable {
    /// The state of the interconnect. The following are the possible values:
    ///
    /// * requested: The initial state of an interconnect. The interconnect stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The interconnect is approved, and is being initialized.
    ///
    /// * available: The network link is up, and the interconnect is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The interconnect is being deleted.
    ///
    /// * deleted: The interconnect is deleted.
    ///
    /// * unknown: The state of the interconnect is not available.
    public var interconnectState: DirectConnectClientTypes.InterconnectState?

    public init (
        interconnectState: DirectConnectClientTypes.InterconnectState? = nil
    )
    {
        self.interconnectState = interconnectState
    }
}

struct DeleteInterconnectOutputResponseBody: Swift.Equatable {
    let interconnectState: DirectConnectClientTypes.InterconnectState?
}

extension DeleteInterconnectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interconnectState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interconnectStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.InterconnectState.self, forKey: .interconnectState)
        interconnectState = interconnectStateDecoded
    }
}

extension DeleteLagInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lagId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lagId = self.lagId {
            try encodeContainer.encode(lagId, forKey: .lagId)
        }
    }
}

extension DeleteLagInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteLagInput: Swift.Equatable {
    /// The ID of the LAG.
    /// This member is required.
    public var lagId: Swift.String?

    public init (
        lagId: Swift.String? = nil
    )
    {
        self.lagId = lagId
    }
}

struct DeleteLagInputBody: Swift.Equatable {
    let lagId: Swift.String?
}

extension DeleteLagInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lagId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
    }
}

extension DeleteLagOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLagOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteLagOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLagOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteLagOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allowsHostedConnections = output.allowsHostedConnections
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.awsLogicalDeviceId = output.awsLogicalDeviceId
            self.connections = output.connections
            self.connectionsBandwidth = output.connectionsBandwidth
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.lagName = output.lagName
            self.lagState = output.lagState
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.minimumLinks = output.minimumLinks
            self.numberOfConnections = output.numberOfConnections
            self.ownerAccount = output.ownerAccount
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
        } else {
            self.allowsHostedConnections = false
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.awsLogicalDeviceId = nil
            self.connections = nil
            self.connectionsBandwidth = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.lagName = nil
            self.lagState = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.minimumLinks = 0
            self.numberOfConnections = 0
            self.ownerAccount = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
        }
    }
}

/// Information about a link aggregation group (LAG).
public struct DeleteLagOutputResponse: Swift.Equatable {
    /// Indicates whether the LAG can host other connections.
    public var allowsHostedConnections: Swift.Bool
    /// The Direct Connect endpoint that hosts the LAG.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that hosts the LAG.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The connections bundled by the LAG.
    public var connections: [DirectConnectClientTypes.Connection]?
    /// The individual bandwidth of the physical connections bundled by the LAG. The possible values are 1Gbps and 10Gbps.
    public var connectionsBandwidth: Swift.String?
    /// The LAG MAC Security (MACsec) encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the LAG supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames (9001 MTU) are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The name of the LAG.
    public var lagName: Swift.String?
    /// The state of the LAG. The following are the possible values:
    ///
    /// * requested: The initial state of a LAG. The LAG stays in the requested state until the Letter of Authorization (LOA) is available.
    ///
    /// * pending: The LAG has been approved and is being initialized.
    ///
    /// * available: The network link is established and the LAG is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The LAG is being deleted.
    ///
    /// * deleted: The LAG is deleted.
    ///
    /// * unknown: The state of the LAG is not available.
    public var lagState: DirectConnectClientTypes.LagState?
    /// The location of the LAG.
    public var location: Swift.String?
    /// Indicates whether the LAG supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the LAG.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The minimum number of physical dedicated connections that must be operational for the LAG itself to be operational.
    public var minimumLinks: Swift.Int
    /// The number of physical dedicated connections bundled by the LAG, up to a maximum of 10.
    public var numberOfConnections: Swift.Int
    /// The ID of the Amazon Web Services account that owns the LAG.
    public var ownerAccount: Swift.String?
    /// The name of the service provider associated with the LAG.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the LAG.
    public var tags: [DirectConnectClientTypes.Tag]?

    public init (
        allowsHostedConnections: Swift.Bool = false,
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        connections: [DirectConnectClientTypes.Connection]? = nil,
        connectionsBandwidth: Swift.String? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        lagName: Swift.String? = nil,
        lagState: DirectConnectClientTypes.LagState? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        minimumLinks: Swift.Int = 0,
        numberOfConnections: Swift.Int = 0,
        ownerAccount: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil
    )
    {
        self.allowsHostedConnections = allowsHostedConnections
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.connections = connections
        self.connectionsBandwidth = connectionsBandwidth
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.lagName = lagName
        self.lagState = lagState
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.minimumLinks = minimumLinks
        self.numberOfConnections = numberOfConnections
        self.ownerAccount = ownerAccount
        self.providerName = providerName
        self.region = region
        self.tags = tags
    }
}

struct DeleteLagOutputResponseBody: Swift.Equatable {
    let connectionsBandwidth: Swift.String?
    let numberOfConnections: Swift.Int
    let lagId: Swift.String?
    let ownerAccount: Swift.String?
    let lagName: Swift.String?
    let lagState: DirectConnectClientTypes.LagState?
    let location: Swift.String?
    let region: Swift.String?
    let minimumLinks: Swift.Int
    let awsDevice: Swift.String?
    let awsDeviceV2: Swift.String?
    let awsLogicalDeviceId: Swift.String?
    let connections: [DirectConnectClientTypes.Connection]?
    let allowsHostedConnections: Swift.Bool
    let jumboFrameCapable: Swift.Bool?
    let hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    let tags: [DirectConnectClientTypes.Tag]?
    let providerName: Swift.String?
    let macSecCapable: Swift.Bool?
    let encryptionMode: Swift.String?
    let macSecKeys: [DirectConnectClientTypes.MacSecKey]?
}

extension DeleteLagOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowsHostedConnections
        case awsDevice
        case awsDeviceV2
        case awsLogicalDeviceId
        case connections
        case connectionsBandwidth
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case lagName
        case lagState
        case location
        case macSecCapable
        case macSecKeys
        case minimumLinks
        case numberOfConnections
        case ownerAccount
        case providerName
        case region
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsBandwidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionsBandwidth)
        connectionsBandwidth = connectionsBandwidthDecoded
        let numberOfConnectionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfConnections) ?? 0
        numberOfConnections = numberOfConnectionsDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let lagNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagName)
        lagName = lagNameDecoded
        let lagStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.LagState.self, forKey: .lagState)
        lagState = lagStateDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let minimumLinksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumLinks) ?? 0
        minimumLinks = minimumLinksDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let connectionsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Connection?].self, forKey: .connections)
        var connectionsDecoded0:[DirectConnectClientTypes.Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [DirectConnectClientTypes.Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
        let allowsHostedConnectionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowsHostedConnections) ?? false
        allowsHostedConnections = allowsHostedConnectionsDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[DirectConnectClientTypes.MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [DirectConnectClientTypes.MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

extension DeleteVirtualInterfaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualInterfaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let virtualInterfaceId = self.virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

extension DeleteVirtualInterfaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteVirtualInterfaceInput: Swift.Equatable {
    /// The ID of the virtual interface.
    /// This member is required.
    public var virtualInterfaceId: Swift.String?

    public init (
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct DeleteVirtualInterfaceInputBody: Swift.Equatable {
    let virtualInterfaceId: Swift.String?
}

extension DeleteVirtualInterfaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualInterfaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
    }
}

extension DeleteVirtualInterfaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVirtualInterfaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVirtualInterfaceOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVirtualInterfaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterfaceState = output.virtualInterfaceState
        } else {
            self.virtualInterfaceState = nil
        }
    }
}

public struct DeleteVirtualInterfaceOutputResponse: Swift.Equatable {
    /// The state of the virtual interface. The following are the possible values:
    ///
    /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
    ///
    /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
    ///
    /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
    ///
    /// * available: A virtual interface that is able to forward traffic.
    ///
    /// * down: A virtual interface that is BGP down.
    ///
    /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
    ///
    /// * deleted: A virtual interface that cannot forward traffic.
    ///
    /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
    ///
    /// * unknown: The state of the virtual interface is not available.
    public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?

    public init (
        virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil
    )
    {
        self.virtualInterfaceState = virtualInterfaceState
    }
}

struct DeleteVirtualInterfaceOutputResponseBody: Swift.Equatable {
    let virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
}

extension DeleteVirtualInterfaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualInterfaceState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
    }
}

extension DescribeConnectionLoaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case loaContentType
        case providerName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let loaContentType = self.loaContentType {
            try encodeContainer.encode(loaContentType.rawValue, forKey: .loaContentType)
        }
        if let providerName = self.providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
    }
}

extension DescribeConnectionLoaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConnectionLoaInput: Swift.Equatable {
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The standard media type for the LOA-CFA document. The only supported value is application/pdf.
    public var loaContentType: DirectConnectClientTypes.LoaContentType?
    /// The name of the APN partner or service provider who establishes connectivity on your behalf. If you specify this parameter, the LOA-CFA lists the provider name alongside your company name as the requester of the cross connect.
    public var providerName: Swift.String?

    public init (
        connectionId: Swift.String? = nil,
        loaContentType: DirectConnectClientTypes.LoaContentType? = nil,
        providerName: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.loaContentType = loaContentType
        self.providerName = providerName
    }
}

struct DescribeConnectionLoaInputBody: Swift.Equatable {
    let connectionId: Swift.String?
    let providerName: Swift.String?
    let loaContentType: DirectConnectClientTypes.LoaContentType?
}

extension DescribeConnectionLoaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case loaContentType
        case providerName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let loaContentTypeDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.LoaContentType.self, forKey: .loaContentType)
        loaContentType = loaContentTypeDecoded
    }
}

extension DescribeConnectionLoaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectionLoaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeConnectionLoaOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectionLoaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeConnectionLoaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loa = output.loa
        } else {
            self.loa = nil
        }
    }
}

public struct DescribeConnectionLoaOutputResponse: Swift.Equatable {
    /// The Letter of Authorization - Connecting Facility Assignment (LOA-CFA).
    public var loa: DirectConnectClientTypes.Loa?

    public init (
        loa: DirectConnectClientTypes.Loa? = nil
    )
    {
        self.loa = loa
    }
}

struct DescribeConnectionLoaOutputResponseBody: Swift.Equatable {
    let loa: DirectConnectClientTypes.Loa?
}

extension DescribeConnectionLoaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loa
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loaDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.Loa.self, forKey: .loa)
        loa = loaDecoded
    }
}

extension DescribeConnectionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
    }
}

extension DescribeConnectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConnectionsInput: Swift.Equatable {
    /// The ID of the connection.
    public var connectionId: Swift.String?

    public init (
        connectionId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

struct DescribeConnectionsInputBody: Swift.Equatable {
    let connectionId: Swift.String?
}

extension DescribeConnectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
    }
}

extension DescribeConnectionsOnInterconnectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interconnectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interconnectId = self.interconnectId {
            try encodeContainer.encode(interconnectId, forKey: .interconnectId)
        }
    }
}

extension DescribeConnectionsOnInterconnectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConnectionsOnInterconnectInput: Swift.Equatable {
    /// The ID of the interconnect.
    /// This member is required.
    public var interconnectId: Swift.String?

    public init (
        interconnectId: Swift.String? = nil
    )
    {
        self.interconnectId = interconnectId
    }
}

struct DescribeConnectionsOnInterconnectInputBody: Swift.Equatable {
    let interconnectId: Swift.String?
}

extension DescribeConnectionsOnInterconnectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interconnectId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interconnectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interconnectId)
        interconnectId = interconnectIdDecoded
    }
}

extension DescribeConnectionsOnInterconnectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectionsOnInterconnectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeConnectionsOnInterconnectOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectionsOnInterconnectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeConnectionsOnInterconnectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connections = output.connections
        } else {
            self.connections = nil
        }
    }
}

public struct DescribeConnectionsOnInterconnectOutputResponse: Swift.Equatable {
    /// The connections.
    public var connections: [DirectConnectClientTypes.Connection]?

    public init (
        connections: [DirectConnectClientTypes.Connection]? = nil
    )
    {
        self.connections = connections
    }
}

struct DescribeConnectionsOnInterconnectOutputResponseBody: Swift.Equatable {
    let connections: [DirectConnectClientTypes.Connection]?
}

extension DescribeConnectionsOnInterconnectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connections
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Connection?].self, forKey: .connections)
        var connectionsDecoded0:[DirectConnectClientTypes.Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [DirectConnectClientTypes.Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
    }
}

extension DescribeConnectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeConnectionsOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connections = output.connections
        } else {
            self.connections = nil
        }
    }
}

public struct DescribeConnectionsOutputResponse: Swift.Equatable {
    /// The connections.
    public var connections: [DirectConnectClientTypes.Connection]?

    public init (
        connections: [DirectConnectClientTypes.Connection]? = nil
    )
    {
        self.connections = connections
    }
}

struct DescribeConnectionsOutputResponseBody: Swift.Equatable {
    let connections: [DirectConnectClientTypes.Connection]?
}

extension DescribeConnectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connections
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Connection?].self, forKey: .connections)
        var connectionsDecoded0:[DirectConnectClientTypes.Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [DirectConnectClientTypes.Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
    }
}

extension DescribeCustomerMetadataInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeCustomerMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCustomerMetadataInput: Swift.Equatable {

    public init () { }
}

struct DescribeCustomerMetadataInputBody: Swift.Equatable {
}

extension DescribeCustomerMetadataInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeCustomerMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCustomerMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeCustomerMetadataOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomerMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeCustomerMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.agreements = output.agreements
            self.nniPartnerType = output.nniPartnerType
        } else {
            self.agreements = nil
            self.nniPartnerType = nil
        }
    }
}

public struct DescribeCustomerMetadataOutputResponse: Swift.Equatable {
    /// The list of customer agreements.
    public var agreements: [DirectConnectClientTypes.CustomerAgreement]?
    /// The type of network-to-network interface (NNI) partner. The partner type will be one of the following:
    ///
    /// * V1: This partner can only allocate 50Mbps, 100Mbps, 200Mbps, 300Mbps, 400Mbps, or 500Mbps subgigabit connections.
    ///
    /// * V2: This partner can only allocate 1GB, 2GB, 5GB, or 10GB hosted connections.
    ///
    /// * nonPartner: The customer is not a partner.
    public var nniPartnerType: DirectConnectClientTypes.NniPartnerType?

    public init (
        agreements: [DirectConnectClientTypes.CustomerAgreement]? = nil,
        nniPartnerType: DirectConnectClientTypes.NniPartnerType? = nil
    )
    {
        self.agreements = agreements
        self.nniPartnerType = nniPartnerType
    }
}

struct DescribeCustomerMetadataOutputResponseBody: Swift.Equatable {
    let agreements: [DirectConnectClientTypes.CustomerAgreement]?
    let nniPartnerType: DirectConnectClientTypes.NniPartnerType?
}

extension DescribeCustomerMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreements
        case nniPartnerType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agreementsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.CustomerAgreement?].self, forKey: .agreements)
        var agreementsDecoded0:[DirectConnectClientTypes.CustomerAgreement]? = nil
        if let agreementsContainer = agreementsContainer {
            agreementsDecoded0 = [DirectConnectClientTypes.CustomerAgreement]()
            for structure0 in agreementsContainer {
                if let structure0 = structure0 {
                    agreementsDecoded0?.append(structure0)
                }
            }
        }
        agreements = agreementsDecoded0
        let nniPartnerTypeDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.NniPartnerType.self, forKey: .nniPartnerType)
        nniPartnerType = nniPartnerTypeDecoded
    }
}

extension DescribeDirectConnectGatewayAssociationProposalsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedGatewayId
        case directConnectGatewayId
        case maxResults
        case nextToken
        case proposalId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedGatewayId = self.associatedGatewayId {
            try encodeContainer.encode(associatedGatewayId, forKey: .associatedGatewayId)
        }
        if let directConnectGatewayId = self.directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let proposalId = self.proposalId {
            try encodeContainer.encode(proposalId, forKey: .proposalId)
        }
    }
}

extension DescribeDirectConnectGatewayAssociationProposalsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDirectConnectGatewayAssociationProposalsInput: Swift.Equatable {
    /// The ID of the associated gateway.
    public var associatedGatewayId: Swift.String?
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value. If MaxResults is given a value larger than 100, only 100 results are returned.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the proposal.
    public var proposalId: Swift.String?

    public init (
        associatedGatewayId: Swift.String? = nil,
        directConnectGatewayId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        proposalId: Swift.String? = nil
    )
    {
        self.associatedGatewayId = associatedGatewayId
        self.directConnectGatewayId = directConnectGatewayId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.proposalId = proposalId
    }
}

struct DescribeDirectConnectGatewayAssociationProposalsInputBody: Swift.Equatable {
    let directConnectGatewayId: Swift.String?
    let proposalId: Swift.String?
    let associatedGatewayId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeDirectConnectGatewayAssociationProposalsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedGatewayId
        case directConnectGatewayId
        case maxResults
        case nextToken
        case proposalId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let proposalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proposalId)
        proposalId = proposalIdDecoded
        let associatedGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedGatewayId)
        associatedGatewayId = associatedGatewayIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDirectConnectGatewayAssociationProposalsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDirectConnectGatewayAssociationProposalsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDirectConnectGatewayAssociationProposalsOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDirectConnectGatewayAssociationProposalsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDirectConnectGatewayAssociationProposalsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGatewayAssociationProposals = output.directConnectGatewayAssociationProposals
            self.nextToken = output.nextToken
        } else {
            self.directConnectGatewayAssociationProposals = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDirectConnectGatewayAssociationProposalsOutputResponse: Swift.Equatable {
    /// Describes the Direct Connect gateway association proposals.
    public var directConnectGatewayAssociationProposals: [DirectConnectClientTypes.DirectConnectGatewayAssociationProposal]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        directConnectGatewayAssociationProposals: [DirectConnectClientTypes.DirectConnectGatewayAssociationProposal]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directConnectGatewayAssociationProposals = directConnectGatewayAssociationProposals
        self.nextToken = nextToken
    }
}

struct DescribeDirectConnectGatewayAssociationProposalsOutputResponseBody: Swift.Equatable {
    let directConnectGatewayAssociationProposals: [DirectConnectClientTypes.DirectConnectGatewayAssociationProposal]?
    let nextToken: Swift.String?
}

extension DescribeDirectConnectGatewayAssociationProposalsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayAssociationProposals
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayAssociationProposalsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.DirectConnectGatewayAssociationProposal?].self, forKey: .directConnectGatewayAssociationProposals)
        var directConnectGatewayAssociationProposalsDecoded0:[DirectConnectClientTypes.DirectConnectGatewayAssociationProposal]? = nil
        if let directConnectGatewayAssociationProposalsContainer = directConnectGatewayAssociationProposalsContainer {
            directConnectGatewayAssociationProposalsDecoded0 = [DirectConnectClientTypes.DirectConnectGatewayAssociationProposal]()
            for structure0 in directConnectGatewayAssociationProposalsContainer {
                if let structure0 = structure0 {
                    directConnectGatewayAssociationProposalsDecoded0?.append(structure0)
                }
            }
        }
        directConnectGatewayAssociationProposals = directConnectGatewayAssociationProposalsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDirectConnectGatewayAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedGatewayId
        case associationId
        case directConnectGatewayId
        case maxResults
        case nextToken
        case virtualGatewayId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedGatewayId = self.associatedGatewayId {
            try encodeContainer.encode(associatedGatewayId, forKey: .associatedGatewayId)
        }
        if let associationId = self.associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let directConnectGatewayId = self.directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let virtualGatewayId = self.virtualGatewayId {
            try encodeContainer.encode(virtualGatewayId, forKey: .virtualGatewayId)
        }
    }
}

extension DescribeDirectConnectGatewayAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDirectConnectGatewayAssociationsInput: Swift.Equatable {
    /// The ID of the associated gateway.
    public var associatedGatewayId: Swift.String?
    /// The ID of the Direct Connect gateway association.
    public var associationId: Swift.String?
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value. If MaxResults is given a value larger than 100, only 100 results are returned.
    public var maxResults: Swift.Int?
    /// The token provided in the previous call to retrieve the next page.
    public var nextToken: Swift.String?
    /// The ID of the virtual private gateway or transit gateway.
    public var virtualGatewayId: Swift.String?

    public init (
        associatedGatewayId: Swift.String? = nil,
        associationId: Swift.String? = nil,
        directConnectGatewayId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        virtualGatewayId: Swift.String? = nil
    )
    {
        self.associatedGatewayId = associatedGatewayId
        self.associationId = associationId
        self.directConnectGatewayId = directConnectGatewayId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.virtualGatewayId = virtualGatewayId
    }
}

struct DescribeDirectConnectGatewayAssociationsInputBody: Swift.Equatable {
    let associationId: Swift.String?
    let associatedGatewayId: Swift.String?
    let directConnectGatewayId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let virtualGatewayId: Swift.String?
}

extension DescribeDirectConnectGatewayAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedGatewayId
        case associationId
        case directConnectGatewayId
        case maxResults
        case nextToken
        case virtualGatewayId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associatedGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedGatewayId)
        associatedGatewayId = associatedGatewayIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
    }
}

extension DescribeDirectConnectGatewayAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDirectConnectGatewayAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDirectConnectGatewayAssociationsOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDirectConnectGatewayAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDirectConnectGatewayAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGatewayAssociations = output.directConnectGatewayAssociations
            self.nextToken = output.nextToken
        } else {
            self.directConnectGatewayAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDirectConnectGatewayAssociationsOutputResponse: Swift.Equatable {
    /// Information about the associations.
    public var directConnectGatewayAssociations: [DirectConnectClientTypes.DirectConnectGatewayAssociation]?
    /// The token to retrieve the next page.
    public var nextToken: Swift.String?

    public init (
        directConnectGatewayAssociations: [DirectConnectClientTypes.DirectConnectGatewayAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directConnectGatewayAssociations = directConnectGatewayAssociations
        self.nextToken = nextToken
    }
}

struct DescribeDirectConnectGatewayAssociationsOutputResponseBody: Swift.Equatable {
    let directConnectGatewayAssociations: [DirectConnectClientTypes.DirectConnectGatewayAssociation]?
    let nextToken: Swift.String?
}

extension DescribeDirectConnectGatewayAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayAssociations
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayAssociationsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.DirectConnectGatewayAssociation?].self, forKey: .directConnectGatewayAssociations)
        var directConnectGatewayAssociationsDecoded0:[DirectConnectClientTypes.DirectConnectGatewayAssociation]? = nil
        if let directConnectGatewayAssociationsContainer = directConnectGatewayAssociationsContainer {
            directConnectGatewayAssociationsDecoded0 = [DirectConnectClientTypes.DirectConnectGatewayAssociation]()
            for structure0 in directConnectGatewayAssociationsContainer {
                if let structure0 = structure0 {
                    directConnectGatewayAssociationsDecoded0?.append(structure0)
                }
            }
        }
        directConnectGatewayAssociations = directConnectGatewayAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDirectConnectGatewayAttachmentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayId
        case maxResults
        case nextToken
        case virtualInterfaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directConnectGatewayId = self.directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let virtualInterfaceId = self.virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

extension DescribeDirectConnectGatewayAttachmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDirectConnectGatewayAttachmentsInput: Swift.Equatable {
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value. If MaxResults is given a value larger than 100, only 100 results are returned.
    public var maxResults: Swift.Int?
    /// The token provided in the previous call to retrieve the next page.
    public var nextToken: Swift.String?
    /// The ID of the virtual interface.
    public var virtualInterfaceId: Swift.String?

    public init (
        directConnectGatewayId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.directConnectGatewayId = directConnectGatewayId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct DescribeDirectConnectGatewayAttachmentsInputBody: Swift.Equatable {
    let directConnectGatewayId: Swift.String?
    let virtualInterfaceId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeDirectConnectGatewayAttachmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayId
        case maxResults
        case nextToken
        case virtualInterfaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDirectConnectGatewayAttachmentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDirectConnectGatewayAttachmentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDirectConnectGatewayAttachmentsOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDirectConnectGatewayAttachmentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDirectConnectGatewayAttachmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGatewayAttachments = output.directConnectGatewayAttachments
            self.nextToken = output.nextToken
        } else {
            self.directConnectGatewayAttachments = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDirectConnectGatewayAttachmentsOutputResponse: Swift.Equatable {
    /// The attachments.
    public var directConnectGatewayAttachments: [DirectConnectClientTypes.DirectConnectGatewayAttachment]?
    /// The token to retrieve the next page.
    public var nextToken: Swift.String?

    public init (
        directConnectGatewayAttachments: [DirectConnectClientTypes.DirectConnectGatewayAttachment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directConnectGatewayAttachments = directConnectGatewayAttachments
        self.nextToken = nextToken
    }
}

struct DescribeDirectConnectGatewayAttachmentsOutputResponseBody: Swift.Equatable {
    let directConnectGatewayAttachments: [DirectConnectClientTypes.DirectConnectGatewayAttachment]?
    let nextToken: Swift.String?
}

extension DescribeDirectConnectGatewayAttachmentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayAttachments
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayAttachmentsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.DirectConnectGatewayAttachment?].self, forKey: .directConnectGatewayAttachments)
        var directConnectGatewayAttachmentsDecoded0:[DirectConnectClientTypes.DirectConnectGatewayAttachment]? = nil
        if let directConnectGatewayAttachmentsContainer = directConnectGatewayAttachmentsContainer {
            directConnectGatewayAttachmentsDecoded0 = [DirectConnectClientTypes.DirectConnectGatewayAttachment]()
            for structure0 in directConnectGatewayAttachmentsContainer {
                if let structure0 = structure0 {
                    directConnectGatewayAttachmentsDecoded0?.append(structure0)
                }
            }
        }
        directConnectGatewayAttachments = directConnectGatewayAttachmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDirectConnectGatewaysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directConnectGatewayId = self.directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeDirectConnectGatewaysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDirectConnectGatewaysInput: Swift.Equatable {
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value. If MaxResults is given a value larger than 100, only 100 results are returned.
    public var maxResults: Swift.Int?
    /// The token provided in the previous call to retrieve the next page.
    public var nextToken: Swift.String?

    public init (
        directConnectGatewayId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directConnectGatewayId = directConnectGatewayId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeDirectConnectGatewaysInputBody: Swift.Equatable {
    let directConnectGatewayId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeDirectConnectGatewaysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayId
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDirectConnectGatewaysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDirectConnectGatewaysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDirectConnectGatewaysOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDirectConnectGatewaysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDirectConnectGatewaysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGateways = output.directConnectGateways
            self.nextToken = output.nextToken
        } else {
            self.directConnectGateways = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDirectConnectGatewaysOutputResponse: Swift.Equatable {
    /// The Direct Connect gateways.
    public var directConnectGateways: [DirectConnectClientTypes.DirectConnectGateway]?
    /// The token to retrieve the next page.
    public var nextToken: Swift.String?

    public init (
        directConnectGateways: [DirectConnectClientTypes.DirectConnectGateway]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directConnectGateways = directConnectGateways
        self.nextToken = nextToken
    }
}

struct DescribeDirectConnectGatewaysOutputResponseBody: Swift.Equatable {
    let directConnectGateways: [DirectConnectClientTypes.DirectConnectGateway]?
    let nextToken: Swift.String?
}

extension DescribeDirectConnectGatewaysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGateways
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewaysContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.DirectConnectGateway?].self, forKey: .directConnectGateways)
        var directConnectGatewaysDecoded0:[DirectConnectClientTypes.DirectConnectGateway]? = nil
        if let directConnectGatewaysContainer = directConnectGatewaysContainer {
            directConnectGatewaysDecoded0 = [DirectConnectClientTypes.DirectConnectGateway]()
            for structure0 in directConnectGatewaysContainer {
                if let structure0 = structure0 {
                    directConnectGatewaysDecoded0?.append(structure0)
                }
            }
        }
        directConnectGateways = directConnectGatewaysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeHostedConnectionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
    }
}

extension DescribeHostedConnectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeHostedConnectionsInput: Swift.Equatable {
    /// The ID of the interconnect or LAG.
    /// This member is required.
    public var connectionId: Swift.String?

    public init (
        connectionId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

struct DescribeHostedConnectionsInputBody: Swift.Equatable {
    let connectionId: Swift.String?
}

extension DescribeHostedConnectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
    }
}

extension DescribeHostedConnectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHostedConnectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeHostedConnectionsOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHostedConnectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeHostedConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connections = output.connections
        } else {
            self.connections = nil
        }
    }
}

public struct DescribeHostedConnectionsOutputResponse: Swift.Equatable {
    /// The connections.
    public var connections: [DirectConnectClientTypes.Connection]?

    public init (
        connections: [DirectConnectClientTypes.Connection]? = nil
    )
    {
        self.connections = connections
    }
}

struct DescribeHostedConnectionsOutputResponseBody: Swift.Equatable {
    let connections: [DirectConnectClientTypes.Connection]?
}

extension DescribeHostedConnectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connections
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Connection?].self, forKey: .connections)
        var connectionsDecoded0:[DirectConnectClientTypes.Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [DirectConnectClientTypes.Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
    }
}

extension DescribeInterconnectLoaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interconnectId
        case loaContentType
        case providerName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interconnectId = self.interconnectId {
            try encodeContainer.encode(interconnectId, forKey: .interconnectId)
        }
        if let loaContentType = self.loaContentType {
            try encodeContainer.encode(loaContentType.rawValue, forKey: .loaContentType)
        }
        if let providerName = self.providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
    }
}

extension DescribeInterconnectLoaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeInterconnectLoaInput: Swift.Equatable {
    /// The ID of the interconnect.
    /// This member is required.
    public var interconnectId: Swift.String?
    /// The standard media type for the LOA-CFA document. The only supported value is application/pdf.
    public var loaContentType: DirectConnectClientTypes.LoaContentType?
    /// The name of the service provider who establishes connectivity on your behalf. If you supply this parameter, the LOA-CFA lists the provider name alongside your company name as the requester of the cross connect.
    public var providerName: Swift.String?

    public init (
        interconnectId: Swift.String? = nil,
        loaContentType: DirectConnectClientTypes.LoaContentType? = nil,
        providerName: Swift.String? = nil
    )
    {
        self.interconnectId = interconnectId
        self.loaContentType = loaContentType
        self.providerName = providerName
    }
}

struct DescribeInterconnectLoaInputBody: Swift.Equatable {
    let interconnectId: Swift.String?
    let providerName: Swift.String?
    let loaContentType: DirectConnectClientTypes.LoaContentType?
}

extension DescribeInterconnectLoaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interconnectId
        case loaContentType
        case providerName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interconnectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interconnectId)
        interconnectId = interconnectIdDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let loaContentTypeDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.LoaContentType.self, forKey: .loaContentType)
        loaContentType = loaContentTypeDecoded
    }
}

extension DescribeInterconnectLoaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInterconnectLoaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeInterconnectLoaOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInterconnectLoaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeInterconnectLoaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loa = output.loa
        } else {
            self.loa = nil
        }
    }
}

public struct DescribeInterconnectLoaOutputResponse: Swift.Equatable {
    /// The Letter of Authorization - Connecting Facility Assignment (LOA-CFA).
    public var loa: DirectConnectClientTypes.Loa?

    public init (
        loa: DirectConnectClientTypes.Loa? = nil
    )
    {
        self.loa = loa
    }
}

struct DescribeInterconnectLoaOutputResponseBody: Swift.Equatable {
    let loa: DirectConnectClientTypes.Loa?
}

extension DescribeInterconnectLoaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loa
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loaDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.Loa.self, forKey: .loa)
        loa = loaDecoded
    }
}

extension DescribeInterconnectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interconnectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interconnectId = self.interconnectId {
            try encodeContainer.encode(interconnectId, forKey: .interconnectId)
        }
    }
}

extension DescribeInterconnectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeInterconnectsInput: Swift.Equatable {
    /// The ID of the interconnect.
    public var interconnectId: Swift.String?

    public init (
        interconnectId: Swift.String? = nil
    )
    {
        self.interconnectId = interconnectId
    }
}

struct DescribeInterconnectsInputBody: Swift.Equatable {
    let interconnectId: Swift.String?
}

extension DescribeInterconnectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interconnectId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interconnectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interconnectId)
        interconnectId = interconnectIdDecoded
    }
}

extension DescribeInterconnectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInterconnectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeInterconnectsOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInterconnectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeInterconnectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.interconnects = output.interconnects
        } else {
            self.interconnects = nil
        }
    }
}

public struct DescribeInterconnectsOutputResponse: Swift.Equatable {
    /// The interconnects.
    public var interconnects: [DirectConnectClientTypes.Interconnect]?

    public init (
        interconnects: [DirectConnectClientTypes.Interconnect]? = nil
    )
    {
        self.interconnects = interconnects
    }
}

struct DescribeInterconnectsOutputResponseBody: Swift.Equatable {
    let interconnects: [DirectConnectClientTypes.Interconnect]?
}

extension DescribeInterconnectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interconnects
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interconnectsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Interconnect?].self, forKey: .interconnects)
        var interconnectsDecoded0:[DirectConnectClientTypes.Interconnect]? = nil
        if let interconnectsContainer = interconnectsContainer {
            interconnectsDecoded0 = [DirectConnectClientTypes.Interconnect]()
            for structure0 in interconnectsContainer {
                if let structure0 = structure0 {
                    interconnectsDecoded0?.append(structure0)
                }
            }
        }
        interconnects = interconnectsDecoded0
    }
}

extension DescribeLagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lagId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lagId = self.lagId {
            try encodeContainer.encode(lagId, forKey: .lagId)
        }
    }
}

extension DescribeLagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeLagsInput: Swift.Equatable {
    /// The ID of the LAG.
    public var lagId: Swift.String?

    public init (
        lagId: Swift.String? = nil
    )
    {
        self.lagId = lagId
    }
}

struct DescribeLagsInputBody: Swift.Equatable {
    let lagId: Swift.String?
}

extension DescribeLagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lagId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
    }
}

extension DescribeLagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeLagsOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeLagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lags = output.lags
        } else {
            self.lags = nil
        }
    }
}

public struct DescribeLagsOutputResponse: Swift.Equatable {
    /// The LAGs.
    public var lags: [DirectConnectClientTypes.Lag]?

    public init (
        lags: [DirectConnectClientTypes.Lag]? = nil
    )
    {
        self.lags = lags
    }
}

struct DescribeLagsOutputResponseBody: Swift.Equatable {
    let lags: [DirectConnectClientTypes.Lag]?
}

extension DescribeLagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Lag?].self, forKey: .lags)
        var lagsDecoded0:[DirectConnectClientTypes.Lag]? = nil
        if let lagsContainer = lagsContainer {
            lagsDecoded0 = [DirectConnectClientTypes.Lag]()
            for structure0 in lagsContainer {
                if let structure0 = structure0 {
                    lagsDecoded0?.append(structure0)
                }
            }
        }
        lags = lagsDecoded0
    }
}

extension DescribeLoaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case loaContentType
        case providerName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let loaContentType = self.loaContentType {
            try encodeContainer.encode(loaContentType.rawValue, forKey: .loaContentType)
        }
        if let providerName = self.providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
    }
}

extension DescribeLoaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeLoaInput: Swift.Equatable {
    /// The ID of a connection, LAG, or interconnect.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The standard media type for the LOA-CFA document. The only supported value is application/pdf.
    public var loaContentType: DirectConnectClientTypes.LoaContentType?
    /// The name of the service provider who establishes connectivity on your behalf. If you specify this parameter, the LOA-CFA lists the provider name alongside your company name as the requester of the cross connect.
    public var providerName: Swift.String?

    public init (
        connectionId: Swift.String? = nil,
        loaContentType: DirectConnectClientTypes.LoaContentType? = nil,
        providerName: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.loaContentType = loaContentType
        self.providerName = providerName
    }
}

struct DescribeLoaInputBody: Swift.Equatable {
    let connectionId: Swift.String?
    let providerName: Swift.String?
    let loaContentType: DirectConnectClientTypes.LoaContentType?
}

extension DescribeLoaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case loaContentType
        case providerName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let loaContentTypeDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.LoaContentType.self, forKey: .loaContentType)
        loaContentType = loaContentTypeDecoded
    }
}

extension DescribeLoaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLoaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeLoaOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeLoaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loaContent = output.loaContent
            self.loaContentType = output.loaContentType
        } else {
            self.loaContent = nil
            self.loaContentType = nil
        }
    }
}

/// Information about a Letter of Authorization - Connecting Facility Assignment (LOA-CFA) for a connection.
public struct DescribeLoaOutputResponse: Swift.Equatable {
    /// The binary contents of the LOA-CFA document.
    public var loaContent: ClientRuntime.Data?
    /// The standard media type for the LOA-CFA document. The only supported value is application/pdf.
    public var loaContentType: DirectConnectClientTypes.LoaContentType?

    public init (
        loaContent: ClientRuntime.Data? = nil,
        loaContentType: DirectConnectClientTypes.LoaContentType? = nil
    )
    {
        self.loaContent = loaContent
        self.loaContentType = loaContentType
    }
}

struct DescribeLoaOutputResponseBody: Swift.Equatable {
    let loaContent: ClientRuntime.Data?
    let loaContentType: DirectConnectClientTypes.LoaContentType?
}

extension DescribeLoaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loaContent
        case loaContentType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loaContentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .loaContent)
        loaContent = loaContentDecoded
        let loaContentTypeDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.LoaContentType.self, forKey: .loaContentType)
        loaContentType = loaContentTypeDecoded
    }
}

extension DescribeLocationsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeLocationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeLocationsInput: Swift.Equatable {

    public init () { }
}

struct DescribeLocationsInputBody: Swift.Equatable {
}

extension DescribeLocationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeLocationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLocationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeLocationsOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLocationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeLocationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.locations = output.locations
        } else {
            self.locations = nil
        }
    }
}

public struct DescribeLocationsOutputResponse: Swift.Equatable {
    /// The locations.
    public var locations: [DirectConnectClientTypes.Location]?

    public init (
        locations: [DirectConnectClientTypes.Location]? = nil
    )
    {
        self.locations = locations
    }
}

struct DescribeLocationsOutputResponseBody: Swift.Equatable {
    let locations: [DirectConnectClientTypes.Location]?
}

extension DescribeLocationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Location?].self, forKey: .locations)
        var locationsDecoded0:[DirectConnectClientTypes.Location]? = nil
        if let locationsContainer = locationsContainer {
            locationsDecoded0 = [DirectConnectClientTypes.Location]()
            for structure0 in locationsContainer {
                if let structure0 = structure0 {
                    locationsDecoded0?.append(structure0)
                }
            }
        }
        locations = locationsDecoded0
    }
}

extension DescribeRouterConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routerTypeIdentifier
        case virtualInterfaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let routerTypeIdentifier = self.routerTypeIdentifier {
            try encodeContainer.encode(routerTypeIdentifier, forKey: .routerTypeIdentifier)
        }
        if let virtualInterfaceId = self.virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

extension DescribeRouterConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Provides the details about a virtual interface's router.
public struct DescribeRouterConfigurationInput: Swift.Equatable {
    /// Identifies the router by a combination of vendor, platform, and software version. For example, CiscoSystemsInc-2900SeriesRouters-IOS124.
    public var routerTypeIdentifier: Swift.String?
    /// The ID of the virtual interface.
    /// This member is required.
    public var virtualInterfaceId: Swift.String?

    public init (
        routerTypeIdentifier: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.routerTypeIdentifier = routerTypeIdentifier
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct DescribeRouterConfigurationInputBody: Swift.Equatable {
    let virtualInterfaceId: Swift.String?
    let routerTypeIdentifier: Swift.String?
}

extension DescribeRouterConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routerTypeIdentifier
        case virtualInterfaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let routerTypeIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routerTypeIdentifier)
        routerTypeIdentifier = routerTypeIdentifierDecoded
    }
}

extension DescribeRouterConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRouterConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeRouterConfigurationOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRouterConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeRouterConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customerRouterConfig = output.customerRouterConfig
            self.router = output.router
            self.virtualInterfaceId = output.virtualInterfaceId
            self.virtualInterfaceName = output.virtualInterfaceName
        } else {
            self.customerRouterConfig = nil
            self.router = nil
            self.virtualInterfaceId = nil
            self.virtualInterfaceName = nil
        }
    }
}

public struct DescribeRouterConfigurationOutputResponse: Swift.Equatable {
    /// The customer router configuration.
    public var customerRouterConfig: Swift.String?
    /// The details about the router.
    public var router: DirectConnectClientTypes.RouterType?
    /// The ID assigned to the virtual interface.
    public var virtualInterfaceId: Swift.String?
    /// Provides the details about a virtual interface's router.
    public var virtualInterfaceName: Swift.String?

    public init (
        customerRouterConfig: Swift.String? = nil,
        router: DirectConnectClientTypes.RouterType? = nil,
        virtualInterfaceId: Swift.String? = nil,
        virtualInterfaceName: Swift.String? = nil
    )
    {
        self.customerRouterConfig = customerRouterConfig
        self.router = router
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
    }
}

struct DescribeRouterConfigurationOutputResponseBody: Swift.Equatable {
    let customerRouterConfig: Swift.String?
    let router: DirectConnectClientTypes.RouterType?
    let virtualInterfaceId: Swift.String?
    let virtualInterfaceName: Swift.String?
}

extension DescribeRouterConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerRouterConfig
        case router
        case virtualInterfaceId
        case virtualInterfaceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerRouterConfigDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerRouterConfig)
        customerRouterConfig = customerRouterConfigDecoded
        let routerDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.RouterType.self, forKey: .router)
        router = routerDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
    }
}

extension DescribeTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearn0 in resourceArns {
                try resourceArnsContainer.encode(resourcearn0)
            }
        }
    }
}

extension DescribeTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeTagsInput: Swift.Equatable {
    /// The Amazon Resource Names (ARNs) of the resources.
    /// This member is required.
    public var resourceArns: [Swift.String]?

    public init (
        resourceArns: [Swift.String]? = nil
    )
    {
        self.resourceArns = resourceArns
    }
}

struct DescribeTagsInputBody: Swift.Equatable {
    let resourceArns: [Swift.String]?
}

extension DescribeTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
    }
}

extension DescribeTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeTagsOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceTags = output.resourceTags
        } else {
            self.resourceTags = nil
        }
    }
}

public struct DescribeTagsOutputResponse: Swift.Equatable {
    /// Information about the tags.
    public var resourceTags: [DirectConnectClientTypes.ResourceTag]?

    public init (
        resourceTags: [DirectConnectClientTypes.ResourceTag]? = nil
    )
    {
        self.resourceTags = resourceTags
    }
}

struct DescribeTagsOutputResponseBody: Swift.Equatable {
    let resourceTags: [DirectConnectClientTypes.ResourceTag]?
}

extension DescribeTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceTags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[DirectConnectClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [DirectConnectClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
    }
}

extension DescribeVirtualGatewaysInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeVirtualGatewaysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeVirtualGatewaysInput: Swift.Equatable {

    public init () { }
}

struct DescribeVirtualGatewaysInputBody: Swift.Equatable {
}

extension DescribeVirtualGatewaysInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeVirtualGatewaysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVirtualGatewaysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeVirtualGatewaysOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVirtualGatewaysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeVirtualGatewaysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualGateways = output.virtualGateways
        } else {
            self.virtualGateways = nil
        }
    }
}

public struct DescribeVirtualGatewaysOutputResponse: Swift.Equatable {
    /// The virtual private gateways.
    public var virtualGateways: [DirectConnectClientTypes.VirtualGateway]?

    public init (
        virtualGateways: [DirectConnectClientTypes.VirtualGateway]? = nil
    )
    {
        self.virtualGateways = virtualGateways
    }
}

struct DescribeVirtualGatewaysOutputResponseBody: Swift.Equatable {
    let virtualGateways: [DirectConnectClientTypes.VirtualGateway]?
}

extension DescribeVirtualGatewaysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualGateways
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualGatewaysContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.VirtualGateway?].self, forKey: .virtualGateways)
        var virtualGatewaysDecoded0:[DirectConnectClientTypes.VirtualGateway]? = nil
        if let virtualGatewaysContainer = virtualGatewaysContainer {
            virtualGatewaysDecoded0 = [DirectConnectClientTypes.VirtualGateway]()
            for structure0 in virtualGatewaysContainer {
                if let structure0 = structure0 {
                    virtualGatewaysDecoded0?.append(structure0)
                }
            }
        }
        virtualGateways = virtualGatewaysDecoded0
    }
}

extension DescribeVirtualInterfacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case virtualInterfaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let virtualInterfaceId = self.virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

extension DescribeVirtualInterfacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeVirtualInterfacesInput: Swift.Equatable {
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The ID of the virtual interface.
    public var virtualInterfaceId: Swift.String?

    public init (
        connectionId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct DescribeVirtualInterfacesInputBody: Swift.Equatable {
    let connectionId: Swift.String?
    let virtualInterfaceId: Swift.String?
}

extension DescribeVirtualInterfacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case virtualInterfaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
    }
}

extension DescribeVirtualInterfacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVirtualInterfacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeVirtualInterfacesOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVirtualInterfacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeVirtualInterfacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterfaces = output.virtualInterfaces
        } else {
            self.virtualInterfaces = nil
        }
    }
}

public struct DescribeVirtualInterfacesOutputResponse: Swift.Equatable {
    /// The virtual interfaces
    public var virtualInterfaces: [DirectConnectClientTypes.VirtualInterface]?

    public init (
        virtualInterfaces: [DirectConnectClientTypes.VirtualInterface]? = nil
    )
    {
        self.virtualInterfaces = virtualInterfaces
    }
}

struct DescribeVirtualInterfacesOutputResponseBody: Swift.Equatable {
    let virtualInterfaces: [DirectConnectClientTypes.VirtualInterface]?
}

extension DescribeVirtualInterfacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualInterfaces
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfacesContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.VirtualInterface?].self, forKey: .virtualInterfaces)
        var virtualInterfacesDecoded0:[DirectConnectClientTypes.VirtualInterface]? = nil
        if let virtualInterfacesContainer = virtualInterfacesContainer {
            virtualInterfacesDecoded0 = [DirectConnectClientTypes.VirtualInterface]()
            for structure0 in virtualInterfacesContainer {
                if let structure0 = structure0 {
                    virtualInterfacesDecoded0?.append(structure0)
                }
            }
        }
        virtualInterfaces = virtualInterfacesDecoded0
    }
}

extension DirectConnectClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DirectConnectClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more parameters are not valid.
public struct DirectConnectClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DirectConnectClientExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DirectConnectClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DirectConnectClientTypes.DirectConnectGateway: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonSideAsn
        case directConnectGatewayId
        case directConnectGatewayName
        case directConnectGatewayState
        case ownerAccount
        case stateChangeError
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonSideAsn = self.amazonSideAsn {
            try encodeContainer.encode(amazonSideAsn, forKey: .amazonSideAsn)
        }
        if let directConnectGatewayId = self.directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let directConnectGatewayName = self.directConnectGatewayName {
            try encodeContainer.encode(directConnectGatewayName, forKey: .directConnectGatewayName)
        }
        if let directConnectGatewayState = self.directConnectGatewayState {
            try encodeContainer.encode(directConnectGatewayState.rawValue, forKey: .directConnectGatewayState)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let stateChangeError = self.stateChangeError {
            try encodeContainer.encode(stateChangeError, forKey: .stateChangeError)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let directConnectGatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayName)
        directConnectGatewayName = directConnectGatewayNameDecoded
        let amazonSideAsnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .amazonSideAsn)
        amazonSideAsn = amazonSideAsnDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let directConnectGatewayStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.DirectConnectGatewayState.self, forKey: .directConnectGatewayState)
        directConnectGatewayState = directConnectGatewayStateDecoded
        let stateChangeErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateChangeError)
        stateChangeError = stateChangeErrorDecoded
    }
}

extension DirectConnectClientTypes {
    /// Information about a Direct Connect gateway, which enables you to connect virtual interfaces and virtual private gateway or transit gateways.
    public struct DirectConnectGateway: Swift.Equatable {
        /// The autonomous system number (ASN) for the Amazon side of the connection.
        public var amazonSideAsn: Swift.Int?
        /// The ID of the Direct Connect gateway.
        public var directConnectGatewayId: Swift.String?
        /// The name of the Direct Connect gateway.
        public var directConnectGatewayName: Swift.String?
        /// The state of the Direct Connect gateway. The following are the possible values:
        ///
        /// * pending: The initial state after calling [CreateDirectConnectGateway].
        ///
        /// * available: The Direct Connect gateway is ready for use.
        ///
        /// * deleting: The initial state after calling [DeleteDirectConnectGateway].
        ///
        /// * deleted: The Direct Connect gateway is deleted and cannot pass traffic.
        public var directConnectGatewayState: DirectConnectClientTypes.DirectConnectGatewayState?
        /// The ID of the Amazon Web Services account that owns the Direct Connect gateway.
        public var ownerAccount: Swift.String?
        /// The error message if the state of an object failed to advance.
        public var stateChangeError: Swift.String?

        public init (
            amazonSideAsn: Swift.Int? = nil,
            directConnectGatewayId: Swift.String? = nil,
            directConnectGatewayName: Swift.String? = nil,
            directConnectGatewayState: DirectConnectClientTypes.DirectConnectGatewayState? = nil,
            ownerAccount: Swift.String? = nil,
            stateChangeError: Swift.String? = nil
        )
        {
            self.amazonSideAsn = amazonSideAsn
            self.directConnectGatewayId = directConnectGatewayId
            self.directConnectGatewayName = directConnectGatewayName
            self.directConnectGatewayState = directConnectGatewayState
            self.ownerAccount = ownerAccount
            self.stateChangeError = stateChangeError
        }
    }

}

extension DirectConnectClientTypes.DirectConnectGatewayAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPrefixesToDirectConnectGateway
        case associatedGateway
        case associationId
        case associationState
        case directConnectGatewayId
        case directConnectGatewayOwnerAccount
        case stateChangeError
        case virtualGatewayId
        case virtualGatewayOwnerAccount
        case virtualGatewayRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPrefixesToDirectConnectGateway = allowedPrefixesToDirectConnectGateway {
            var allowedPrefixesToDirectConnectGatewayContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedPrefixesToDirectConnectGateway)
            for routefilterprefix0 in allowedPrefixesToDirectConnectGateway {
                try allowedPrefixesToDirectConnectGatewayContainer.encode(routefilterprefix0)
            }
        }
        if let associatedGateway = self.associatedGateway {
            try encodeContainer.encode(associatedGateway, forKey: .associatedGateway)
        }
        if let associationId = self.associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationState = self.associationState {
            try encodeContainer.encode(associationState.rawValue, forKey: .associationState)
        }
        if let directConnectGatewayId = self.directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let directConnectGatewayOwnerAccount = self.directConnectGatewayOwnerAccount {
            try encodeContainer.encode(directConnectGatewayOwnerAccount, forKey: .directConnectGatewayOwnerAccount)
        }
        if let stateChangeError = self.stateChangeError {
            try encodeContainer.encode(stateChangeError, forKey: .stateChangeError)
        }
        if let virtualGatewayId = self.virtualGatewayId {
            try encodeContainer.encode(virtualGatewayId, forKey: .virtualGatewayId)
        }
        if let virtualGatewayOwnerAccount = self.virtualGatewayOwnerAccount {
            try encodeContainer.encode(virtualGatewayOwnerAccount, forKey: .virtualGatewayOwnerAccount)
        }
        if let virtualGatewayRegion = self.virtualGatewayRegion {
            try encodeContainer.encode(virtualGatewayRegion, forKey: .virtualGatewayRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let directConnectGatewayOwnerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayOwnerAccount)
        directConnectGatewayOwnerAccount = directConnectGatewayOwnerAccountDecoded
        let associationStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.DirectConnectGatewayAssociationState.self, forKey: .associationState)
        associationState = associationStateDecoded
        let stateChangeErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateChangeError)
        stateChangeError = stateChangeErrorDecoded
        let associatedGatewayDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.AssociatedGateway.self, forKey: .associatedGateway)
        associatedGateway = associatedGatewayDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let allowedPrefixesToDirectConnectGatewayContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.RouteFilterPrefix?].self, forKey: .allowedPrefixesToDirectConnectGateway)
        var allowedPrefixesToDirectConnectGatewayDecoded0:[DirectConnectClientTypes.RouteFilterPrefix]? = nil
        if let allowedPrefixesToDirectConnectGatewayContainer = allowedPrefixesToDirectConnectGatewayContainer {
            allowedPrefixesToDirectConnectGatewayDecoded0 = [DirectConnectClientTypes.RouteFilterPrefix]()
            for structure0 in allowedPrefixesToDirectConnectGatewayContainer {
                if let structure0 = structure0 {
                    allowedPrefixesToDirectConnectGatewayDecoded0?.append(structure0)
                }
            }
        }
        allowedPrefixesToDirectConnectGateway = allowedPrefixesToDirectConnectGatewayDecoded0
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let virtualGatewayRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayRegion)
        virtualGatewayRegion = virtualGatewayRegionDecoded
        let virtualGatewayOwnerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayOwnerAccount)
        virtualGatewayOwnerAccount = virtualGatewayOwnerAccountDecoded
    }
}

extension DirectConnectClientTypes {
    /// Information about an association between a Direct Connect gateway and a virtual private gateway or transit gateway.
    public struct DirectConnectGatewayAssociation: Swift.Equatable {
        /// The Amazon VPC prefixes to advertise to the Direct Connect gateway.
        public var allowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?
        /// Information about the associated gateway.
        public var associatedGateway: DirectConnectClientTypes.AssociatedGateway?
        /// The ID of the Direct Connect gateway association.
        public var associationId: Swift.String?
        /// The state of the association. The following are the possible values:
        ///
        /// * associating: The initial state after calling [CreateDirectConnectGatewayAssociation].
        ///
        /// * associated: The Direct Connect gateway and virtual private gateway or transit gateway are successfully associated and ready to pass traffic.
        ///
        /// * disassociating: The initial state after calling [DeleteDirectConnectGatewayAssociation].
        ///
        /// * disassociated: The virtual private gateway or transit gateway is disassociated from the Direct Connect gateway. Traffic flow between the Direct Connect gateway and virtual private gateway or transit gateway is stopped.
        public var associationState: DirectConnectClientTypes.DirectConnectGatewayAssociationState?
        /// The ID of the Direct Connect gateway.
        public var directConnectGatewayId: Swift.String?
        /// The ID of the Amazon Web Services account that owns the associated gateway.
        public var directConnectGatewayOwnerAccount: Swift.String?
        /// The error message if the state of an object failed to advance.
        public var stateChangeError: Swift.String?
        /// The ID of the virtual private gateway. Applies only to private virtual interfaces.
        public var virtualGatewayId: Swift.String?
        /// The ID of the Amazon Web Services account that owns the virtual private gateway.
        public var virtualGatewayOwnerAccount: Swift.String?
        /// The Amazon Web Services Region where the virtual private gateway is located.
        @available(*, deprecated)
        public var virtualGatewayRegion: Swift.String?

        public init (
            allowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
            associatedGateway: DirectConnectClientTypes.AssociatedGateway? = nil,
            associationId: Swift.String? = nil,
            associationState: DirectConnectClientTypes.DirectConnectGatewayAssociationState? = nil,
            directConnectGatewayId: Swift.String? = nil,
            directConnectGatewayOwnerAccount: Swift.String? = nil,
            stateChangeError: Swift.String? = nil,
            virtualGatewayId: Swift.String? = nil,
            virtualGatewayOwnerAccount: Swift.String? = nil,
            virtualGatewayRegion: Swift.String? = nil
        )
        {
            self.allowedPrefixesToDirectConnectGateway = allowedPrefixesToDirectConnectGateway
            self.associatedGateway = associatedGateway
            self.associationId = associationId
            self.associationState = associationState
            self.directConnectGatewayId = directConnectGatewayId
            self.directConnectGatewayOwnerAccount = directConnectGatewayOwnerAccount
            self.stateChangeError = stateChangeError
            self.virtualGatewayId = virtualGatewayId
            self.virtualGatewayOwnerAccount = virtualGatewayOwnerAccount
            self.virtualGatewayRegion = virtualGatewayRegion
        }
    }

}

extension DirectConnectClientTypes.DirectConnectGatewayAssociationProposal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedGateway
        case directConnectGatewayId
        case directConnectGatewayOwnerAccount
        case existingAllowedPrefixesToDirectConnectGateway
        case proposalId
        case proposalState
        case requestedAllowedPrefixesToDirectConnectGateway
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedGateway = self.associatedGateway {
            try encodeContainer.encode(associatedGateway, forKey: .associatedGateway)
        }
        if let directConnectGatewayId = self.directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let directConnectGatewayOwnerAccount = self.directConnectGatewayOwnerAccount {
            try encodeContainer.encode(directConnectGatewayOwnerAccount, forKey: .directConnectGatewayOwnerAccount)
        }
        if let existingAllowedPrefixesToDirectConnectGateway = existingAllowedPrefixesToDirectConnectGateway {
            var existingAllowedPrefixesToDirectConnectGatewayContainer = encodeContainer.nestedUnkeyedContainer(forKey: .existingAllowedPrefixesToDirectConnectGateway)
            for routefilterprefix0 in existingAllowedPrefixesToDirectConnectGateway {
                try existingAllowedPrefixesToDirectConnectGatewayContainer.encode(routefilterprefix0)
            }
        }
        if let proposalId = self.proposalId {
            try encodeContainer.encode(proposalId, forKey: .proposalId)
        }
        if let proposalState = self.proposalState {
            try encodeContainer.encode(proposalState.rawValue, forKey: .proposalState)
        }
        if let requestedAllowedPrefixesToDirectConnectGateway = requestedAllowedPrefixesToDirectConnectGateway {
            var requestedAllowedPrefixesToDirectConnectGatewayContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requestedAllowedPrefixesToDirectConnectGateway)
            for routefilterprefix0 in requestedAllowedPrefixesToDirectConnectGateway {
                try requestedAllowedPrefixesToDirectConnectGatewayContainer.encode(routefilterprefix0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proposalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proposalId)
        proposalId = proposalIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let directConnectGatewayOwnerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayOwnerAccount)
        directConnectGatewayOwnerAccount = directConnectGatewayOwnerAccountDecoded
        let proposalStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.DirectConnectGatewayAssociationProposalState.self, forKey: .proposalState)
        proposalState = proposalStateDecoded
        let associatedGatewayDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.AssociatedGateway.self, forKey: .associatedGateway)
        associatedGateway = associatedGatewayDecoded
        let existingAllowedPrefixesToDirectConnectGatewayContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.RouteFilterPrefix?].self, forKey: .existingAllowedPrefixesToDirectConnectGateway)
        var existingAllowedPrefixesToDirectConnectGatewayDecoded0:[DirectConnectClientTypes.RouteFilterPrefix]? = nil
        if let existingAllowedPrefixesToDirectConnectGatewayContainer = existingAllowedPrefixesToDirectConnectGatewayContainer {
            existingAllowedPrefixesToDirectConnectGatewayDecoded0 = [DirectConnectClientTypes.RouteFilterPrefix]()
            for structure0 in existingAllowedPrefixesToDirectConnectGatewayContainer {
                if let structure0 = structure0 {
                    existingAllowedPrefixesToDirectConnectGatewayDecoded0?.append(structure0)
                }
            }
        }
        existingAllowedPrefixesToDirectConnectGateway = existingAllowedPrefixesToDirectConnectGatewayDecoded0
        let requestedAllowedPrefixesToDirectConnectGatewayContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.RouteFilterPrefix?].self, forKey: .requestedAllowedPrefixesToDirectConnectGateway)
        var requestedAllowedPrefixesToDirectConnectGatewayDecoded0:[DirectConnectClientTypes.RouteFilterPrefix]? = nil
        if let requestedAllowedPrefixesToDirectConnectGatewayContainer = requestedAllowedPrefixesToDirectConnectGatewayContainer {
            requestedAllowedPrefixesToDirectConnectGatewayDecoded0 = [DirectConnectClientTypes.RouteFilterPrefix]()
            for structure0 in requestedAllowedPrefixesToDirectConnectGatewayContainer {
                if let structure0 = structure0 {
                    requestedAllowedPrefixesToDirectConnectGatewayDecoded0?.append(structure0)
                }
            }
        }
        requestedAllowedPrefixesToDirectConnectGateway = requestedAllowedPrefixesToDirectConnectGatewayDecoded0
    }
}

extension DirectConnectClientTypes {
    /// Information about the proposal request to attach a virtual private gateway to a Direct Connect gateway.
    public struct DirectConnectGatewayAssociationProposal: Swift.Equatable {
        /// Information about the associated gateway.
        public var associatedGateway: DirectConnectClientTypes.AssociatedGateway?
        /// The ID of the Direct Connect gateway.
        public var directConnectGatewayId: Swift.String?
        /// The ID of the Amazon Web Services account that owns the Direct Connect gateway.
        public var directConnectGatewayOwnerAccount: Swift.String?
        /// The existing Amazon VPC prefixes advertised to the Direct Connect gateway.
        public var existingAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?
        /// The ID of the association proposal.
        public var proposalId: Swift.String?
        /// The state of the proposal. The following are possible values:
        ///
        /// * accepted: The proposal has been accepted. The Direct Connect gateway association is available to use in this state.
        ///
        /// * deleted: The proposal has been deleted by the owner that made the proposal. The Direct Connect gateway association cannot be used in this state.
        ///
        /// * requested: The proposal has been requested. The Direct Connect gateway association cannot be used in this state.
        public var proposalState: DirectConnectClientTypes.DirectConnectGatewayAssociationProposalState?
        /// The Amazon VPC prefixes to advertise to the Direct Connect gateway.
        public var requestedAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?

        public init (
            associatedGateway: DirectConnectClientTypes.AssociatedGateway? = nil,
            directConnectGatewayId: Swift.String? = nil,
            directConnectGatewayOwnerAccount: Swift.String? = nil,
            existingAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
            proposalId: Swift.String? = nil,
            proposalState: DirectConnectClientTypes.DirectConnectGatewayAssociationProposalState? = nil,
            requestedAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]? = nil
        )
        {
            self.associatedGateway = associatedGateway
            self.directConnectGatewayId = directConnectGatewayId
            self.directConnectGatewayOwnerAccount = directConnectGatewayOwnerAccount
            self.existingAllowedPrefixesToDirectConnectGateway = existingAllowedPrefixesToDirectConnectGateway
            self.proposalId = proposalId
            self.proposalState = proposalState
            self.requestedAllowedPrefixesToDirectConnectGateway = requestedAllowedPrefixesToDirectConnectGateway
        }
    }

}

extension DirectConnectClientTypes {
    public enum DirectConnectGatewayAssociationProposalState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accepted
        case deleted
        case requested
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectConnectGatewayAssociationProposalState] {
            return [
                .accepted,
                .deleted,
                .requested,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "accepted"
            case .deleted: return "deleted"
            case .requested: return "requested"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DirectConnectGatewayAssociationProposalState(rawValue: rawValue) ?? DirectConnectGatewayAssociationProposalState.sdkUnknown(rawValue)
        }
    }
}

extension DirectConnectClientTypes {
    public enum DirectConnectGatewayAssociationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associated
        case associating
        case disassociated
        case disassociating
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectConnectGatewayAssociationState] {
            return [
                .associated,
                .associating,
                .disassociated,
                .disassociating,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associated: return "associated"
            case .associating: return "associating"
            case .disassociated: return "disassociated"
            case .disassociating: return "disassociating"
            case .updating: return "updating"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DirectConnectGatewayAssociationState(rawValue: rawValue) ?? DirectConnectGatewayAssociationState.sdkUnknown(rawValue)
        }
    }
}

extension DirectConnectClientTypes.DirectConnectGatewayAttachment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentState
        case attachmentType
        case directConnectGatewayId
        case stateChangeError
        case virtualInterfaceId
        case virtualInterfaceOwnerAccount
        case virtualInterfaceRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentState = self.attachmentState {
            try encodeContainer.encode(attachmentState.rawValue, forKey: .attachmentState)
        }
        if let attachmentType = self.attachmentType {
            try encodeContainer.encode(attachmentType.rawValue, forKey: .attachmentType)
        }
        if let directConnectGatewayId = self.directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let stateChangeError = self.stateChangeError {
            try encodeContainer.encode(stateChangeError, forKey: .stateChangeError)
        }
        if let virtualInterfaceId = self.virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
        if let virtualInterfaceOwnerAccount = self.virtualInterfaceOwnerAccount {
            try encodeContainer.encode(virtualInterfaceOwnerAccount, forKey: .virtualInterfaceOwnerAccount)
        }
        if let virtualInterfaceRegion = self.virtualInterfaceRegion {
            try encodeContainer.encode(virtualInterfaceRegion, forKey: .virtualInterfaceRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let virtualInterfaceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceRegion)
        virtualInterfaceRegion = virtualInterfaceRegionDecoded
        let virtualInterfaceOwnerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceOwnerAccount)
        virtualInterfaceOwnerAccount = virtualInterfaceOwnerAccountDecoded
        let attachmentStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.DirectConnectGatewayAttachmentState.self, forKey: .attachmentState)
        attachmentState = attachmentStateDecoded
        let attachmentTypeDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.DirectConnectGatewayAttachmentType.self, forKey: .attachmentType)
        attachmentType = attachmentTypeDecoded
        let stateChangeErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateChangeError)
        stateChangeError = stateChangeErrorDecoded
    }
}

extension DirectConnectClientTypes {
    /// Information about an attachment between a Direct Connect gateway and a virtual interface.
    public struct DirectConnectGatewayAttachment: Swift.Equatable {
        /// The state of the attachment. The following are the possible values:
        ///
        /// * attaching: The initial state after a virtual interface is created using the Direct Connect gateway.
        ///
        /// * attached: The Direct Connect gateway and virtual interface are attached and ready to pass traffic.
        ///
        /// * detaching: The initial state after calling [DeleteVirtualInterface].
        ///
        /// * detached: The virtual interface is detached from the Direct Connect gateway. Traffic flow between the Direct Connect gateway and virtual interface is stopped.
        public var attachmentState: DirectConnectClientTypes.DirectConnectGatewayAttachmentState?
        /// The type of attachment.
        public var attachmentType: DirectConnectClientTypes.DirectConnectGatewayAttachmentType?
        /// The ID of the Direct Connect gateway.
        public var directConnectGatewayId: Swift.String?
        /// The error message if the state of an object failed to advance.
        public var stateChangeError: Swift.String?
        /// The ID of the virtual interface.
        public var virtualInterfaceId: Swift.String?
        /// The ID of the Amazon Web Services account that owns the virtual interface.
        public var virtualInterfaceOwnerAccount: Swift.String?
        /// The Amazon Web Services Region where the virtual interface is located.
        public var virtualInterfaceRegion: Swift.String?

        public init (
            attachmentState: DirectConnectClientTypes.DirectConnectGatewayAttachmentState? = nil,
            attachmentType: DirectConnectClientTypes.DirectConnectGatewayAttachmentType? = nil,
            directConnectGatewayId: Swift.String? = nil,
            stateChangeError: Swift.String? = nil,
            virtualInterfaceId: Swift.String? = nil,
            virtualInterfaceOwnerAccount: Swift.String? = nil,
            virtualInterfaceRegion: Swift.String? = nil
        )
        {
            self.attachmentState = attachmentState
            self.attachmentType = attachmentType
            self.directConnectGatewayId = directConnectGatewayId
            self.stateChangeError = stateChangeError
            self.virtualInterfaceId = virtualInterfaceId
            self.virtualInterfaceOwnerAccount = virtualInterfaceOwnerAccount
            self.virtualInterfaceRegion = virtualInterfaceRegion
        }
    }

}

extension DirectConnectClientTypes {
    public enum DirectConnectGatewayAttachmentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attached
        case attaching
        case detached
        case detaching
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectConnectGatewayAttachmentState] {
            return [
                .attached,
                .attaching,
                .detached,
                .detaching,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attached: return "attached"
            case .attaching: return "attaching"
            case .detached: return "detached"
            case .detaching: return "detaching"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DirectConnectGatewayAttachmentState(rawValue: rawValue) ?? DirectConnectGatewayAttachmentState.sdkUnknown(rawValue)
        }
    }
}

extension DirectConnectClientTypes {
    public enum DirectConnectGatewayAttachmentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case privatevirtualinterface
        case transitvirtualinterface
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectConnectGatewayAttachmentType] {
            return [
                .privatevirtualinterface,
                .transitvirtualinterface,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .privatevirtualinterface: return "PrivateVirtualInterface"
            case .transitvirtualinterface: return "TransitVirtualInterface"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DirectConnectGatewayAttachmentType(rawValue: rawValue) ?? DirectConnectGatewayAttachmentType.sdkUnknown(rawValue)
        }
    }
}

extension DirectConnectClientTypes {
    public enum DirectConnectGatewayState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectConnectGatewayState] {
            return [
                .available,
                .deleted,
                .deleting,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .deleted: return "deleted"
            case .deleting: return "deleting"
            case .pending: return "pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DirectConnectGatewayState(rawValue: rawValue) ?? DirectConnectGatewayState.sdkUnknown(rawValue)
        }
    }
}

extension DirectConnectServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DirectConnectServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A server-side error occurred.
public struct DirectConnectServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DirectConnectServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DirectConnectServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DisassociateConnectionFromLagInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case lagId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let lagId = self.lagId {
            try encodeContainer.encode(lagId, forKey: .lagId)
        }
    }
}

extension DisassociateConnectionFromLagInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateConnectionFromLagInput: Swift.Equatable {
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The ID of the LAG.
    /// This member is required.
    public var lagId: Swift.String?

    public init (
        connectionId: Swift.String? = nil,
        lagId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.lagId = lagId
    }
}

struct DisassociateConnectionFromLagInputBody: Swift.Equatable {
    let connectionId: Swift.String?
    let lagId: Swift.String?
}

extension DisassociateConnectionFromLagInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case lagId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
    }
}

extension DisassociateConnectionFromLagOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateConnectionFromLagOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateConnectionFromLagOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateConnectionFromLagOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociateConnectionFromLagOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.awsLogicalDeviceId = output.awsLogicalDeviceId
            self.bandwidth = output.bandwidth
            self.connectionId = output.connectionId
            self.connectionName = output.connectionName
            self.connectionState = output.connectionState
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.loaIssueTime = output.loaIssueTime
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.ownerAccount = output.ownerAccount
            self.partnerName = output.partnerName
            self.portEncryptionStatus = output.portEncryptionStatus
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
            self.vlan = output.vlan
        } else {
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.awsLogicalDeviceId = nil
            self.bandwidth = nil
            self.connectionId = nil
            self.connectionName = nil
            self.connectionState = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.loaIssueTime = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.ownerAccount = nil
            self.partnerName = nil
            self.portEncryptionStatus = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
            self.vlan = 0
        }
    }
}

/// Information about an Direct Connect connection.
public struct DisassociateConnectionFromLagOutputResponse: Swift.Equatable {
    /// The Direct Connect endpoint on which the physical connection terminates.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The bandwidth of the connection.
    public var bandwidth: Swift.String?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The name of the connection.
    public var connectionName: Swift.String?
    /// The state of the connection. The following are the possible values:
    ///
    /// * ordering: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.
    ///
    /// * requested: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The connection has been approved and is being initialized.
    ///
    /// * available: The network link is up and the connection is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The connection is being deleted.
    ///
    /// * deleted: The connection has been deleted.
    ///
    /// * rejected: A hosted connection in the ordering state enters the rejected state if it is deleted by the customer.
    ///
    /// * unknown: The state of the connection is not available.
    public var connectionState: DirectConnectClientTypes.ConnectionState?
    /// The MAC Security (MACsec) connection encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames (9001 MTU) are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The time of the most recent call to [DescribeLoa] for this connection.
    public var loaIssueTime: ClientRuntime.Date?
    /// The location of the connection.
    public var location: Swift.String?
    /// Indicates whether the connection supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the connection.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The ID of the Amazon Web Services account that owns the connection.
    public var ownerAccount: Swift.String?
    /// The name of the Direct Connect service provider associated with the connection.
    public var partnerName: Swift.String?
    /// The MAC Security (MACsec) port link status of the connection. The valid values are Encryption Up, which means that there is an active Connection Key Name, or Encryption Down.
    public var portEncryptionStatus: Swift.String?
    /// The name of the service provider associated with the connection.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the connection.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init (
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bandwidth: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        connectionState: DirectConnectClientTypes.ConnectionState? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        loaIssueTime: ClientRuntime.Date? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        ownerAccount: Swift.String? = nil,
        partnerName: Swift.String? = nil,
        portEncryptionStatus: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

struct DisassociateConnectionFromLagOutputResponseBody: Swift.Equatable {
    let ownerAccount: Swift.String?
    let connectionId: Swift.String?
    let connectionName: Swift.String?
    let connectionState: DirectConnectClientTypes.ConnectionState?
    let region: Swift.String?
    let location: Swift.String?
    let bandwidth: Swift.String?
    let vlan: Swift.Int
    let partnerName: Swift.String?
    let loaIssueTime: ClientRuntime.Date?
    let lagId: Swift.String?
    let awsDevice: Swift.String?
    let jumboFrameCapable: Swift.Bool?
    let awsDeviceV2: Swift.String?
    let awsLogicalDeviceId: Swift.String?
    let hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    let tags: [DirectConnectClientTypes.Tag]?
    let providerName: Swift.String?
    let macSecCapable: Swift.Bool?
    let portEncryptionStatus: Swift.String?
    let encryptionMode: Swift.String?
    let macSecKeys: [DirectConnectClientTypes.MacSecKey]?
}

extension DisassociateConnectionFromLagOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsDevice
        case awsDeviceV2
        case awsLogicalDeviceId
        case bandwidth
        case connectionId
        case connectionName
        case connectionState
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case macSecCapable
        case macSecKeys
        case ownerAccount
        case partnerName
        case portEncryptionStatus
        case providerName
        case region
        case tags
        case vlan
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
        let loaIssueTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let portEncryptionStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portEncryptionStatus)
        portEncryptionStatus = portEncryptionStatusDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[DirectConnectClientTypes.MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [DirectConnectClientTypes.MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

extension DisassociateMacSecKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case secretARN
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let secretARN = self.secretARN {
            try encodeContainer.encode(secretARN, forKey: .secretARN)
        }
    }
}

extension DisassociateMacSecKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateMacSecKeyInput: Swift.Equatable {
    /// The ID of the dedicated connection (dxcon-xxxx), or the ID of the LAG (dxlag-xxxx). You can use [DescribeConnections] or [DescribeLags] to retrieve connection ID.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the MAC Security (MACsec) secret key. You can use [DescribeConnections] to retrieve the ARN of the MAC Security (MACsec) secret key.
    /// This member is required.
    public var secretARN: Swift.String?

    public init (
        connectionId: Swift.String? = nil,
        secretARN: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.secretARN = secretARN
    }
}

struct DisassociateMacSecKeyInputBody: Swift.Equatable {
    let connectionId: Swift.String?
    let secretARN: Swift.String?
}

extension DisassociateMacSecKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case secretARN
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let secretARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretARN)
        secretARN = secretARNDecoded
    }
}

extension DisassociateMacSecKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateMacSecKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateMacSecKeyOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateMacSecKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociateMacSecKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionId = output.connectionId
            self.macSecKeys = output.macSecKeys
        } else {
            self.connectionId = nil
            self.macSecKeys = nil
        }
    }
}

public struct DisassociateMacSecKeyOutputResponse: Swift.Equatable {
    /// The ID of the dedicated connection (dxcon-xxxx), or the ID of the LAG (dxlag-xxxx).
    public var connectionId: Swift.String?
    /// The MAC Security (MACsec) security keys no longer associated with the dedicated connection.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?

    public init (
        connectionId: Swift.String? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil
    )
    {
        self.connectionId = connectionId
        self.macSecKeys = macSecKeys
    }
}

struct DisassociateMacSecKeyOutputResponseBody: Swift.Equatable {
    let connectionId: Swift.String?
    let macSecKeys: [DirectConnectClientTypes.MacSecKey]?
}

extension DisassociateMacSecKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case macSecKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[DirectConnectClientTypes.MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [DirectConnectClientTypes.MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

extension DuplicateTagKeysException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DuplicateTagKeysExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A tag key was specified more than once.
public struct DuplicateTagKeysException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateTagKeysExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateTagKeysExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DirectConnectClientTypes {
    public enum GatewayType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case transitgateway
        case virtualprivategateway
        case sdkUnknown(Swift.String)

        public static var allCases: [GatewayType] {
            return [
                .transitgateway,
                .virtualprivategateway,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .transitgateway: return "transitGateway"
            case .virtualprivategateway: return "virtualPrivateGateway"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GatewayType(rawValue: rawValue) ?? GatewayType.sdkUnknown(rawValue)
        }
    }
}

extension DirectConnectClientTypes {
    public enum HasLogicalRedundancy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case no
        case unknown
        case yes
        case sdkUnknown(Swift.String)

        public static var allCases: [HasLogicalRedundancy] {
            return [
                .no,
                .unknown,
                .yes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .no: return "no"
            case .unknown: return "unknown"
            case .yes: return "yes"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HasLogicalRedundancy(rawValue: rawValue) ?? HasLogicalRedundancy.sdkUnknown(rawValue)
        }
    }
}

extension DirectConnectClientTypes.Interconnect: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsDevice
        case awsDeviceV2
        case awsLogicalDeviceId
        case bandwidth
        case hasLogicalRedundancy
        case interconnectId
        case interconnectName
        case interconnectState
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case providerName
        case region
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsDevice = self.awsDevice {
            try encodeContainer.encode(awsDevice, forKey: .awsDevice)
        }
        if let awsDeviceV2 = self.awsDeviceV2 {
            try encodeContainer.encode(awsDeviceV2, forKey: .awsDeviceV2)
        }
        if let awsLogicalDeviceId = self.awsLogicalDeviceId {
            try encodeContainer.encode(awsLogicalDeviceId, forKey: .awsLogicalDeviceId)
        }
        if let bandwidth = self.bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let hasLogicalRedundancy = self.hasLogicalRedundancy {
            try encodeContainer.encode(hasLogicalRedundancy.rawValue, forKey: .hasLogicalRedundancy)
        }
        if let interconnectId = self.interconnectId {
            try encodeContainer.encode(interconnectId, forKey: .interconnectId)
        }
        if let interconnectName = self.interconnectName {
            try encodeContainer.encode(interconnectName, forKey: .interconnectName)
        }
        if let interconnectState = self.interconnectState {
            try encodeContainer.encode(interconnectState.rawValue, forKey: .interconnectState)
        }
        if let jumboFrameCapable = self.jumboFrameCapable {
            try encodeContainer.encode(jumboFrameCapable, forKey: .jumboFrameCapable)
        }
        if let lagId = self.lagId {
            try encodeContainer.encode(lagId, forKey: .lagId)
        }
        if let loaIssueTime = self.loaIssueTime {
            try encodeContainer.encodeTimestamp(loaIssueTime, format: .epochSeconds, forKey: .loaIssueTime)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let providerName = self.providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interconnectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interconnectId)
        interconnectId = interconnectIdDecoded
        let interconnectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interconnectName)
        interconnectName = interconnectNameDecoded
        let interconnectStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.InterconnectState.self, forKey: .interconnectState)
        interconnectState = interconnectStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let loaIssueTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
    }
}

extension DirectConnectClientTypes {
    /// Information about an interconnect.
    public struct Interconnect: Swift.Equatable {
        /// The Direct Connect endpoint on which the physical connection terminates.
        @available(*, deprecated)
        public var awsDevice: Swift.String?
        /// The Direct Connect endpoint that terminates the physical connection.
        public var awsDeviceV2: Swift.String?
        /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
        public var awsLogicalDeviceId: Swift.String?
        /// The bandwidth of the connection.
        public var bandwidth: Swift.String?
        /// Indicates whether the interconnect supports a secondary BGP in the same address family (IPv4/IPv6).
        public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
        /// The ID of the interconnect.
        public var interconnectId: Swift.String?
        /// The name of the interconnect.
        public var interconnectName: Swift.String?
        /// The state of the interconnect. The following are the possible values:
        ///
        /// * requested: The initial state of an interconnect. The interconnect stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
        ///
        /// * pending: The interconnect is approved, and is being initialized.
        ///
        /// * available: The network link is up, and the interconnect is ready for use.
        ///
        /// * down: The network link is down.
        ///
        /// * deleting: The interconnect is being deleted.
        ///
        /// * deleted: The interconnect is deleted.
        ///
        /// * unknown: The state of the interconnect is not available.
        public var interconnectState: DirectConnectClientTypes.InterconnectState?
        /// Indicates whether jumbo frames (9001 MTU) are supported.
        public var jumboFrameCapable: Swift.Bool?
        /// The ID of the LAG.
        public var lagId: Swift.String?
        /// The time of the most recent call to [DescribeLoa] for this connection.
        public var loaIssueTime: ClientRuntime.Date?
        /// The location of the connection.
        public var location: Swift.String?
        /// The name of the service provider associated with the interconnect.
        public var providerName: Swift.String?
        /// The Amazon Web Services Region where the connection is located.
        public var region: Swift.String?
        /// The tags associated with the interconnect.
        public var tags: [DirectConnectClientTypes.Tag]?

        public init (
            awsDevice: Swift.String? = nil,
            awsDeviceV2: Swift.String? = nil,
            awsLogicalDeviceId: Swift.String? = nil,
            bandwidth: Swift.String? = nil,
            hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
            interconnectId: Swift.String? = nil,
            interconnectName: Swift.String? = nil,
            interconnectState: DirectConnectClientTypes.InterconnectState? = nil,
            jumboFrameCapable: Swift.Bool? = nil,
            lagId: Swift.String? = nil,
            loaIssueTime: ClientRuntime.Date? = nil,
            location: Swift.String? = nil,
            providerName: Swift.String? = nil,
            region: Swift.String? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil
        )
        {
            self.awsDevice = awsDevice
            self.awsDeviceV2 = awsDeviceV2
            self.awsLogicalDeviceId = awsLogicalDeviceId
            self.bandwidth = bandwidth
            self.hasLogicalRedundancy = hasLogicalRedundancy
            self.interconnectId = interconnectId
            self.interconnectName = interconnectName
            self.interconnectState = interconnectState
            self.jumboFrameCapable = jumboFrameCapable
            self.lagId = lagId
            self.loaIssueTime = loaIssueTime
            self.location = location
            self.providerName = providerName
            self.region = region
            self.tags = tags
        }
    }

}

extension DirectConnectClientTypes {
    public enum InterconnectState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case down
        case pending
        case requested
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [InterconnectState] {
            return [
                .available,
                .deleted,
                .deleting,
                .down,
                .pending,
                .requested,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .deleted: return "deleted"
            case .deleting: return "deleting"
            case .down: return "down"
            case .pending: return "pending"
            case .requested: return "requested"
            case .unknown: return "unknown"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InterconnectState(rawValue: rawValue) ?? InterconnectState.sdkUnknown(rawValue)
        }
    }
}

extension DirectConnectClientTypes.Lag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowsHostedConnections
        case awsDevice
        case awsDeviceV2
        case awsLogicalDeviceId
        case connections
        case connectionsBandwidth
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case lagName
        case lagState
        case location
        case macSecCapable
        case macSecKeys
        case minimumLinks
        case numberOfConnections
        case ownerAccount
        case providerName
        case region
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowsHostedConnections != false {
            try encodeContainer.encode(allowsHostedConnections, forKey: .allowsHostedConnections)
        }
        if let awsDevice = self.awsDevice {
            try encodeContainer.encode(awsDevice, forKey: .awsDevice)
        }
        if let awsDeviceV2 = self.awsDeviceV2 {
            try encodeContainer.encode(awsDeviceV2, forKey: .awsDeviceV2)
        }
        if let awsLogicalDeviceId = self.awsLogicalDeviceId {
            try encodeContainer.encode(awsLogicalDeviceId, forKey: .awsLogicalDeviceId)
        }
        if let connections = connections {
            var connectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connections)
            for connection0 in connections {
                try connectionsContainer.encode(connection0)
            }
        }
        if let connectionsBandwidth = self.connectionsBandwidth {
            try encodeContainer.encode(connectionsBandwidth, forKey: .connectionsBandwidth)
        }
        if let encryptionMode = self.encryptionMode {
            try encodeContainer.encode(encryptionMode, forKey: .encryptionMode)
        }
        if let hasLogicalRedundancy = self.hasLogicalRedundancy {
            try encodeContainer.encode(hasLogicalRedundancy.rawValue, forKey: .hasLogicalRedundancy)
        }
        if let jumboFrameCapable = self.jumboFrameCapable {
            try encodeContainer.encode(jumboFrameCapable, forKey: .jumboFrameCapable)
        }
        if let lagId = self.lagId {
            try encodeContainer.encode(lagId, forKey: .lagId)
        }
        if let lagName = self.lagName {
            try encodeContainer.encode(lagName, forKey: .lagName)
        }
        if let lagState = self.lagState {
            try encodeContainer.encode(lagState.rawValue, forKey: .lagState)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let macSecCapable = self.macSecCapable {
            try encodeContainer.encode(macSecCapable, forKey: .macSecCapable)
        }
        if let macSecKeys = macSecKeys {
            var macSecKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .macSecKeys)
            for macseckey0 in macSecKeys {
                try macSecKeysContainer.encode(macseckey0)
            }
        }
        if minimumLinks != 0 {
            try encodeContainer.encode(minimumLinks, forKey: .minimumLinks)
        }
        if numberOfConnections != 0 {
            try encodeContainer.encode(numberOfConnections, forKey: .numberOfConnections)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let providerName = self.providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsBandwidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionsBandwidth)
        connectionsBandwidth = connectionsBandwidthDecoded
        let numberOfConnectionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfConnections) ?? 0
        numberOfConnections = numberOfConnectionsDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let lagNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagName)
        lagName = lagNameDecoded
        let lagStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.LagState.self, forKey: .lagState)
        lagState = lagStateDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let minimumLinksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumLinks) ?? 0
        minimumLinks = minimumLinksDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let connectionsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Connection?].self, forKey: .connections)
        var connectionsDecoded0:[DirectConnectClientTypes.Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [DirectConnectClientTypes.Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
        let allowsHostedConnectionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowsHostedConnections) ?? false
        allowsHostedConnections = allowsHostedConnectionsDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[DirectConnectClientTypes.MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [DirectConnectClientTypes.MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

extension DirectConnectClientTypes {
    /// Information about a link aggregation group (LAG).
    public struct Lag: Swift.Equatable {
        /// Indicates whether the LAG can host other connections.
        public var allowsHostedConnections: Swift.Bool
        /// The Direct Connect endpoint that hosts the LAG.
        @available(*, deprecated)
        public var awsDevice: Swift.String?
        /// The Direct Connect endpoint that hosts the LAG.
        public var awsDeviceV2: Swift.String?
        /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
        public var awsLogicalDeviceId: Swift.String?
        /// The connections bundled by the LAG.
        public var connections: [DirectConnectClientTypes.Connection]?
        /// The individual bandwidth of the physical connections bundled by the LAG. The possible values are 1Gbps and 10Gbps.
        public var connectionsBandwidth: Swift.String?
        /// The LAG MAC Security (MACsec) encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
        public var encryptionMode: Swift.String?
        /// Indicates whether the LAG supports a secondary BGP peer in the same address family (IPv4/IPv6).
        public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
        /// Indicates whether jumbo frames (9001 MTU) are supported.
        public var jumboFrameCapable: Swift.Bool?
        /// The ID of the LAG.
        public var lagId: Swift.String?
        /// The name of the LAG.
        public var lagName: Swift.String?
        /// The state of the LAG. The following are the possible values:
        ///
        /// * requested: The initial state of a LAG. The LAG stays in the requested state until the Letter of Authorization (LOA) is available.
        ///
        /// * pending: The LAG has been approved and is being initialized.
        ///
        /// * available: The network link is established and the LAG is ready for use.
        ///
        /// * down: The network link is down.
        ///
        /// * deleting: The LAG is being deleted.
        ///
        /// * deleted: The LAG is deleted.
        ///
        /// * unknown: The state of the LAG is not available.
        public var lagState: DirectConnectClientTypes.LagState?
        /// The location of the LAG.
        public var location: Swift.String?
        /// Indicates whether the LAG supports MAC Security (MACsec).
        public var macSecCapable: Swift.Bool?
        /// The MAC Security (MACsec) security keys associated with the LAG.
        public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
        /// The minimum number of physical dedicated connections that must be operational for the LAG itself to be operational.
        public var minimumLinks: Swift.Int
        /// The number of physical dedicated connections bundled by the LAG, up to a maximum of 10.
        public var numberOfConnections: Swift.Int
        /// The ID of the Amazon Web Services account that owns the LAG.
        public var ownerAccount: Swift.String?
        /// The name of the service provider associated with the LAG.
        public var providerName: Swift.String?
        /// The Amazon Web Services Region where the connection is located.
        public var region: Swift.String?
        /// The tags associated with the LAG.
        public var tags: [DirectConnectClientTypes.Tag]?

        public init (
            allowsHostedConnections: Swift.Bool = false,
            awsDevice: Swift.String? = nil,
            awsDeviceV2: Swift.String? = nil,
            awsLogicalDeviceId: Swift.String? = nil,
            connections: [DirectConnectClientTypes.Connection]? = nil,
            connectionsBandwidth: Swift.String? = nil,
            encryptionMode: Swift.String? = nil,
            hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
            jumboFrameCapable: Swift.Bool? = nil,
            lagId: Swift.String? = nil,
            lagName: Swift.String? = nil,
            lagState: DirectConnectClientTypes.LagState? = nil,
            location: Swift.String? = nil,
            macSecCapable: Swift.Bool? = nil,
            macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
            minimumLinks: Swift.Int = 0,
            numberOfConnections: Swift.Int = 0,
            ownerAccount: Swift.String? = nil,
            providerName: Swift.String? = nil,
            region: Swift.String? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil
        )
        {
            self.allowsHostedConnections = allowsHostedConnections
            self.awsDevice = awsDevice
            self.awsDeviceV2 = awsDeviceV2
            self.awsLogicalDeviceId = awsLogicalDeviceId
            self.connections = connections
            self.connectionsBandwidth = connectionsBandwidth
            self.encryptionMode = encryptionMode
            self.hasLogicalRedundancy = hasLogicalRedundancy
            self.jumboFrameCapable = jumboFrameCapable
            self.lagId = lagId
            self.lagName = lagName
            self.lagState = lagState
            self.location = location
            self.macSecCapable = macSecCapable
            self.macSecKeys = macSecKeys
            self.minimumLinks = minimumLinks
            self.numberOfConnections = numberOfConnections
            self.ownerAccount = ownerAccount
            self.providerName = providerName
            self.region = region
            self.tags = tags
        }
    }

}

extension DirectConnectClientTypes {
    public enum LagState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case down
        case pending
        case requested
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [LagState] {
            return [
                .available,
                .deleted,
                .deleting,
                .down,
                .pending,
                .requested,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .deleted: return "deleted"
            case .deleting: return "deleting"
            case .down: return "down"
            case .pending: return "pending"
            case .requested: return "requested"
            case .unknown: return "unknown"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LagState(rawValue: rawValue) ?? LagState.sdkUnknown(rawValue)
        }
    }
}

extension ListVirtualInterfaceTestHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bgpPeers
        case maxResults
        case nextToken
        case status
        case testId
        case virtualInterfaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bgpPeers = bgpPeers {
            var bgpPeersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bgpPeers)
            for bgppeerid0 in bgpPeers {
                try bgpPeersContainer.encode(bgppeerid0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let testId = self.testId {
            try encodeContainer.encode(testId, forKey: .testId)
        }
        if let virtualInterfaceId = self.virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

extension ListVirtualInterfaceTestHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListVirtualInterfaceTestHistoryInput: Swift.Equatable {
    /// The BGP peers that were placed in the DOWN state during the virtual interface failover test.
    public var bgpPeers: [Swift.String]?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value. If MaxResults is given a value larger than 100, only 100 results are returned.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The status of the virtual interface failover test.
    public var status: Swift.String?
    /// The ID of the virtual interface failover test.
    public var testId: Swift.String?
    /// The ID of the virtual interface that was tested.
    public var virtualInterfaceId: Swift.String?

    public init (
        bgpPeers: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: Swift.String? = nil,
        testId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.bgpPeers = bgpPeers
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
        self.testId = testId
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct ListVirtualInterfaceTestHistoryInputBody: Swift.Equatable {
    let testId: Swift.String?
    let virtualInterfaceId: Swift.String?
    let bgpPeers: [Swift.String]?
    let status: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListVirtualInterfaceTestHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bgpPeers
        case maxResults
        case nextToken
        case status
        case testId
        case virtualInterfaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testId)
        testId = testIdDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let bgpPeersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .bgpPeers)
        var bgpPeersDecoded0:[Swift.String]? = nil
        if let bgpPeersContainer = bgpPeersContainer {
            bgpPeersDecoded0 = [Swift.String]()
            for string0 in bgpPeersContainer {
                if let string0 = string0 {
                    bgpPeersDecoded0?.append(string0)
                }
            }
        }
        bgpPeers = bgpPeersDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVirtualInterfaceTestHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVirtualInterfaceTestHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVirtualInterfaceTestHistoryOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVirtualInterfaceTestHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVirtualInterfaceTestHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.virtualInterfaceTestHistory = output.virtualInterfaceTestHistory
        } else {
            self.nextToken = nil
            self.virtualInterfaceTestHistory = nil
        }
    }
}

public struct ListVirtualInterfaceTestHistoryOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The ID of the tested virtual interface.
    public var virtualInterfaceTestHistory: [DirectConnectClientTypes.VirtualInterfaceTestHistory]?

    public init (
        nextToken: Swift.String? = nil,
        virtualInterfaceTestHistory: [DirectConnectClientTypes.VirtualInterfaceTestHistory]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualInterfaceTestHistory = virtualInterfaceTestHistory
    }
}

struct ListVirtualInterfaceTestHistoryOutputResponseBody: Swift.Equatable {
    let virtualInterfaceTestHistory: [DirectConnectClientTypes.VirtualInterfaceTestHistory]?
    let nextToken: Swift.String?
}

extension ListVirtualInterfaceTestHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case virtualInterfaceTestHistory
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceTestHistoryContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.VirtualInterfaceTestHistory?].self, forKey: .virtualInterfaceTestHistory)
        var virtualInterfaceTestHistoryDecoded0:[DirectConnectClientTypes.VirtualInterfaceTestHistory]? = nil
        if let virtualInterfaceTestHistoryContainer = virtualInterfaceTestHistoryContainer {
            virtualInterfaceTestHistoryDecoded0 = [DirectConnectClientTypes.VirtualInterfaceTestHistory]()
            for structure0 in virtualInterfaceTestHistoryContainer {
                if let structure0 = structure0 {
                    virtualInterfaceTestHistoryDecoded0?.append(structure0)
                }
            }
        }
        virtualInterfaceTestHistory = virtualInterfaceTestHistoryDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DirectConnectClientTypes.Loa: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loaContent
        case loaContentType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loaContent = self.loaContent {
            try encodeContainer.encode(loaContent.base64EncodedString(), forKey: .loaContent)
        }
        if let loaContentType = self.loaContentType {
            try encodeContainer.encode(loaContentType.rawValue, forKey: .loaContentType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loaContentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .loaContent)
        loaContent = loaContentDecoded
        let loaContentTypeDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.LoaContentType.self, forKey: .loaContentType)
        loaContentType = loaContentTypeDecoded
    }
}

extension DirectConnectClientTypes {
    /// Information about a Letter of Authorization - Connecting Facility Assignment (LOA-CFA) for a connection.
    public struct Loa: Swift.Equatable {
        /// The binary contents of the LOA-CFA document.
        public var loaContent: ClientRuntime.Data?
        /// The standard media type for the LOA-CFA document. The only supported value is application/pdf.
        public var loaContentType: DirectConnectClientTypes.LoaContentType?

        public init (
            loaContent: ClientRuntime.Data? = nil,
            loaContentType: DirectConnectClientTypes.LoaContentType? = nil
        )
        {
            self.loaContent = loaContent
            self.loaContentType = loaContentType
        }
    }

}

extension DirectConnectClientTypes {
    public enum LoaContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pdf
        case sdkUnknown(Swift.String)

        public static var allCases: [LoaContentType] {
            return [
                .pdf,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pdf: return "application/pdf"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoaContentType(rawValue: rawValue) ?? LoaContentType.sdkUnknown(rawValue)
        }
    }
}

extension DirectConnectClientTypes.Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availableMacSecPortSpeeds
        case availablePortSpeeds
        case availableProviders
        case locationCode
        case locationName
        case region
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availableMacSecPortSpeeds = availableMacSecPortSpeeds {
            var availableMacSecPortSpeedsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availableMacSecPortSpeeds)
            for portspeed0 in availableMacSecPortSpeeds {
                try availableMacSecPortSpeedsContainer.encode(portspeed0)
            }
        }
        if let availablePortSpeeds = availablePortSpeeds {
            var availablePortSpeedsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availablePortSpeeds)
            for portspeed0 in availablePortSpeeds {
                try availablePortSpeedsContainer.encode(portspeed0)
            }
        }
        if let availableProviders = availableProviders {
            var availableProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availableProviders)
            for providername0 in availableProviders {
                try availableProvidersContainer.encode(providername0)
            }
        }
        if let locationCode = self.locationCode {
            try encodeContainer.encode(locationCode, forKey: .locationCode)
        }
        if let locationName = self.locationName {
            try encodeContainer.encode(locationName, forKey: .locationName)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationCode)
        locationCode = locationCodeDecoded
        let locationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationName)
        locationName = locationNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let availablePortSpeedsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availablePortSpeeds)
        var availablePortSpeedsDecoded0:[Swift.String]? = nil
        if let availablePortSpeedsContainer = availablePortSpeedsContainer {
            availablePortSpeedsDecoded0 = [Swift.String]()
            for string0 in availablePortSpeedsContainer {
                if let string0 = string0 {
                    availablePortSpeedsDecoded0?.append(string0)
                }
            }
        }
        availablePortSpeeds = availablePortSpeedsDecoded0
        let availableProvidersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availableProviders)
        var availableProvidersDecoded0:[Swift.String]? = nil
        if let availableProvidersContainer = availableProvidersContainer {
            availableProvidersDecoded0 = [Swift.String]()
            for string0 in availableProvidersContainer {
                if let string0 = string0 {
                    availableProvidersDecoded0?.append(string0)
                }
            }
        }
        availableProviders = availableProvidersDecoded0
        let availableMacSecPortSpeedsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availableMacSecPortSpeeds)
        var availableMacSecPortSpeedsDecoded0:[Swift.String]? = nil
        if let availableMacSecPortSpeedsContainer = availableMacSecPortSpeedsContainer {
            availableMacSecPortSpeedsDecoded0 = [Swift.String]()
            for string0 in availableMacSecPortSpeedsContainer {
                if let string0 = string0 {
                    availableMacSecPortSpeedsDecoded0?.append(string0)
                }
            }
        }
        availableMacSecPortSpeeds = availableMacSecPortSpeedsDecoded0
    }
}

extension DirectConnectClientTypes {
    /// Information about an Direct Connect location.
    public struct Location: Swift.Equatable {
        /// The available MAC Security (MACsec) port speeds for the location.
        public var availableMacSecPortSpeeds: [Swift.String]?
        /// The available port speeds for the location.
        public var availablePortSpeeds: [Swift.String]?
        /// The name of the service provider for the location.
        public var availableProviders: [Swift.String]?
        /// The code for the location.
        public var locationCode: Swift.String?
        /// The name of the location. This includes the name of the colocation partner and the physical site of the building.
        public var locationName: Swift.String?
        /// The Amazon Web Services Region for the location.
        public var region: Swift.String?

        public init (
            availableMacSecPortSpeeds: [Swift.String]? = nil,
            availablePortSpeeds: [Swift.String]? = nil,
            availableProviders: [Swift.String]? = nil,
            locationCode: Swift.String? = nil,
            locationName: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.availableMacSecPortSpeeds = availableMacSecPortSpeeds
            self.availablePortSpeeds = availablePortSpeeds
            self.availableProviders = availableProviders
            self.locationCode = locationCode
            self.locationName = locationName
            self.region = region
        }
    }

}

extension DirectConnectClientTypes.MacSecKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ckn
        case secretARN
        case startOn
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ckn = self.ckn {
            try encodeContainer.encode(ckn, forKey: .ckn)
        }
        if let secretARN = self.secretARN {
            try encodeContainer.encode(secretARN, forKey: .secretARN)
        }
        if let startOn = self.startOn {
            try encodeContainer.encode(startOn, forKey: .startOn)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretARN)
        secretARN = secretARNDecoded
        let cknDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ckn)
        ckn = cknDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let startOnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startOn)
        startOn = startOnDecoded
    }
}

extension DirectConnectClientTypes {
    /// Information about the MAC Security (MACsec) secret key.
    public struct MacSecKey: Swift.Equatable {
        /// The Connection Key Name (CKN) for the MAC Security secret key.
        public var ckn: Swift.String?
        /// The Amazon Resource Name (ARN) of the MAC Security (MACsec) secret key.
        public var secretARN: Swift.String?
        /// The date that the MAC Security (MACsec) secret key takes effect. The value is displayed in UTC format.
        public var startOn: Swift.String?
        /// The state of the MAC Security (MACsec) secret key. The possible values are:
        ///
        /// * associating: The MAC Security (MACsec) secret key is being validated and not yet associated with the connection or LAG.
        ///
        /// * associated: The MAC Security (MACsec) secret key is validated and associated with the connection or LAG.
        ///
        /// * disassociating: The MAC Security (MACsec) secret key is being disassociated from the connection or LAG
        ///
        /// * disassociated: The MAC Security (MACsec) secret key is no longer associated with the connection or LAG.
        public var state: Swift.String?

        public init (
            ckn: Swift.String? = nil,
            secretARN: Swift.String? = nil,
            startOn: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.ckn = ckn
            self.secretARN = secretARN
            self.startOn = startOn
            self.state = state
        }
    }

}

extension DirectConnectClientTypes.NewBGPPeer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressFamily
        case amazonAddress
        case asn
        case authKey
        case customerAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressFamily = self.addressFamily {
            try encodeContainer.encode(addressFamily.rawValue, forKey: .addressFamily)
        }
        if let amazonAddress = self.amazonAddress {
            try encodeContainer.encode(amazonAddress, forKey: .amazonAddress)
        }
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let authKey = self.authKey {
            try encodeContainer.encode(authKey, forKey: .authKey)
        }
        if let customerAddress = self.customerAddress {
            try encodeContainer.encode(customerAddress, forKey: .customerAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn) ?? 0
        asn = asnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
    }
}

extension DirectConnectClientTypes {
    /// Information about a new BGP peer.
    public struct NewBGPPeer: Swift.Equatable {
        /// The address family for the BGP peer.
        public var addressFamily: DirectConnectClientTypes.AddressFamily?
        /// The IP address assigned to the Amazon interface.
        public var amazonAddress: Swift.String?
        /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.
        public var asn: Swift.Int
        /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
        public var authKey: Swift.String?
        /// The IP address assigned to the customer interface.
        public var customerAddress: Swift.String?

        public init (
            addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
            amazonAddress: Swift.String? = nil,
            asn: Swift.Int = 0,
            authKey: Swift.String? = nil,
            customerAddress: Swift.String? = nil
        )
        {
            self.addressFamily = addressFamily
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.authKey = authKey
            self.customerAddress = customerAddress
        }
    }

}

extension DirectConnectClientTypes.NewPrivateVirtualInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressFamily
        case amazonAddress
        case asn
        case authKey
        case customerAddress
        case directConnectGatewayId
        case enableSiteLink
        case mtu
        case tags
        case virtualGatewayId
        case virtualInterfaceName
        case vlan
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressFamily = self.addressFamily {
            try encodeContainer.encode(addressFamily.rawValue, forKey: .addressFamily)
        }
        if let amazonAddress = self.amazonAddress {
            try encodeContainer.encode(amazonAddress, forKey: .amazonAddress)
        }
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let authKey = self.authKey {
            try encodeContainer.encode(authKey, forKey: .authKey)
        }
        if let customerAddress = self.customerAddress {
            try encodeContainer.encode(customerAddress, forKey: .customerAddress)
        }
        if let directConnectGatewayId = self.directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let enableSiteLink = self.enableSiteLink {
            try encodeContainer.encode(enableSiteLink, forKey: .enableSiteLink)
        }
        if let mtu = self.mtu {
            try encodeContainer.encode(mtu, forKey: .mtu)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let virtualGatewayId = self.virtualGatewayId {
            try encodeContainer.encode(virtualGatewayId, forKey: .virtualGatewayId)
        }
        if let virtualInterfaceName = self.virtualInterfaceName {
            try encodeContainer.encode(virtualInterfaceName, forKey: .virtualInterfaceName)
        }
        if vlan != 0 {
            try encodeContainer.encode(vlan, forKey: .vlan)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn) ?? 0
        asn = asnDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let enableSiteLinkDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSiteLink)
        enableSiteLink = enableSiteLinkDecoded
    }
}

extension DirectConnectClientTypes {
    /// Information about a private virtual interface.
    public struct NewPrivateVirtualInterface: Swift.Equatable {
        /// The address family for the BGP peer.
        public var addressFamily: DirectConnectClientTypes.AddressFamily?
        /// The IP address assigned to the Amazon interface.
        public var amazonAddress: Swift.String?
        /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
        /// This member is required.
        public var asn: Swift.Int
        /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
        public var authKey: Swift.String?
        /// The IP address assigned to the customer interface.
        public var customerAddress: Swift.String?
        /// The ID of the Direct Connect gateway.
        public var directConnectGatewayId: Swift.String?
        /// Indicates whether to enable or disable SiteLink.
        public var enableSiteLink: Swift.Bool?
        /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.
        public var mtu: Swift.Int?
        /// The tags associated with the private virtual interface.
        public var tags: [DirectConnectClientTypes.Tag]?
        /// The ID of the virtual private gateway.
        public var virtualGatewayId: Swift.String?
        /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
        /// This member is required.
        public var virtualInterfaceName: Swift.String?
        /// The ID of the VLAN.
        /// This member is required.
        public var vlan: Swift.Int

        public init (
            addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
            amazonAddress: Swift.String? = nil,
            asn: Swift.Int = 0,
            authKey: Swift.String? = nil,
            customerAddress: Swift.String? = nil,
            directConnectGatewayId: Swift.String? = nil,
            enableSiteLink: Swift.Bool? = nil,
            mtu: Swift.Int? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil,
            virtualGatewayId: Swift.String? = nil,
            virtualInterfaceName: Swift.String? = nil,
            vlan: Swift.Int = 0
        )
        {
            self.addressFamily = addressFamily
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.authKey = authKey
            self.customerAddress = customerAddress
            self.directConnectGatewayId = directConnectGatewayId
            self.enableSiteLink = enableSiteLink
            self.mtu = mtu
            self.tags = tags
            self.virtualGatewayId = virtualGatewayId
            self.virtualInterfaceName = virtualInterfaceName
            self.vlan = vlan
        }
    }

}

extension DirectConnectClientTypes.NewPrivateVirtualInterfaceAllocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressFamily
        case amazonAddress
        case asn
        case authKey
        case customerAddress
        case mtu
        case tags
        case virtualInterfaceName
        case vlan
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressFamily = self.addressFamily {
            try encodeContainer.encode(addressFamily.rawValue, forKey: .addressFamily)
        }
        if let amazonAddress = self.amazonAddress {
            try encodeContainer.encode(amazonAddress, forKey: .amazonAddress)
        }
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let authKey = self.authKey {
            try encodeContainer.encode(authKey, forKey: .authKey)
        }
        if let customerAddress = self.customerAddress {
            try encodeContainer.encode(customerAddress, forKey: .customerAddress)
        }
        if let mtu = self.mtu {
            try encodeContainer.encode(mtu, forKey: .mtu)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let virtualInterfaceName = self.virtualInterfaceName {
            try encodeContainer.encode(virtualInterfaceName, forKey: .virtualInterfaceName)
        }
        if vlan != 0 {
            try encodeContainer.encode(vlan, forKey: .vlan)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn) ?? 0
        asn = asnDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DirectConnectClientTypes {
    /// Information about a private virtual interface to be provisioned on a connection.
    public struct NewPrivateVirtualInterfaceAllocation: Swift.Equatable {
        /// The address family for the BGP peer.
        public var addressFamily: DirectConnectClientTypes.AddressFamily?
        /// The IP address assigned to the Amazon interface.
        public var amazonAddress: Swift.String?
        /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
        /// This member is required.
        public var asn: Swift.Int
        /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
        public var authKey: Swift.String?
        /// The IP address assigned to the customer interface.
        public var customerAddress: Swift.String?
        /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.
        public var mtu: Swift.Int?
        /// The tags associated with the private virtual interface.
        public var tags: [DirectConnectClientTypes.Tag]?
        /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
        /// This member is required.
        public var virtualInterfaceName: Swift.String?
        /// The ID of the VLAN.
        /// This member is required.
        public var vlan: Swift.Int

        public init (
            addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
            amazonAddress: Swift.String? = nil,
            asn: Swift.Int = 0,
            authKey: Swift.String? = nil,
            customerAddress: Swift.String? = nil,
            mtu: Swift.Int? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil,
            virtualInterfaceName: Swift.String? = nil,
            vlan: Swift.Int = 0
        )
        {
            self.addressFamily = addressFamily
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.authKey = authKey
            self.customerAddress = customerAddress
            self.mtu = mtu
            self.tags = tags
            self.virtualInterfaceName = virtualInterfaceName
            self.vlan = vlan
        }
    }

}

extension DirectConnectClientTypes.NewPublicVirtualInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressFamily
        case amazonAddress
        case asn
        case authKey
        case customerAddress
        case routeFilterPrefixes
        case tags
        case virtualInterfaceName
        case vlan
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressFamily = self.addressFamily {
            try encodeContainer.encode(addressFamily.rawValue, forKey: .addressFamily)
        }
        if let amazonAddress = self.amazonAddress {
            try encodeContainer.encode(amazonAddress, forKey: .amazonAddress)
        }
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let authKey = self.authKey {
            try encodeContainer.encode(authKey, forKey: .authKey)
        }
        if let customerAddress = self.customerAddress {
            try encodeContainer.encode(customerAddress, forKey: .customerAddress)
        }
        if let routeFilterPrefixes = routeFilterPrefixes {
            var routeFilterPrefixesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routeFilterPrefixes)
            for routefilterprefix0 in routeFilterPrefixes {
                try routeFilterPrefixesContainer.encode(routefilterprefix0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let virtualInterfaceName = self.virtualInterfaceName {
            try encodeContainer.encode(virtualInterfaceName, forKey: .virtualInterfaceName)
        }
        if vlan != 0 {
            try encodeContainer.encode(vlan, forKey: .vlan)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn) ?? 0
        asn = asnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let routeFilterPrefixesContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.RouteFilterPrefix?].self, forKey: .routeFilterPrefixes)
        var routeFilterPrefixesDecoded0:[DirectConnectClientTypes.RouteFilterPrefix]? = nil
        if let routeFilterPrefixesContainer = routeFilterPrefixesContainer {
            routeFilterPrefixesDecoded0 = [DirectConnectClientTypes.RouteFilterPrefix]()
            for structure0 in routeFilterPrefixesContainer {
                if let structure0 = structure0 {
                    routeFilterPrefixesDecoded0?.append(structure0)
                }
            }
        }
        routeFilterPrefixes = routeFilterPrefixesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DirectConnectClientTypes {
    /// Information about a public virtual interface.
    public struct NewPublicVirtualInterface: Swift.Equatable {
        /// The address family for the BGP peer.
        public var addressFamily: DirectConnectClientTypes.AddressFamily?
        /// The IP address assigned to the Amazon interface.
        public var amazonAddress: Swift.String?
        /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
        /// This member is required.
        public var asn: Swift.Int
        /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
        public var authKey: Swift.String?
        /// The IP address assigned to the customer interface.
        public var customerAddress: Swift.String?
        /// The routes to be advertised to the Amazon Web Services network in this Region. Applies to public virtual interfaces.
        public var routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
        /// The tags associated with the public virtual interface.
        public var tags: [DirectConnectClientTypes.Tag]?
        /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
        /// This member is required.
        public var virtualInterfaceName: Swift.String?
        /// The ID of the VLAN.
        /// This member is required.
        public var vlan: Swift.Int

        public init (
            addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
            amazonAddress: Swift.String? = nil,
            asn: Swift.Int = 0,
            authKey: Swift.String? = nil,
            customerAddress: Swift.String? = nil,
            routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil,
            virtualInterfaceName: Swift.String? = nil,
            vlan: Swift.Int = 0
        )
        {
            self.addressFamily = addressFamily
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.authKey = authKey
            self.customerAddress = customerAddress
            self.routeFilterPrefixes = routeFilterPrefixes
            self.tags = tags
            self.virtualInterfaceName = virtualInterfaceName
            self.vlan = vlan
        }
    }

}

extension DirectConnectClientTypes.NewPublicVirtualInterfaceAllocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressFamily
        case amazonAddress
        case asn
        case authKey
        case customerAddress
        case routeFilterPrefixes
        case tags
        case virtualInterfaceName
        case vlan
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressFamily = self.addressFamily {
            try encodeContainer.encode(addressFamily.rawValue, forKey: .addressFamily)
        }
        if let amazonAddress = self.amazonAddress {
            try encodeContainer.encode(amazonAddress, forKey: .amazonAddress)
        }
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let authKey = self.authKey {
            try encodeContainer.encode(authKey, forKey: .authKey)
        }
        if let customerAddress = self.customerAddress {
            try encodeContainer.encode(customerAddress, forKey: .customerAddress)
        }
        if let routeFilterPrefixes = routeFilterPrefixes {
            var routeFilterPrefixesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routeFilterPrefixes)
            for routefilterprefix0 in routeFilterPrefixes {
                try routeFilterPrefixesContainer.encode(routefilterprefix0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let virtualInterfaceName = self.virtualInterfaceName {
            try encodeContainer.encode(virtualInterfaceName, forKey: .virtualInterfaceName)
        }
        if vlan != 0 {
            try encodeContainer.encode(vlan, forKey: .vlan)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn) ?? 0
        asn = asnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let routeFilterPrefixesContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.RouteFilterPrefix?].self, forKey: .routeFilterPrefixes)
        var routeFilterPrefixesDecoded0:[DirectConnectClientTypes.RouteFilterPrefix]? = nil
        if let routeFilterPrefixesContainer = routeFilterPrefixesContainer {
            routeFilterPrefixesDecoded0 = [DirectConnectClientTypes.RouteFilterPrefix]()
            for structure0 in routeFilterPrefixesContainer {
                if let structure0 = structure0 {
                    routeFilterPrefixesDecoded0?.append(structure0)
                }
            }
        }
        routeFilterPrefixes = routeFilterPrefixesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DirectConnectClientTypes {
    /// Information about a public virtual interface to be provisioned on a connection.
    public struct NewPublicVirtualInterfaceAllocation: Swift.Equatable {
        /// The address family for the BGP peer.
        public var addressFamily: DirectConnectClientTypes.AddressFamily?
        /// The IP address assigned to the Amazon interface.
        public var amazonAddress: Swift.String?
        /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
        /// This member is required.
        public var asn: Swift.Int
        /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
        public var authKey: Swift.String?
        /// The IP address assigned to the customer interface.
        public var customerAddress: Swift.String?
        /// The routes to be advertised to the Amazon Web Services network in this Region. Applies to public virtual interfaces.
        public var routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
        /// The tags associated with the public virtual interface.
        public var tags: [DirectConnectClientTypes.Tag]?
        /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
        /// This member is required.
        public var virtualInterfaceName: Swift.String?
        /// The ID of the VLAN.
        /// This member is required.
        public var vlan: Swift.Int

        public init (
            addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
            amazonAddress: Swift.String? = nil,
            asn: Swift.Int = 0,
            authKey: Swift.String? = nil,
            customerAddress: Swift.String? = nil,
            routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil,
            virtualInterfaceName: Swift.String? = nil,
            vlan: Swift.Int = 0
        )
        {
            self.addressFamily = addressFamily
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.authKey = authKey
            self.customerAddress = customerAddress
            self.routeFilterPrefixes = routeFilterPrefixes
            self.tags = tags
            self.virtualInterfaceName = virtualInterfaceName
            self.vlan = vlan
        }
    }

}

extension DirectConnectClientTypes.NewTransitVirtualInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressFamily
        case amazonAddress
        case asn
        case authKey
        case customerAddress
        case directConnectGatewayId
        case enableSiteLink
        case mtu
        case tags
        case virtualInterfaceName
        case vlan
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressFamily = self.addressFamily {
            try encodeContainer.encode(addressFamily.rawValue, forKey: .addressFamily)
        }
        if let amazonAddress = self.amazonAddress {
            try encodeContainer.encode(amazonAddress, forKey: .amazonAddress)
        }
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let authKey = self.authKey {
            try encodeContainer.encode(authKey, forKey: .authKey)
        }
        if let customerAddress = self.customerAddress {
            try encodeContainer.encode(customerAddress, forKey: .customerAddress)
        }
        if let directConnectGatewayId = self.directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let enableSiteLink = self.enableSiteLink {
            try encodeContainer.encode(enableSiteLink, forKey: .enableSiteLink)
        }
        if let mtu = self.mtu {
            try encodeContainer.encode(mtu, forKey: .mtu)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let virtualInterfaceName = self.virtualInterfaceName {
            try encodeContainer.encode(virtualInterfaceName, forKey: .virtualInterfaceName)
        }
        if vlan != 0 {
            try encodeContainer.encode(vlan, forKey: .vlan)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn) ?? 0
        asn = asnDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let enableSiteLinkDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSiteLink)
        enableSiteLink = enableSiteLinkDecoded
    }
}

extension DirectConnectClientTypes {
    /// Information about a transit virtual interface.
    public struct NewTransitVirtualInterface: Swift.Equatable {
        /// The address family for the BGP peer.
        public var addressFamily: DirectConnectClientTypes.AddressFamily?
        /// The IP address assigned to the Amazon interface.
        public var amazonAddress: Swift.String?
        /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
        public var asn: Swift.Int
        /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
        public var authKey: Swift.String?
        /// The IP address assigned to the customer interface.
        public var customerAddress: Swift.String?
        /// The ID of the Direct Connect gateway.
        public var directConnectGatewayId: Swift.String?
        /// Indicates whether to enable or disable SiteLink.
        public var enableSiteLink: Swift.Bool?
        /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.
        public var mtu: Swift.Int?
        /// The tags associated with the transitive virtual interface.
        public var tags: [DirectConnectClientTypes.Tag]?
        /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
        public var virtualInterfaceName: Swift.String?
        /// The ID of the VLAN.
        public var vlan: Swift.Int

        public init (
            addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
            amazonAddress: Swift.String? = nil,
            asn: Swift.Int = 0,
            authKey: Swift.String? = nil,
            customerAddress: Swift.String? = nil,
            directConnectGatewayId: Swift.String? = nil,
            enableSiteLink: Swift.Bool? = nil,
            mtu: Swift.Int? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil,
            virtualInterfaceName: Swift.String? = nil,
            vlan: Swift.Int = 0
        )
        {
            self.addressFamily = addressFamily
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.authKey = authKey
            self.customerAddress = customerAddress
            self.directConnectGatewayId = directConnectGatewayId
            self.enableSiteLink = enableSiteLink
            self.mtu = mtu
            self.tags = tags
            self.virtualInterfaceName = virtualInterfaceName
            self.vlan = vlan
        }
    }

}

extension DirectConnectClientTypes.NewTransitVirtualInterfaceAllocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressFamily
        case amazonAddress
        case asn
        case authKey
        case customerAddress
        case mtu
        case tags
        case virtualInterfaceName
        case vlan
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressFamily = self.addressFamily {
            try encodeContainer.encode(addressFamily.rawValue, forKey: .addressFamily)
        }
        if let amazonAddress = self.amazonAddress {
            try encodeContainer.encode(amazonAddress, forKey: .amazonAddress)
        }
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let authKey = self.authKey {
            try encodeContainer.encode(authKey, forKey: .authKey)
        }
        if let customerAddress = self.customerAddress {
            try encodeContainer.encode(customerAddress, forKey: .customerAddress)
        }
        if let mtu = self.mtu {
            try encodeContainer.encode(mtu, forKey: .mtu)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let virtualInterfaceName = self.virtualInterfaceName {
            try encodeContainer.encode(virtualInterfaceName, forKey: .virtualInterfaceName)
        }
        if vlan != 0 {
            try encodeContainer.encode(vlan, forKey: .vlan)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn) ?? 0
        asn = asnDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DirectConnectClientTypes {
    /// Information about a transit virtual interface to be provisioned on a connection.
    public struct NewTransitVirtualInterfaceAllocation: Swift.Equatable {
        /// The address family for the BGP peer.
        public var addressFamily: DirectConnectClientTypes.AddressFamily?
        /// The IP address assigned to the Amazon interface.
        public var amazonAddress: Swift.String?
        /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
        public var asn: Swift.Int
        /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
        public var authKey: Swift.String?
        /// The IP address assigned to the customer interface.
        public var customerAddress: Swift.String?
        /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.
        public var mtu: Swift.Int?
        /// The tags associated with the transitive virtual interface.
        public var tags: [DirectConnectClientTypes.Tag]?
        /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
        public var virtualInterfaceName: Swift.String?
        /// The ID of the VLAN.
        public var vlan: Swift.Int

        public init (
            addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
            amazonAddress: Swift.String? = nil,
            asn: Swift.Int = 0,
            authKey: Swift.String? = nil,
            customerAddress: Swift.String? = nil,
            mtu: Swift.Int? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil,
            virtualInterfaceName: Swift.String? = nil,
            vlan: Swift.Int = 0
        )
        {
            self.addressFamily = addressFamily
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.authKey = authKey
            self.customerAddress = customerAddress
            self.mtu = mtu
            self.tags = tags
            self.virtualInterfaceName = virtualInterfaceName
            self.vlan = vlan
        }
    }

}

extension DirectConnectClientTypes {
    public enum NniPartnerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nonpartner
        case v1
        case v2
        case sdkUnknown(Swift.String)

        public static var allCases: [NniPartnerType] {
            return [
                .nonpartner,
                .v1,
                .v2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nonpartner: return "nonPartner"
            case .v1: return "v1"
            case .v2: return "v2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NniPartnerType(rawValue: rawValue) ?? NniPartnerType.sdkUnknown(rawValue)
        }
    }
}

extension DirectConnectClientTypes.ResourceTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DirectConnectClientTypes {
    /// Information about a tag associated with an Direct Connect resource.
    public struct ResourceTag: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var resourceArn: Swift.String?
        /// The tags.
        public var tags: [DirectConnectClientTypes.Tag]?

        public init (
            resourceArn: Swift.String? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil
        )
        {
            self.resourceArn = resourceArn
            self.tags = tags
        }
    }

}

extension DirectConnectClientTypes.RouteFilterPrefix: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = self.cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidr)
        cidr = cidrDecoded
    }
}

extension DirectConnectClientTypes {
    /// Information about a route filter prefix that a customer can advertise through Border Gateway Protocol (BGP) over a public virtual interface.
    public struct RouteFilterPrefix: Swift.Equatable {
        /// The CIDR block for the advertised route. Separate multiple routes using commas. An IPv6 CIDR must use /64 or shorter.
        public var cidr: Swift.String?

        public init (
            cidr: Swift.String? = nil
        )
        {
            self.cidr = cidr
        }
    }

}

extension DirectConnectClientTypes.RouterType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case platform
        case routerTypeIdentifier
        case software
        case vendor
        case xsltTemplateName
        case xsltTemplateNameForMacSec
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let platform = self.platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let routerTypeIdentifier = self.routerTypeIdentifier {
            try encodeContainer.encode(routerTypeIdentifier, forKey: .routerTypeIdentifier)
        }
        if let software = self.software {
            try encodeContainer.encode(software, forKey: .software)
        }
        if let vendor = self.vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
        if let xsltTemplateName = self.xsltTemplateName {
            try encodeContainer.encode(xsltTemplateName, forKey: .xsltTemplateName)
        }
        if let xsltTemplateNameForMacSec = self.xsltTemplateNameForMacSec {
            try encodeContainer.encode(xsltTemplateNameForMacSec, forKey: .xsltTemplateNameForMacSec)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vendorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendor)
        vendor = vendorDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let softwareDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .software)
        software = softwareDecoded
        let xsltTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .xsltTemplateName)
        xsltTemplateName = xsltTemplateNameDecoded
        let xsltTemplateNameForMacSecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .xsltTemplateNameForMacSec)
        xsltTemplateNameForMacSec = xsltTemplateNameForMacSecDecoded
        let routerTypeIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routerTypeIdentifier)
        routerTypeIdentifier = routerTypeIdentifierDecoded
    }
}

extension DirectConnectClientTypes {
    /// Information about the virtual router.
    public struct RouterType: Swift.Equatable {
        /// The virtual interface router platform.
        public var platform: Swift.String?
        /// Identifies the router by a combination of vendor, platform, and software version. For example, CiscoSystemsInc-2900SeriesRouters-IOS124.
        public var routerTypeIdentifier: Swift.String?
        /// The router software.
        public var software: Swift.String?
        /// The vendor for the virtual interface's router.
        public var vendor: Swift.String?
        /// The template for the virtual interface's router.
        public var xsltTemplateName: Swift.String?
        /// The MAC Security (MACsec) template for the virtual interface's router.
        public var xsltTemplateNameForMacSec: Swift.String?

        public init (
            platform: Swift.String? = nil,
            routerTypeIdentifier: Swift.String? = nil,
            software: Swift.String? = nil,
            vendor: Swift.String? = nil,
            xsltTemplateName: Swift.String? = nil,
            xsltTemplateNameForMacSec: Swift.String? = nil
        )
        {
            self.platform = platform
            self.routerTypeIdentifier = routerTypeIdentifier
            self.software = software
            self.vendor = vendor
            self.xsltTemplateName = xsltTemplateName
            self.xsltTemplateNameForMacSec = xsltTemplateNameForMacSec
        }
    }

}

extension StartBgpFailoverTestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bgpPeers
        case testDurationInMinutes
        case virtualInterfaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bgpPeers = bgpPeers {
            var bgpPeersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bgpPeers)
            for bgppeerid0 in bgpPeers {
                try bgpPeersContainer.encode(bgppeerid0)
            }
        }
        if let testDurationInMinutes = self.testDurationInMinutes {
            try encodeContainer.encode(testDurationInMinutes, forKey: .testDurationInMinutes)
        }
        if let virtualInterfaceId = self.virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

extension StartBgpFailoverTestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartBgpFailoverTestInput: Swift.Equatable {
    /// The BGP peers to place in the DOWN state.
    public var bgpPeers: [Swift.String]?
    /// The time in minutes that the virtual interface failover test will last. Maximum value: 180 minutes (3 hours). Default: 180 minutes (3 hours).
    public var testDurationInMinutes: Swift.Int?
    /// The ID of the virtual interface you want to test.
    /// This member is required.
    public var virtualInterfaceId: Swift.String?

    public init (
        bgpPeers: [Swift.String]? = nil,
        testDurationInMinutes: Swift.Int? = nil,
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.bgpPeers = bgpPeers
        self.testDurationInMinutes = testDurationInMinutes
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct StartBgpFailoverTestInputBody: Swift.Equatable {
    let virtualInterfaceId: Swift.String?
    let bgpPeers: [Swift.String]?
    let testDurationInMinutes: Swift.Int?
}

extension StartBgpFailoverTestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bgpPeers
        case testDurationInMinutes
        case virtualInterfaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let bgpPeersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .bgpPeers)
        var bgpPeersDecoded0:[Swift.String]? = nil
        if let bgpPeersContainer = bgpPeersContainer {
            bgpPeersDecoded0 = [Swift.String]()
            for string0 in bgpPeersContainer {
                if let string0 = string0 {
                    bgpPeersDecoded0?.append(string0)
                }
            }
        }
        bgpPeers = bgpPeersDecoded0
        let testDurationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .testDurationInMinutes)
        testDurationInMinutes = testDurationInMinutesDecoded
    }
}

extension StartBgpFailoverTestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartBgpFailoverTestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartBgpFailoverTestOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartBgpFailoverTestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartBgpFailoverTestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterfaceTest = output.virtualInterfaceTest
        } else {
            self.virtualInterfaceTest = nil
        }
    }
}

public struct StartBgpFailoverTestOutputResponse: Swift.Equatable {
    /// Information about the virtual interface failover test.
    public var virtualInterfaceTest: DirectConnectClientTypes.VirtualInterfaceTestHistory?

    public init (
        virtualInterfaceTest: DirectConnectClientTypes.VirtualInterfaceTestHistory? = nil
    )
    {
        self.virtualInterfaceTest = virtualInterfaceTest
    }
}

struct StartBgpFailoverTestOutputResponseBody: Swift.Equatable {
    let virtualInterfaceTest: DirectConnectClientTypes.VirtualInterfaceTestHistory?
}

extension StartBgpFailoverTestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualInterfaceTest
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceTestDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.VirtualInterfaceTestHistory.self, forKey: .virtualInterfaceTest)
        virtualInterfaceTest = virtualInterfaceTestDecoded
    }
}

extension StopBgpFailoverTestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualInterfaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let virtualInterfaceId = self.virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

extension StopBgpFailoverTestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopBgpFailoverTestInput: Swift.Equatable {
    /// The ID of the virtual interface you no longer want to test.
    /// This member is required.
    public var virtualInterfaceId: Swift.String?

    public init (
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct StopBgpFailoverTestInputBody: Swift.Equatable {
    let virtualInterfaceId: Swift.String?
}

extension StopBgpFailoverTestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualInterfaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
    }
}

extension StopBgpFailoverTestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopBgpFailoverTestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopBgpFailoverTestOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopBgpFailoverTestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StopBgpFailoverTestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterfaceTest = output.virtualInterfaceTest
        } else {
            self.virtualInterfaceTest = nil
        }
    }
}

public struct StopBgpFailoverTestOutputResponse: Swift.Equatable {
    /// Information about the virtual interface failover test.
    public var virtualInterfaceTest: DirectConnectClientTypes.VirtualInterfaceTestHistory?

    public init (
        virtualInterfaceTest: DirectConnectClientTypes.VirtualInterfaceTestHistory? = nil
    )
    {
        self.virtualInterfaceTest = virtualInterfaceTest
    }
}

struct StopBgpFailoverTestOutputResponseBody: Swift.Equatable {
    let virtualInterfaceTest: DirectConnectClientTypes.VirtualInterfaceTestHistory?
}

extension StopBgpFailoverTestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualInterfaceTest
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceTestDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.VirtualInterfaceTestHistory.self, forKey: .virtualInterfaceTest)
        virtualInterfaceTest = virtualInterfaceTestDecoded
    }
}

extension DirectConnectClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DirectConnectClientTypes {
    /// Information about a tag.
    public struct Tag: Swift.Equatable {
        /// The key.
        /// This member is required.
        public var key: Swift.String?
        /// The value.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add.
    /// This member is required.
    public var tags: [DirectConnectClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [DirectConnectClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the limit on the number of tags that can be assigned.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case connectionName
        case encryptionMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionName = self.connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let encryptionMode = self.encryptionMode {
            try encodeContainer.encode(encryptionMode, forKey: .encryptionMode)
        }
    }
}

extension UpdateConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateConnectionInput: Swift.Equatable {
    /// The ID of the dedicated connection. You can use [DescribeConnections] to retrieve the connection ID.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The name of the connection.
    public var connectionName: Swift.String?
    /// The connection MAC Security (MACsec) encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?

    public init (
        connectionId: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        encryptionMode: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.encryptionMode = encryptionMode
    }
}

struct UpdateConnectionInputBody: Swift.Equatable {
    let connectionId: Swift.String?
    let connectionName: Swift.String?
    let encryptionMode: Swift.String?
}

extension UpdateConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId
        case connectionName
        case encryptionMode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
    }
}

extension UpdateConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateConnectionOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.awsLogicalDeviceId = output.awsLogicalDeviceId
            self.bandwidth = output.bandwidth
            self.connectionId = output.connectionId
            self.connectionName = output.connectionName
            self.connectionState = output.connectionState
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.loaIssueTime = output.loaIssueTime
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.ownerAccount = output.ownerAccount
            self.partnerName = output.partnerName
            self.portEncryptionStatus = output.portEncryptionStatus
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
            self.vlan = output.vlan
        } else {
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.awsLogicalDeviceId = nil
            self.bandwidth = nil
            self.connectionId = nil
            self.connectionName = nil
            self.connectionState = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.loaIssueTime = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.ownerAccount = nil
            self.partnerName = nil
            self.portEncryptionStatus = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
            self.vlan = 0
        }
    }
}

/// Information about an Direct Connect connection.
public struct UpdateConnectionOutputResponse: Swift.Equatable {
    /// The Direct Connect endpoint on which the physical connection terminates.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The bandwidth of the connection.
    public var bandwidth: Swift.String?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The name of the connection.
    public var connectionName: Swift.String?
    /// The state of the connection. The following are the possible values:
    ///
    /// * ordering: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.
    ///
    /// * requested: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The connection has been approved and is being initialized.
    ///
    /// * available: The network link is up and the connection is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The connection is being deleted.
    ///
    /// * deleted: The connection has been deleted.
    ///
    /// * rejected: A hosted connection in the ordering state enters the rejected state if it is deleted by the customer.
    ///
    /// * unknown: The state of the connection is not available.
    public var connectionState: DirectConnectClientTypes.ConnectionState?
    /// The MAC Security (MACsec) connection encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames (9001 MTU) are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The time of the most recent call to [DescribeLoa] for this connection.
    public var loaIssueTime: ClientRuntime.Date?
    /// The location of the connection.
    public var location: Swift.String?
    /// Indicates whether the connection supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the connection.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The ID of the Amazon Web Services account that owns the connection.
    public var ownerAccount: Swift.String?
    /// The name of the Direct Connect service provider associated with the connection.
    public var partnerName: Swift.String?
    /// The MAC Security (MACsec) port link status of the connection. The valid values are Encryption Up, which means that there is an active Connection Key Name, or Encryption Down.
    public var portEncryptionStatus: Swift.String?
    /// The name of the service provider associated with the connection.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the connection.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init (
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bandwidth: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        connectionState: DirectConnectClientTypes.ConnectionState? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        loaIssueTime: ClientRuntime.Date? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        ownerAccount: Swift.String? = nil,
        partnerName: Swift.String? = nil,
        portEncryptionStatus: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

struct UpdateConnectionOutputResponseBody: Swift.Equatable {
    let ownerAccount: Swift.String?
    let connectionId: Swift.String?
    let connectionName: Swift.String?
    let connectionState: DirectConnectClientTypes.ConnectionState?
    let region: Swift.String?
    let location: Swift.String?
    let bandwidth: Swift.String?
    let vlan: Swift.Int
    let partnerName: Swift.String?
    let loaIssueTime: ClientRuntime.Date?
    let lagId: Swift.String?
    let awsDevice: Swift.String?
    let jumboFrameCapable: Swift.Bool?
    let awsDeviceV2: Swift.String?
    let awsLogicalDeviceId: Swift.String?
    let hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    let tags: [DirectConnectClientTypes.Tag]?
    let providerName: Swift.String?
    let macSecCapable: Swift.Bool?
    let portEncryptionStatus: Swift.String?
    let encryptionMode: Swift.String?
    let macSecKeys: [DirectConnectClientTypes.MacSecKey]?
}

extension UpdateConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsDevice
        case awsDeviceV2
        case awsLogicalDeviceId
        case bandwidth
        case connectionId
        case connectionName
        case connectionState
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case macSecCapable
        case macSecKeys
        case ownerAccount
        case partnerName
        case portEncryptionStatus
        case providerName
        case region
        case tags
        case vlan
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
        let loaIssueTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let portEncryptionStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portEncryptionStatus)
        portEncryptionStatus = portEncryptionStatusDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[DirectConnectClientTypes.MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [DirectConnectClientTypes.MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

extension UpdateDirectConnectGatewayAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addAllowedPrefixesToDirectConnectGateway
        case associationId
        case removeAllowedPrefixesToDirectConnectGateway
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGateway {
            var addAllowedPrefixesToDirectConnectGatewayContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addAllowedPrefixesToDirectConnectGateway)
            for routefilterprefix0 in addAllowedPrefixesToDirectConnectGateway {
                try addAllowedPrefixesToDirectConnectGatewayContainer.encode(routefilterprefix0)
            }
        }
        if let associationId = self.associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let removeAllowedPrefixesToDirectConnectGateway = removeAllowedPrefixesToDirectConnectGateway {
            var removeAllowedPrefixesToDirectConnectGatewayContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeAllowedPrefixesToDirectConnectGateway)
            for routefilterprefix0 in removeAllowedPrefixesToDirectConnectGateway {
                try removeAllowedPrefixesToDirectConnectGatewayContainer.encode(routefilterprefix0)
            }
        }
    }
}

extension UpdateDirectConnectGatewayAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDirectConnectGatewayAssociationInput: Swift.Equatable {
    /// The Amazon VPC prefixes to advertise to the Direct Connect gateway.
    public var addAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?
    /// The ID of the Direct Connect gateway association.
    public var associationId: Swift.String?
    /// The Amazon VPC prefixes to no longer advertise to the Direct Connect gateway.
    public var removeAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?

    public init (
        addAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
        associationId: Swift.String? = nil,
        removeAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]? = nil
    )
    {
        self.addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGateway
        self.associationId = associationId
        self.removeAllowedPrefixesToDirectConnectGateway = removeAllowedPrefixesToDirectConnectGateway
    }
}

struct UpdateDirectConnectGatewayAssociationInputBody: Swift.Equatable {
    let associationId: Swift.String?
    let addAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?
    let removeAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?
}

extension UpdateDirectConnectGatewayAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addAllowedPrefixesToDirectConnectGateway
        case associationId
        case removeAllowedPrefixesToDirectConnectGateway
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let addAllowedPrefixesToDirectConnectGatewayContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.RouteFilterPrefix?].self, forKey: .addAllowedPrefixesToDirectConnectGateway)
        var addAllowedPrefixesToDirectConnectGatewayDecoded0:[DirectConnectClientTypes.RouteFilterPrefix]? = nil
        if let addAllowedPrefixesToDirectConnectGatewayContainer = addAllowedPrefixesToDirectConnectGatewayContainer {
            addAllowedPrefixesToDirectConnectGatewayDecoded0 = [DirectConnectClientTypes.RouteFilterPrefix]()
            for structure0 in addAllowedPrefixesToDirectConnectGatewayContainer {
                if let structure0 = structure0 {
                    addAllowedPrefixesToDirectConnectGatewayDecoded0?.append(structure0)
                }
            }
        }
        addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGatewayDecoded0
        let removeAllowedPrefixesToDirectConnectGatewayContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.RouteFilterPrefix?].self, forKey: .removeAllowedPrefixesToDirectConnectGateway)
        var removeAllowedPrefixesToDirectConnectGatewayDecoded0:[DirectConnectClientTypes.RouteFilterPrefix]? = nil
        if let removeAllowedPrefixesToDirectConnectGatewayContainer = removeAllowedPrefixesToDirectConnectGatewayContainer {
            removeAllowedPrefixesToDirectConnectGatewayDecoded0 = [DirectConnectClientTypes.RouteFilterPrefix]()
            for structure0 in removeAllowedPrefixesToDirectConnectGatewayContainer {
                if let structure0 = structure0 {
                    removeAllowedPrefixesToDirectConnectGatewayDecoded0?.append(structure0)
                }
            }
        }
        removeAllowedPrefixesToDirectConnectGateway = removeAllowedPrefixesToDirectConnectGatewayDecoded0
    }
}

extension UpdateDirectConnectGatewayAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDirectConnectGatewayAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDirectConnectGatewayAssociationOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDirectConnectGatewayAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDirectConnectGatewayAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGatewayAssociation = output.directConnectGatewayAssociation
        } else {
            self.directConnectGatewayAssociation = nil
        }
    }
}

public struct UpdateDirectConnectGatewayAssociationOutputResponse: Swift.Equatable {
    /// Information about an association between a Direct Connect gateway and a virtual private gateway or transit gateway.
    public var directConnectGatewayAssociation: DirectConnectClientTypes.DirectConnectGatewayAssociation?

    public init (
        directConnectGatewayAssociation: DirectConnectClientTypes.DirectConnectGatewayAssociation? = nil
    )
    {
        self.directConnectGatewayAssociation = directConnectGatewayAssociation
    }
}

struct UpdateDirectConnectGatewayAssociationOutputResponseBody: Swift.Equatable {
    let directConnectGatewayAssociation: DirectConnectClientTypes.DirectConnectGatewayAssociation?
}

extension UpdateDirectConnectGatewayAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayAssociation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayAssociationDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.DirectConnectGatewayAssociation.self, forKey: .directConnectGatewayAssociation)
        directConnectGatewayAssociation = directConnectGatewayAssociationDecoded
    }
}

extension UpdateDirectConnectGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayId
        case newDirectConnectGatewayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directConnectGatewayId = self.directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let newDirectConnectGatewayName = self.newDirectConnectGatewayName {
            try encodeContainer.encode(newDirectConnectGatewayName, forKey: .newDirectConnectGatewayName)
        }
    }
}

extension UpdateDirectConnectGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDirectConnectGatewayInput: Swift.Equatable {
    /// The ID of the Direct Connect gateway to update.
    /// This member is required.
    public var directConnectGatewayId: Swift.String?
    /// The new name for the Direct Connect gateway.
    /// This member is required.
    public var newDirectConnectGatewayName: Swift.String?

    public init (
        directConnectGatewayId: Swift.String? = nil,
        newDirectConnectGatewayName: Swift.String? = nil
    )
    {
        self.directConnectGatewayId = directConnectGatewayId
        self.newDirectConnectGatewayName = newDirectConnectGatewayName
    }
}

struct UpdateDirectConnectGatewayInputBody: Swift.Equatable {
    let directConnectGatewayId: Swift.String?
    let newDirectConnectGatewayName: Swift.String?
}

extension UpdateDirectConnectGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGatewayId
        case newDirectConnectGatewayName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let newDirectConnectGatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newDirectConnectGatewayName)
        newDirectConnectGatewayName = newDirectConnectGatewayNameDecoded
    }
}

extension UpdateDirectConnectGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDirectConnectGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDirectConnectGatewayOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDirectConnectGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDirectConnectGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGateway = output.directConnectGateway
        } else {
            self.directConnectGateway = nil
        }
    }
}

public struct UpdateDirectConnectGatewayOutputResponse: Swift.Equatable {
    /// Information about a Direct Connect gateway, which enables you to connect virtual interfaces and virtual private gateway or transit gateways.
    public var directConnectGateway: DirectConnectClientTypes.DirectConnectGateway?

    public init (
        directConnectGateway: DirectConnectClientTypes.DirectConnectGateway? = nil
    )
    {
        self.directConnectGateway = directConnectGateway
    }
}

struct UpdateDirectConnectGatewayOutputResponseBody: Swift.Equatable {
    let directConnectGateway: DirectConnectClientTypes.DirectConnectGateway?
}

extension UpdateDirectConnectGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directConnectGateway
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.DirectConnectGateway.self, forKey: .directConnectGateway)
        directConnectGateway = directConnectGatewayDecoded
    }
}

extension UpdateLagInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionMode
        case lagId
        case lagName
        case minimumLinks
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionMode = self.encryptionMode {
            try encodeContainer.encode(encryptionMode, forKey: .encryptionMode)
        }
        if let lagId = self.lagId {
            try encodeContainer.encode(lagId, forKey: .lagId)
        }
        if let lagName = self.lagName {
            try encodeContainer.encode(lagName, forKey: .lagName)
        }
        if minimumLinks != 0 {
            try encodeContainer.encode(minimumLinks, forKey: .minimumLinks)
        }
    }
}

extension UpdateLagInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateLagInput: Swift.Equatable {
    /// The LAG MAC Security (MACsec) encryption mode. Amazon Web Services applies the value to all connections which are part of the LAG.
    public var encryptionMode: Swift.String?
    /// The ID of the LAG.
    /// This member is required.
    public var lagId: Swift.String?
    /// The name of the LAG.
    public var lagName: Swift.String?
    /// The minimum number of physical connections that must be operational for the LAG itself to be operational.
    public var minimumLinks: Swift.Int

    public init (
        encryptionMode: Swift.String? = nil,
        lagId: Swift.String? = nil,
        lagName: Swift.String? = nil,
        minimumLinks: Swift.Int = 0
    )
    {
        self.encryptionMode = encryptionMode
        self.lagId = lagId
        self.lagName = lagName
        self.minimumLinks = minimumLinks
    }
}

struct UpdateLagInputBody: Swift.Equatable {
    let lagId: Swift.String?
    let lagName: Swift.String?
    let minimumLinks: Swift.Int
    let encryptionMode: Swift.String?
}

extension UpdateLagInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionMode
        case lagId
        case lagName
        case minimumLinks
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let lagNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagName)
        lagName = lagNameDecoded
        let minimumLinksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumLinks) ?? 0
        minimumLinks = minimumLinksDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
    }
}

extension UpdateLagOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLagOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateLagOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLagOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateLagOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allowsHostedConnections = output.allowsHostedConnections
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.awsLogicalDeviceId = output.awsLogicalDeviceId
            self.connections = output.connections
            self.connectionsBandwidth = output.connectionsBandwidth
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.lagName = output.lagName
            self.lagState = output.lagState
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.minimumLinks = output.minimumLinks
            self.numberOfConnections = output.numberOfConnections
            self.ownerAccount = output.ownerAccount
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
        } else {
            self.allowsHostedConnections = false
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.awsLogicalDeviceId = nil
            self.connections = nil
            self.connectionsBandwidth = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.lagName = nil
            self.lagState = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.minimumLinks = 0
            self.numberOfConnections = 0
            self.ownerAccount = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
        }
    }
}

/// Information about a link aggregation group (LAG).
public struct UpdateLagOutputResponse: Swift.Equatable {
    /// Indicates whether the LAG can host other connections.
    public var allowsHostedConnections: Swift.Bool
    /// The Direct Connect endpoint that hosts the LAG.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that hosts the LAG.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The connections bundled by the LAG.
    public var connections: [DirectConnectClientTypes.Connection]?
    /// The individual bandwidth of the physical connections bundled by the LAG. The possible values are 1Gbps and 10Gbps.
    public var connectionsBandwidth: Swift.String?
    /// The LAG MAC Security (MACsec) encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the LAG supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames (9001 MTU) are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The name of the LAG.
    public var lagName: Swift.String?
    /// The state of the LAG. The following are the possible values:
    ///
    /// * requested: The initial state of a LAG. The LAG stays in the requested state until the Letter of Authorization (LOA) is available.
    ///
    /// * pending: The LAG has been approved and is being initialized.
    ///
    /// * available: The network link is established and the LAG is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The LAG is being deleted.
    ///
    /// * deleted: The LAG is deleted.
    ///
    /// * unknown: The state of the LAG is not available.
    public var lagState: DirectConnectClientTypes.LagState?
    /// The location of the LAG.
    public var location: Swift.String?
    /// Indicates whether the LAG supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the LAG.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The minimum number of physical dedicated connections that must be operational for the LAG itself to be operational.
    public var minimumLinks: Swift.Int
    /// The number of physical dedicated connections bundled by the LAG, up to a maximum of 10.
    public var numberOfConnections: Swift.Int
    /// The ID of the Amazon Web Services account that owns the LAG.
    public var ownerAccount: Swift.String?
    /// The name of the service provider associated with the LAG.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the LAG.
    public var tags: [DirectConnectClientTypes.Tag]?

    public init (
        allowsHostedConnections: Swift.Bool = false,
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        connections: [DirectConnectClientTypes.Connection]? = nil,
        connectionsBandwidth: Swift.String? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        lagName: Swift.String? = nil,
        lagState: DirectConnectClientTypes.LagState? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        minimumLinks: Swift.Int = 0,
        numberOfConnections: Swift.Int = 0,
        ownerAccount: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil
    )
    {
        self.allowsHostedConnections = allowsHostedConnections
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.connections = connections
        self.connectionsBandwidth = connectionsBandwidth
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.lagName = lagName
        self.lagState = lagState
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.minimumLinks = minimumLinks
        self.numberOfConnections = numberOfConnections
        self.ownerAccount = ownerAccount
        self.providerName = providerName
        self.region = region
        self.tags = tags
    }
}

struct UpdateLagOutputResponseBody: Swift.Equatable {
    let connectionsBandwidth: Swift.String?
    let numberOfConnections: Swift.Int
    let lagId: Swift.String?
    let ownerAccount: Swift.String?
    let lagName: Swift.String?
    let lagState: DirectConnectClientTypes.LagState?
    let location: Swift.String?
    let region: Swift.String?
    let minimumLinks: Swift.Int
    let awsDevice: Swift.String?
    let awsDeviceV2: Swift.String?
    let awsLogicalDeviceId: Swift.String?
    let connections: [DirectConnectClientTypes.Connection]?
    let allowsHostedConnections: Swift.Bool
    let jumboFrameCapable: Swift.Bool?
    let hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    let tags: [DirectConnectClientTypes.Tag]?
    let providerName: Swift.String?
    let macSecCapable: Swift.Bool?
    let encryptionMode: Swift.String?
    let macSecKeys: [DirectConnectClientTypes.MacSecKey]?
}

extension UpdateLagOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowsHostedConnections
        case awsDevice
        case awsDeviceV2
        case awsLogicalDeviceId
        case connections
        case connectionsBandwidth
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case lagName
        case lagState
        case location
        case macSecCapable
        case macSecKeys
        case minimumLinks
        case numberOfConnections
        case ownerAccount
        case providerName
        case region
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsBandwidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionsBandwidth)
        connectionsBandwidth = connectionsBandwidthDecoded
        let numberOfConnectionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfConnections) ?? 0
        numberOfConnections = numberOfConnectionsDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let lagNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagName)
        lagName = lagNameDecoded
        let lagStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.LagState.self, forKey: .lagState)
        lagState = lagStateDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let minimumLinksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumLinks) ?? 0
        minimumLinks = minimumLinksDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let connectionsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Connection?].self, forKey: .connections)
        var connectionsDecoded0:[DirectConnectClientTypes.Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [DirectConnectClientTypes.Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
        let allowsHostedConnectionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowsHostedConnections) ?? false
        allowsHostedConnections = allowsHostedConnectionsDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[DirectConnectClientTypes.MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [DirectConnectClientTypes.MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

extension UpdateVirtualInterfaceAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableSiteLink
        case mtu
        case virtualInterfaceId
        case virtualInterfaceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableSiteLink = self.enableSiteLink {
            try encodeContainer.encode(enableSiteLink, forKey: .enableSiteLink)
        }
        if let mtu = self.mtu {
            try encodeContainer.encode(mtu, forKey: .mtu)
        }
        if let virtualInterfaceId = self.virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
        if let virtualInterfaceName = self.virtualInterfaceName {
            try encodeContainer.encode(virtualInterfaceName, forKey: .virtualInterfaceName)
        }
    }
}

extension UpdateVirtualInterfaceAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateVirtualInterfaceAttributesInput: Swift.Equatable {
    /// Indicates whether to enable or disable SiteLink.
    public var enableSiteLink: Swift.Bool?
    /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.
    public var mtu: Swift.Int?
    /// The ID of the virtual private interface.
    /// This member is required.
    public var virtualInterfaceId: Swift.String?
    /// The name of the virtual private interface.
    public var virtualInterfaceName: Swift.String?

    public init (
        enableSiteLink: Swift.Bool? = nil,
        mtu: Swift.Int? = nil,
        virtualInterfaceId: Swift.String? = nil,
        virtualInterfaceName: Swift.String? = nil
    )
    {
        self.enableSiteLink = enableSiteLink
        self.mtu = mtu
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
    }
}

struct UpdateVirtualInterfaceAttributesInputBody: Swift.Equatable {
    let virtualInterfaceId: Swift.String?
    let mtu: Swift.Int?
    let enableSiteLink: Swift.Bool?
    let virtualInterfaceName: Swift.String?
}

extension UpdateVirtualInterfaceAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableSiteLink
        case mtu
        case virtualInterfaceId
        case virtualInterfaceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let enableSiteLinkDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSiteLink)
        enableSiteLink = enableSiteLinkDecoded
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
    }
}

extension UpdateVirtualInterfaceAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVirtualInterfaceAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateVirtualInterfaceAttributesOutputError: Swift.Error, Swift.Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVirtualInterfaceAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateVirtualInterfaceAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addressFamily = output.addressFamily
            self.amazonAddress = output.amazonAddress
            self.amazonSideAsn = output.amazonSideAsn
            self.asn = output.asn
            self.authKey = output.authKey
            self.awsDeviceV2 = output.awsDeviceV2
            self.awsLogicalDeviceId = output.awsLogicalDeviceId
            self.bgpPeers = output.bgpPeers
            self.connectionId = output.connectionId
            self.customerAddress = output.customerAddress
            self.customerRouterConfig = output.customerRouterConfig
            self.directConnectGatewayId = output.directConnectGatewayId
            self.jumboFrameCapable = output.jumboFrameCapable
            self.location = output.location
            self.mtu = output.mtu
            self.ownerAccount = output.ownerAccount
            self.region = output.region
            self.routeFilterPrefixes = output.routeFilterPrefixes
            self.siteLinkEnabled = output.siteLinkEnabled
            self.tags = output.tags
            self.virtualGatewayId = output.virtualGatewayId
            self.virtualInterfaceId = output.virtualInterfaceId
            self.virtualInterfaceName = output.virtualInterfaceName
            self.virtualInterfaceState = output.virtualInterfaceState
            self.virtualInterfaceType = output.virtualInterfaceType
            self.vlan = output.vlan
        } else {
            self.addressFamily = nil
            self.amazonAddress = nil
            self.amazonSideAsn = nil
            self.asn = 0
            self.authKey = nil
            self.awsDeviceV2 = nil
            self.awsLogicalDeviceId = nil
            self.bgpPeers = nil
            self.connectionId = nil
            self.customerAddress = nil
            self.customerRouterConfig = nil
            self.directConnectGatewayId = nil
            self.jumboFrameCapable = nil
            self.location = nil
            self.mtu = nil
            self.ownerAccount = nil
            self.region = nil
            self.routeFilterPrefixes = nil
            self.siteLinkEnabled = nil
            self.tags = nil
            self.virtualGatewayId = nil
            self.virtualInterfaceId = nil
            self.virtualInterfaceName = nil
            self.virtualInterfaceState = nil
            self.virtualInterfaceType = nil
            self.vlan = 0
        }
    }
}

/// Information about a virtual interface.
public struct UpdateVirtualInterfaceAttributesOutputResponse: Swift.Equatable {
    /// The address family for the BGP peer.
    public var addressFamily: DirectConnectClientTypes.AddressFamily?
    /// The IP address assigned to the Amazon interface.
    public var amazonAddress: Swift.String?
    /// The autonomous system number (ASN) for the Amazon side of the connection.
    public var amazonSideAsn: Swift.Int?
    /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
    public var asn: Swift.Int
    /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
    public var authKey: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The BGP peers configured on this virtual interface.
    public var bgpPeers: [DirectConnectClientTypes.BGPPeer]?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The IP address assigned to the customer interface.
    public var customerAddress: Swift.String?
    /// The customer router configuration.
    public var customerRouterConfig: Swift.String?
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// Indicates whether jumbo frames (9001 MTU) are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The location of the connection.
    public var location: Swift.String?
    /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.
    public var mtu: Swift.Int?
    /// The ID of the Amazon Web Services account that owns the virtual interface.
    public var ownerAccount: Swift.String?
    /// The Amazon Web Services Region where the virtual interface is located.
    public var region: Swift.String?
    /// The routes to be advertised to the Amazon Web Services network in this Region. Applies to public virtual interfaces.
    public var routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
    /// Indicates whether SiteLink is enabled.
    public var siteLinkEnabled: Swift.Bool?
    /// The tags associated with the virtual interface.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the virtual private gateway. Applies only to private virtual interfaces.
    public var virtualGatewayId: Swift.String?
    /// The ID of the virtual interface.
    public var virtualInterfaceId: Swift.String?
    /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
    public var virtualInterfaceName: Swift.String?
    /// The state of the virtual interface. The following are the possible values:
    ///
    /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
    ///
    /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
    ///
    /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
    ///
    /// * available: A virtual interface that is able to forward traffic.
    ///
    /// * down: A virtual interface that is BGP down.
    ///
    /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
    ///
    /// * deleted: A virtual interface that cannot forward traffic.
    ///
    /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
    ///
    /// * unknown: The state of the virtual interface is not available.
    public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
    /// The type of virtual interface. The possible values are private and public.
    public var virtualInterfaceType: Swift.String?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init (
        addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
        amazonAddress: Swift.String? = nil,
        amazonSideAsn: Swift.Int? = nil,
        asn: Swift.Int = 0,
        authKey: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bgpPeers: [DirectConnectClientTypes.BGPPeer]? = nil,
        connectionId: Swift.String? = nil,
        customerAddress: Swift.String? = nil,
        customerRouterConfig: Swift.String? = nil,
        directConnectGatewayId: Swift.String? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        location: Swift.String? = nil,
        mtu: Swift.Int? = nil,
        ownerAccount: Swift.String? = nil,
        region: Swift.String? = nil,
        routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
        siteLinkEnabled: Swift.Bool? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        virtualGatewayId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil,
        virtualInterfaceName: Swift.String? = nil,
        virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil,
        virtualInterfaceType: Swift.String? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.amazonSideAsn = amazonSideAsn
        self.asn = asn
        self.authKey = authKey
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bgpPeers = bgpPeers
        self.connectionId = connectionId
        self.customerAddress = customerAddress
        self.customerRouterConfig = customerRouterConfig
        self.directConnectGatewayId = directConnectGatewayId
        self.jumboFrameCapable = jumboFrameCapable
        self.location = location
        self.mtu = mtu
        self.ownerAccount = ownerAccount
        self.region = region
        self.routeFilterPrefixes = routeFilterPrefixes
        self.siteLinkEnabled = siteLinkEnabled
        self.tags = tags
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
        self.virtualInterfaceState = virtualInterfaceState
        self.virtualInterfaceType = virtualInterfaceType
        self.vlan = vlan
    }
}

struct UpdateVirtualInterfaceAttributesOutputResponseBody: Swift.Equatable {
    let ownerAccount: Swift.String?
    let virtualInterfaceId: Swift.String?
    let location: Swift.String?
    let connectionId: Swift.String?
    let virtualInterfaceType: Swift.String?
    let virtualInterfaceName: Swift.String?
    let vlan: Swift.Int
    let asn: Swift.Int
    let amazonSideAsn: Swift.Int?
    let authKey: Swift.String?
    let amazonAddress: Swift.String?
    let customerAddress: Swift.String?
    let addressFamily: DirectConnectClientTypes.AddressFamily?
    let virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
    let customerRouterConfig: Swift.String?
    let mtu: Swift.Int?
    let jumboFrameCapable: Swift.Bool?
    let virtualGatewayId: Swift.String?
    let directConnectGatewayId: Swift.String?
    let routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
    let bgpPeers: [DirectConnectClientTypes.BGPPeer]?
    let region: Swift.String?
    let awsDeviceV2: Swift.String?
    let awsLogicalDeviceId: Swift.String?
    let tags: [DirectConnectClientTypes.Tag]?
    let siteLinkEnabled: Swift.Bool?
}

extension UpdateVirtualInterfaceAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressFamily
        case amazonAddress
        case amazonSideAsn
        case asn
        case authKey
        case awsDeviceV2
        case awsLogicalDeviceId
        case bgpPeers
        case connectionId
        case customerAddress
        case customerRouterConfig
        case directConnectGatewayId
        case jumboFrameCapable
        case location
        case mtu
        case ownerAccount
        case region
        case routeFilterPrefixes
        case siteLinkEnabled
        case tags
        case virtualGatewayId
        case virtualInterfaceId
        case virtualInterfaceName
        case virtualInterfaceState
        case virtualInterfaceType
        case vlan
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let virtualInterfaceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceType)
        virtualInterfaceType = virtualInterfaceTypeDecoded
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn) ?? 0
        asn = asnDecoded
        let amazonSideAsnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .amazonSideAsn)
        amazonSideAsn = amazonSideAsnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
        let customerRouterConfigDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerRouterConfig)
        customerRouterConfig = customerRouterConfigDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let routeFilterPrefixesContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.RouteFilterPrefix?].self, forKey: .routeFilterPrefixes)
        var routeFilterPrefixesDecoded0:[DirectConnectClientTypes.RouteFilterPrefix]? = nil
        if let routeFilterPrefixesContainer = routeFilterPrefixesContainer {
            routeFilterPrefixesDecoded0 = [DirectConnectClientTypes.RouteFilterPrefix]()
            for structure0 in routeFilterPrefixesContainer {
                if let structure0 = structure0 {
                    routeFilterPrefixesDecoded0?.append(structure0)
                }
            }
        }
        routeFilterPrefixes = routeFilterPrefixesDecoded0
        let bgpPeersContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.BGPPeer?].self, forKey: .bgpPeers)
        var bgpPeersDecoded0:[DirectConnectClientTypes.BGPPeer]? = nil
        if let bgpPeersContainer = bgpPeersContainer {
            bgpPeersDecoded0 = [DirectConnectClientTypes.BGPPeer]()
            for structure0 in bgpPeersContainer {
                if let structure0 = structure0 {
                    bgpPeersDecoded0?.append(structure0)
                }
            }
        }
        bgpPeers = bgpPeersDecoded0
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let siteLinkEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .siteLinkEnabled)
        siteLinkEnabled = siteLinkEnabledDecoded
    }
}

extension DirectConnectClientTypes.VirtualGateway: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualGatewayId
        case virtualGatewayState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let virtualGatewayId = self.virtualGatewayId {
            try encodeContainer.encode(virtualGatewayId, forKey: .virtualGatewayId)
        }
        if let virtualGatewayState = self.virtualGatewayState {
            try encodeContainer.encode(virtualGatewayState, forKey: .virtualGatewayState)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let virtualGatewayStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayState)
        virtualGatewayState = virtualGatewayStateDecoded
    }
}

extension DirectConnectClientTypes {
    /// Information about a virtual private gateway for a private virtual interface.
    public struct VirtualGateway: Swift.Equatable {
        /// The ID of the virtual private gateway.
        public var virtualGatewayId: Swift.String?
        /// The state of the virtual private gateway. The following are the possible values:
        ///
        /// * pending: Initial state after creating the virtual private gateway.
        ///
        /// * available: Ready for use by a private virtual interface.
        ///
        /// * deleting: Initial state after deleting the virtual private gateway.
        ///
        /// * deleted: The virtual private gateway is deleted. The private virtual interface is unable to send traffic over this gateway.
        public var virtualGatewayState: Swift.String?

        public init (
            virtualGatewayId: Swift.String? = nil,
            virtualGatewayState: Swift.String? = nil
        )
        {
            self.virtualGatewayId = virtualGatewayId
            self.virtualGatewayState = virtualGatewayState
        }
    }

}

extension DirectConnectClientTypes.VirtualInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressFamily
        case amazonAddress
        case amazonSideAsn
        case asn
        case authKey
        case awsDeviceV2
        case awsLogicalDeviceId
        case bgpPeers
        case connectionId
        case customerAddress
        case customerRouterConfig
        case directConnectGatewayId
        case jumboFrameCapable
        case location
        case mtu
        case ownerAccount
        case region
        case routeFilterPrefixes
        case siteLinkEnabled
        case tags
        case virtualGatewayId
        case virtualInterfaceId
        case virtualInterfaceName
        case virtualInterfaceState
        case virtualInterfaceType
        case vlan
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressFamily = self.addressFamily {
            try encodeContainer.encode(addressFamily.rawValue, forKey: .addressFamily)
        }
        if let amazonAddress = self.amazonAddress {
            try encodeContainer.encode(amazonAddress, forKey: .amazonAddress)
        }
        if let amazonSideAsn = self.amazonSideAsn {
            try encodeContainer.encode(amazonSideAsn, forKey: .amazonSideAsn)
        }
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let authKey = self.authKey {
            try encodeContainer.encode(authKey, forKey: .authKey)
        }
        if let awsDeviceV2 = self.awsDeviceV2 {
            try encodeContainer.encode(awsDeviceV2, forKey: .awsDeviceV2)
        }
        if let awsLogicalDeviceId = self.awsLogicalDeviceId {
            try encodeContainer.encode(awsLogicalDeviceId, forKey: .awsLogicalDeviceId)
        }
        if let bgpPeers = bgpPeers {
            var bgpPeersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bgpPeers)
            for bgppeer0 in bgpPeers {
                try bgpPeersContainer.encode(bgppeer0)
            }
        }
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let customerAddress = self.customerAddress {
            try encodeContainer.encode(customerAddress, forKey: .customerAddress)
        }
        if let customerRouterConfig = self.customerRouterConfig {
            try encodeContainer.encode(customerRouterConfig, forKey: .customerRouterConfig)
        }
        if let directConnectGatewayId = self.directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let jumboFrameCapable = self.jumboFrameCapable {
            try encodeContainer.encode(jumboFrameCapable, forKey: .jumboFrameCapable)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let mtu = self.mtu {
            try encodeContainer.encode(mtu, forKey: .mtu)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let routeFilterPrefixes = routeFilterPrefixes {
            var routeFilterPrefixesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routeFilterPrefixes)
            for routefilterprefix0 in routeFilterPrefixes {
                try routeFilterPrefixesContainer.encode(routefilterprefix0)
            }
        }
        if let siteLinkEnabled = self.siteLinkEnabled {
            try encodeContainer.encode(siteLinkEnabled, forKey: .siteLinkEnabled)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let virtualGatewayId = self.virtualGatewayId {
            try encodeContainer.encode(virtualGatewayId, forKey: .virtualGatewayId)
        }
        if let virtualInterfaceId = self.virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
        if let virtualInterfaceName = self.virtualInterfaceName {
            try encodeContainer.encode(virtualInterfaceName, forKey: .virtualInterfaceName)
        }
        if let virtualInterfaceState = self.virtualInterfaceState {
            try encodeContainer.encode(virtualInterfaceState.rawValue, forKey: .virtualInterfaceState)
        }
        if let virtualInterfaceType = self.virtualInterfaceType {
            try encodeContainer.encode(virtualInterfaceType, forKey: .virtualInterfaceType)
        }
        if vlan != 0 {
            try encodeContainer.encode(vlan, forKey: .vlan)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let virtualInterfaceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceType)
        virtualInterfaceType = virtualInterfaceTypeDecoded
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vlan) ?? 0
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn) ?? 0
        asn = asnDecoded
        let amazonSideAsnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .amazonSideAsn)
        amazonSideAsn = amazonSideAsnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(DirectConnectClientTypes.VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
        let customerRouterConfigDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerRouterConfig)
        customerRouterConfig = customerRouterConfigDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let routeFilterPrefixesContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.RouteFilterPrefix?].self, forKey: .routeFilterPrefixes)
        var routeFilterPrefixesDecoded0:[DirectConnectClientTypes.RouteFilterPrefix]? = nil
        if let routeFilterPrefixesContainer = routeFilterPrefixesContainer {
            routeFilterPrefixesDecoded0 = [DirectConnectClientTypes.RouteFilterPrefix]()
            for structure0 in routeFilterPrefixesContainer {
                if let structure0 = structure0 {
                    routeFilterPrefixesDecoded0?.append(structure0)
                }
            }
        }
        routeFilterPrefixes = routeFilterPrefixesDecoded0
        let bgpPeersContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.BGPPeer?].self, forKey: .bgpPeers)
        var bgpPeersDecoded0:[DirectConnectClientTypes.BGPPeer]? = nil
        if let bgpPeersContainer = bgpPeersContainer {
            bgpPeersDecoded0 = [DirectConnectClientTypes.BGPPeer]()
            for structure0 in bgpPeersContainer {
                if let structure0 = structure0 {
                    bgpPeersDecoded0?.append(structure0)
                }
            }
        }
        bgpPeers = bgpPeersDecoded0
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let awsLogicalDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsLogicalDeviceId)
        awsLogicalDeviceId = awsLogicalDeviceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectConnectClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectConnectClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectConnectClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let siteLinkEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .siteLinkEnabled)
        siteLinkEnabled = siteLinkEnabledDecoded
    }
}

extension DirectConnectClientTypes {
    /// Information about a virtual interface.
    public struct VirtualInterface: Swift.Equatable {
        /// The address family for the BGP peer.
        public var addressFamily: DirectConnectClientTypes.AddressFamily?
        /// The IP address assigned to the Amazon interface.
        public var amazonAddress: Swift.String?
        /// The autonomous system number (ASN) for the Amazon side of the connection.
        public var amazonSideAsn: Swift.Int?
        /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
        public var asn: Swift.Int
        /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
        public var authKey: Swift.String?
        /// The Direct Connect endpoint that terminates the physical connection.
        public var awsDeviceV2: Swift.String?
        /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
        public var awsLogicalDeviceId: Swift.String?
        /// The BGP peers configured on this virtual interface.
        public var bgpPeers: [DirectConnectClientTypes.BGPPeer]?
        /// The ID of the connection.
        public var connectionId: Swift.String?
        /// The IP address assigned to the customer interface.
        public var customerAddress: Swift.String?
        /// The customer router configuration.
        public var customerRouterConfig: Swift.String?
        /// The ID of the Direct Connect gateway.
        public var directConnectGatewayId: Swift.String?
        /// Indicates whether jumbo frames (9001 MTU) are supported.
        public var jumboFrameCapable: Swift.Bool?
        /// The location of the connection.
        public var location: Swift.String?
        /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.
        public var mtu: Swift.Int?
        /// The ID of the Amazon Web Services account that owns the virtual interface.
        public var ownerAccount: Swift.String?
        /// The Amazon Web Services Region where the virtual interface is located.
        public var region: Swift.String?
        /// The routes to be advertised to the Amazon Web Services network in this Region. Applies to public virtual interfaces.
        public var routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
        /// Indicates whether SiteLink is enabled.
        public var siteLinkEnabled: Swift.Bool?
        /// The tags associated with the virtual interface.
        public var tags: [DirectConnectClientTypes.Tag]?
        /// The ID of the virtual private gateway. Applies only to private virtual interfaces.
        public var virtualGatewayId: Swift.String?
        /// The ID of the virtual interface.
        public var virtualInterfaceId: Swift.String?
        /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
        public var virtualInterfaceName: Swift.String?
        /// The state of the virtual interface. The following are the possible values:
        ///
        /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
        ///
        /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
        ///
        /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
        ///
        /// * available: A virtual interface that is able to forward traffic.
        ///
        /// * down: A virtual interface that is BGP down.
        ///
        /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
        ///
        /// * deleted: A virtual interface that cannot forward traffic.
        ///
        /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
        ///
        /// * unknown: The state of the virtual interface is not available.
        public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
        /// The type of virtual interface. The possible values are private and public.
        public var virtualInterfaceType: Swift.String?
        /// The ID of the VLAN.
        public var vlan: Swift.Int

        public init (
            addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
            amazonAddress: Swift.String? = nil,
            amazonSideAsn: Swift.Int? = nil,
            asn: Swift.Int = 0,
            authKey: Swift.String? = nil,
            awsDeviceV2: Swift.String? = nil,
            awsLogicalDeviceId: Swift.String? = nil,
            bgpPeers: [DirectConnectClientTypes.BGPPeer]? = nil,
            connectionId: Swift.String? = nil,
            customerAddress: Swift.String? = nil,
            customerRouterConfig: Swift.String? = nil,
            directConnectGatewayId: Swift.String? = nil,
            jumboFrameCapable: Swift.Bool? = nil,
            location: Swift.String? = nil,
            mtu: Swift.Int? = nil,
            ownerAccount: Swift.String? = nil,
            region: Swift.String? = nil,
            routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
            siteLinkEnabled: Swift.Bool? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil,
            virtualGatewayId: Swift.String? = nil,
            virtualInterfaceId: Swift.String? = nil,
            virtualInterfaceName: Swift.String? = nil,
            virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil,
            virtualInterfaceType: Swift.String? = nil,
            vlan: Swift.Int = 0
        )
        {
            self.addressFamily = addressFamily
            self.amazonAddress = amazonAddress
            self.amazonSideAsn = amazonSideAsn
            self.asn = asn
            self.authKey = authKey
            self.awsDeviceV2 = awsDeviceV2
            self.awsLogicalDeviceId = awsLogicalDeviceId
            self.bgpPeers = bgpPeers
            self.connectionId = connectionId
            self.customerAddress = customerAddress
            self.customerRouterConfig = customerRouterConfig
            self.directConnectGatewayId = directConnectGatewayId
            self.jumboFrameCapable = jumboFrameCapable
            self.location = location
            self.mtu = mtu
            self.ownerAccount = ownerAccount
            self.region = region
            self.routeFilterPrefixes = routeFilterPrefixes
            self.siteLinkEnabled = siteLinkEnabled
            self.tags = tags
            self.virtualGatewayId = virtualGatewayId
            self.virtualInterfaceId = virtualInterfaceId
            self.virtualInterfaceName = virtualInterfaceName
            self.virtualInterfaceState = virtualInterfaceState
            self.virtualInterfaceType = virtualInterfaceType
            self.vlan = vlan
        }
    }

}

extension DirectConnectClientTypes {
    public enum VirtualInterfaceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case confirming
        case deleted
        case deleting
        case down
        case pending
        case rejected
        case unknown
        case verifying
        case sdkUnknown(Swift.String)

        public static var allCases: [VirtualInterfaceState] {
            return [
                .available,
                .confirming,
                .deleted,
                .deleting,
                .down,
                .pending,
                .rejected,
                .unknown,
                .verifying,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .confirming: return "confirming"
            case .deleted: return "deleted"
            case .deleting: return "deleting"
            case .down: return "down"
            case .pending: return "pending"
            case .rejected: return "rejected"
            case .unknown: return "unknown"
            case .verifying: return "verifying"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VirtualInterfaceState(rawValue: rawValue) ?? VirtualInterfaceState.sdkUnknown(rawValue)
        }
    }
}

extension DirectConnectClientTypes.VirtualInterfaceTestHistory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bgpPeers
        case endTime
        case ownerAccount
        case startTime
        case status
        case testDurationInMinutes
        case testId
        case virtualInterfaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bgpPeers = bgpPeers {
            var bgpPeersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bgpPeers)
            for bgppeerid0 in bgpPeers {
                try bgpPeersContainer.encode(bgppeerid0)
            }
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let testDurationInMinutes = self.testDurationInMinutes {
            try encodeContainer.encode(testDurationInMinutes, forKey: .testDurationInMinutes)
        }
        if let testId = self.testId {
            try encodeContainer.encode(testId, forKey: .testId)
        }
        if let virtualInterfaceId = self.virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testId)
        testId = testIdDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let bgpPeersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .bgpPeers)
        var bgpPeersDecoded0:[Swift.String]? = nil
        if let bgpPeersContainer = bgpPeersContainer {
            bgpPeersDecoded0 = [Swift.String]()
            for string0 in bgpPeersContainer {
                if let string0 = string0 {
                    bgpPeersDecoded0?.append(string0)
                }
            }
        }
        bgpPeers = bgpPeersDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let testDurationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .testDurationInMinutes)
        testDurationInMinutes = testDurationInMinutesDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension DirectConnectClientTypes {
    /// Information about the virtual interface failover test.
    public struct VirtualInterfaceTestHistory: Swift.Equatable {
        /// The BGP peers that were put in the DOWN state as part of the virtual interface failover test.
        public var bgpPeers: [Swift.String]?
        /// The time that the virtual interface moves out of the DOWN state.
        public var endTime: ClientRuntime.Date?
        /// The owner ID of the tested virtual interface.
        public var ownerAccount: Swift.String?
        /// The time that the virtual interface moves to the DOWN state.
        public var startTime: ClientRuntime.Date?
        /// The status of the virtual interface failover test.
        public var status: Swift.String?
        /// The time that the virtual interface failover test ran in minutes.
        public var testDurationInMinutes: Swift.Int?
        /// The ID of the virtual interface failover test.
        public var testId: Swift.String?
        /// The ID of the tested virtual interface.
        public var virtualInterfaceId: Swift.String?

        public init (
            bgpPeers: [Swift.String]? = nil,
            endTime: ClientRuntime.Date? = nil,
            ownerAccount: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: Swift.String? = nil,
            testDurationInMinutes: Swift.Int? = nil,
            testId: Swift.String? = nil,
            virtualInterfaceId: Swift.String? = nil
        )
        {
            self.bgpPeers = bgpPeers
            self.endTime = endTime
            self.ownerAccount = ownerAccount
            self.startTime = startTime
            self.status = status
            self.testDurationInMinutes = testDurationInMinutes
            self.testId = testId
            self.virtualInterfaceId = virtualInterfaceId
        }
    }

}
