// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ActivityDoesNotExist: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivityDoesNotExist(message: \(String(describing: message)))"}
}

extension ActivityDoesNotExist: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ActivityDoesNotExistBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified activity does not exist.</p>
public struct ActivityDoesNotExist: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ActivityDoesNotExistBody: Equatable {
    public let message: String?
}

extension ActivityDoesNotExistBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ActivityFailedEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cause
        case error
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension ActivityFailedEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivityFailedEventDetails(cause: \(String(describing: cause)), error: \(String(describing: error)))"}
}

/// <p>Contains details about an activity that failed during an execution.</p>
public struct ActivityFailedEventDetails: Equatable {
    /// <p>A more detailed explanation of the cause of the failure.</p>
    public let cause: String?
    /// <p>The error code of the failure.</p>
    public let error: String?

    public init (
        cause: String? = nil,
        error: String? = nil
    )
    {
        self.cause = cause
        self.error = error
    }
}

extension ActivityLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivityLimitExceeded(message: \(String(describing: message)))"}
}

extension ActivityLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ActivityLimitExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of activities has been reached. Existing activities must be deleted
///       before a new activity can be created.</p>
public struct ActivityLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ActivityLimitExceededBody: Equatable {
    public let message: String?
}

extension ActivityLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ActivityListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activityArn
        case creationDate
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activityArn = activityArn {
            try encodeContainer.encode(activityArn, forKey: .activityArn)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activityArn)
        activityArn = activityArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension ActivityListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivityListItem(activityArn: \(String(describing: activityArn)), creationDate: \(String(describing: creationDate)), name: \(String(describing: name)))"}
}

/// <p>Contains details about an activity.</p>
public struct ActivityListItem: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the activity.</p>
    public let activityArn: String?
    /// <p>The date the activity is created.</p>
    public let creationDate: Date?
    /// <p>The name of the activity.</p>
    ///          <p>A name must <i>not</i> contain:</p>
    ///          <ul>
    ///             <li>
    ///                <p>white space</p>
    ///             </li>
    ///             <li>
    ///                <p>brackets <code>< > { } [ ]</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>wildcard characters <code>? *</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>special characters <code>" # % \ ^ | ~ ` $ & , ; : /</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>control characters (<code>U+0000-001F</code>, <code>U+007F-009F</code>)</p>
    ///             </li>
    ///          </ul>
    ///          <p>To enable logging with CloudWatch Logs, the name should only contain  0-9, A-Z, a-z, - and _.</p>
    public let name: String?

    public init (
        activityArn: String? = nil,
        creationDate: Date? = nil,
        name: String? = nil
    )
    {
        self.activityArn = activityArn
        self.creationDate = creationDate
        self.name = name
    }
}

extension ActivityScheduleFailedEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cause
        case error
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension ActivityScheduleFailedEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivityScheduleFailedEventDetails(cause: \(String(describing: cause)), error: \(String(describing: error)))"}
}

/// <p>Contains details about an activity schedule failure that occurred during an
///       execution.</p>
public struct ActivityScheduleFailedEventDetails: Equatable {
    /// <p>A more detailed explanation of the cause of the failure.</p>
    public let cause: String?
    /// <p>The error code of the failure.</p>
    public let error: String?

    public init (
        cause: String? = nil,
        error: String? = nil
    )
    {
        self.cause = cause
        self.error = error
    }
}

extension ActivityScheduledEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case heartbeatInSeconds
        case input
        case inputDetails
        case resource
        case timeoutInSeconds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if heartbeatInSeconds != 0 {
            try encodeContainer.encode(heartbeatInSeconds, forKey: .heartbeatInSeconds)
        }
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let inputDetails = inputDetails {
            try encodeContainer.encode(inputDetails, forKey: .inputDetails)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if timeoutInSeconds != 0 {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
        let inputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .input)
        input = inputDecoded
        let inputDetailsDecoded = try containerValues.decodeIfPresent(HistoryEventExecutionDataDetails.self, forKey: .inputDetails)
        inputDetails = inputDetailsDecoded
        let timeoutInSecondsDecoded = try containerValues.decode(Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let heartbeatInSecondsDecoded = try containerValues.decode(Int.self, forKey: .heartbeatInSeconds)
        heartbeatInSeconds = heartbeatInSecondsDecoded
    }
}

extension ActivityScheduledEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivityScheduledEventDetails(heartbeatInSeconds: \(String(describing: heartbeatInSeconds)), input: \(String(describing: input)), inputDetails: \(String(describing: inputDetails)), resource: \(String(describing: resource)), timeoutInSeconds: \(String(describing: timeoutInSeconds)))"}
}

/// <p>Contains details about an activity scheduled during an execution.</p>
public struct ActivityScheduledEventDetails: Equatable {
    /// <p>The maximum allowed duration between two heartbeats for the activity task.</p>
    public let heartbeatInSeconds: Int
    /// <p>The JSON data input to the activity task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.</p>
    public let input: String?
    /// <p>Contains details about the input for an execution history event.</p>
    public let inputDetails: HistoryEventExecutionDataDetails?
    /// <p>The Amazon Resource Name (ARN) of the scheduled activity.</p>
    public let resource: String?
    /// <p>The maximum allowed duration of the activity task.</p>
    public let timeoutInSeconds: Int

    public init (
        heartbeatInSeconds: Int = 0,
        input: String? = nil,
        inputDetails: HistoryEventExecutionDataDetails? = nil,
        resource: String? = nil,
        timeoutInSeconds: Int = 0
    )
    {
        self.heartbeatInSeconds = heartbeatInSeconds
        self.input = input
        self.inputDetails = inputDetails
        self.resource = resource
        self.timeoutInSeconds = timeoutInSeconds
    }
}

extension ActivityStartedEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case workerName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workerName = workerName {
            try encodeContainer.encode(workerName, forKey: .workerName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workerName)
        workerName = workerNameDecoded
    }
}

extension ActivityStartedEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivityStartedEventDetails(workerName: \(String(describing: workerName)))"}
}

/// <p>Contains details about the start of an activity during an execution.</p>
public struct ActivityStartedEventDetails: Equatable {
    /// <p>The name of the worker that the task is assigned to. These names are provided by the
    ///       workers when calling <a>GetActivityTask</a>.</p>
    public let workerName: String?

    public init (
        workerName: String? = nil
    )
    {
        self.workerName = workerName
    }
}

extension ActivitySucceededEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case output
        case outputDetails
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let outputDetails = outputDetails {
            try encodeContainer.encode(outputDetails, forKey: .outputDetails)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .output)
        output = outputDecoded
        let outputDetailsDecoded = try containerValues.decodeIfPresent(HistoryEventExecutionDataDetails.self, forKey: .outputDetails)
        outputDetails = outputDetailsDecoded
    }
}

extension ActivitySucceededEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivitySucceededEventDetails(output: \(String(describing: output)), outputDetails: \(String(describing: outputDetails)))"}
}

/// <p>Contains details about an activity that successfully terminated during an
///       execution.</p>
public struct ActivitySucceededEventDetails: Equatable {
    /// <p>The JSON data output by the activity task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.</p>
    public let output: String?
    /// <p>Contains details about the output of an execution history event.</p>
    public let outputDetails: HistoryEventExecutionDataDetails?

    public init (
        output: String? = nil,
        outputDetails: HistoryEventExecutionDataDetails? = nil
    )
    {
        self.output = output
        self.outputDetails = outputDetails
    }
}

extension ActivityTimedOutEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cause
        case error
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension ActivityTimedOutEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivityTimedOutEventDetails(cause: \(String(describing: cause)), error: \(String(describing: error)))"}
}

/// <p>Contains details about an activity timeout that occurred during an execution.</p>
public struct ActivityTimedOutEventDetails: Equatable {
    /// <p>A more detailed explanation of the cause of the timeout.</p>
    public let cause: String?
    /// <p>The error code of the failure.</p>
    public let error: String?

    public init (
        cause: String? = nil,
        error: String? = nil
    )
    {
        self.cause = cause
        self.error = error
    }
}

extension ActivityWorkerLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivityWorkerLimitExceeded(message: \(String(describing: message)))"}
}

extension ActivityWorkerLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ActivityWorkerLimitExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of workers concurrently polling for activity tasks has been
///       reached.</p>
public struct ActivityWorkerLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ActivityWorkerLimitExceededBody: Equatable {
    public let message: String?
}

extension ActivityWorkerLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BillingDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case billedDurationInMilliseconds
        case billedMemoryUsedInMB
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if billedDurationInMilliseconds != 0 {
            try encodeContainer.encode(billedDurationInMilliseconds, forKey: .billedDurationInMilliseconds)
        }
        if billedMemoryUsedInMB != 0 {
            try encodeContainer.encode(billedMemoryUsedInMB, forKey: .billedMemoryUsedInMB)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billedMemoryUsedInMBDecoded = try containerValues.decode(Int.self, forKey: .billedMemoryUsedInMB)
        billedMemoryUsedInMB = billedMemoryUsedInMBDecoded
        let billedDurationInMillisecondsDecoded = try containerValues.decode(Int.self, forKey: .billedDurationInMilliseconds)
        billedDurationInMilliseconds = billedDurationInMillisecondsDecoded
    }
}

extension BillingDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BillingDetails(billedDurationInMilliseconds: \(String(describing: billedDurationInMilliseconds)), billedMemoryUsedInMB: \(String(describing: billedMemoryUsedInMB)))"}
}

/// <p>An object that describes workflow billing details.</p>
public struct BillingDetails: Equatable {
    /// <p>Billed duration of your workflow, in milliseconds.</p>
    public let billedDurationInMilliseconds: Int
    /// <p>Billed memory consumption of your workflow, in MB.</p>
    public let billedMemoryUsedInMB: Int

    public init (
        billedDurationInMilliseconds: Int = 0,
        billedMemoryUsedInMB: Int = 0
    )
    {
        self.billedDurationInMilliseconds = billedDurationInMilliseconds
        self.billedMemoryUsedInMB = billedMemoryUsedInMB
    }
}

extension CloudWatchEventsExecutionDataDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case included
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if included != false {
            try encodeContainer.encode(included, forKey: .included)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let includedDecoded = try containerValues.decode(Bool.self, forKey: .included)
        included = includedDecoded
    }
}

extension CloudWatchEventsExecutionDataDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchEventsExecutionDataDetails(included: \(String(describing: included)))"}
}

/// <p>Provides details about execution input or output.</p>
public struct CloudWatchEventsExecutionDataDetails: Equatable {
    /// <p>Indicates whether input or output was included in the response. Always <code>true</code>
    ///       for API calls. </p>
    public let included: Bool

    public init (
        included: Bool = false
    )
    {
        self.included = included
    }
}

extension CloudWatchLogsLogGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logGroupArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupArn = logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
    }
}

extension CloudWatchLogsLogGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchLogsLogGroup(logGroupArn: \(String(describing: logGroupArn)))"}
}

/// <p></p>
public struct CloudWatchLogsLogGroup: Equatable {
    /// <p>The ARN of the the CloudWatch log group to which you want your logs emitted to. The ARN
    ///       must end with <code>:*</code>
    ///          </p>
    public let logGroupArn: String?

    public init (
        logGroupArn: String? = nil
    )
    {
        self.logGroupArn = logGroupArn
    }
}

public struct CreateActivityInputBodyMiddleware: Middleware {
    public let id: String = "CreateActivityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateActivityInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateActivityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateActivityInput>
    public typealias MOutput = OperationOutput<CreateActivityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateActivityOutputError>
}

extension CreateActivityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateActivityInput(name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateActivityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateActivityInputHeadersMiddleware: Middleware {
    public let id: String = "CreateActivityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateActivityInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateActivityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateActivityInput>
    public typealias MOutput = OperationOutput<CreateActivityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateActivityOutputError>
}

public struct CreateActivityInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateActivityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateActivityInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateActivityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateActivityInput>
    public typealias MOutput = OperationOutput<CreateActivityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateActivityOutputError>
}

public struct CreateActivityInput: Equatable {
    /// <p>The name of the activity to create. This name must be unique for your AWS account and region for 90 days. For more information,
    ///     see <a href="https://docs.aws.amazon.com/step-functions/latest/dg/limits.html#service-limits-state-machine-executions">
    ///     Limits Related to State Machine Executions</a> in the <i>AWS Step Functions Developer Guide</i>.</p>
    ///          <p>A name must <i>not</i> contain:</p>
    ///          <ul>
    ///             <li>
    ///                <p>white space</p>
    ///             </li>
    ///             <li>
    ///                <p>brackets <code>< > { } [ ]</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>wildcard characters <code>? *</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>special characters <code>" # % \ ^ | ~ ` $ & , ; : /</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>control characters (<code>U+0000-001F</code>, <code>U+007F-009F</code>)</p>
    ///             </li>
    ///          </ul>
    ///          <p>To enable logging with CloudWatch Logs, the name should only contain  0-9, A-Z, a-z, - and _.</p>
    public let name: String?
    /// <p>The list of tags to add to a resource.</p>
    ///          <p>An array of key-value pairs. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using
    ///       Cost Allocation Tags</a> in the <i>AWS Billing and Cost Management User
    ///         Guide</i>, and <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_iam-tags.html">Controlling Access Using IAM
    ///           Tags</a>.</p>
    ///          <p>Tags may only contain Unicode letters, digits, white space, or these symbols: <code>_ . : / = + - @</code>.</p>
    public let tags: [Tag]?

    public init (
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.name = name
        self.tags = tags
    }
}

struct CreateActivityInputBody: Equatable {
    public let name: String?
    public let tags: [Tag]?
}

extension CreateActivityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateActivityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateActivityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ActivityLimitExceeded" : self = .activityLimitExceeded(try ActivityLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidName" : self = .invalidName(try InvalidName(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTags" : self = .tooManyTags(try TooManyTags(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateActivityOutputError: Equatable {
    case activityLimitExceeded(ActivityLimitExceeded)
    case invalidName(InvalidName)
    case tooManyTags(TooManyTags)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateActivityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateActivityOutputResponse(activityArn: \(String(describing: activityArn)), creationDate: \(String(describing: creationDate)))"}
}

extension CreateActivityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateActivityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.activityArn = output.activityArn
            self.creationDate = output.creationDate
        } else {
            self.activityArn = nil
            self.creationDate = nil
        }
    }
}

public struct CreateActivityOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the created activity.</p>
    public let activityArn: String?
    /// <p>The date the activity is created.</p>
    public let creationDate: Date?

    public init (
        activityArn: String? = nil,
        creationDate: Date? = nil
    )
    {
        self.activityArn = activityArn
        self.creationDate = creationDate
    }
}

struct CreateActivityOutputResponseBody: Equatable {
    public let activityArn: String?
    public let creationDate: Date?
}

extension CreateActivityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activityArn
        case creationDate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activityArn)
        activityArn = activityArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

public struct CreateStateMachineInputBodyMiddleware: Middleware {
    public let id: String = "CreateStateMachineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStateMachineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStateMachineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStateMachineInput>
    public typealias MOutput = OperationOutput<CreateStateMachineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStateMachineOutputError>
}

extension CreateStateMachineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStateMachineInput(definition: \(String(describing: definition)), loggingConfiguration: \(String(describing: loggingConfiguration)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), tags: \(String(describing: tags)), tracingConfiguration: \(String(describing: tracingConfiguration)), type: \(String(describing: type)))"}
}

extension CreateStateMachineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case definition
        case loggingConfiguration
        case name
        case roleArn
        case tags
        case tracingConfiguration
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let loggingConfiguration = loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let tracingConfiguration = tracingConfiguration {
            try encodeContainer.encode(tracingConfiguration, forKey: .tracingConfiguration)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateStateMachineInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStateMachineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStateMachineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStateMachineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStateMachineInput>
    public typealias MOutput = OperationOutput<CreateStateMachineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStateMachineOutputError>
}

public struct CreateStateMachineInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStateMachineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStateMachineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStateMachineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStateMachineInput>
    public typealias MOutput = OperationOutput<CreateStateMachineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStateMachineOutputError>
}

public struct CreateStateMachineInput: Equatable {
    /// <p>The Amazon States Language definition of the state machine. See <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-amazon-states-language.html">Amazon States Language</a>.</p>
    public let definition: String?
    /// <p>Defines what execution history events are logged and where they are logged.</p>
    ///          <note>
    ///             <p>By default, the <code>level</code> is set to <code>OFF</code>. For more information see
    ///           <a href="https://docs.aws.amazon.com/step-functions/latest/dg/cloudwatch-log-level.html">Log
    ///           Levels</a> in the AWS Step Functions User Guide.</p>
    ///          </note>
    public let loggingConfiguration: LoggingConfiguration?
    /// <p>The name of the state machine. </p>
    ///          <p>A name must <i>not</i> contain:</p>
    ///          <ul>
    ///             <li>
    ///                <p>white space</p>
    ///             </li>
    ///             <li>
    ///                <p>brackets <code>< > { } [ ]</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>wildcard characters <code>? *</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>special characters <code>" # % \ ^ | ~ ` $ & , ; : /</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>control characters (<code>U+0000-001F</code>, <code>U+007F-009F</code>)</p>
    ///             </li>
    ///          </ul>
    ///          <p>To enable logging with CloudWatch Logs, the name should only contain  0-9, A-Z, a-z, - and _.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role to use for this state machine.</p>
    public let roleArn: String?
    /// <p>Tags to be added when creating a state machine.</p>
    ///          <p>An array of key-value pairs. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using
    ///       Cost Allocation Tags</a> in the <i>AWS Billing and Cost Management User
    ///         Guide</i>, and <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_iam-tags.html">Controlling Access Using IAM
    ///           Tags</a>.</p>
    ///          <p>Tags may only contain Unicode letters, digits, white space, or these symbols: <code>_ . : / = + - @</code>.</p>
    public let tags: [Tag]?
    /// <p>Selects whether AWS X-Ray tracing is enabled.</p>
    public let tracingConfiguration: TracingConfiguration?
    /// <p>Determines whether a Standard or Express state machine is created. The default is
    ///         <code>STANDARD</code>. You cannot update the <code>type</code> of a state machine once it
    ///       has been created.</p>
    public let type: StateMachineType?

    public init (
        definition: String? = nil,
        loggingConfiguration: LoggingConfiguration? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        tags: [Tag]? = nil,
        tracingConfiguration: TracingConfiguration? = nil,
        type: StateMachineType? = nil
    )
    {
        self.definition = definition
        self.loggingConfiguration = loggingConfiguration
        self.name = name
        self.roleArn = roleArn
        self.tags = tags
        self.tracingConfiguration = tracingConfiguration
        self.type = type
    }
}

struct CreateStateMachineInputBody: Equatable {
    public let name: String?
    public let definition: String?
    public let roleArn: String?
    public let type: StateMachineType?
    public let loggingConfiguration: LoggingConfiguration?
    public let tags: [Tag]?
    public let tracingConfiguration: TracingConfiguration?
}

extension CreateStateMachineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case definition
        case loggingConfiguration
        case name
        case roleArn
        case tags
        case tracingConfiguration
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .definition)
        definition = definitionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(StateMachineType.self, forKey: .type)
        type = typeDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let tracingConfigurationDecoded = try containerValues.decodeIfPresent(TracingConfiguration.self, forKey: .tracingConfiguration)
        tracingConfiguration = tracingConfigurationDecoded
    }
}

extension CreateStateMachineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStateMachineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDefinition" : self = .invalidDefinition(try InvalidDefinition(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLoggingConfiguration" : self = .invalidLoggingConfiguration(try InvalidLoggingConfiguration(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidName" : self = .invalidName(try InvalidName(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTracingConfiguration" : self = .invalidTracingConfiguration(try InvalidTracingConfiguration(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineAlreadyExists" : self = .stateMachineAlreadyExists(try StateMachineAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineDeleting" : self = .stateMachineDeleting(try StateMachineDeleting(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineLimitExceeded" : self = .stateMachineLimitExceeded(try StateMachineLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineTypeNotSupported" : self = .stateMachineTypeNotSupported(try StateMachineTypeNotSupported(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTags" : self = .tooManyTags(try TooManyTags(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStateMachineOutputError: Equatable {
    case invalidArn(InvalidArn)
    case invalidDefinition(InvalidDefinition)
    case invalidLoggingConfiguration(InvalidLoggingConfiguration)
    case invalidName(InvalidName)
    case invalidTracingConfiguration(InvalidTracingConfiguration)
    case stateMachineAlreadyExists(StateMachineAlreadyExists)
    case stateMachineDeleting(StateMachineDeleting)
    case stateMachineLimitExceeded(StateMachineLimitExceeded)
    case stateMachineTypeNotSupported(StateMachineTypeNotSupported)
    case tooManyTags(TooManyTags)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStateMachineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStateMachineOutputResponse(creationDate: \(String(describing: creationDate)), stateMachineArn: \(String(describing: stateMachineArn)))"}
}

extension CreateStateMachineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateStateMachineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDate = output.creationDate
            self.stateMachineArn = output.stateMachineArn
        } else {
            self.creationDate = nil
            self.stateMachineArn = nil
        }
    }
}

public struct CreateStateMachineOutputResponse: Equatable {
    /// <p>The date the state machine is created.</p>
    public let creationDate: Date?
    /// <p>The Amazon Resource Name (ARN) that identifies the created state machine.</p>
    public let stateMachineArn: String?

    public init (
        creationDate: Date? = nil,
        stateMachineArn: String? = nil
    )
    {
        self.creationDate = creationDate
        self.stateMachineArn = stateMachineArn
    }
}

struct CreateStateMachineOutputResponseBody: Equatable {
    public let stateMachineArn: String?
    public let creationDate: Date?
}

extension CreateStateMachineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case stateMachineArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

public struct DeleteActivityInputBodyMiddleware: Middleware {
    public let id: String = "DeleteActivityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteActivityInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteActivityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteActivityInput>
    public typealias MOutput = OperationOutput<DeleteActivityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteActivityOutputError>
}

extension DeleteActivityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteActivityInput(activityArn: \(String(describing: activityArn)))"}
}

extension DeleteActivityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activityArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activityArn = activityArn {
            try encodeContainer.encode(activityArn, forKey: .activityArn)
        }
    }
}

public struct DeleteActivityInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteActivityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteActivityInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteActivityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteActivityInput>
    public typealias MOutput = OperationOutput<DeleteActivityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteActivityOutputError>
}

public struct DeleteActivityInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteActivityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteActivityInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteActivityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteActivityInput>
    public typealias MOutput = OperationOutput<DeleteActivityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteActivityOutputError>
}

public struct DeleteActivityInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the activity to delete.</p>
    public let activityArn: String?

    public init (
        activityArn: String? = nil
    )
    {
        self.activityArn = activityArn
    }
}

struct DeleteActivityInputBody: Equatable {
    public let activityArn: String?
}

extension DeleteActivityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activityArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activityArn)
        activityArn = activityArnDecoded
    }
}

extension DeleteActivityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteActivityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteActivityOutputError: Equatable {
    case invalidArn(InvalidArn)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteActivityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteActivityOutputResponse()"}
}

extension DeleteActivityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteActivityOutputResponse: Equatable {

    public init() {}
}

struct DeleteActivityOutputResponseBody: Equatable {
}

extension DeleteActivityOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteStateMachineInputBodyMiddleware: Middleware {
    public let id: String = "DeleteStateMachineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStateMachineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStateMachineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStateMachineInput>
    public typealias MOutput = OperationOutput<DeleteStateMachineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStateMachineOutputError>
}

extension DeleteStateMachineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStateMachineInput(stateMachineArn: \(String(describing: stateMachineArn)))"}
}

extension DeleteStateMachineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stateMachineArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stateMachineArn = stateMachineArn {
            try encodeContainer.encode(stateMachineArn, forKey: .stateMachineArn)
        }
    }
}

public struct DeleteStateMachineInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStateMachineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStateMachineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStateMachineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStateMachineInput>
    public typealias MOutput = OperationOutput<DeleteStateMachineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStateMachineOutputError>
}

public struct DeleteStateMachineInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStateMachineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStateMachineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStateMachineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStateMachineInput>
    public typealias MOutput = OperationOutput<DeleteStateMachineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStateMachineOutputError>
}

public struct DeleteStateMachineInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the state machine to delete.</p>
    public let stateMachineArn: String?

    public init (
        stateMachineArn: String? = nil
    )
    {
        self.stateMachineArn = stateMachineArn
    }
}

struct DeleteStateMachineInputBody: Equatable {
    public let stateMachineArn: String?
}

extension DeleteStateMachineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stateMachineArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
    }
}

extension DeleteStateMachineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStateMachineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStateMachineOutputError: Equatable {
    case invalidArn(InvalidArn)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStateMachineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStateMachineOutputResponse()"}
}

extension DeleteStateMachineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStateMachineOutputResponse: Equatable {

    public init() {}
}

struct DeleteStateMachineOutputResponseBody: Equatable {
}

extension DeleteStateMachineOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeActivityInputBodyMiddleware: Middleware {
    public let id: String = "DescribeActivityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeActivityInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeActivityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeActivityInput>
    public typealias MOutput = OperationOutput<DescribeActivityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeActivityOutputError>
}

extension DescribeActivityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeActivityInput(activityArn: \(String(describing: activityArn)))"}
}

extension DescribeActivityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activityArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activityArn = activityArn {
            try encodeContainer.encode(activityArn, forKey: .activityArn)
        }
    }
}

public struct DescribeActivityInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeActivityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeActivityInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeActivityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeActivityInput>
    public typealias MOutput = OperationOutput<DescribeActivityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeActivityOutputError>
}

public struct DescribeActivityInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeActivityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeActivityInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeActivityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeActivityInput>
    public typealias MOutput = OperationOutput<DescribeActivityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeActivityOutputError>
}

public struct DescribeActivityInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the activity to describe.</p>
    public let activityArn: String?

    public init (
        activityArn: String? = nil
    )
    {
        self.activityArn = activityArn
    }
}

struct DescribeActivityInputBody: Equatable {
    public let activityArn: String?
}

extension DescribeActivityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activityArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activityArn)
        activityArn = activityArnDecoded
    }
}

extension DescribeActivityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeActivityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ActivityDoesNotExist" : self = .activityDoesNotExist(try ActivityDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeActivityOutputError: Equatable {
    case activityDoesNotExist(ActivityDoesNotExist)
    case invalidArn(InvalidArn)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeActivityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeActivityOutputResponse(activityArn: \(String(describing: activityArn)), creationDate: \(String(describing: creationDate)), name: \(String(describing: name)))"}
}

extension DescribeActivityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeActivityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.activityArn = output.activityArn
            self.creationDate = output.creationDate
            self.name = output.name
        } else {
            self.activityArn = nil
            self.creationDate = nil
            self.name = nil
        }
    }
}

public struct DescribeActivityOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the activity.</p>
    public let activityArn: String?
    /// <p>The date the activity is created.</p>
    public let creationDate: Date?
    /// <p>The name of the activity.</p>
    ///          <p>A name must <i>not</i> contain:</p>
    ///          <ul>
    ///             <li>
    ///                <p>white space</p>
    ///             </li>
    ///             <li>
    ///                <p>brackets <code>< > { } [ ]</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>wildcard characters <code>? *</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>special characters <code>" # % \ ^ | ~ ` $ & , ; : /</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>control characters (<code>U+0000-001F</code>, <code>U+007F-009F</code>)</p>
    ///             </li>
    ///          </ul>
    ///          <p>To enable logging with CloudWatch Logs, the name should only contain  0-9, A-Z, a-z, - and _.</p>
    public let name: String?

    public init (
        activityArn: String? = nil,
        creationDate: Date? = nil,
        name: String? = nil
    )
    {
        self.activityArn = activityArn
        self.creationDate = creationDate
        self.name = name
    }
}

struct DescribeActivityOutputResponseBody: Equatable {
    public let activityArn: String?
    public let name: String?
    public let creationDate: Date?
}

extension DescribeActivityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activityArn
        case creationDate
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activityArn)
        activityArn = activityArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

public struct DescribeExecutionInputBodyMiddleware: Middleware {
    public let id: String = "DescribeExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeExecutionInput>
    public typealias MOutput = OperationOutput<DescribeExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeExecutionOutputError>
}

extension DescribeExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeExecutionInput(executionArn: \(String(describing: executionArn)))"}
}

extension DescribeExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case executionArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionArn = executionArn {
            try encodeContainer.encode(executionArn, forKey: .executionArn)
        }
    }
}

public struct DescribeExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeExecutionInput>
    public typealias MOutput = OperationOutput<DescribeExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeExecutionOutputError>
}

public struct DescribeExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeExecutionInput>
    public typealias MOutput = OperationOutput<DescribeExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeExecutionOutputError>
}

public struct DescribeExecutionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the execution to describe.</p>
    public let executionArn: String?

    public init (
        executionArn: String? = nil
    )
    {
        self.executionArn = executionArn
    }
}

struct DescribeExecutionInputBody: Equatable {
    public let executionArn: String?
}

extension DescribeExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case executionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionArn)
        executionArn = executionArnDecoded
    }
}

extension DescribeExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExecutionDoesNotExist" : self = .executionDoesNotExist(try ExecutionDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeExecutionOutputError: Equatable {
    case executionDoesNotExist(ExecutionDoesNotExist)
    case invalidArn(InvalidArn)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeExecutionOutputResponse(executionArn: \(String(describing: executionArn)), input: \(String(describing: input)), inputDetails: \(String(describing: inputDetails)), name: \(String(describing: name)), output: \(String(describing: output)), outputDetails: \(String(describing: outputDetails)), startDate: \(String(describing: startDate)), stateMachineArn: \(String(describing: stateMachineArn)), status: \(String(describing: status)), stopDate: \(String(describing: stopDate)), traceHeader: \(String(describing: traceHeader)))"}
}

extension DescribeExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeExecutionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.executionArn = output.executionArn
            self.input = output.input
            self.inputDetails = output.inputDetails
            self.name = output.name
            self.output = output.output
            self.outputDetails = output.outputDetails
            self.startDate = output.startDate
            self.stateMachineArn = output.stateMachineArn
            self.status = output.status
            self.stopDate = output.stopDate
            self.traceHeader = output.traceHeader
        } else {
            self.executionArn = nil
            self.input = nil
            self.inputDetails = nil
            self.name = nil
            self.output = nil
            self.outputDetails = nil
            self.startDate = nil
            self.stateMachineArn = nil
            self.status = nil
            self.stopDate = nil
            self.traceHeader = nil
        }
    }
}

public struct DescribeExecutionOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the execution.</p>
    public let executionArn: String?
    /// <p>The string that contains the JSON input data of the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.</p>
    public let input: String?
    /// <p>Provides details about execution input or output.</p>
    public let inputDetails: CloudWatchEventsExecutionDataDetails?
    /// <p>The name of the execution.</p>
    ///          <p>A name must <i>not</i> contain:</p>
    ///          <ul>
    ///             <li>
    ///                <p>white space</p>
    ///             </li>
    ///             <li>
    ///                <p>brackets <code>< > { } [ ]</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>wildcard characters <code>? *</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>special characters <code>" # % \ ^ | ~ ` $ & , ; : /</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>control characters (<code>U+0000-001F</code>, <code>U+007F-009F</code>)</p>
    ///             </li>
    ///          </ul>
    ///          <p>To enable logging with CloudWatch Logs, the name should only contain  0-9, A-Z, a-z, - and _.</p>
    public let name: String?
    /// <p>The JSON output data of the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.</p>
    ///          <note>
    ///             <p>This field is set only if the execution succeeds. If the execution fails, this field is
    ///         null.</p>
    ///          </note>
    public let output: String?
    /// <p>Provides details about execution input or output.</p>
    public let outputDetails: CloudWatchEventsExecutionDataDetails?
    /// <p>The date the execution is started.</p>
    public let startDate: Date?
    /// <p>The Amazon Resource Name (ARN) of the executed stated machine.</p>
    public let stateMachineArn: String?
    /// <p>The current status of the execution.</p>
    public let status: ExecutionStatus?
    /// <p>If the execution has already ended, the date the execution stopped.</p>
    public let stopDate: Date?
    /// <p>The AWS X-Ray trace header that was passed to the execution.</p>
    public let traceHeader: String?

    public init (
        executionArn: String? = nil,
        input: String? = nil,
        inputDetails: CloudWatchEventsExecutionDataDetails? = nil,
        name: String? = nil,
        output: String? = nil,
        outputDetails: CloudWatchEventsExecutionDataDetails? = nil,
        startDate: Date? = nil,
        stateMachineArn: String? = nil,
        status: ExecutionStatus? = nil,
        stopDate: Date? = nil,
        traceHeader: String? = nil
    )
    {
        self.executionArn = executionArn
        self.input = input
        self.inputDetails = inputDetails
        self.name = name
        self.output = output
        self.outputDetails = outputDetails
        self.startDate = startDate
        self.stateMachineArn = stateMachineArn
        self.status = status
        self.stopDate = stopDate
        self.traceHeader = traceHeader
    }
}

struct DescribeExecutionOutputResponseBody: Equatable {
    public let executionArn: String?
    public let stateMachineArn: String?
    public let name: String?
    public let status: ExecutionStatus?
    public let startDate: Date?
    public let stopDate: Date?
    public let input: String?
    public let inputDetails: CloudWatchEventsExecutionDataDetails?
    public let output: String?
    public let outputDetails: CloudWatchEventsExecutionDataDetails?
    public let traceHeader: String?
}

extension DescribeExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case executionArn
        case input
        case inputDetails
        case name
        case output
        case outputDetails
        case startDate
        case stateMachineArn
        case status
        case stopDate
        case traceHeader
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionArn)
        executionArn = executionArnDecoded
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startDate)
        startDate = startDateDecoded
        let stopDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stopDate)
        stopDate = stopDateDecoded
        let inputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .input)
        input = inputDecoded
        let inputDetailsDecoded = try containerValues.decodeIfPresent(CloudWatchEventsExecutionDataDetails.self, forKey: .inputDetails)
        inputDetails = inputDetailsDecoded
        let outputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .output)
        output = outputDecoded
        let outputDetailsDecoded = try containerValues.decodeIfPresent(CloudWatchEventsExecutionDataDetails.self, forKey: .outputDetails)
        outputDetails = outputDetailsDecoded
        let traceHeaderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .traceHeader)
        traceHeader = traceHeaderDecoded
    }
}

public struct DescribeStateMachineForExecutionInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStateMachineForExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStateMachineForExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStateMachineForExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStateMachineForExecutionInput>
    public typealias MOutput = OperationOutput<DescribeStateMachineForExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStateMachineForExecutionOutputError>
}

extension DescribeStateMachineForExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStateMachineForExecutionInput(executionArn: \(String(describing: executionArn)))"}
}

extension DescribeStateMachineForExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case executionArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionArn = executionArn {
            try encodeContainer.encode(executionArn, forKey: .executionArn)
        }
    }
}

public struct DescribeStateMachineForExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStateMachineForExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStateMachineForExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStateMachineForExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStateMachineForExecutionInput>
    public typealias MOutput = OperationOutput<DescribeStateMachineForExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStateMachineForExecutionOutputError>
}

public struct DescribeStateMachineForExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStateMachineForExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStateMachineForExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStateMachineForExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStateMachineForExecutionInput>
    public typealias MOutput = OperationOutput<DescribeStateMachineForExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStateMachineForExecutionOutputError>
}

public struct DescribeStateMachineForExecutionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the execution you want state machine information for.</p>
    public let executionArn: String?

    public init (
        executionArn: String? = nil
    )
    {
        self.executionArn = executionArn
    }
}

struct DescribeStateMachineForExecutionInputBody: Equatable {
    public let executionArn: String?
}

extension DescribeStateMachineForExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case executionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionArn)
        executionArn = executionArnDecoded
    }
}

extension DescribeStateMachineForExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStateMachineForExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExecutionDoesNotExist" : self = .executionDoesNotExist(try ExecutionDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStateMachineForExecutionOutputError: Equatable {
    case executionDoesNotExist(ExecutionDoesNotExist)
    case invalidArn(InvalidArn)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStateMachineForExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStateMachineForExecutionOutputResponse(definition: \(String(describing: definition)), loggingConfiguration: \(String(describing: loggingConfiguration)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), stateMachineArn: \(String(describing: stateMachineArn)), tracingConfiguration: \(String(describing: tracingConfiguration)), updateDate: \(String(describing: updateDate)))"}
}

extension DescribeStateMachineForExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStateMachineForExecutionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.definition = output.definition
            self.loggingConfiguration = output.loggingConfiguration
            self.name = output.name
            self.roleArn = output.roleArn
            self.stateMachineArn = output.stateMachineArn
            self.tracingConfiguration = output.tracingConfiguration
            self.updateDate = output.updateDate
        } else {
            self.definition = nil
            self.loggingConfiguration = nil
            self.name = nil
            self.roleArn = nil
            self.stateMachineArn = nil
            self.tracingConfiguration = nil
            self.updateDate = nil
        }
    }
}

public struct DescribeStateMachineForExecutionOutputResponse: Equatable {
    /// <p>The Amazon States Language definition of the state machine. See <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-amazon-states-language.html">Amazon States Language</a>.</p>
    public let definition: String?
    /// <p>The <code>LoggingConfiguration</code> data type is used to set CloudWatch Logs
    ///       options.</p>
    public let loggingConfiguration: LoggingConfiguration?
    /// <p>The name of the state machine associated with the execution.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role of the State Machine for the execution. </p>
    public let roleArn: String?
    /// <p>The Amazon Resource Name (ARN) of the state machine associated with the execution.</p>
    public let stateMachineArn: String?
    /// <p>Selects whether AWS X-Ray tracing is enabled.</p>
    public let tracingConfiguration: TracingConfiguration?
    /// <p>The date and time the state machine associated with an execution was updated. For a newly
    ///       created state machine, this is the creation date.</p>
    public let updateDate: Date?

    public init (
        definition: String? = nil,
        loggingConfiguration: LoggingConfiguration? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        stateMachineArn: String? = nil,
        tracingConfiguration: TracingConfiguration? = nil,
        updateDate: Date? = nil
    )
    {
        self.definition = definition
        self.loggingConfiguration = loggingConfiguration
        self.name = name
        self.roleArn = roleArn
        self.stateMachineArn = stateMachineArn
        self.tracingConfiguration = tracingConfiguration
        self.updateDate = updateDate
    }
}

struct DescribeStateMachineForExecutionOutputResponseBody: Equatable {
    public let stateMachineArn: String?
    public let name: String?
    public let definition: String?
    public let roleArn: String?
    public let updateDate: Date?
    public let loggingConfiguration: LoggingConfiguration?
    public let tracingConfiguration: TracingConfiguration?
}

extension DescribeStateMachineForExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case definition
        case loggingConfiguration
        case name
        case roleArn
        case stateMachineArn
        case tracingConfiguration
        case updateDate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .definition)
        definition = definitionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let updateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updateDate)
        updateDate = updateDateDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
        let tracingConfigurationDecoded = try containerValues.decodeIfPresent(TracingConfiguration.self, forKey: .tracingConfiguration)
        tracingConfiguration = tracingConfigurationDecoded
    }
}

public struct DescribeStateMachineInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStateMachineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStateMachineInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStateMachineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStateMachineInput>
    public typealias MOutput = OperationOutput<DescribeStateMachineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStateMachineOutputError>
}

extension DescribeStateMachineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStateMachineInput(stateMachineArn: \(String(describing: stateMachineArn)))"}
}

extension DescribeStateMachineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stateMachineArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stateMachineArn = stateMachineArn {
            try encodeContainer.encode(stateMachineArn, forKey: .stateMachineArn)
        }
    }
}

public struct DescribeStateMachineInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStateMachineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStateMachineInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStateMachineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStateMachineInput>
    public typealias MOutput = OperationOutput<DescribeStateMachineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStateMachineOutputError>
}

public struct DescribeStateMachineInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStateMachineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStateMachineInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStateMachineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStateMachineInput>
    public typealias MOutput = OperationOutput<DescribeStateMachineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStateMachineOutputError>
}

public struct DescribeStateMachineInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the state machine to describe.</p>
    public let stateMachineArn: String?

    public init (
        stateMachineArn: String? = nil
    )
    {
        self.stateMachineArn = stateMachineArn
    }
}

struct DescribeStateMachineInputBody: Equatable {
    public let stateMachineArn: String?
}

extension DescribeStateMachineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stateMachineArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
    }
}

extension DescribeStateMachineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStateMachineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineDoesNotExist" : self = .stateMachineDoesNotExist(try StateMachineDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStateMachineOutputError: Equatable {
    case invalidArn(InvalidArn)
    case stateMachineDoesNotExist(StateMachineDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStateMachineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStateMachineOutputResponse(creationDate: \(String(describing: creationDate)), definition: \(String(describing: definition)), loggingConfiguration: \(String(describing: loggingConfiguration)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), stateMachineArn: \(String(describing: stateMachineArn)), status: \(String(describing: status)), tracingConfiguration: \(String(describing: tracingConfiguration)), type: \(String(describing: type)))"}
}

extension DescribeStateMachineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStateMachineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDate = output.creationDate
            self.definition = output.definition
            self.loggingConfiguration = output.loggingConfiguration
            self.name = output.name
            self.roleArn = output.roleArn
            self.stateMachineArn = output.stateMachineArn
            self.status = output.status
            self.tracingConfiguration = output.tracingConfiguration
            self.type = output.type
        } else {
            self.creationDate = nil
            self.definition = nil
            self.loggingConfiguration = nil
            self.name = nil
            self.roleArn = nil
            self.stateMachineArn = nil
            self.status = nil
            self.tracingConfiguration = nil
            self.type = nil
        }
    }
}

public struct DescribeStateMachineOutputResponse: Equatable {
    /// <p>The date the state machine is created.</p>
    public let creationDate: Date?
    /// <p>The Amazon States Language definition of the state machine. See <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-amazon-states-language.html">Amazon States Language</a>.</p>
    public let definition: String?
    /// <p>The <code>LoggingConfiguration</code> data type is used to set CloudWatch Logs
    ///       options.</p>
    public let loggingConfiguration: LoggingConfiguration?
    /// <p>The name of the state machine.</p>
    ///          <p>A name must <i>not</i> contain:</p>
    ///          <ul>
    ///             <li>
    ///                <p>white space</p>
    ///             </li>
    ///             <li>
    ///                <p>brackets <code>< > { } [ ]</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>wildcard characters <code>? *</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>special characters <code>" # % \ ^ | ~ ` $ & , ; : /</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>control characters (<code>U+0000-001F</code>, <code>U+007F-009F</code>)</p>
    ///             </li>
    ///          </ul>
    ///          <p>To enable logging with CloudWatch Logs, the name should only contain  0-9, A-Z, a-z, - and _.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role used when creating this state machine. (The IAM role
    ///       maintains security by granting Step Functions access to AWS resources.)</p>
    public let roleArn: String?
    /// <p>The Amazon Resource Name (ARN) that identifies the state machine.</p>
    public let stateMachineArn: String?
    /// <p>The current status of the state machine.</p>
    public let status: StateMachineStatus?
    /// <p>Selects whether AWS X-Ray tracing is enabled.</p>
    public let tracingConfiguration: TracingConfiguration?
    /// <p>The <code>type</code> of the state machine (<code>STANDARD</code> or
    ///       <code>EXPRESS</code>).</p>
    public let type: StateMachineType?

    public init (
        creationDate: Date? = nil,
        definition: String? = nil,
        loggingConfiguration: LoggingConfiguration? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        stateMachineArn: String? = nil,
        status: StateMachineStatus? = nil,
        tracingConfiguration: TracingConfiguration? = nil,
        type: StateMachineType? = nil
    )
    {
        self.creationDate = creationDate
        self.definition = definition
        self.loggingConfiguration = loggingConfiguration
        self.name = name
        self.roleArn = roleArn
        self.stateMachineArn = stateMachineArn
        self.status = status
        self.tracingConfiguration = tracingConfiguration
        self.type = type
    }
}

struct DescribeStateMachineOutputResponseBody: Equatable {
    public let stateMachineArn: String?
    public let name: String?
    public let status: StateMachineStatus?
    public let definition: String?
    public let roleArn: String?
    public let type: StateMachineType?
    public let creationDate: Date?
    public let loggingConfiguration: LoggingConfiguration?
    public let tracingConfiguration: TracingConfiguration?
}

extension DescribeStateMachineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case definition
        case loggingConfiguration
        case name
        case roleArn
        case stateMachineArn
        case status
        case tracingConfiguration
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StateMachineStatus.self, forKey: .status)
        status = statusDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .definition)
        definition = definitionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(StateMachineType.self, forKey: .type)
        type = typeDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
        let tracingConfigurationDecoded = try containerValues.decodeIfPresent(TracingConfiguration.self, forKey: .tracingConfiguration)
        tracingConfiguration = tracingConfigurationDecoded
    }
}

extension ExecutionAbortedEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cause
        case error
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension ExecutionAbortedEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecutionAbortedEventDetails(cause: \(String(describing: cause)), error: \(String(describing: error)))"}
}

/// <p>Contains details about an abort of an execution.</p>
public struct ExecutionAbortedEventDetails: Equatable {
    /// <p>A more detailed explanation of the cause of the failure.</p>
    public let cause: String?
    /// <p>The error code of the failure.</p>
    public let error: String?

    public init (
        cause: String? = nil,
        error: String? = nil
    )
    {
        self.cause = cause
        self.error = error
    }
}

extension ExecutionAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecutionAlreadyExists(message: \(String(describing: message)))"}
}

extension ExecutionAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExecutionAlreadyExistsBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The execution has the same <code>name</code> as another execution (but a different
///         <code>input</code>).</p>
///          <note>
///             <p>Executions with the same <code>name</code> and <code>input</code> are considered
///         idempotent.</p>
///          </note>
public struct ExecutionAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ExecutionAlreadyExistsBody: Equatable {
    public let message: String?
}

extension ExecutionAlreadyExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ExecutionDoesNotExist: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecutionDoesNotExist(message: \(String(describing: message)))"}
}

extension ExecutionDoesNotExist: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExecutionDoesNotExistBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified execution does not exist.</p>
public struct ExecutionDoesNotExist: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ExecutionDoesNotExistBody: Equatable {
    public let message: String?
}

extension ExecutionDoesNotExistBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ExecutionFailedEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cause
        case error
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension ExecutionFailedEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecutionFailedEventDetails(cause: \(String(describing: cause)), error: \(String(describing: error)))"}
}

/// <p>Contains details about an execution failure event.</p>
public struct ExecutionFailedEventDetails: Equatable {
    /// <p>A more detailed explanation of the cause of the failure.</p>
    public let cause: String?
    /// <p>The error code of the failure.</p>
    public let error: String?

    public init (
        cause: String? = nil,
        error: String? = nil
    )
    {
        self.cause = cause
        self.error = error
    }
}

extension ExecutionLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecutionLimitExceeded(message: \(String(describing: message)))"}
}

extension ExecutionLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExecutionLimitExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of running executions has been reached. Running executions must end or
///       be stopped before a new execution can be started.</p>
public struct ExecutionLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ExecutionLimitExceededBody: Equatable {
    public let message: String?
}

extension ExecutionLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ExecutionListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case executionArn
        case name
        case startDate
        case stateMachineArn
        case status
        case stopDate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionArn = executionArn {
            try encodeContainer.encode(executionArn, forKey: .executionArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate.timeIntervalSince1970, forKey: .startDate)
        }
        if let stateMachineArn = stateMachineArn {
            try encodeContainer.encode(stateMachineArn, forKey: .stateMachineArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopDate = stopDate {
            try encodeContainer.encode(stopDate.timeIntervalSince1970, forKey: .stopDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionArn)
        executionArn = executionArnDecoded
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startDate)
        startDate = startDateDecoded
        let stopDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stopDate)
        stopDate = stopDateDecoded
    }
}

extension ExecutionListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecutionListItem(executionArn: \(String(describing: executionArn)), name: \(String(describing: name)), startDate: \(String(describing: startDate)), stateMachineArn: \(String(describing: stateMachineArn)), status: \(String(describing: status)), stopDate: \(String(describing: stopDate)))"}
}

/// <p>Contains details about an execution.</p>
public struct ExecutionListItem: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the execution.</p>
    public let executionArn: String?
    /// <p>The name of the execution.</p>
    ///          <p>A name must <i>not</i> contain:</p>
    ///          <ul>
    ///             <li>
    ///                <p>white space</p>
    ///             </li>
    ///             <li>
    ///                <p>brackets <code>< > { } [ ]</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>wildcard characters <code>? *</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>special characters <code>" # % \ ^ | ~ ` $ & , ; : /</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>control characters (<code>U+0000-001F</code>, <code>U+007F-009F</code>)</p>
    ///             </li>
    ///          </ul>
    ///          <p>To enable logging with CloudWatch Logs, the name should only contain  0-9, A-Z, a-z, - and _.</p>
    public let name: String?
    /// <p>The date the execution started.</p>
    public let startDate: Date?
    /// <p>The Amazon Resource Name (ARN) of the executed state machine.</p>
    public let stateMachineArn: String?
    /// <p>The current status of the execution.</p>
    public let status: ExecutionStatus?
    /// <p>If the execution already ended, the date the execution stopped.</p>
    public let stopDate: Date?

    public init (
        executionArn: String? = nil,
        name: String? = nil,
        startDate: Date? = nil,
        stateMachineArn: String? = nil,
        status: ExecutionStatus? = nil,
        stopDate: Date? = nil
    )
    {
        self.executionArn = executionArn
        self.name = name
        self.startDate = startDate
        self.stateMachineArn = stateMachineArn
        self.status = status
        self.stopDate = stopDate
    }
}

extension ExecutionStartedEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case input
        case inputDetails
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let inputDetails = inputDetails {
            try encodeContainer.encode(inputDetails, forKey: .inputDetails)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .input)
        input = inputDecoded
        let inputDetailsDecoded = try containerValues.decodeIfPresent(HistoryEventExecutionDataDetails.self, forKey: .inputDetails)
        inputDetails = inputDetailsDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension ExecutionStartedEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecutionStartedEventDetails(input: \(String(describing: input)), inputDetails: \(String(describing: inputDetails)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Contains details about the start of the execution.</p>
public struct ExecutionStartedEventDetails: Equatable {
    /// <p>The JSON data input to the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.</p>
    public let input: String?
    /// <p>Contains details about the input for an execution history event.</p>
    public let inputDetails: HistoryEventExecutionDataDetails?
    /// <p>The Amazon Resource Name (ARN) of the IAM role used for executing AWS Lambda tasks.</p>
    public let roleArn: String?

    public init (
        input: String? = nil,
        inputDetails: HistoryEventExecutionDataDetails? = nil,
        roleArn: String? = nil
    )
    {
        self.input = input
        self.inputDetails = inputDetails
        self.roleArn = roleArn
    }
}

public enum ExecutionStatus {
    case aborted
    case failed
    case running
    case succeeded
    case timedOut
    case sdkUnknown(String)
}

extension ExecutionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExecutionStatus] {
        return [
            .aborted,
            .failed,
            .running,
            .succeeded,
            .timedOut,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aborted: return "ABORTED"
        case .failed: return "FAILED"
        case .running: return "RUNNING"
        case .succeeded: return "SUCCEEDED"
        case .timedOut: return "TIMED_OUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExecutionStatus(rawValue: rawValue) ?? ExecutionStatus.sdkUnknown(rawValue)
    }
}

extension ExecutionSucceededEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case output
        case outputDetails
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let outputDetails = outputDetails {
            try encodeContainer.encode(outputDetails, forKey: .outputDetails)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .output)
        output = outputDecoded
        let outputDetailsDecoded = try containerValues.decodeIfPresent(HistoryEventExecutionDataDetails.self, forKey: .outputDetails)
        outputDetails = outputDetailsDecoded
    }
}

extension ExecutionSucceededEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecutionSucceededEventDetails(output: \(String(describing: output)), outputDetails: \(String(describing: outputDetails)))"}
}

/// <p>Contains details about the successful termination of the execution.</p>
public struct ExecutionSucceededEventDetails: Equatable {
    /// <p>The JSON data output by the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.</p>
    public let output: String?
    /// <p>Contains details about the output of an execution history event.</p>
    public let outputDetails: HistoryEventExecutionDataDetails?

    public init (
        output: String? = nil,
        outputDetails: HistoryEventExecutionDataDetails? = nil
    )
    {
        self.output = output
        self.outputDetails = outputDetails
    }
}

extension ExecutionTimedOutEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cause
        case error
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension ExecutionTimedOutEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecutionTimedOutEventDetails(cause: \(String(describing: cause)), error: \(String(describing: error)))"}
}

/// <p>Contains details about the execution timeout that occurred during the execution.</p>
public struct ExecutionTimedOutEventDetails: Equatable {
    /// <p>A more detailed explanation of the cause of the timeout.</p>
    public let cause: String?
    /// <p>The error code of the failure.</p>
    public let error: String?

    public init (
        cause: String? = nil,
        error: String? = nil
    )
    {
        self.cause = cause
        self.error = error
    }
}

public struct GetActivityTaskInputBodyMiddleware: Middleware {
    public let id: String = "GetActivityTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetActivityTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<GetActivityTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetActivityTaskInput>
    public typealias MOutput = OperationOutput<GetActivityTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetActivityTaskOutputError>
}

extension GetActivityTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetActivityTaskInput(activityArn: \(String(describing: activityArn)), workerName: \(String(describing: workerName)))"}
}

extension GetActivityTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activityArn
        case workerName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activityArn = activityArn {
            try encodeContainer.encode(activityArn, forKey: .activityArn)
        }
        if let workerName = workerName {
            try encodeContainer.encode(workerName, forKey: .workerName)
        }
    }
}

public struct GetActivityTaskInputHeadersMiddleware: Middleware {
    public let id: String = "GetActivityTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetActivityTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<GetActivityTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetActivityTaskInput>
    public typealias MOutput = OperationOutput<GetActivityTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetActivityTaskOutputError>
}

public struct GetActivityTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "GetActivityTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetActivityTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<GetActivityTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetActivityTaskInput>
    public typealias MOutput = OperationOutput<GetActivityTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetActivityTaskOutputError>
}

public struct GetActivityTaskInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the activity to retrieve tasks from (assigned when you create the task
    ///       using <a>CreateActivity</a>.)</p>
    public let activityArn: String?
    /// <p>You can provide an arbitrary name in order to identify the worker that the task is
    ///       assigned to. This name is used when it is logged in the execution history.</p>
    public let workerName: String?

    public init (
        activityArn: String? = nil,
        workerName: String? = nil
    )
    {
        self.activityArn = activityArn
        self.workerName = workerName
    }
}

struct GetActivityTaskInputBody: Equatable {
    public let activityArn: String?
    public let workerName: String?
}

extension GetActivityTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activityArn
        case workerName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activityArn)
        activityArn = activityArnDecoded
        let workerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workerName)
        workerName = workerNameDecoded
    }
}

extension GetActivityTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetActivityTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ActivityDoesNotExist" : self = .activityDoesNotExist(try ActivityDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ActivityWorkerLimitExceeded" : self = .activityWorkerLimitExceeded(try ActivityWorkerLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetActivityTaskOutputError: Equatable {
    case activityDoesNotExist(ActivityDoesNotExist)
    case activityWorkerLimitExceeded(ActivityWorkerLimitExceeded)
    case invalidArn(InvalidArn)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetActivityTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetActivityTaskOutputResponse(input: \(String(describing: input)), taskToken: \(String(describing: taskToken)))"}
}

extension GetActivityTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetActivityTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.input = output.input
            self.taskToken = output.taskToken
        } else {
            self.input = nil
            self.taskToken = nil
        }
    }
}

public struct GetActivityTaskOutputResponse: Equatable {
    /// <p>The string that contains the JSON input data for the task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.</p>
    public let input: String?
    /// <p>A token that identifies the scheduled task. This token must be copied and included in
    ///       subsequent calls to <a>SendTaskHeartbeat</a>, <a>SendTaskSuccess</a> or
    ///         <a>SendTaskFailure</a> in order to report the progress or completion of the
    ///       task.</p>
    public let taskToken: String?

    public init (
        input: String? = nil,
        taskToken: String? = nil
    )
    {
        self.input = input
        self.taskToken = taskToken
    }
}

struct GetActivityTaskOutputResponseBody: Equatable {
    public let taskToken: String?
    public let input: String?
}

extension GetActivityTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case input
        case taskToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskToken)
        taskToken = taskTokenDecoded
        let inputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .input)
        input = inputDecoded
    }
}

public struct GetExecutionHistoryInputBodyMiddleware: Middleware {
    public let id: String = "GetExecutionHistoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetExecutionHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetExecutionHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetExecutionHistoryInput>
    public typealias MOutput = OperationOutput<GetExecutionHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetExecutionHistoryOutputError>
}

extension GetExecutionHistoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetExecutionHistoryInput(executionArn: \(String(describing: executionArn)), includeExecutionData: \(String(describing: includeExecutionData)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), reverseOrder: \(String(describing: reverseOrder)))"}
}

extension GetExecutionHistoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case executionArn
        case includeExecutionData
        case maxResults
        case nextToken
        case reverseOrder
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionArn = executionArn {
            try encodeContainer.encode(executionArn, forKey: .executionArn)
        }
        if let includeExecutionData = includeExecutionData {
            try encodeContainer.encode(includeExecutionData, forKey: .includeExecutionData)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if reverseOrder != false {
            try encodeContainer.encode(reverseOrder, forKey: .reverseOrder)
        }
    }
}

public struct GetExecutionHistoryInputHeadersMiddleware: Middleware {
    public let id: String = "GetExecutionHistoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetExecutionHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetExecutionHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetExecutionHistoryInput>
    public typealias MOutput = OperationOutput<GetExecutionHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetExecutionHistoryOutputError>
}

public struct GetExecutionHistoryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetExecutionHistoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetExecutionHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetExecutionHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetExecutionHistoryInput>
    public typealias MOutput = OperationOutput<GetExecutionHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetExecutionHistoryOutputError>
}

public struct GetExecutionHistoryInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the execution.</p>
    public let executionArn: String?
    /// <p>You can select whether execution data (input or output of a history event) is returned.
    ///       The default is <code>true</code>.</p>
    public let includeExecutionData: Bool?
    /// <p>The maximum number of results that are returned per call. You can use <code>nextToken</code> to obtain further pages of results.
    ///     The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default.</p>
    ///          <p>This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.</p>
    public let maxResults: Int
    /// <p>If <code>nextToken</code> is returned, there are more results available. The value of <code>nextToken</code> is a unique pagination token for each page.
    ///     Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an <i>HTTP 400 InvalidToken</i> error.</p>
    public let nextToken: String?
    /// <p>Lists events in descending order of their <code>timeStamp</code>.</p>
    public let reverseOrder: Bool

    public init (
        executionArn: String? = nil,
        includeExecutionData: Bool? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        reverseOrder: Bool = false
    )
    {
        self.executionArn = executionArn
        self.includeExecutionData = includeExecutionData
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reverseOrder = reverseOrder
    }
}

struct GetExecutionHistoryInputBody: Equatable {
    public let executionArn: String?
    public let maxResults: Int
    public let reverseOrder: Bool
    public let nextToken: String?
    public let includeExecutionData: Bool?
}

extension GetExecutionHistoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case executionArn
        case includeExecutionData
        case maxResults
        case nextToken
        case reverseOrder
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionArn)
        executionArn = executionArnDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let reverseOrderDecoded = try containerValues.decode(Bool.self, forKey: .reverseOrder)
        reverseOrder = reverseOrderDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let includeExecutionDataDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeExecutionData)
        includeExecutionData = includeExecutionDataDecoded
    }
}

extension GetExecutionHistoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExecutionHistoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExecutionDoesNotExist" : self = .executionDoesNotExist(try ExecutionDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidToken" : self = .invalidToken(try InvalidToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetExecutionHistoryOutputError: Equatable {
    case executionDoesNotExist(ExecutionDoesNotExist)
    case invalidArn(InvalidArn)
    case invalidToken(InvalidToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExecutionHistoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetExecutionHistoryOutputResponse(events: \(String(describing: events)), nextToken: \(String(describing: nextToken)))"}
}

extension GetExecutionHistoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetExecutionHistoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct GetExecutionHistoryOutputResponse: Equatable {
    /// <p>The list of events that occurred in the execution.</p>
    public let events: [HistoryEvent]?
    /// <p>If <code>nextToken</code> is returned, there are more results available. The value of <code>nextToken</code> is a unique pagination token for each page.
    ///     Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an <i>HTTP 400 InvalidToken</i> error.</p>
    public let nextToken: String?

    public init (
        events: [HistoryEvent]? = nil,
        nextToken: String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct GetExecutionHistoryOutputResponseBody: Equatable {
    public let events: [HistoryEvent]?
    public let nextToken: String?
}

extension GetExecutionHistoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case events
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([HistoryEvent?].self, forKey: .events)
        var eventsDecoded0:[HistoryEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [HistoryEvent]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension HistoryEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activityFailedEventDetails
        case activityScheduleFailedEventDetails
        case activityScheduledEventDetails
        case activityStartedEventDetails
        case activitySucceededEventDetails
        case activityTimedOutEventDetails
        case executionAbortedEventDetails
        case executionFailedEventDetails
        case executionStartedEventDetails
        case executionSucceededEventDetails
        case executionTimedOutEventDetails
        case id
        case lambdaFunctionFailedEventDetails
        case lambdaFunctionScheduleFailedEventDetails
        case lambdaFunctionScheduledEventDetails
        case lambdaFunctionStartFailedEventDetails
        case lambdaFunctionSucceededEventDetails
        case lambdaFunctionTimedOutEventDetails
        case mapIterationAbortedEventDetails
        case mapIterationFailedEventDetails
        case mapIterationStartedEventDetails
        case mapIterationSucceededEventDetails
        case mapStateStartedEventDetails
        case previousEventId
        case stateEnteredEventDetails
        case stateExitedEventDetails
        case taskFailedEventDetails
        case taskScheduledEventDetails
        case taskStartFailedEventDetails
        case taskStartedEventDetails
        case taskSubmitFailedEventDetails
        case taskSubmittedEventDetails
        case taskSucceededEventDetails
        case taskTimedOutEventDetails
        case timestamp
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activityFailedEventDetails = activityFailedEventDetails {
            try encodeContainer.encode(activityFailedEventDetails, forKey: .activityFailedEventDetails)
        }
        if let activityScheduleFailedEventDetails = activityScheduleFailedEventDetails {
            try encodeContainer.encode(activityScheduleFailedEventDetails, forKey: .activityScheduleFailedEventDetails)
        }
        if let activityScheduledEventDetails = activityScheduledEventDetails {
            try encodeContainer.encode(activityScheduledEventDetails, forKey: .activityScheduledEventDetails)
        }
        if let activityStartedEventDetails = activityStartedEventDetails {
            try encodeContainer.encode(activityStartedEventDetails, forKey: .activityStartedEventDetails)
        }
        if let activitySucceededEventDetails = activitySucceededEventDetails {
            try encodeContainer.encode(activitySucceededEventDetails, forKey: .activitySucceededEventDetails)
        }
        if let activityTimedOutEventDetails = activityTimedOutEventDetails {
            try encodeContainer.encode(activityTimedOutEventDetails, forKey: .activityTimedOutEventDetails)
        }
        if let executionAbortedEventDetails = executionAbortedEventDetails {
            try encodeContainer.encode(executionAbortedEventDetails, forKey: .executionAbortedEventDetails)
        }
        if let executionFailedEventDetails = executionFailedEventDetails {
            try encodeContainer.encode(executionFailedEventDetails, forKey: .executionFailedEventDetails)
        }
        if let executionStartedEventDetails = executionStartedEventDetails {
            try encodeContainer.encode(executionStartedEventDetails, forKey: .executionStartedEventDetails)
        }
        if let executionSucceededEventDetails = executionSucceededEventDetails {
            try encodeContainer.encode(executionSucceededEventDetails, forKey: .executionSucceededEventDetails)
        }
        if let executionTimedOutEventDetails = executionTimedOutEventDetails {
            try encodeContainer.encode(executionTimedOutEventDetails, forKey: .executionTimedOutEventDetails)
        }
        if id != 0 {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lambdaFunctionFailedEventDetails = lambdaFunctionFailedEventDetails {
            try encodeContainer.encode(lambdaFunctionFailedEventDetails, forKey: .lambdaFunctionFailedEventDetails)
        }
        if let lambdaFunctionScheduleFailedEventDetails = lambdaFunctionScheduleFailedEventDetails {
            try encodeContainer.encode(lambdaFunctionScheduleFailedEventDetails, forKey: .lambdaFunctionScheduleFailedEventDetails)
        }
        if let lambdaFunctionScheduledEventDetails = lambdaFunctionScheduledEventDetails {
            try encodeContainer.encode(lambdaFunctionScheduledEventDetails, forKey: .lambdaFunctionScheduledEventDetails)
        }
        if let lambdaFunctionStartFailedEventDetails = lambdaFunctionStartFailedEventDetails {
            try encodeContainer.encode(lambdaFunctionStartFailedEventDetails, forKey: .lambdaFunctionStartFailedEventDetails)
        }
        if let lambdaFunctionSucceededEventDetails = lambdaFunctionSucceededEventDetails {
            try encodeContainer.encode(lambdaFunctionSucceededEventDetails, forKey: .lambdaFunctionSucceededEventDetails)
        }
        if let lambdaFunctionTimedOutEventDetails = lambdaFunctionTimedOutEventDetails {
            try encodeContainer.encode(lambdaFunctionTimedOutEventDetails, forKey: .lambdaFunctionTimedOutEventDetails)
        }
        if let mapIterationAbortedEventDetails = mapIterationAbortedEventDetails {
            try encodeContainer.encode(mapIterationAbortedEventDetails, forKey: .mapIterationAbortedEventDetails)
        }
        if let mapIterationFailedEventDetails = mapIterationFailedEventDetails {
            try encodeContainer.encode(mapIterationFailedEventDetails, forKey: .mapIterationFailedEventDetails)
        }
        if let mapIterationStartedEventDetails = mapIterationStartedEventDetails {
            try encodeContainer.encode(mapIterationStartedEventDetails, forKey: .mapIterationStartedEventDetails)
        }
        if let mapIterationSucceededEventDetails = mapIterationSucceededEventDetails {
            try encodeContainer.encode(mapIterationSucceededEventDetails, forKey: .mapIterationSucceededEventDetails)
        }
        if let mapStateStartedEventDetails = mapStateStartedEventDetails {
            try encodeContainer.encode(mapStateStartedEventDetails, forKey: .mapStateStartedEventDetails)
        }
        if previousEventId != 0 {
            try encodeContainer.encode(previousEventId, forKey: .previousEventId)
        }
        if let stateEnteredEventDetails = stateEnteredEventDetails {
            try encodeContainer.encode(stateEnteredEventDetails, forKey: .stateEnteredEventDetails)
        }
        if let stateExitedEventDetails = stateExitedEventDetails {
            try encodeContainer.encode(stateExitedEventDetails, forKey: .stateExitedEventDetails)
        }
        if let taskFailedEventDetails = taskFailedEventDetails {
            try encodeContainer.encode(taskFailedEventDetails, forKey: .taskFailedEventDetails)
        }
        if let taskScheduledEventDetails = taskScheduledEventDetails {
            try encodeContainer.encode(taskScheduledEventDetails, forKey: .taskScheduledEventDetails)
        }
        if let taskStartFailedEventDetails = taskStartFailedEventDetails {
            try encodeContainer.encode(taskStartFailedEventDetails, forKey: .taskStartFailedEventDetails)
        }
        if let taskStartedEventDetails = taskStartedEventDetails {
            try encodeContainer.encode(taskStartedEventDetails, forKey: .taskStartedEventDetails)
        }
        if let taskSubmitFailedEventDetails = taskSubmitFailedEventDetails {
            try encodeContainer.encode(taskSubmitFailedEventDetails, forKey: .taskSubmitFailedEventDetails)
        }
        if let taskSubmittedEventDetails = taskSubmittedEventDetails {
            try encodeContainer.encode(taskSubmittedEventDetails, forKey: .taskSubmittedEventDetails)
        }
        if let taskSucceededEventDetails = taskSucceededEventDetails {
            try encodeContainer.encode(taskSucceededEventDetails, forKey: .taskSucceededEventDetails)
        }
        if let taskTimedOutEventDetails = taskTimedOutEventDetails {
            try encodeContainer.encode(taskTimedOutEventDetails, forKey: .taskTimedOutEventDetails)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let typeDecoded = try containerValues.decodeIfPresent(HistoryEventType.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decode(Int.self, forKey: .id)
        id = idDecoded
        let previousEventIdDecoded = try containerValues.decode(Int.self, forKey: .previousEventId)
        previousEventId = previousEventIdDecoded
        let activityFailedEventDetailsDecoded = try containerValues.decodeIfPresent(ActivityFailedEventDetails.self, forKey: .activityFailedEventDetails)
        activityFailedEventDetails = activityFailedEventDetailsDecoded
        let activityScheduleFailedEventDetailsDecoded = try containerValues.decodeIfPresent(ActivityScheduleFailedEventDetails.self, forKey: .activityScheduleFailedEventDetails)
        activityScheduleFailedEventDetails = activityScheduleFailedEventDetailsDecoded
        let activityScheduledEventDetailsDecoded = try containerValues.decodeIfPresent(ActivityScheduledEventDetails.self, forKey: .activityScheduledEventDetails)
        activityScheduledEventDetails = activityScheduledEventDetailsDecoded
        let activityStartedEventDetailsDecoded = try containerValues.decodeIfPresent(ActivityStartedEventDetails.self, forKey: .activityStartedEventDetails)
        activityStartedEventDetails = activityStartedEventDetailsDecoded
        let activitySucceededEventDetailsDecoded = try containerValues.decodeIfPresent(ActivitySucceededEventDetails.self, forKey: .activitySucceededEventDetails)
        activitySucceededEventDetails = activitySucceededEventDetailsDecoded
        let activityTimedOutEventDetailsDecoded = try containerValues.decodeIfPresent(ActivityTimedOutEventDetails.self, forKey: .activityTimedOutEventDetails)
        activityTimedOutEventDetails = activityTimedOutEventDetailsDecoded
        let taskFailedEventDetailsDecoded = try containerValues.decodeIfPresent(TaskFailedEventDetails.self, forKey: .taskFailedEventDetails)
        taskFailedEventDetails = taskFailedEventDetailsDecoded
        let taskScheduledEventDetailsDecoded = try containerValues.decodeIfPresent(TaskScheduledEventDetails.self, forKey: .taskScheduledEventDetails)
        taskScheduledEventDetails = taskScheduledEventDetailsDecoded
        let taskStartFailedEventDetailsDecoded = try containerValues.decodeIfPresent(TaskStartFailedEventDetails.self, forKey: .taskStartFailedEventDetails)
        taskStartFailedEventDetails = taskStartFailedEventDetailsDecoded
        let taskStartedEventDetailsDecoded = try containerValues.decodeIfPresent(TaskStartedEventDetails.self, forKey: .taskStartedEventDetails)
        taskStartedEventDetails = taskStartedEventDetailsDecoded
        let taskSubmitFailedEventDetailsDecoded = try containerValues.decodeIfPresent(TaskSubmitFailedEventDetails.self, forKey: .taskSubmitFailedEventDetails)
        taskSubmitFailedEventDetails = taskSubmitFailedEventDetailsDecoded
        let taskSubmittedEventDetailsDecoded = try containerValues.decodeIfPresent(TaskSubmittedEventDetails.self, forKey: .taskSubmittedEventDetails)
        taskSubmittedEventDetails = taskSubmittedEventDetailsDecoded
        let taskSucceededEventDetailsDecoded = try containerValues.decodeIfPresent(TaskSucceededEventDetails.self, forKey: .taskSucceededEventDetails)
        taskSucceededEventDetails = taskSucceededEventDetailsDecoded
        let taskTimedOutEventDetailsDecoded = try containerValues.decodeIfPresent(TaskTimedOutEventDetails.self, forKey: .taskTimedOutEventDetails)
        taskTimedOutEventDetails = taskTimedOutEventDetailsDecoded
        let executionFailedEventDetailsDecoded = try containerValues.decodeIfPresent(ExecutionFailedEventDetails.self, forKey: .executionFailedEventDetails)
        executionFailedEventDetails = executionFailedEventDetailsDecoded
        let executionStartedEventDetailsDecoded = try containerValues.decodeIfPresent(ExecutionStartedEventDetails.self, forKey: .executionStartedEventDetails)
        executionStartedEventDetails = executionStartedEventDetailsDecoded
        let executionSucceededEventDetailsDecoded = try containerValues.decodeIfPresent(ExecutionSucceededEventDetails.self, forKey: .executionSucceededEventDetails)
        executionSucceededEventDetails = executionSucceededEventDetailsDecoded
        let executionAbortedEventDetailsDecoded = try containerValues.decodeIfPresent(ExecutionAbortedEventDetails.self, forKey: .executionAbortedEventDetails)
        executionAbortedEventDetails = executionAbortedEventDetailsDecoded
        let executionTimedOutEventDetailsDecoded = try containerValues.decodeIfPresent(ExecutionTimedOutEventDetails.self, forKey: .executionTimedOutEventDetails)
        executionTimedOutEventDetails = executionTimedOutEventDetailsDecoded
        let mapStateStartedEventDetailsDecoded = try containerValues.decodeIfPresent(MapStateStartedEventDetails.self, forKey: .mapStateStartedEventDetails)
        mapStateStartedEventDetails = mapStateStartedEventDetailsDecoded
        let mapIterationStartedEventDetailsDecoded = try containerValues.decodeIfPresent(MapIterationEventDetails.self, forKey: .mapIterationStartedEventDetails)
        mapIterationStartedEventDetails = mapIterationStartedEventDetailsDecoded
        let mapIterationSucceededEventDetailsDecoded = try containerValues.decodeIfPresent(MapIterationEventDetails.self, forKey: .mapIterationSucceededEventDetails)
        mapIterationSucceededEventDetails = mapIterationSucceededEventDetailsDecoded
        let mapIterationFailedEventDetailsDecoded = try containerValues.decodeIfPresent(MapIterationEventDetails.self, forKey: .mapIterationFailedEventDetails)
        mapIterationFailedEventDetails = mapIterationFailedEventDetailsDecoded
        let mapIterationAbortedEventDetailsDecoded = try containerValues.decodeIfPresent(MapIterationEventDetails.self, forKey: .mapIterationAbortedEventDetails)
        mapIterationAbortedEventDetails = mapIterationAbortedEventDetailsDecoded
        let lambdaFunctionFailedEventDetailsDecoded = try containerValues.decodeIfPresent(LambdaFunctionFailedEventDetails.self, forKey: .lambdaFunctionFailedEventDetails)
        lambdaFunctionFailedEventDetails = lambdaFunctionFailedEventDetailsDecoded
        let lambdaFunctionScheduleFailedEventDetailsDecoded = try containerValues.decodeIfPresent(LambdaFunctionScheduleFailedEventDetails.self, forKey: .lambdaFunctionScheduleFailedEventDetails)
        lambdaFunctionScheduleFailedEventDetails = lambdaFunctionScheduleFailedEventDetailsDecoded
        let lambdaFunctionScheduledEventDetailsDecoded = try containerValues.decodeIfPresent(LambdaFunctionScheduledEventDetails.self, forKey: .lambdaFunctionScheduledEventDetails)
        lambdaFunctionScheduledEventDetails = lambdaFunctionScheduledEventDetailsDecoded
        let lambdaFunctionStartFailedEventDetailsDecoded = try containerValues.decodeIfPresent(LambdaFunctionStartFailedEventDetails.self, forKey: .lambdaFunctionStartFailedEventDetails)
        lambdaFunctionStartFailedEventDetails = lambdaFunctionStartFailedEventDetailsDecoded
        let lambdaFunctionSucceededEventDetailsDecoded = try containerValues.decodeIfPresent(LambdaFunctionSucceededEventDetails.self, forKey: .lambdaFunctionSucceededEventDetails)
        lambdaFunctionSucceededEventDetails = lambdaFunctionSucceededEventDetailsDecoded
        let lambdaFunctionTimedOutEventDetailsDecoded = try containerValues.decodeIfPresent(LambdaFunctionTimedOutEventDetails.self, forKey: .lambdaFunctionTimedOutEventDetails)
        lambdaFunctionTimedOutEventDetails = lambdaFunctionTimedOutEventDetailsDecoded
        let stateEnteredEventDetailsDecoded = try containerValues.decodeIfPresent(StateEnteredEventDetails.self, forKey: .stateEnteredEventDetails)
        stateEnteredEventDetails = stateEnteredEventDetailsDecoded
        let stateExitedEventDetailsDecoded = try containerValues.decodeIfPresent(StateExitedEventDetails.self, forKey: .stateExitedEventDetails)
        stateExitedEventDetails = stateExitedEventDetailsDecoded
    }
}

extension HistoryEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HistoryEvent(activityFailedEventDetails: \(String(describing: activityFailedEventDetails)), activityScheduleFailedEventDetails: \(String(describing: activityScheduleFailedEventDetails)), activityScheduledEventDetails: \(String(describing: activityScheduledEventDetails)), activityStartedEventDetails: \(String(describing: activityStartedEventDetails)), activitySucceededEventDetails: \(String(describing: activitySucceededEventDetails)), activityTimedOutEventDetails: \(String(describing: activityTimedOutEventDetails)), executionAbortedEventDetails: \(String(describing: executionAbortedEventDetails)), executionFailedEventDetails: \(String(describing: executionFailedEventDetails)), executionStartedEventDetails: \(String(describing: executionStartedEventDetails)), executionSucceededEventDetails: \(String(describing: executionSucceededEventDetails)), executionTimedOutEventDetails: \(String(describing: executionTimedOutEventDetails)), id: \(String(describing: id)), lambdaFunctionFailedEventDetails: \(String(describing: lambdaFunctionFailedEventDetails)), lambdaFunctionScheduleFailedEventDetails: \(String(describing: lambdaFunctionScheduleFailedEventDetails)), lambdaFunctionScheduledEventDetails: \(String(describing: lambdaFunctionScheduledEventDetails)), lambdaFunctionStartFailedEventDetails: \(String(describing: lambdaFunctionStartFailedEventDetails)), lambdaFunctionSucceededEventDetails: \(String(describing: lambdaFunctionSucceededEventDetails)), lambdaFunctionTimedOutEventDetails: \(String(describing: lambdaFunctionTimedOutEventDetails)), mapIterationAbortedEventDetails: \(String(describing: mapIterationAbortedEventDetails)), mapIterationFailedEventDetails: \(String(describing: mapIterationFailedEventDetails)), mapIterationStartedEventDetails: \(String(describing: mapIterationStartedEventDetails)), mapIterationSucceededEventDetails: \(String(describing: mapIterationSucceededEventDetails)), mapStateStartedEventDetails: \(String(describing: mapStateStartedEventDetails)), previousEventId: \(String(describing: previousEventId)), stateEnteredEventDetails: \(String(describing: stateEnteredEventDetails)), stateExitedEventDetails: \(String(describing: stateExitedEventDetails)), taskFailedEventDetails: \(String(describing: taskFailedEventDetails)), taskScheduledEventDetails: \(String(describing: taskScheduledEventDetails)), taskStartFailedEventDetails: \(String(describing: taskStartFailedEventDetails)), taskStartedEventDetails: \(String(describing: taskStartedEventDetails)), taskSubmitFailedEventDetails: \(String(describing: taskSubmitFailedEventDetails)), taskSubmittedEventDetails: \(String(describing: taskSubmittedEventDetails)), taskSucceededEventDetails: \(String(describing: taskSucceededEventDetails)), taskTimedOutEventDetails: \(String(describing: taskTimedOutEventDetails)), timestamp: \(String(describing: timestamp)), type: \(String(describing: type)))"}
}

/// <p>Contains details about the events of an execution.</p>
public struct HistoryEvent: Equatable {
    /// <p>Contains details about an activity that failed during an execution.</p>
    public let activityFailedEventDetails: ActivityFailedEventDetails?
    /// <p>Contains details about an activity schedule event that failed during an execution.</p>
    public let activityScheduleFailedEventDetails: ActivityScheduleFailedEventDetails?
    /// <p>Contains details about an activity scheduled during an execution.</p>
    public let activityScheduledEventDetails: ActivityScheduledEventDetails?
    /// <p>Contains details about the start of an activity during an execution.</p>
    public let activityStartedEventDetails: ActivityStartedEventDetails?
    /// <p>Contains details about an activity that successfully terminated during an
    ///       execution.</p>
    public let activitySucceededEventDetails: ActivitySucceededEventDetails?
    /// <p>Contains details about an activity timeout that occurred during an execution.</p>
    public let activityTimedOutEventDetails: ActivityTimedOutEventDetails?
    /// <p>Contains details about an abort of an execution.</p>
    public let executionAbortedEventDetails: ExecutionAbortedEventDetails?
    /// <p>Contains details about an execution failure event.</p>
    public let executionFailedEventDetails: ExecutionFailedEventDetails?
    /// <p>Contains details about the start of the execution.</p>
    public let executionStartedEventDetails: ExecutionStartedEventDetails?
    /// <p>Contains details about the successful termination of the execution.</p>
    public let executionSucceededEventDetails: ExecutionSucceededEventDetails?
    /// <p>Contains details about the execution timeout that occurred during the execution.</p>
    public let executionTimedOutEventDetails: ExecutionTimedOutEventDetails?
    /// <p>The id of the event. Events are numbered sequentially, starting at one.</p>
    public let id: Int
    /// <p>Contains details about a lambda function that failed during an execution.</p>
    public let lambdaFunctionFailedEventDetails: LambdaFunctionFailedEventDetails?
    /// <p>Contains details about a failed lambda function schedule event that occurred during an
    ///       execution.</p>
    public let lambdaFunctionScheduleFailedEventDetails: LambdaFunctionScheduleFailedEventDetails?
    /// <p>Contains details about a lambda function scheduled during an execution.</p>
    public let lambdaFunctionScheduledEventDetails: LambdaFunctionScheduledEventDetails?
    /// <p>Contains details about a lambda function that failed to start during an execution.</p>
    public let lambdaFunctionStartFailedEventDetails: LambdaFunctionStartFailedEventDetails?
    /// <p>Contains details about a lambda function that terminated successfully during an
    ///       execution.</p>
    public let lambdaFunctionSucceededEventDetails: LambdaFunctionSucceededEventDetails?
    /// <p>Contains details about a lambda function timeout that occurred during an execution.</p>
    public let lambdaFunctionTimedOutEventDetails: LambdaFunctionTimedOutEventDetails?
    /// <p>Contains details about an iteration of a Map state that was aborted.</p>
    public let mapIterationAbortedEventDetails: MapIterationEventDetails?
    /// <p>Contains details about an iteration of a Map state that failed.</p>
    public let mapIterationFailedEventDetails: MapIterationEventDetails?
    /// <p>Contains details about an iteration of a Map state that was started.</p>
    public let mapIterationStartedEventDetails: MapIterationEventDetails?
    /// <p>Contains details about an iteration of a Map state that succeeded.</p>
    public let mapIterationSucceededEventDetails: MapIterationEventDetails?
    /// <p>Contains details about Map state that was started.</p>
    public let mapStateStartedEventDetails: MapStateStartedEventDetails?
    /// <p>The id of the previous event.</p>
    public let previousEventId: Int
    /// <p>Contains details about a state entered during an execution.</p>
    public let stateEnteredEventDetails: StateEnteredEventDetails?
    /// <p>Contains details about an exit from a state during an execution.</p>
    public let stateExitedEventDetails: StateExitedEventDetails?
    /// <p>Contains details about the failure of a task.</p>
    public let taskFailedEventDetails: TaskFailedEventDetails?
    /// <p>Contains details about a task that was scheduled.</p>
    public let taskScheduledEventDetails: TaskScheduledEventDetails?
    /// <p>Contains details about a task that failed to start.</p>
    public let taskStartFailedEventDetails: TaskStartFailedEventDetails?
    /// <p>Contains details about a task that was started.</p>
    public let taskStartedEventDetails: TaskStartedEventDetails?
    /// <p>Contains details about a task that where the submit failed.</p>
    public let taskSubmitFailedEventDetails: TaskSubmitFailedEventDetails?
    /// <p>Contains details about a submitted task.</p>
    public let taskSubmittedEventDetails: TaskSubmittedEventDetails?
    /// <p>Contains details about a task that succeeded.</p>
    public let taskSucceededEventDetails: TaskSucceededEventDetails?
    /// <p>Contains details about a task that timed out.</p>
    public let taskTimedOutEventDetails: TaskTimedOutEventDetails?
    /// <p>The date and time the event occurred.</p>
    public let timestamp: Date?
    /// <p>The type of the event.</p>
    public let type: HistoryEventType?

    public init (
        activityFailedEventDetails: ActivityFailedEventDetails? = nil,
        activityScheduleFailedEventDetails: ActivityScheduleFailedEventDetails? = nil,
        activityScheduledEventDetails: ActivityScheduledEventDetails? = nil,
        activityStartedEventDetails: ActivityStartedEventDetails? = nil,
        activitySucceededEventDetails: ActivitySucceededEventDetails? = nil,
        activityTimedOutEventDetails: ActivityTimedOutEventDetails? = nil,
        executionAbortedEventDetails: ExecutionAbortedEventDetails? = nil,
        executionFailedEventDetails: ExecutionFailedEventDetails? = nil,
        executionStartedEventDetails: ExecutionStartedEventDetails? = nil,
        executionSucceededEventDetails: ExecutionSucceededEventDetails? = nil,
        executionTimedOutEventDetails: ExecutionTimedOutEventDetails? = nil,
        id: Int = 0,
        lambdaFunctionFailedEventDetails: LambdaFunctionFailedEventDetails? = nil,
        lambdaFunctionScheduleFailedEventDetails: LambdaFunctionScheduleFailedEventDetails? = nil,
        lambdaFunctionScheduledEventDetails: LambdaFunctionScheduledEventDetails? = nil,
        lambdaFunctionStartFailedEventDetails: LambdaFunctionStartFailedEventDetails? = nil,
        lambdaFunctionSucceededEventDetails: LambdaFunctionSucceededEventDetails? = nil,
        lambdaFunctionTimedOutEventDetails: LambdaFunctionTimedOutEventDetails? = nil,
        mapIterationAbortedEventDetails: MapIterationEventDetails? = nil,
        mapIterationFailedEventDetails: MapIterationEventDetails? = nil,
        mapIterationStartedEventDetails: MapIterationEventDetails? = nil,
        mapIterationSucceededEventDetails: MapIterationEventDetails? = nil,
        mapStateStartedEventDetails: MapStateStartedEventDetails? = nil,
        previousEventId: Int = 0,
        stateEnteredEventDetails: StateEnteredEventDetails? = nil,
        stateExitedEventDetails: StateExitedEventDetails? = nil,
        taskFailedEventDetails: TaskFailedEventDetails? = nil,
        taskScheduledEventDetails: TaskScheduledEventDetails? = nil,
        taskStartFailedEventDetails: TaskStartFailedEventDetails? = nil,
        taskStartedEventDetails: TaskStartedEventDetails? = nil,
        taskSubmitFailedEventDetails: TaskSubmitFailedEventDetails? = nil,
        taskSubmittedEventDetails: TaskSubmittedEventDetails? = nil,
        taskSucceededEventDetails: TaskSucceededEventDetails? = nil,
        taskTimedOutEventDetails: TaskTimedOutEventDetails? = nil,
        timestamp: Date? = nil,
        type: HistoryEventType? = nil
    )
    {
        self.activityFailedEventDetails = activityFailedEventDetails
        self.activityScheduleFailedEventDetails = activityScheduleFailedEventDetails
        self.activityScheduledEventDetails = activityScheduledEventDetails
        self.activityStartedEventDetails = activityStartedEventDetails
        self.activitySucceededEventDetails = activitySucceededEventDetails
        self.activityTimedOutEventDetails = activityTimedOutEventDetails
        self.executionAbortedEventDetails = executionAbortedEventDetails
        self.executionFailedEventDetails = executionFailedEventDetails
        self.executionStartedEventDetails = executionStartedEventDetails
        self.executionSucceededEventDetails = executionSucceededEventDetails
        self.executionTimedOutEventDetails = executionTimedOutEventDetails
        self.id = id
        self.lambdaFunctionFailedEventDetails = lambdaFunctionFailedEventDetails
        self.lambdaFunctionScheduleFailedEventDetails = lambdaFunctionScheduleFailedEventDetails
        self.lambdaFunctionScheduledEventDetails = lambdaFunctionScheduledEventDetails
        self.lambdaFunctionStartFailedEventDetails = lambdaFunctionStartFailedEventDetails
        self.lambdaFunctionSucceededEventDetails = lambdaFunctionSucceededEventDetails
        self.lambdaFunctionTimedOutEventDetails = lambdaFunctionTimedOutEventDetails
        self.mapIterationAbortedEventDetails = mapIterationAbortedEventDetails
        self.mapIterationFailedEventDetails = mapIterationFailedEventDetails
        self.mapIterationStartedEventDetails = mapIterationStartedEventDetails
        self.mapIterationSucceededEventDetails = mapIterationSucceededEventDetails
        self.mapStateStartedEventDetails = mapStateStartedEventDetails
        self.previousEventId = previousEventId
        self.stateEnteredEventDetails = stateEnteredEventDetails
        self.stateExitedEventDetails = stateExitedEventDetails
        self.taskFailedEventDetails = taskFailedEventDetails
        self.taskScheduledEventDetails = taskScheduledEventDetails
        self.taskStartFailedEventDetails = taskStartFailedEventDetails
        self.taskStartedEventDetails = taskStartedEventDetails
        self.taskSubmitFailedEventDetails = taskSubmitFailedEventDetails
        self.taskSubmittedEventDetails = taskSubmittedEventDetails
        self.taskSucceededEventDetails = taskSucceededEventDetails
        self.taskTimedOutEventDetails = taskTimedOutEventDetails
        self.timestamp = timestamp
        self.type = type
    }
}

extension HistoryEventExecutionDataDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case truncated
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if truncated != false {
            try encodeContainer.encode(truncated, forKey: .truncated)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let truncatedDecoded = try containerValues.decode(Bool.self, forKey: .truncated)
        truncated = truncatedDecoded
    }
}

extension HistoryEventExecutionDataDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HistoryEventExecutionDataDetails(truncated: \(String(describing: truncated)))"}
}

/// <p>Provides details about input or output in an execution history event.</p>
public struct HistoryEventExecutionDataDetails: Equatable {
    /// <p>Indicates whether input or output was truncated in the response. Always
    ///       <code>false</code> for API calls.</p>
    public let truncated: Bool

    public init (
        truncated: Bool = false
    )
    {
        self.truncated = truncated
    }
}

public enum HistoryEventType {
    case activityfailed
    case activityschedulefailed
    case activityscheduled
    case activitystarted
    case activitysucceeded
    case activitytimedout
    case choicestateentered
    case choicestateexited
    case executionaborted
    case executionfailed
    case executionstarted
    case executionsucceeded
    case executiontimedout
    case failstateentered
    case lambdafunctionfailed
    case lambdafunctionschedulefailed
    case lambdafunctionscheduled
    case lambdafunctionstartfailed
    case lambdafunctionstarted
    case lambdafunctionsucceeded
    case lambdafunctiontimedout
    case mapiterationaborted
    case mapiterationfailed
    case mapiterationstarted
    case mapiterationsucceeded
    case mapstateaborted
    case mapstateentered
    case mapstateexited
    case mapstatefailed
    case mapstatestarted
    case mapstatesucceeded
    case parallelstateaborted
    case parallelstateentered
    case parallelstateexited
    case parallelstatefailed
    case parallelstatestarted
    case parallelstatesucceeded
    case passstateentered
    case passstateexited
    case succeedstateentered
    case succeedstateexited
    case taskfailed
    case taskscheduled
    case taskstartfailed
    case taskstarted
    case taskstateaborted
    case taskstateentered
    case taskstateexited
    case tasksubmitfailed
    case tasksubmitted
    case tasksucceeded
    case tasktimedout
    case waitstateaborted
    case waitstateentered
    case waitstateexited
    case sdkUnknown(String)
}

extension HistoryEventType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HistoryEventType] {
        return [
            .activityfailed,
            .activityschedulefailed,
            .activityscheduled,
            .activitystarted,
            .activitysucceeded,
            .activitytimedout,
            .choicestateentered,
            .choicestateexited,
            .executionaborted,
            .executionfailed,
            .executionstarted,
            .executionsucceeded,
            .executiontimedout,
            .failstateentered,
            .lambdafunctionfailed,
            .lambdafunctionschedulefailed,
            .lambdafunctionscheduled,
            .lambdafunctionstartfailed,
            .lambdafunctionstarted,
            .lambdafunctionsucceeded,
            .lambdafunctiontimedout,
            .mapiterationaborted,
            .mapiterationfailed,
            .mapiterationstarted,
            .mapiterationsucceeded,
            .mapstateaborted,
            .mapstateentered,
            .mapstateexited,
            .mapstatefailed,
            .mapstatestarted,
            .mapstatesucceeded,
            .parallelstateaborted,
            .parallelstateentered,
            .parallelstateexited,
            .parallelstatefailed,
            .parallelstatestarted,
            .parallelstatesucceeded,
            .passstateentered,
            .passstateexited,
            .succeedstateentered,
            .succeedstateexited,
            .taskfailed,
            .taskscheduled,
            .taskstartfailed,
            .taskstarted,
            .taskstateaborted,
            .taskstateentered,
            .taskstateexited,
            .tasksubmitfailed,
            .tasksubmitted,
            .tasksucceeded,
            .tasktimedout,
            .waitstateaborted,
            .waitstateentered,
            .waitstateexited,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .activityfailed: return "ActivityFailed"
        case .activityschedulefailed: return "ActivityScheduleFailed"
        case .activityscheduled: return "ActivityScheduled"
        case .activitystarted: return "ActivityStarted"
        case .activitysucceeded: return "ActivitySucceeded"
        case .activitytimedout: return "ActivityTimedOut"
        case .choicestateentered: return "ChoiceStateEntered"
        case .choicestateexited: return "ChoiceStateExited"
        case .executionaborted: return "ExecutionAborted"
        case .executionfailed: return "ExecutionFailed"
        case .executionstarted: return "ExecutionStarted"
        case .executionsucceeded: return "ExecutionSucceeded"
        case .executiontimedout: return "ExecutionTimedOut"
        case .failstateentered: return "FailStateEntered"
        case .lambdafunctionfailed: return "LambdaFunctionFailed"
        case .lambdafunctionschedulefailed: return "LambdaFunctionScheduleFailed"
        case .lambdafunctionscheduled: return "LambdaFunctionScheduled"
        case .lambdafunctionstartfailed: return "LambdaFunctionStartFailed"
        case .lambdafunctionstarted: return "LambdaFunctionStarted"
        case .lambdafunctionsucceeded: return "LambdaFunctionSucceeded"
        case .lambdafunctiontimedout: return "LambdaFunctionTimedOut"
        case .mapiterationaborted: return "MapIterationAborted"
        case .mapiterationfailed: return "MapIterationFailed"
        case .mapiterationstarted: return "MapIterationStarted"
        case .mapiterationsucceeded: return "MapIterationSucceeded"
        case .mapstateaborted: return "MapStateAborted"
        case .mapstateentered: return "MapStateEntered"
        case .mapstateexited: return "MapStateExited"
        case .mapstatefailed: return "MapStateFailed"
        case .mapstatestarted: return "MapStateStarted"
        case .mapstatesucceeded: return "MapStateSucceeded"
        case .parallelstateaborted: return "ParallelStateAborted"
        case .parallelstateentered: return "ParallelStateEntered"
        case .parallelstateexited: return "ParallelStateExited"
        case .parallelstatefailed: return "ParallelStateFailed"
        case .parallelstatestarted: return "ParallelStateStarted"
        case .parallelstatesucceeded: return "ParallelStateSucceeded"
        case .passstateentered: return "PassStateEntered"
        case .passstateexited: return "PassStateExited"
        case .succeedstateentered: return "SucceedStateEntered"
        case .succeedstateexited: return "SucceedStateExited"
        case .taskfailed: return "TaskFailed"
        case .taskscheduled: return "TaskScheduled"
        case .taskstartfailed: return "TaskStartFailed"
        case .taskstarted: return "TaskStarted"
        case .taskstateaborted: return "TaskStateAborted"
        case .taskstateentered: return "TaskStateEntered"
        case .taskstateexited: return "TaskStateExited"
        case .tasksubmitfailed: return "TaskSubmitFailed"
        case .tasksubmitted: return "TaskSubmitted"
        case .tasksucceeded: return "TaskSucceeded"
        case .tasktimedout: return "TaskTimedOut"
        case .waitstateaborted: return "WaitStateAborted"
        case .waitstateentered: return "WaitStateEntered"
        case .waitstateexited: return "WaitStateExited"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HistoryEventType(rawValue: rawValue) ?? HistoryEventType.sdkUnknown(rawValue)
    }
}

extension InvalidArn: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidArn(message: \(String(describing: message)))"}
}

extension InvalidArn: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidArnBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The provided Amazon Resource Name (ARN) is invalid.</p>
public struct InvalidArn: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArnBody: Equatable {
    public let message: String?
}

extension InvalidArnBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDefinition(message: \(String(describing: message)))"}
}

extension InvalidDefinition: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidDefinitionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The provided Amazon States Language definition is invalid.</p>
public struct InvalidDefinition: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDefinitionBody: Equatable {
    public let message: String?
}

extension InvalidDefinitionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidExecutionInput(message: \(String(describing: message)))"}
}

extension InvalidExecutionInput: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidExecutionInputBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The provided JSON input data is invalid.</p>
public struct InvalidExecutionInput: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidExecutionInputBody: Equatable {
    public let message: String?
}

extension InvalidExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLoggingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidLoggingConfiguration(message: \(String(describing: message)))"}
}

extension InvalidLoggingConfiguration: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidLoggingConfigurationBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct InvalidLoggingConfiguration: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLoggingConfigurationBody: Equatable {
    public let message: String?
}

extension InvalidLoggingConfigurationBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidName: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidName(message: \(String(describing: message)))"}
}

extension InvalidName: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNameBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The provided name is invalid.</p>
public struct InvalidName: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNameBody: Equatable {
    public let message: String?
}

extension InvalidNameBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidOutput(message: \(String(describing: message)))"}
}

extension InvalidOutput: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidOutputBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The provided JSON output data is invalid.</p>
public struct InvalidOutput: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOutputBody: Equatable {
    public let message: String?
}

extension InvalidOutputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidToken: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidToken(message: \(String(describing: message)))"}
}

extension InvalidToken: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTokenBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The provided token is invalid.</p>
public struct InvalidToken: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTokenBody: Equatable {
    public let message: String?
}

extension InvalidTokenBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTracingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTracingConfiguration(message: \(String(describing: message)))"}
}

extension InvalidTracingConfiguration: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTracingConfigurationBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your <code>tracingConfiguration</code> key does not match, or <code>enabled</code> has not been set to <code>true</code> or <code>false</code>.</p>
public struct InvalidTracingConfiguration: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTracingConfigurationBody: Equatable {
    public let message: String?
}

extension InvalidTracingConfigurationBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaFunctionFailedEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cause
        case error
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension LambdaFunctionFailedEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaFunctionFailedEventDetails(cause: \(String(describing: cause)), error: \(String(describing: error)))"}
}

/// <p>Contains details about a lambda function that failed during an execution.</p>
public struct LambdaFunctionFailedEventDetails: Equatable {
    /// <p>A more detailed explanation of the cause of the failure.</p>
    public let cause: String?
    /// <p>The error code of the failure.</p>
    public let error: String?

    public init (
        cause: String? = nil,
        error: String? = nil
    )
    {
        self.cause = cause
        self.error = error
    }
}

extension LambdaFunctionScheduleFailedEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cause
        case error
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension LambdaFunctionScheduleFailedEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaFunctionScheduleFailedEventDetails(cause: \(String(describing: cause)), error: \(String(describing: error)))"}
}

/// <p>Contains details about a failed lambda function schedule event that occurred during an
///       execution.</p>
public struct LambdaFunctionScheduleFailedEventDetails: Equatable {
    /// <p>A more detailed explanation of the cause of the failure.</p>
    public let cause: String?
    /// <p>The error code of the failure.</p>
    public let error: String?

    public init (
        cause: String? = nil,
        error: String? = nil
    )
    {
        self.cause = cause
        self.error = error
    }
}

extension LambdaFunctionScheduledEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case input
        case inputDetails
        case resource
        case timeoutInSeconds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let inputDetails = inputDetails {
            try encodeContainer.encode(inputDetails, forKey: .inputDetails)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if timeoutInSeconds != 0 {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
        let inputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .input)
        input = inputDecoded
        let inputDetailsDecoded = try containerValues.decodeIfPresent(HistoryEventExecutionDataDetails.self, forKey: .inputDetails)
        inputDetails = inputDetailsDecoded
        let timeoutInSecondsDecoded = try containerValues.decode(Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
    }
}

extension LambdaFunctionScheduledEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaFunctionScheduledEventDetails(input: \(String(describing: input)), inputDetails: \(String(describing: inputDetails)), resource: \(String(describing: resource)), timeoutInSeconds: \(String(describing: timeoutInSeconds)))"}
}

/// <p>Contains details about a lambda function scheduled during an execution.</p>
public struct LambdaFunctionScheduledEventDetails: Equatable {
    /// <p>The JSON data input to the lambda function. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.</p>
    public let input: String?
    /// <p>Contains details about input for an execution history event.</p>
    public let inputDetails: HistoryEventExecutionDataDetails?
    /// <p>The Amazon Resource Name (ARN) of the scheduled lambda function.</p>
    public let resource: String?
    /// <p>The maximum allowed duration of the lambda function.</p>
    public let timeoutInSeconds: Int

    public init (
        input: String? = nil,
        inputDetails: HistoryEventExecutionDataDetails? = nil,
        resource: String? = nil,
        timeoutInSeconds: Int = 0
    )
    {
        self.input = input
        self.inputDetails = inputDetails
        self.resource = resource
        self.timeoutInSeconds = timeoutInSeconds
    }
}

extension LambdaFunctionStartFailedEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cause
        case error
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension LambdaFunctionStartFailedEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaFunctionStartFailedEventDetails(cause: \(String(describing: cause)), error: \(String(describing: error)))"}
}

/// <p>Contains details about a lambda function that failed to start during an execution.</p>
public struct LambdaFunctionStartFailedEventDetails: Equatable {
    /// <p>A more detailed explanation of the cause of the failure.</p>
    public let cause: String?
    /// <p>The error code of the failure.</p>
    public let error: String?

    public init (
        cause: String? = nil,
        error: String? = nil
    )
    {
        self.cause = cause
        self.error = error
    }
}

extension LambdaFunctionSucceededEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case output
        case outputDetails
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let outputDetails = outputDetails {
            try encodeContainer.encode(outputDetails, forKey: .outputDetails)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .output)
        output = outputDecoded
        let outputDetailsDecoded = try containerValues.decodeIfPresent(HistoryEventExecutionDataDetails.self, forKey: .outputDetails)
        outputDetails = outputDetailsDecoded
    }
}

extension LambdaFunctionSucceededEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaFunctionSucceededEventDetails(output: \(String(describing: output)), outputDetails: \(String(describing: outputDetails)))"}
}

/// <p>Contains details about a lambda function that successfully terminated during an
///       execution.</p>
public struct LambdaFunctionSucceededEventDetails: Equatable {
    /// <p>The JSON data output by the lambda function. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.</p>
    public let output: String?
    /// <p>Contains details about the output of an execution history event.</p>
    public let outputDetails: HistoryEventExecutionDataDetails?

    public init (
        output: String? = nil,
        outputDetails: HistoryEventExecutionDataDetails? = nil
    )
    {
        self.output = output
        self.outputDetails = outputDetails
    }
}

extension LambdaFunctionTimedOutEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cause
        case error
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension LambdaFunctionTimedOutEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaFunctionTimedOutEventDetails(cause: \(String(describing: cause)), error: \(String(describing: error)))"}
}

/// <p>Contains details about a lambda function timeout that occurred during an execution.</p>
public struct LambdaFunctionTimedOutEventDetails: Equatable {
    /// <p>A more detailed explanation of the cause of the timeout.</p>
    public let cause: String?
    /// <p>The error code of the failure.</p>
    public let error: String?

    public init (
        cause: String? = nil,
        error: String? = nil
    )
    {
        self.cause = cause
        self.error = error
    }
}

public struct ListActivitiesInputBodyMiddleware: Middleware {
    public let id: String = "ListActivitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListActivitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListActivitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListActivitiesInput>
    public typealias MOutput = OperationOutput<ListActivitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListActivitiesOutputError>
}

extension ListActivitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListActivitiesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListActivitiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListActivitiesInputHeadersMiddleware: Middleware {
    public let id: String = "ListActivitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListActivitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListActivitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListActivitiesInput>
    public typealias MOutput = OperationOutput<ListActivitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListActivitiesOutputError>
}

public struct ListActivitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListActivitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListActivitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListActivitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListActivitiesInput>
    public typealias MOutput = OperationOutput<ListActivitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListActivitiesOutputError>
}

public struct ListActivitiesInput: Equatable {
    /// <p>The maximum number of results that are returned per call. You can use <code>nextToken</code> to obtain further pages of results.
    ///     The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default.</p>
    ///          <p>This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.</p>
    public let maxResults: Int
    /// <p>If <code>nextToken</code> is returned, there are more results available. The value of <code>nextToken</code> is a unique pagination token for each page.
    ///     Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an <i>HTTP 400 InvalidToken</i> error.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListActivitiesInputBody: Equatable {
    public let maxResults: Int
    public let nextToken: String?
}

extension ListActivitiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListActivitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListActivitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidToken" : self = .invalidToken(try InvalidToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListActivitiesOutputError: Equatable {
    case invalidToken(InvalidToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListActivitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListActivitiesOutputResponse(activities: \(String(describing: activities)), nextToken: \(String(describing: nextToken)))"}
}

extension ListActivitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListActivitiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.activities = output.activities
            self.nextToken = output.nextToken
        } else {
            self.activities = nil
            self.nextToken = nil
        }
    }
}

public struct ListActivitiesOutputResponse: Equatable {
    /// <p>The list of activities.</p>
    public let activities: [ActivityListItem]?
    /// <p>If <code>nextToken</code> is returned, there are more results available. The value of <code>nextToken</code> is a unique pagination token for each page.
    ///     Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an <i>HTTP 400 InvalidToken</i> error.</p>
    public let nextToken: String?

    public init (
        activities: [ActivityListItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.activities = activities
        self.nextToken = nextToken
    }
}

struct ListActivitiesOutputResponseBody: Equatable {
    public let activities: [ActivityListItem]?
    public let nextToken: String?
}

extension ListActivitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activities
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activitiesContainer = try containerValues.decodeIfPresent([ActivityListItem?].self, forKey: .activities)
        var activitiesDecoded0:[ActivityListItem]? = nil
        if let activitiesContainer = activitiesContainer {
            activitiesDecoded0 = [ActivityListItem]()
            for structure0 in activitiesContainer {
                if let structure0 = structure0 {
                    activitiesDecoded0?.append(structure0)
                }
            }
        }
        activities = activitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListExecutionsInputBodyMiddleware: Middleware {
    public let id: String = "ListExecutionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListExecutionsInput>
    public typealias MOutput = OperationOutput<ListExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListExecutionsOutputError>
}

extension ListExecutionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListExecutionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), stateMachineArn: \(String(describing: stateMachineArn)), statusFilter: \(String(describing: statusFilter)))"}
}

extension ListExecutionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case stateMachineArn
        case statusFilter
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stateMachineArn = stateMachineArn {
            try encodeContainer.encode(stateMachineArn, forKey: .stateMachineArn)
        }
        if let statusFilter = statusFilter {
            try encodeContainer.encode(statusFilter.rawValue, forKey: .statusFilter)
        }
    }
}

public struct ListExecutionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListExecutionsInput>
    public typealias MOutput = OperationOutput<ListExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListExecutionsOutputError>
}

public struct ListExecutionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListExecutionsInput>
    public typealias MOutput = OperationOutput<ListExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListExecutionsOutputError>
}

public struct ListExecutionsInput: Equatable {
    /// <p>The maximum number of results that are returned per call. You can use <code>nextToken</code> to obtain further pages of results.
    ///     The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default.</p>
    ///          <p>This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.</p>
    public let maxResults: Int
    /// <p>If <code>nextToken</code> is returned, there are more results available. The value of <code>nextToken</code> is a unique pagination token for each page.
    ///     Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an <i>HTTP 400 InvalidToken</i> error.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the state machine whose executions is listed.</p>
    public let stateMachineArn: String?
    /// <p>If specified, only list the executions whose current execution status matches the given
    ///       filter.</p>
    public let statusFilter: ExecutionStatus?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        stateMachineArn: String? = nil,
        statusFilter: ExecutionStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stateMachineArn = stateMachineArn
        self.statusFilter = statusFilter
    }
}

struct ListExecutionsInputBody: Equatable {
    public let stateMachineArn: String?
    public let statusFilter: ExecutionStatus?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListExecutionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case stateMachineArn
        case statusFilter
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let statusFilterDecoded = try containerValues.decodeIfPresent(ExecutionStatus.self, forKey: .statusFilter)
        statusFilter = statusFilterDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExecutionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExecutionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidToken" : self = .invalidToken(try InvalidToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineDoesNotExist" : self = .stateMachineDoesNotExist(try StateMachineDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineTypeNotSupported" : self = .stateMachineTypeNotSupported(try StateMachineTypeNotSupported(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListExecutionsOutputError: Equatable {
    case invalidArn(InvalidArn)
    case invalidToken(InvalidToken)
    case stateMachineDoesNotExist(StateMachineDoesNotExist)
    case stateMachineTypeNotSupported(StateMachineTypeNotSupported)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExecutionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListExecutionsOutputResponse(executions: \(String(describing: executions)), nextToken: \(String(describing: nextToken)))"}
}

extension ListExecutionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.executions = output.executions
            self.nextToken = output.nextToken
        } else {
            self.executions = nil
            self.nextToken = nil
        }
    }
}

public struct ListExecutionsOutputResponse: Equatable {
    /// <p>The list of matching executions.</p>
    public let executions: [ExecutionListItem]?
    /// <p>If <code>nextToken</code> is returned, there are more results available. The value of <code>nextToken</code> is a unique pagination token for each page.
    ///     Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an <i>HTTP 400 InvalidToken</i> error.</p>
    public let nextToken: String?

    public init (
        executions: [ExecutionListItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.executions = executions
        self.nextToken = nextToken
    }
}

struct ListExecutionsOutputResponseBody: Equatable {
    public let executions: [ExecutionListItem]?
    public let nextToken: String?
}

extension ListExecutionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case executions
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionsContainer = try containerValues.decodeIfPresent([ExecutionListItem?].self, forKey: .executions)
        var executionsDecoded0:[ExecutionListItem]? = nil
        if let executionsContainer = executionsContainer {
            executionsDecoded0 = [ExecutionListItem]()
            for structure0 in executionsContainer {
                if let structure0 = structure0 {
                    executionsDecoded0?.append(structure0)
                }
            }
        }
        executions = executionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListStateMachinesInputBodyMiddleware: Middleware {
    public let id: String = "ListStateMachinesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStateMachinesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStateMachinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStateMachinesInput>
    public typealias MOutput = OperationOutput<ListStateMachinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStateMachinesOutputError>
}

extension ListStateMachinesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStateMachinesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListStateMachinesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListStateMachinesInputHeadersMiddleware: Middleware {
    public let id: String = "ListStateMachinesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStateMachinesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStateMachinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStateMachinesInput>
    public typealias MOutput = OperationOutput<ListStateMachinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStateMachinesOutputError>
}

public struct ListStateMachinesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStateMachinesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStateMachinesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStateMachinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStateMachinesInput>
    public typealias MOutput = OperationOutput<ListStateMachinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStateMachinesOutputError>
}

public struct ListStateMachinesInput: Equatable {
    /// <p>The maximum number of results that are returned per call. You can use <code>nextToken</code> to obtain further pages of results.
    ///     The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default.</p>
    ///          <p>This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.</p>
    public let maxResults: Int
    /// <p>If <code>nextToken</code> is returned, there are more results available. The value of <code>nextToken</code> is a unique pagination token for each page.
    ///     Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an <i>HTTP 400 InvalidToken</i> error.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStateMachinesInputBody: Equatable {
    public let maxResults: Int
    public let nextToken: String?
}

extension ListStateMachinesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListStateMachinesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStateMachinesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidToken" : self = .invalidToken(try InvalidToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStateMachinesOutputError: Equatable {
    case invalidToken(InvalidToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStateMachinesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStateMachinesOutputResponse(nextToken: \(String(describing: nextToken)), stateMachines: \(String(describing: stateMachines)))"}
}

extension ListStateMachinesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListStateMachinesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.stateMachines = output.stateMachines
        } else {
            self.nextToken = nil
            self.stateMachines = nil
        }
    }
}

public struct ListStateMachinesOutputResponse: Equatable {
    /// <p>If <code>nextToken</code> is returned, there are more results available. The value of <code>nextToken</code> is a unique pagination token for each page.
    ///     Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an <i>HTTP 400 InvalidToken</i> error.</p>
    public let nextToken: String?
    public let stateMachines: [StateMachineListItem]?

    public init (
        nextToken: String? = nil,
        stateMachines: [StateMachineListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.stateMachines = stateMachines
    }
}

struct ListStateMachinesOutputResponseBody: Equatable {
    public let stateMachines: [StateMachineListItem]?
    public let nextToken: String?
}

extension ListStateMachinesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case stateMachines
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachinesContainer = try containerValues.decodeIfPresent([StateMachineListItem?].self, forKey: .stateMachines)
        var stateMachinesDecoded0:[StateMachineListItem]? = nil
        if let stateMachinesContainer = stateMachinesContainer {
            stateMachinesDecoded0 = [StateMachineListItem]()
            for structure0 in stateMachinesContainer {
                if let structure0 = structure0 {
                    stateMachinesDecoded0?.append(structure0)
                }
            }
        }
        stateMachines = stateMachinesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the Step Functions state machine or activity.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFound(try ResourceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case invalidArn(InvalidArn)
    case resourceNotFound(ResourceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>An array of tags associated with the resource.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LogDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogsLogGroup
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroup = cloudWatchLogsLogGroup {
            try encodeContainer.encode(cloudWatchLogsLogGroup, forKey: .cloudWatchLogsLogGroup)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsLogGroupDecoded = try containerValues.decodeIfPresent(CloudWatchLogsLogGroup.self, forKey: .cloudWatchLogsLogGroup)
        cloudWatchLogsLogGroup = cloudWatchLogsLogGroupDecoded
    }
}

extension LogDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LogDestination(cloudWatchLogsLogGroup: \(String(describing: cloudWatchLogsLogGroup)))"}
}

/// <p></p>
public struct LogDestination: Equatable {
    /// <p>An object describing a CloudWatch log group. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-loggroup.html">AWS::Logs::LogGroup</a> in the AWS CloudFormation User Guide.</p>
    public let cloudWatchLogsLogGroup: CloudWatchLogsLogGroup?

    public init (
        cloudWatchLogsLogGroup: CloudWatchLogsLogGroup? = nil
    )
    {
        self.cloudWatchLogsLogGroup = cloudWatchLogsLogGroup
    }
}

public enum LogLevel {
    case all
    case error
    case fatal
    case off
    case sdkUnknown(String)
}

extension LogLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LogLevel] {
        return [
            .all,
            .error,
            .fatal,
            .off,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .error: return "ERROR"
        case .fatal: return "FATAL"
        case .off: return "OFF"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LogLevel(rawValue: rawValue) ?? LogLevel.sdkUnknown(rawValue)
    }
}

extension LoggingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinations
        case includeExecutionData
        case level
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for logdestinationlist0 in destinations {
                try destinationsContainer.encode(logdestinationlist0)
            }
        }
        if includeExecutionData != false {
            try encodeContainer.encode(includeExecutionData, forKey: .includeExecutionData)
        }
        if let level = level {
            try encodeContainer.encode(level.rawValue, forKey: .level)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let levelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .level)
        level = levelDecoded
        let includeExecutionDataDecoded = try containerValues.decode(Bool.self, forKey: .includeExecutionData)
        includeExecutionData = includeExecutionDataDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([LogDestination?].self, forKey: .destinations)
        var destinationsDecoded0:[LogDestination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [LogDestination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
    }
}

extension LoggingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoggingConfiguration(destinations: \(String(describing: destinations)), includeExecutionData: \(String(describing: includeExecutionData)), level: \(String(describing: level)))"}
}

/// <p>The <code>LoggingConfiguration</code> data type is used to set CloudWatch Logs
///       options.</p>
public struct LoggingConfiguration: Equatable {
    /// <p>An array of objects that describes where your execution history events will be logged.
    ///       Limited to size 1. Required, if your log level is not set to <code>OFF</code>.</p>
    public let destinations: [LogDestination]?
    /// <p>Determines whether execution data is included in your log. When set to <code>false</code>,
    ///       data is excluded.</p>
    public let includeExecutionData: Bool
    /// <p>Defines which category of execution history events are logged.</p>
    public let level: LogLevel?

    public init (
        destinations: [LogDestination]? = nil,
        includeExecutionData: Bool = false,
        level: LogLevel? = nil
    )
    {
        self.destinations = destinations
        self.includeExecutionData = includeExecutionData
        self.level = level
    }
}

extension MapIterationEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case index
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if index != 0 {
            try encodeContainer.encode(index, forKey: .index)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let indexDecoded = try containerValues.decode(Int.self, forKey: .index)
        index = indexDecoded
    }
}

extension MapIterationEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MapIterationEventDetails(index: \(String(describing: index)), name: \(String(describing: name)))"}
}

/// <p>Contains details about an iteration of a Map state.</p>
public struct MapIterationEventDetails: Equatable {
    /// <p>The index of the array belonging to the Map state iteration.</p>
    public let index: Int
    /// <p>The name of the iteration’s parent Map state.</p>
    public let name: String?

    public init (
        index: Int = 0,
        name: String? = nil
    )
    {
        self.index = index
        self.name = name
    }
}

extension MapStateStartedEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case length
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if length != 0 {
            try encodeContainer.encode(length, forKey: .length)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lengthDecoded = try containerValues.decode(Int.self, forKey: .length)
        length = lengthDecoded
    }
}

extension MapStateStartedEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MapStateStartedEventDetails(length: \(String(describing: length)))"}
}

/// <p>Details about a Map state that was started.</p>
public struct MapStateStartedEventDetails: Equatable {
    /// <p>The size of the array for Map state iterations.</p>
    public let length: Int

    public init (
        length: Int = 0
    )
    {
        self.length = length
    }
}

extension MissingRequiredParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MissingRequiredParameter(message: \(String(describing: message)))"}
}

extension MissingRequiredParameter: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MissingRequiredParameterBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request is missing a required parameter. This error occurs if both <code>definition</code>
///       and <code>roleArn</code> are not specified.</p>
public struct MissingRequiredParameter: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MissingRequiredParameterBody: Equatable {
    public let message: String?
}

extension MissingRequiredParameterBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFound(message: \(String(describing: message)), resourceName: \(String(describing: resourceName)))"}
}

extension ResourceNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Could not find the referenced resource. Only state machine and activity ARNs are
///       supported.</p>
public struct ResourceNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var resourceName: String?

    public init (
        message: String? = nil,
        resourceName: String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct ResourceNotFoundBody: Equatable {
    public let message: String?
    public let resourceName: String?
}

extension ResourceNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

public struct SendTaskFailureInputBodyMiddleware: Middleware {
    public let id: String = "SendTaskFailureInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendTaskFailureInput>,
                  next: H) -> Swift.Result<OperationOutput<SendTaskFailureOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendTaskFailureInput>
    public typealias MOutput = OperationOutput<SendTaskFailureOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendTaskFailureOutputError>
}

extension SendTaskFailureInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendTaskFailureInput(cause: \(String(describing: cause)), error: \(String(describing: error)), taskToken: \(String(describing: taskToken)))"}
}

extension SendTaskFailureInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cause
        case error
        case taskToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let taskToken = taskToken {
            try encodeContainer.encode(taskToken, forKey: .taskToken)
        }
    }
}

public struct SendTaskFailureInputHeadersMiddleware: Middleware {
    public let id: String = "SendTaskFailureInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendTaskFailureInput>,
                  next: H) -> Swift.Result<OperationOutput<SendTaskFailureOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendTaskFailureInput>
    public typealias MOutput = OperationOutput<SendTaskFailureOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendTaskFailureOutputError>
}

public struct SendTaskFailureInputQueryItemMiddleware: Middleware {
    public let id: String = "SendTaskFailureInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendTaskFailureInput>,
                  next: H) -> Swift.Result<OperationOutput<SendTaskFailureOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendTaskFailureInput>
    public typealias MOutput = OperationOutput<SendTaskFailureOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendTaskFailureOutputError>
}

public struct SendTaskFailureInput: Equatable {
    /// <p>A more detailed explanation of the cause of the failure.</p>
    public let cause: String?
    /// <p>The error code of the failure.</p>
    public let error: String?
    /// <p>The token that represents this task. Task tokens are generated by Step Functions when
    ///       tasks are assigned to a worker, or in the <a href="https://docs.aws.amazon.com/step-functions/latest/dg/input-output-contextobject.html">context object</a> when a
    ///       workflow enters a task state. See <a>GetActivityTaskOutput$taskToken</a>.</p>
    public let taskToken: String?

    public init (
        cause: String? = nil,
        error: String? = nil,
        taskToken: String? = nil
    )
    {
        self.cause = cause
        self.error = error
        self.taskToken = taskToken
    }
}

struct SendTaskFailureInputBody: Equatable {
    public let taskToken: String?
    public let error: String?
    public let cause: String?
}

extension SendTaskFailureInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cause
        case error
        case taskToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskToken)
        taskToken = taskTokenDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension SendTaskFailureOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendTaskFailureOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidToken" : self = .invalidToken(try InvalidToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TaskDoesNotExist" : self = .taskDoesNotExist(try TaskDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TaskTimedOut" : self = .taskTimedOut(try TaskTimedOut(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendTaskFailureOutputError: Equatable {
    case invalidToken(InvalidToken)
    case taskDoesNotExist(TaskDoesNotExist)
    case taskTimedOut(TaskTimedOut)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendTaskFailureOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendTaskFailureOutputResponse()"}
}

extension SendTaskFailureOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SendTaskFailureOutputResponse: Equatable {

    public init() {}
}

struct SendTaskFailureOutputResponseBody: Equatable {
}

extension SendTaskFailureOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SendTaskHeartbeatInputBodyMiddleware: Middleware {
    public let id: String = "SendTaskHeartbeatInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendTaskHeartbeatInput>,
                  next: H) -> Swift.Result<OperationOutput<SendTaskHeartbeatOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendTaskHeartbeatInput>
    public typealias MOutput = OperationOutput<SendTaskHeartbeatOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendTaskHeartbeatOutputError>
}

extension SendTaskHeartbeatInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendTaskHeartbeatInput(taskToken: \(String(describing: taskToken)))"}
}

extension SendTaskHeartbeatInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case taskToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let taskToken = taskToken {
            try encodeContainer.encode(taskToken, forKey: .taskToken)
        }
    }
}

public struct SendTaskHeartbeatInputHeadersMiddleware: Middleware {
    public let id: String = "SendTaskHeartbeatInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendTaskHeartbeatInput>,
                  next: H) -> Swift.Result<OperationOutput<SendTaskHeartbeatOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendTaskHeartbeatInput>
    public typealias MOutput = OperationOutput<SendTaskHeartbeatOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendTaskHeartbeatOutputError>
}

public struct SendTaskHeartbeatInputQueryItemMiddleware: Middleware {
    public let id: String = "SendTaskHeartbeatInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendTaskHeartbeatInput>,
                  next: H) -> Swift.Result<OperationOutput<SendTaskHeartbeatOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendTaskHeartbeatInput>
    public typealias MOutput = OperationOutput<SendTaskHeartbeatOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendTaskHeartbeatOutputError>
}

public struct SendTaskHeartbeatInput: Equatable {
    /// <p>The token that represents this task. Task tokens are generated by Step Functions when
    ///       tasks are assigned to a worker, or in the <a href="https://docs.aws.amazon.com/step-functions/latest/dg/input-output-contextobject.html">context object</a> when a
    ///       workflow enters a task state. See <a>GetActivityTaskOutput$taskToken</a>.</p>
    public let taskToken: String?

    public init (
        taskToken: String? = nil
    )
    {
        self.taskToken = taskToken
    }
}

struct SendTaskHeartbeatInputBody: Equatable {
    public let taskToken: String?
}

extension SendTaskHeartbeatInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskToken)
        taskToken = taskTokenDecoded
    }
}

extension SendTaskHeartbeatOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendTaskHeartbeatOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidToken" : self = .invalidToken(try InvalidToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TaskDoesNotExist" : self = .taskDoesNotExist(try TaskDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TaskTimedOut" : self = .taskTimedOut(try TaskTimedOut(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendTaskHeartbeatOutputError: Equatable {
    case invalidToken(InvalidToken)
    case taskDoesNotExist(TaskDoesNotExist)
    case taskTimedOut(TaskTimedOut)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendTaskHeartbeatOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendTaskHeartbeatOutputResponse()"}
}

extension SendTaskHeartbeatOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SendTaskHeartbeatOutputResponse: Equatable {

    public init() {}
}

struct SendTaskHeartbeatOutputResponseBody: Equatable {
}

extension SendTaskHeartbeatOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SendTaskSuccessInputBodyMiddleware: Middleware {
    public let id: String = "SendTaskSuccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendTaskSuccessInput>,
                  next: H) -> Swift.Result<OperationOutput<SendTaskSuccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendTaskSuccessInput>
    public typealias MOutput = OperationOutput<SendTaskSuccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendTaskSuccessOutputError>
}

extension SendTaskSuccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendTaskSuccessInput(output: \(String(describing: output)), taskToken: \(String(describing: taskToken)))"}
}

extension SendTaskSuccessInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case output
        case taskToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let taskToken = taskToken {
            try encodeContainer.encode(taskToken, forKey: .taskToken)
        }
    }
}

public struct SendTaskSuccessInputHeadersMiddleware: Middleware {
    public let id: String = "SendTaskSuccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendTaskSuccessInput>,
                  next: H) -> Swift.Result<OperationOutput<SendTaskSuccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendTaskSuccessInput>
    public typealias MOutput = OperationOutput<SendTaskSuccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendTaskSuccessOutputError>
}

public struct SendTaskSuccessInputQueryItemMiddleware: Middleware {
    public let id: String = "SendTaskSuccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendTaskSuccessInput>,
                  next: H) -> Swift.Result<OperationOutput<SendTaskSuccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendTaskSuccessInput>
    public typealias MOutput = OperationOutput<SendTaskSuccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendTaskSuccessOutputError>
}

public struct SendTaskSuccessInput: Equatable {
    /// <p>The JSON output of the task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.</p>
    public let output: String?
    /// <p>The token that represents this task. Task tokens are generated by Step Functions when
    ///       tasks are assigned to a worker, or in the <a href="https://docs.aws.amazon.com/step-functions/latest/dg/input-output-contextobject.html">context object</a> when a
    ///       workflow enters a task state. See <a>GetActivityTaskOutput$taskToken</a>.</p>
    public let taskToken: String?

    public init (
        output: String? = nil,
        taskToken: String? = nil
    )
    {
        self.output = output
        self.taskToken = taskToken
    }
}

struct SendTaskSuccessInputBody: Equatable {
    public let taskToken: String?
    public let output: String?
}

extension SendTaskSuccessInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case output
        case taskToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskToken)
        taskToken = taskTokenDecoded
        let outputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .output)
        output = outputDecoded
    }
}

extension SendTaskSuccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendTaskSuccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidOutput" : self = .invalidOutput(try InvalidOutput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidToken" : self = .invalidToken(try InvalidToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TaskDoesNotExist" : self = .taskDoesNotExist(try TaskDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TaskTimedOut" : self = .taskTimedOut(try TaskTimedOut(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendTaskSuccessOutputError: Equatable {
    case invalidOutput(InvalidOutput)
    case invalidToken(InvalidToken)
    case taskDoesNotExist(TaskDoesNotExist)
    case taskTimedOut(TaskTimedOut)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendTaskSuccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendTaskSuccessOutputResponse()"}
}

extension SendTaskSuccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SendTaskSuccessOutputResponse: Equatable {

    public init() {}
}

struct SendTaskSuccessOutputResponseBody: Equatable {
}

extension SendTaskSuccessOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StartExecutionInputBodyMiddleware: Middleware {
    public let id: String = "StartExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartExecutionInput>
    public typealias MOutput = OperationOutput<StartExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartExecutionOutputError>
}

extension StartExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartExecutionInput(input: \(String(describing: input)), name: \(String(describing: name)), stateMachineArn: \(String(describing: stateMachineArn)), traceHeader: \(String(describing: traceHeader)))"}
}

extension StartExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case input
        case name
        case stateMachineArn
        case traceHeader
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stateMachineArn = stateMachineArn {
            try encodeContainer.encode(stateMachineArn, forKey: .stateMachineArn)
        }
        if let traceHeader = traceHeader {
            try encodeContainer.encode(traceHeader, forKey: .traceHeader)
        }
    }
}

public struct StartExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "StartExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartExecutionInput>
    public typealias MOutput = OperationOutput<StartExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartExecutionOutputError>
}

public struct StartExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "StartExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartExecutionInput>
    public typealias MOutput = OperationOutput<StartExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartExecutionOutputError>
}

public struct StartExecutionInput: Equatable {
    /// <p>The string that contains the JSON input data for the execution, for example:</p>
    ///          <p>
    ///             <code>"input": "{\"first_name\" : \"test\"}"</code>
    ///          </p>
    ///          <note>
    ///             <p>If you don't include any JSON input data, you still must include the two braces, for
    ///         example: <code>"input": "{}"</code>
    ///             </p>
    ///          </note>
    ///          <p>Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.</p>
    public let input: String?
    /// <p>The name of the execution. This name must be unique for your AWS account, region, and state machine for 90 days. For more information,
    ///     see <a href="https://docs.aws.amazon.com/step-functions/latest/dg/limits.html#service-limits-state-machine-executions">
    ///     Limits Related to State Machine Executions</a> in the <i>AWS Step Functions Developer Guide</i>.</p>
    ///          <p>A name must <i>not</i> contain:</p>
    ///          <ul>
    ///             <li>
    ///                <p>white space</p>
    ///             </li>
    ///             <li>
    ///                <p>brackets <code>< > { } [ ]</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>wildcard characters <code>? *</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>special characters <code>" # % \ ^ | ~ ` $ & , ; : /</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>control characters (<code>U+0000-001F</code>, <code>U+007F-009F</code>)</p>
    ///             </li>
    ///          </ul>
    ///          <p>To enable logging with CloudWatch Logs, the name should only contain  0-9, A-Z, a-z, - and _.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the state machine to execute.</p>
    public let stateMachineArn: String?
    /// <p>Passes the AWS X-Ray trace header. The trace header can also be passed in the request payload.</p>
    public let traceHeader: String?

    public init (
        input: String? = nil,
        name: String? = nil,
        stateMachineArn: String? = nil,
        traceHeader: String? = nil
    )
    {
        self.input = input
        self.name = name
        self.stateMachineArn = stateMachineArn
        self.traceHeader = traceHeader
    }
}

struct StartExecutionInputBody: Equatable {
    public let stateMachineArn: String?
    public let name: String?
    public let input: String?
    public let traceHeader: String?
}

extension StartExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case input
        case name
        case stateMachineArn
        case traceHeader
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let inputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .input)
        input = inputDecoded
        let traceHeaderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .traceHeader)
        traceHeader = traceHeaderDecoded
    }
}

extension StartExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExecutionAlreadyExists" : self = .executionAlreadyExists(try ExecutionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExecutionLimitExceeded" : self = .executionLimitExceeded(try ExecutionLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidExecutionInput" : self = .invalidExecutionInput(try InvalidExecutionInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidName" : self = .invalidName(try InvalidName(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineDeleting" : self = .stateMachineDeleting(try StateMachineDeleting(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineDoesNotExist" : self = .stateMachineDoesNotExist(try StateMachineDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartExecutionOutputError: Equatable {
    case executionAlreadyExists(ExecutionAlreadyExists)
    case executionLimitExceeded(ExecutionLimitExceeded)
    case invalidArn(InvalidArn)
    case invalidExecutionInput(InvalidExecutionInput)
    case invalidName(InvalidName)
    case stateMachineDeleting(StateMachineDeleting)
    case stateMachineDoesNotExist(StateMachineDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartExecutionOutputResponse(executionArn: \(String(describing: executionArn)), startDate: \(String(describing: startDate)))"}
}

extension StartExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartExecutionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.executionArn = output.executionArn
            self.startDate = output.startDate
        } else {
            self.executionArn = nil
            self.startDate = nil
        }
    }
}

public struct StartExecutionOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the execution.</p>
    public let executionArn: String?
    /// <p>The date the execution is started.</p>
    public let startDate: Date?

    public init (
        executionArn: String? = nil,
        startDate: Date? = nil
    )
    {
        self.executionArn = executionArn
        self.startDate = startDate
    }
}

struct StartExecutionOutputResponseBody: Equatable {
    public let executionArn: String?
    public let startDate: Date?
}

extension StartExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case executionArn
        case startDate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionArn)
        executionArn = executionArnDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startDate)
        startDate = startDateDecoded
    }
}

public struct StartSyncExecutionInputBodyMiddleware: Middleware {
    public let id: String = "StartSyncExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSyncExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSyncExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSyncExecutionInput>
    public typealias MOutput = OperationOutput<StartSyncExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSyncExecutionOutputError>
}

extension StartSyncExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSyncExecutionInput(input: \(String(describing: input)), name: \(String(describing: name)), stateMachineArn: \(String(describing: stateMachineArn)), traceHeader: \(String(describing: traceHeader)))"}
}

extension StartSyncExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case input
        case name
        case stateMachineArn
        case traceHeader
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stateMachineArn = stateMachineArn {
            try encodeContainer.encode(stateMachineArn, forKey: .stateMachineArn)
        }
        if let traceHeader = traceHeader {
            try encodeContainer.encode(traceHeader, forKey: .traceHeader)
        }
    }
}

public struct StartSyncExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "StartSyncExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSyncExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSyncExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSyncExecutionInput>
    public typealias MOutput = OperationOutput<StartSyncExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSyncExecutionOutputError>
}

public struct StartSyncExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "StartSyncExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSyncExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSyncExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSyncExecutionInput>
    public typealias MOutput = OperationOutput<StartSyncExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSyncExecutionOutputError>
}

public struct StartSyncExecutionInput: Equatable {
    /// <p>The string that contains the JSON input data for the execution, for example:</p>
    ///          <p>
    ///             <code>"input": "{\"first_name\" : \"test\"}"</code>
    ///          </p>
    ///          <note>
    ///             <p>If you don't include any JSON input data, you still must include the two braces, for
    ///          example: <code>"input": "{}"</code>
    ///             </p>
    ///          </note>
    ///          <p>Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.</p>
    public let input: String?
    /// <p>The name of the execution.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the state machine to execute.</p>
    public let stateMachineArn: String?
    /// <p>Passes the AWS X-Ray trace header. The trace header can also be passed in the request payload.</p>
    public let traceHeader: String?

    public init (
        input: String? = nil,
        name: String? = nil,
        stateMachineArn: String? = nil,
        traceHeader: String? = nil
    )
    {
        self.input = input
        self.name = name
        self.stateMachineArn = stateMachineArn
        self.traceHeader = traceHeader
    }
}

struct StartSyncExecutionInputBody: Equatable {
    public let stateMachineArn: String?
    public let name: String?
    public let input: String?
    public let traceHeader: String?
}

extension StartSyncExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case input
        case name
        case stateMachineArn
        case traceHeader
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let inputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .input)
        input = inputDecoded
        let traceHeaderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .traceHeader)
        traceHeader = traceHeaderDecoded
    }
}

extension StartSyncExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSyncExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidExecutionInput" : self = .invalidExecutionInput(try InvalidExecutionInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidName" : self = .invalidName(try InvalidName(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineDeleting" : self = .stateMachineDeleting(try StateMachineDeleting(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineDoesNotExist" : self = .stateMachineDoesNotExist(try StateMachineDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineTypeNotSupported" : self = .stateMachineTypeNotSupported(try StateMachineTypeNotSupported(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSyncExecutionOutputError: Equatable {
    case invalidArn(InvalidArn)
    case invalidExecutionInput(InvalidExecutionInput)
    case invalidName(InvalidName)
    case stateMachineDeleting(StateMachineDeleting)
    case stateMachineDoesNotExist(StateMachineDoesNotExist)
    case stateMachineTypeNotSupported(StateMachineTypeNotSupported)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSyncExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSyncExecutionOutputResponse(billingDetails: \(String(describing: billingDetails)), cause: \(String(describing: cause)), error: \(String(describing: error)), executionArn: \(String(describing: executionArn)), input: \(String(describing: input)), inputDetails: \(String(describing: inputDetails)), name: \(String(describing: name)), output: \(String(describing: output)), outputDetails: \(String(describing: outputDetails)), startDate: \(String(describing: startDate)), stateMachineArn: \(String(describing: stateMachineArn)), status: \(String(describing: status)), stopDate: \(String(describing: stopDate)), traceHeader: \(String(describing: traceHeader)))"}
}

extension StartSyncExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartSyncExecutionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.billingDetails = output.billingDetails
            self.cause = output.cause
            self.error = output.error
            self.executionArn = output.executionArn
            self.input = output.input
            self.inputDetails = output.inputDetails
            self.name = output.name
            self.output = output.output
            self.outputDetails = output.outputDetails
            self.startDate = output.startDate
            self.stateMachineArn = output.stateMachineArn
            self.status = output.status
            self.stopDate = output.stopDate
            self.traceHeader = output.traceHeader
        } else {
            self.billingDetails = nil
            self.cause = nil
            self.error = nil
            self.executionArn = nil
            self.input = nil
            self.inputDetails = nil
            self.name = nil
            self.output = nil
            self.outputDetails = nil
            self.startDate = nil
            self.stateMachineArn = nil
            self.status = nil
            self.stopDate = nil
            self.traceHeader = nil
        }
    }
}

public struct StartSyncExecutionOutputResponse: Equatable {
    /// <p>An object that describes workflow billing details, including billed duration
    ///       and memory use.</p>
    public let billingDetails: BillingDetails?
    /// <p>A more detailed explanation of the cause of the failure.</p>
    public let cause: String?
    /// <p>The error code of the failure.</p>
    public let error: String?
    /// <p>The Amazon Resource Name (ARN) that identifies the execution.</p>
    public let executionArn: String?
    /// <p>The string that contains the JSON input data of the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.</p>
    public let input: String?
    /// <p>Provides details about execution input or output.</p>
    public let inputDetails: CloudWatchEventsExecutionDataDetails?
    /// <p>The name of the execution.</p>
    public let name: String?
    /// <p>The JSON output data of the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.</p>
    ///          <note>
    ///             <p>This field is set only if the execution succeeds. If the execution fails, this field is
    ///          null.</p>
    ///          </note>
    public let output: String?
    /// <p>Provides details about execution input or output.</p>
    public let outputDetails: CloudWatchEventsExecutionDataDetails?
    /// <p>The date the execution is started.</p>
    public let startDate: Date?
    /// <p>The Amazon Resource Name (ARN) that identifies the state machine.</p>
    public let stateMachineArn: String?
    /// <p>The current status of the execution.</p>
    public let status: SyncExecutionStatus?
    /// <p>If the execution has already ended, the date the execution stopped.</p>
    public let stopDate: Date?
    /// <p>The AWS X-Ray trace header that was passed to the execution.</p>
    public let traceHeader: String?

    public init (
        billingDetails: BillingDetails? = nil,
        cause: String? = nil,
        error: String? = nil,
        executionArn: String? = nil,
        input: String? = nil,
        inputDetails: CloudWatchEventsExecutionDataDetails? = nil,
        name: String? = nil,
        output: String? = nil,
        outputDetails: CloudWatchEventsExecutionDataDetails? = nil,
        startDate: Date? = nil,
        stateMachineArn: String? = nil,
        status: SyncExecutionStatus? = nil,
        stopDate: Date? = nil,
        traceHeader: String? = nil
    )
    {
        self.billingDetails = billingDetails
        self.cause = cause
        self.error = error
        self.executionArn = executionArn
        self.input = input
        self.inputDetails = inputDetails
        self.name = name
        self.output = output
        self.outputDetails = outputDetails
        self.startDate = startDate
        self.stateMachineArn = stateMachineArn
        self.status = status
        self.stopDate = stopDate
        self.traceHeader = traceHeader
    }
}

struct StartSyncExecutionOutputResponseBody: Equatable {
    public let executionArn: String?
    public let stateMachineArn: String?
    public let name: String?
    public let startDate: Date?
    public let stopDate: Date?
    public let status: SyncExecutionStatus?
    public let error: String?
    public let cause: String?
    public let input: String?
    public let inputDetails: CloudWatchEventsExecutionDataDetails?
    public let output: String?
    public let outputDetails: CloudWatchEventsExecutionDataDetails?
    public let traceHeader: String?
    public let billingDetails: BillingDetails?
}

extension StartSyncExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case billingDetails
        case cause
        case error
        case executionArn
        case input
        case inputDetails
        case name
        case output
        case outputDetails
        case startDate
        case stateMachineArn
        case status
        case stopDate
        case traceHeader
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionArn)
        executionArn = executionArnDecoded
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startDate)
        startDate = startDateDecoded
        let stopDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stopDate)
        stopDate = stopDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SyncExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cause)
        cause = causeDecoded
        let inputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .input)
        input = inputDecoded
        let inputDetailsDecoded = try containerValues.decodeIfPresent(CloudWatchEventsExecutionDataDetails.self, forKey: .inputDetails)
        inputDetails = inputDetailsDecoded
        let outputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .output)
        output = outputDecoded
        let outputDetailsDecoded = try containerValues.decodeIfPresent(CloudWatchEventsExecutionDataDetails.self, forKey: .outputDetails)
        outputDetails = outputDetailsDecoded
        let traceHeaderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .traceHeader)
        traceHeader = traceHeaderDecoded
        let billingDetailsDecoded = try containerValues.decodeIfPresent(BillingDetails.self, forKey: .billingDetails)
        billingDetails = billingDetailsDecoded
    }
}

extension StateEnteredEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case input
        case inputDetails
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let inputDetails = inputDetails {
            try encodeContainer.encode(inputDetails, forKey: .inputDetails)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let inputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .input)
        input = inputDecoded
        let inputDetailsDecoded = try containerValues.decodeIfPresent(HistoryEventExecutionDataDetails.self, forKey: .inputDetails)
        inputDetails = inputDetailsDecoded
    }
}

extension StateEnteredEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StateEnteredEventDetails(input: \(String(describing: input)), inputDetails: \(String(describing: inputDetails)), name: \(String(describing: name)))"}
}

/// <p>Contains details about a state entered during an execution.</p>
public struct StateEnteredEventDetails: Equatable {
    /// <p>The string that contains the JSON input data for the state. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.</p>
    public let input: String?
    /// <p>Contains details about the input for an execution history event.</p>
    public let inputDetails: HistoryEventExecutionDataDetails?
    /// <p>The name of the state.</p>
    public let name: String?

    public init (
        input: String? = nil,
        inputDetails: HistoryEventExecutionDataDetails? = nil,
        name: String? = nil
    )
    {
        self.input = input
        self.inputDetails = inputDetails
        self.name = name
    }
}

extension StateExitedEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case output
        case outputDetails
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let outputDetails = outputDetails {
            try encodeContainer.encode(outputDetails, forKey: .outputDetails)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let outputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .output)
        output = outputDecoded
        let outputDetailsDecoded = try containerValues.decodeIfPresent(HistoryEventExecutionDataDetails.self, forKey: .outputDetails)
        outputDetails = outputDetailsDecoded
    }
}

extension StateExitedEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StateExitedEventDetails(name: \(String(describing: name)), output: \(String(describing: output)), outputDetails: \(String(describing: outputDetails)))"}
}

/// <p>Contains details about an exit from a state during an execution.</p>
public struct StateExitedEventDetails: Equatable {
    /// <p>The name of the state.</p>
    ///          <p>A name must <i>not</i> contain:</p>
    ///          <ul>
    ///             <li>
    ///                <p>white space</p>
    ///             </li>
    ///             <li>
    ///                <p>brackets <code>< > { } [ ]</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>wildcard characters <code>? *</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>special characters <code>" # % \ ^ | ~ ` $ & , ; : /</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>control characters (<code>U+0000-001F</code>, <code>U+007F-009F</code>)</p>
    ///             </li>
    ///          </ul>
    ///          <p>To enable logging with CloudWatch Logs, the name should only contain  0-9, A-Z, a-z, - and _.</p>
    public let name: String?
    /// <p>The JSON output data of the state. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.</p>
    public let output: String?
    /// <p>Contains details about the output of an execution history event.</p>
    public let outputDetails: HistoryEventExecutionDataDetails?

    public init (
        name: String? = nil,
        output: String? = nil,
        outputDetails: HistoryEventExecutionDataDetails? = nil
    )
    {
        self.name = name
        self.output = output
        self.outputDetails = outputDetails
    }
}

extension StateMachineAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StateMachineAlreadyExists(message: \(String(describing: message)))"}
}

extension StateMachineAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StateMachineAlreadyExistsBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A state machine with the same name but a different definition or role ARN already
///       exists.</p>
public struct StateMachineAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StateMachineAlreadyExistsBody: Equatable {
    public let message: String?
}

extension StateMachineAlreadyExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StateMachineDeleting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StateMachineDeleting(message: \(String(describing: message)))"}
}

extension StateMachineDeleting: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StateMachineDeletingBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified state machine is being deleted.</p>
public struct StateMachineDeleting: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StateMachineDeletingBody: Equatable {
    public let message: String?
}

extension StateMachineDeletingBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StateMachineDoesNotExist: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StateMachineDoesNotExist(message: \(String(describing: message)))"}
}

extension StateMachineDoesNotExist: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StateMachineDoesNotExistBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified state machine does not exist.</p>
public struct StateMachineDoesNotExist: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StateMachineDoesNotExistBody: Equatable {
    public let message: String?
}

extension StateMachineDoesNotExistBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StateMachineLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StateMachineLimitExceeded(message: \(String(describing: message)))"}
}

extension StateMachineLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StateMachineLimitExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of state machines has been reached. Existing state machines must be
///       deleted before a new state machine can be created.</p>
public struct StateMachineLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StateMachineLimitExceededBody: Equatable {
    public let message: String?
}

extension StateMachineLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StateMachineListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case name
        case stateMachineArn
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stateMachineArn = stateMachineArn {
            try encodeContainer.encode(stateMachineArn, forKey: .stateMachineArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(StateMachineType.self, forKey: .type)
        type = typeDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension StateMachineListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StateMachineListItem(creationDate: \(String(describing: creationDate)), name: \(String(describing: name)), stateMachineArn: \(String(describing: stateMachineArn)), type: \(String(describing: type)))"}
}

/// <p>Contains details about the state machine.</p>
public struct StateMachineListItem: Equatable {
    /// <p>The date the state machine is created.</p>
    public let creationDate: Date?
    /// <p>The name of the state machine.</p>
    ///          <p>A name must <i>not</i> contain:</p>
    ///          <ul>
    ///             <li>
    ///                <p>white space</p>
    ///             </li>
    ///             <li>
    ///                <p>brackets <code>< > { } [ ]</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>wildcard characters <code>? *</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>special characters <code>" # % \ ^ | ~ ` $ & , ; : /</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>control characters (<code>U+0000-001F</code>, <code>U+007F-009F</code>)</p>
    ///             </li>
    ///          </ul>
    ///          <p>To enable logging with CloudWatch Logs, the name should only contain  0-9, A-Z, a-z, - and _.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) that identifies the state machine.</p>
    public let stateMachineArn: String?
    /// <p></p>
    public let type: StateMachineType?

    public init (
        creationDate: Date? = nil,
        name: String? = nil,
        stateMachineArn: String? = nil,
        type: StateMachineType? = nil
    )
    {
        self.creationDate = creationDate
        self.name = name
        self.stateMachineArn = stateMachineArn
        self.type = type
    }
}

public enum StateMachineStatus {
    case active
    case deleting
    case sdkUnknown(String)
}

extension StateMachineStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StateMachineStatus] {
        return [
            .active,
            .deleting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleting: return "DELETING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StateMachineStatus(rawValue: rawValue) ?? StateMachineStatus.sdkUnknown(rawValue)
    }
}

public enum StateMachineType {
    case express
    case standard
    case sdkUnknown(String)
}

extension StateMachineType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StateMachineType] {
        return [
            .express,
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .express: return "EXPRESS"
        case .standard: return "STANDARD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StateMachineType(rawValue: rawValue) ?? StateMachineType.sdkUnknown(rawValue)
    }
}

extension StateMachineTypeNotSupported: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StateMachineTypeNotSupported(message: \(String(describing: message)))"}
}

extension StateMachineTypeNotSupported: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StateMachineTypeNotSupportedBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct StateMachineTypeNotSupported: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StateMachineTypeNotSupportedBody: Equatable {
    public let message: String?
}

extension StateMachineTypeNotSupportedBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StopExecutionInputBodyMiddleware: Middleware {
    public let id: String = "StopExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StopExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopExecutionInput>
    public typealias MOutput = OperationOutput<StopExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopExecutionOutputError>
}

extension StopExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopExecutionInput(cause: \(String(describing: cause)), error: \(String(describing: error)), executionArn: \(String(describing: executionArn)))"}
}

extension StopExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cause
        case error
        case executionArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let executionArn = executionArn {
            try encodeContainer.encode(executionArn, forKey: .executionArn)
        }
    }
}

public struct StopExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "StopExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StopExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopExecutionInput>
    public typealias MOutput = OperationOutput<StopExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopExecutionOutputError>
}

public struct StopExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "StopExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StopExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopExecutionInput>
    public typealias MOutput = OperationOutput<StopExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopExecutionOutputError>
}

public struct StopExecutionInput: Equatable {
    /// <p>A more detailed explanation of the cause of the failure.</p>
    public let cause: String?
    /// <p>The error code of the failure.</p>
    public let error: String?
    /// <p>The Amazon Resource Name (ARN) of the execution to stop.</p>
    public let executionArn: String?

    public init (
        cause: String? = nil,
        error: String? = nil,
        executionArn: String? = nil
    )
    {
        self.cause = cause
        self.error = error
        self.executionArn = executionArn
    }
}

struct StopExecutionInputBody: Equatable {
    public let executionArn: String?
    public let error: String?
    public let cause: String?
}

extension StopExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cause
        case error
        case executionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionArn)
        executionArn = executionArnDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension StopExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExecutionDoesNotExist" : self = .executionDoesNotExist(try ExecutionDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopExecutionOutputError: Equatable {
    case executionDoesNotExist(ExecutionDoesNotExist)
    case invalidArn(InvalidArn)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopExecutionOutputResponse(stopDate: \(String(describing: stopDate)))"}
}

extension StopExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopExecutionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stopDate = output.stopDate
        } else {
            self.stopDate = nil
        }
    }
}

public struct StopExecutionOutputResponse: Equatable {
    /// <p>The date the execution is stopped.</p>
    public let stopDate: Date?

    public init (
        stopDate: Date? = nil
    )
    {
        self.stopDate = stopDate
    }
}

struct StopExecutionOutputResponseBody: Equatable {
    public let stopDate: Date?
}

extension StopExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stopDate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stopDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stopDate)
        stopDate = stopDateDecoded
    }
}

public enum SyncExecutionStatus {
    case failed
    case succeeded
    case timedOut
    case sdkUnknown(String)
}

extension SyncExecutionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SyncExecutionStatus] {
        return [
            .failed,
            .succeeded,
            .timedOut,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .succeeded: return "SUCCEEDED"
        case .timedOut: return "TIMED_OUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SyncExecutionStatus(rawValue: rawValue) ?? SyncExecutionStatus.sdkUnknown(rawValue)
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Tags are key-value pairs that can be associated with Step Functions state machines and
///       activities.</p>
///          <p>An array of key-value pairs. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using
///       Cost Allocation Tags</a> in the <i>AWS Billing and Cost Management User
///         Guide</i>, and <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_iam-tags.html">Controlling Access Using IAM
///           Tags</a>.</p>
///          <p>Tags may only contain Unicode letters, digits, white space, or these symbols: <code>_ . : / = + - @</code>.</p>
public struct Tag: Equatable {
    /// <p>The key of a tag.</p>
    public let key: String?
    /// <p>The value of a tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the Step Functions state machine or activity.</p>
    public let resourceArn: String?
    /// <p>The list of tags to add to a resource.</p>
    ///          <p>Tags may only contain Unicode letters, digits, white space, or these symbols: <code>_ . : / = + - @</code>.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFound(try ResourceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTags" : self = .tooManyTags(try TooManyTags(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case invalidArn(InvalidArn)
    case resourceNotFound(ResourceNotFound)
    case tooManyTags(TooManyTags)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TaskDoesNotExist: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskDoesNotExist(message: \(String(describing: message)))"}
}

extension TaskDoesNotExist: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TaskDoesNotExistBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct TaskDoesNotExist: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TaskDoesNotExistBody: Equatable {
    public let message: String?
}

extension TaskDoesNotExistBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TaskFailedEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cause
        case error
        case resource
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension TaskFailedEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskFailedEventDetails(cause: \(String(describing: cause)), error: \(String(describing: error)), resource: \(String(describing: resource)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Contains details about a task failure event.</p>
public struct TaskFailedEventDetails: Equatable {
    /// <p>A more detailed explanation of the cause of the failure.</p>
    public let cause: String?
    /// <p>The error code of the failure.</p>
    public let error: String?
    /// <p>The service name of the resource in a task state.</p>
    public let resource: String?
    /// <p>The action of the resource called by a task state.</p>
    public let resourceType: String?

    public init (
        cause: String? = nil,
        error: String? = nil,
        resource: String? = nil,
        resourceType: String? = nil
    )
    {
        self.cause = cause
        self.error = error
        self.resource = resource
        self.resourceType = resourceType
    }
}

extension TaskScheduledEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case heartbeatInSeconds
        case parameters
        case region
        case resource
        case resourceType
        case timeoutInSeconds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if heartbeatInSeconds != 0 {
            try encodeContainer.encode(heartbeatInSeconds, forKey: .heartbeatInSeconds)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if timeoutInSeconds != 0 {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameters)
        parameters = parametersDecoded
        let timeoutInSecondsDecoded = try containerValues.decode(Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let heartbeatInSecondsDecoded = try containerValues.decode(Int.self, forKey: .heartbeatInSeconds)
        heartbeatInSeconds = heartbeatInSecondsDecoded
    }
}

extension TaskScheduledEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskScheduledEventDetails(heartbeatInSeconds: \(String(describing: heartbeatInSeconds)), parameters: \(String(describing: parameters)), region: \(String(describing: region)), resource: \(String(describing: resource)), resourceType: \(String(describing: resourceType)), timeoutInSeconds: \(String(describing: timeoutInSeconds)))"}
}

/// <p>Contains details about a task scheduled during an execution.</p>
public struct TaskScheduledEventDetails: Equatable {
    /// <p>The maximum allowed duration between two heartbeats for the task.</p>
    public let heartbeatInSeconds: Int
    /// <p>The JSON data passed to the resource referenced in a task state.
    ///       Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.</p>
    public let parameters: String?
    /// <p>The region of the scheduled task</p>
    public let region: String?
    /// <p>The service name of the resource in a task state.</p>
    public let resource: String?
    /// <p>The action of the resource called by a task state.</p>
    public let resourceType: String?
    /// <p>The maximum allowed duration of the task.</p>
    public let timeoutInSeconds: Int

    public init (
        heartbeatInSeconds: Int = 0,
        parameters: String? = nil,
        region: String? = nil,
        resource: String? = nil,
        resourceType: String? = nil,
        timeoutInSeconds: Int = 0
    )
    {
        self.heartbeatInSeconds = heartbeatInSeconds
        self.parameters = parameters
        self.region = region
        self.resource = resource
        self.resourceType = resourceType
        self.timeoutInSeconds = timeoutInSeconds
    }
}

extension TaskStartFailedEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cause
        case error
        case resource
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension TaskStartFailedEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskStartFailedEventDetails(cause: \(String(describing: cause)), error: \(String(describing: error)), resource: \(String(describing: resource)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Contains details about a task that failed to start during an execution.</p>
public struct TaskStartFailedEventDetails: Equatable {
    /// <p>A more detailed explanation of the cause of the failure.</p>
    public let cause: String?
    /// <p>The error code of the failure.</p>
    public let error: String?
    /// <p>The service name of the resource in a task state.</p>
    public let resource: String?
    /// <p>The action of the resource called by a task state.</p>
    public let resourceType: String?

    public init (
        cause: String? = nil,
        error: String? = nil,
        resource: String? = nil,
        resourceType: String? = nil
    )
    {
        self.cause = cause
        self.error = error
        self.resource = resource
        self.resourceType = resourceType
    }
}

extension TaskStartedEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resource
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
    }
}

extension TaskStartedEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskStartedEventDetails(resource: \(String(describing: resource)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Contains details about the start of a task during an execution.</p>
public struct TaskStartedEventDetails: Equatable {
    /// <p>The service name of the resource in a task state.</p>
    public let resource: String?
    /// <p>The action of the resource called by a task state.</p>
    public let resourceType: String?

    public init (
        resource: String? = nil,
        resourceType: String? = nil
    )
    {
        self.resource = resource
        self.resourceType = resourceType
    }
}

extension TaskSubmitFailedEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cause
        case error
        case resource
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension TaskSubmitFailedEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskSubmitFailedEventDetails(cause: \(String(describing: cause)), error: \(String(describing: error)), resource: \(String(describing: resource)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Contains details about a task that failed to submit during an execution.</p>
public struct TaskSubmitFailedEventDetails: Equatable {
    /// <p>A more detailed explanation of the cause of the failure.</p>
    public let cause: String?
    /// <p>The error code of the failure.</p>
    public let error: String?
    /// <p>The service name of the resource in a task state.</p>
    public let resource: String?
    /// <p>The action of the resource called by a task state.</p>
    public let resourceType: String?

    public init (
        cause: String? = nil,
        error: String? = nil,
        resource: String? = nil,
        resourceType: String? = nil
    )
    {
        self.cause = cause
        self.error = error
        self.resource = resource
        self.resourceType = resourceType
    }
}

extension TaskSubmittedEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case output
        case outputDetails
        case resource
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let outputDetails = outputDetails {
            try encodeContainer.encode(outputDetails, forKey: .outputDetails)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
        let outputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .output)
        output = outputDecoded
        let outputDetailsDecoded = try containerValues.decodeIfPresent(HistoryEventExecutionDataDetails.self, forKey: .outputDetails)
        outputDetails = outputDetailsDecoded
    }
}

extension TaskSubmittedEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskSubmittedEventDetails(output: \(String(describing: output)), outputDetails: \(String(describing: outputDetails)), resource: \(String(describing: resource)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Contains details about a task submitted to a resource .</p>
public struct TaskSubmittedEventDetails: Equatable {
    /// <p>The response from a resource when a task has started. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.</p>
    public let output: String?
    /// <p>Contains details about the output of an execution history event.</p>
    public let outputDetails: HistoryEventExecutionDataDetails?
    /// <p>The service name of the resource in a task state.</p>
    public let resource: String?
    /// <p>The action of the resource called by a task state.</p>
    public let resourceType: String?

    public init (
        output: String? = nil,
        outputDetails: HistoryEventExecutionDataDetails? = nil,
        resource: String? = nil,
        resourceType: String? = nil
    )
    {
        self.output = output
        self.outputDetails = outputDetails
        self.resource = resource
        self.resourceType = resourceType
    }
}

extension TaskSucceededEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case output
        case outputDetails
        case resource
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let outputDetails = outputDetails {
            try encodeContainer.encode(outputDetails, forKey: .outputDetails)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
        let outputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .output)
        output = outputDecoded
        let outputDetailsDecoded = try containerValues.decodeIfPresent(HistoryEventExecutionDataDetails.self, forKey: .outputDetails)
        outputDetails = outputDetailsDecoded
    }
}

extension TaskSucceededEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskSucceededEventDetails(output: \(String(describing: output)), outputDetails: \(String(describing: outputDetails)), resource: \(String(describing: resource)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Contains details about the successful completion of a task state.</p>
public struct TaskSucceededEventDetails: Equatable {
    /// <p>The full JSON response from a resource when a task has succeeded. This response becomes
    ///       the output of the related task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.</p>
    public let output: String?
    /// <p>Contains details about the output of an execution history event.</p>
    public let outputDetails: HistoryEventExecutionDataDetails?
    /// <p>The service name of the resource in a task state.</p>
    public let resource: String?
    /// <p>The action of the resource called by a task state.</p>
    public let resourceType: String?

    public init (
        output: String? = nil,
        outputDetails: HistoryEventExecutionDataDetails? = nil,
        resource: String? = nil,
        resourceType: String? = nil
    )
    {
        self.output = output
        self.outputDetails = outputDetails
        self.resource = resource
        self.resourceType = resourceType
    }
}

extension TaskTimedOut: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskTimedOut(message: \(String(describing: message)))"}
}

extension TaskTimedOut: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TaskTimedOutBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct TaskTimedOut: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TaskTimedOutBody: Equatable {
    public let message: String?
}

extension TaskTimedOutBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TaskTimedOutEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cause
        case error
        case resource
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension TaskTimedOutEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskTimedOutEventDetails(cause: \(String(describing: cause)), error: \(String(describing: error)), resource: \(String(describing: resource)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Contains details about a resource timeout that occurred during an execution.</p>
public struct TaskTimedOutEventDetails: Equatable {
    /// <p>A more detailed explanation of the cause of the failure.</p>
    public let cause: String?
    /// <p>The error code of the failure.</p>
    public let error: String?
    /// <p>The service name of the resource in a task state.</p>
    public let resource: String?
    /// <p>The action of the resource called by a task state.</p>
    public let resourceType: String?

    public init (
        cause: String? = nil,
        error: String? = nil,
        resource: String? = nil,
        resourceType: String? = nil
    )
    {
        self.cause = cause
        self.error = error
        self.resource = resource
        self.resourceType = resourceType
    }
}

extension TooManyTags: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTags(message: \(String(describing: message)), resourceName: \(String(describing: resourceName)))"}
}

extension TooManyTags: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyTagsBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've exceeded the number of tags allowed for a resource. See the <a href="https://docs.aws.amazon.com/step-functions/latest/dg/limits.html"> Limits Topic</a> in the
///       AWS Step Functions Developer Guide.</p>
public struct TooManyTags: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var resourceName: String?

    public init (
        message: String? = nil,
        resourceName: String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsBody: Equatable {
    public let message: String?
    public let resourceName: String?
}

extension TooManyTagsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension TracingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension TracingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TracingConfiguration(enabled: \(String(describing: enabled)))"}
}

/// <p>Selects whether or not the state machine's AWS X-Ray tracing is enabled. Default is <code>false</code>
///          </p>
public struct TracingConfiguration: Equatable {
    /// <p>When set to <code>true</code>, AWS X-Ray tracing is enabled.</p>
    public let enabled: Bool

    public init (
        enabled: Bool = false
    )
    {
        self.enabled = enabled
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the Step Functions state machine or activity.</p>
    public let resourceArn: String?
    /// <p>The list of tags to remove from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFound(try ResourceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case invalidArn(InvalidArn)
    case resourceNotFound(ResourceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateStateMachineInputBodyMiddleware: Middleware {
    public let id: String = "UpdateStateMachineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStateMachineInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStateMachineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStateMachineInput>
    public typealias MOutput = OperationOutput<UpdateStateMachineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStateMachineOutputError>
}

extension UpdateStateMachineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStateMachineInput(definition: \(String(describing: definition)), loggingConfiguration: \(String(describing: loggingConfiguration)), roleArn: \(String(describing: roleArn)), stateMachineArn: \(String(describing: stateMachineArn)), tracingConfiguration: \(String(describing: tracingConfiguration)))"}
}

extension UpdateStateMachineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case definition
        case loggingConfiguration
        case roleArn
        case stateMachineArn
        case tracingConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let loggingConfiguration = loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stateMachineArn = stateMachineArn {
            try encodeContainer.encode(stateMachineArn, forKey: .stateMachineArn)
        }
        if let tracingConfiguration = tracingConfiguration {
            try encodeContainer.encode(tracingConfiguration, forKey: .tracingConfiguration)
        }
    }
}

public struct UpdateStateMachineInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateStateMachineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStateMachineInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStateMachineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStateMachineInput>
    public typealias MOutput = OperationOutput<UpdateStateMachineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStateMachineOutputError>
}

public struct UpdateStateMachineInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateStateMachineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStateMachineInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStateMachineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStateMachineInput>
    public typealias MOutput = OperationOutput<UpdateStateMachineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStateMachineOutputError>
}

public struct UpdateStateMachineInput: Equatable {
    /// <p>The Amazon States Language definition of the state machine. See <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-amazon-states-language.html">Amazon States Language</a>.</p>
    public let definition: String?
    /// <p>The <code>LoggingConfiguration</code> data type is used to set CloudWatch Logs
    ///       options.</p>
    public let loggingConfiguration: LoggingConfiguration?
    /// <p>The Amazon Resource Name (ARN) of the IAM role of the state machine.</p>
    public let roleArn: String?
    /// <p>The Amazon Resource Name (ARN) of the state machine.</p>
    public let stateMachineArn: String?
    /// <p>Selects whether AWS X-Ray tracing is enabled.</p>
    public let tracingConfiguration: TracingConfiguration?

    public init (
        definition: String? = nil,
        loggingConfiguration: LoggingConfiguration? = nil,
        roleArn: String? = nil,
        stateMachineArn: String? = nil,
        tracingConfiguration: TracingConfiguration? = nil
    )
    {
        self.definition = definition
        self.loggingConfiguration = loggingConfiguration
        self.roleArn = roleArn
        self.stateMachineArn = stateMachineArn
        self.tracingConfiguration = tracingConfiguration
    }
}

struct UpdateStateMachineInputBody: Equatable {
    public let stateMachineArn: String?
    public let definition: String?
    public let roleArn: String?
    public let loggingConfiguration: LoggingConfiguration?
    public let tracingConfiguration: TracingConfiguration?
}

extension UpdateStateMachineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case definition
        case loggingConfiguration
        case roleArn
        case stateMachineArn
        case tracingConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .definition)
        definition = definitionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
        let tracingConfigurationDecoded = try containerValues.decodeIfPresent(TracingConfiguration.self, forKey: .tracingConfiguration)
        tracingConfiguration = tracingConfigurationDecoded
    }
}

extension UpdateStateMachineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStateMachineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDefinition" : self = .invalidDefinition(try InvalidDefinition(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLoggingConfiguration" : self = .invalidLoggingConfiguration(try InvalidLoggingConfiguration(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTracingConfiguration" : self = .invalidTracingConfiguration(try InvalidTracingConfiguration(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameter" : self = .missingRequiredParameter(try MissingRequiredParameter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineDeleting" : self = .stateMachineDeleting(try StateMachineDeleting(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineDoesNotExist" : self = .stateMachineDoesNotExist(try StateMachineDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStateMachineOutputError: Equatable {
    case invalidArn(InvalidArn)
    case invalidDefinition(InvalidDefinition)
    case invalidLoggingConfiguration(InvalidLoggingConfiguration)
    case invalidTracingConfiguration(InvalidTracingConfiguration)
    case missingRequiredParameter(MissingRequiredParameter)
    case stateMachineDeleting(StateMachineDeleting)
    case stateMachineDoesNotExist(StateMachineDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStateMachineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStateMachineOutputResponse(updateDate: \(String(describing: updateDate)))"}
}

extension UpdateStateMachineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateStateMachineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.updateDate = output.updateDate
        } else {
            self.updateDate = nil
        }
    }
}

public struct UpdateStateMachineOutputResponse: Equatable {
    /// <p>The date and time the state machine was updated.</p>
    public let updateDate: Date?

    public init (
        updateDate: Date? = nil
    )
    {
        self.updateDate = updateDate
    }
}

struct UpdateStateMachineOutputResponseBody: Equatable {
    public let updateDate: Date?
}

extension UpdateStateMachineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case updateDate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updateDate)
        updateDate = updateDateDecoded
    }
}
