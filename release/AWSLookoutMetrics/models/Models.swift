// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient permissions to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LookoutMetricsClientTypes.Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaConfiguration = "LambdaConfiguration"
        case sNSConfiguration = "SNSConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaConfiguration = lambdaConfiguration {
            try encodeContainer.encode(lambdaConfiguration, forKey: .lambdaConfiguration)
        }
        if let sNSConfiguration = sNSConfiguration {
            try encodeContainer.encode(sNSConfiguration, forKey: .sNSConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sNSConfigurationDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.SNSConfiguration.self, forKey: .sNSConfiguration)
        sNSConfiguration = sNSConfigurationDecoded
        let lambdaConfigurationDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.LambdaConfiguration.self, forKey: .lambdaConfiguration)
        lambdaConfiguration = lambdaConfigurationDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// A configuration that specifies the action to perform when anomalies are detected.
    public struct Action: Swift.Equatable {
        /// A configuration for an AWS Lambda channel.
        public var lambdaConfiguration: LookoutMetricsClientTypes.LambdaConfiguration?
        /// A configuration for an Amazon SNS channel.
        public var sNSConfiguration: LookoutMetricsClientTypes.SNSConfiguration?

        public init (
            lambdaConfiguration: LookoutMetricsClientTypes.LambdaConfiguration? = nil,
            sNSConfiguration: LookoutMetricsClientTypes.SNSConfiguration? = nil
        )
        {
            self.lambdaConfiguration = lambdaConfiguration
            self.sNSConfiguration = sNSConfiguration
        }
    }

}

extension ActivateAnomalyDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
    }
}

extension ActivateAnomalyDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ActivateAnomalyDetector"
    }
}

public struct ActivateAnomalyDetectorInput: Swift.Equatable {
    /// The ARN of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

struct ActivateAnomalyDetectorInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
}

extension ActivateAnomalyDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

extension ActivateAnomalyDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ActivateAnomalyDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ActivateAnomalyDetectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ActivateAnomalyDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ActivateAnomalyDetectorOutputResponse: Swift.Equatable {

}

extension LookoutMetricsClientTypes {
    public enum AggregationFunction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case avg
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationFunction] {
            return [
                .avg,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .avg: return "AVG"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregationFunction(rawValue: rawValue) ?? AggregationFunction.sdkUnknown(rawValue)
        }
    }
}

extension LookoutMetricsClientTypes.Alert: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case alertArn = "AlertArn"
        case alertDescription = "AlertDescription"
        case alertName = "AlertName"
        case alertSensitivityThreshold = "AlertSensitivityThreshold"
        case alertStatus = "AlertStatus"
        case alertType = "AlertType"
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case creationTime = "CreationTime"
        case lastModificationTime = "LastModificationTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let alertArn = alertArn {
            try encodeContainer.encode(alertArn, forKey: .alertArn)
        }
        if let alertDescription = alertDescription {
            try encodeContainer.encode(alertDescription, forKey: .alertDescription)
        }
        if let alertName = alertName {
            try encodeContainer.encode(alertName, forKey: .alertName)
        }
        if alertSensitivityThreshold != 0 {
            try encodeContainer.encode(alertSensitivityThreshold, forKey: .alertSensitivityThreshold)
        }
        if let alertStatus = alertStatus {
            try encodeContainer.encode(alertStatus.rawValue, forKey: .alertStatus)
        }
        if let alertType = alertType {
            try encodeContainer.encode(alertType.rawValue, forKey: .alertType)
        }
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let alertDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertDescription)
        alertDescription = alertDescriptionDecoded
        let alertArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertArn)
        alertArn = alertArnDecoded
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let alertNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertName)
        alertName = alertNameDecoded
        let alertSensitivityThresholdDecoded = try containerValues.decode(Swift.Int.self, forKey: .alertSensitivityThreshold)
        alertSensitivityThreshold = alertSensitivityThresholdDecoded
        let alertTypeDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AlertType.self, forKey: .alertType)
        alertType = alertTypeDecoded
        let alertStatusDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AlertStatus.self, forKey: .alertStatus)
        alertStatus = alertStatusDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// A configuration for Amazon SNS-integrated notifications.
    public struct Alert: Swift.Equatable {
        /// Action that will be triggered when there is an alert.
        public var action: LookoutMetricsClientTypes.Action?
        /// The ARN of the alert.
        public var alertArn: Swift.String?
        /// A description of the alert.
        public var alertDescription: Swift.String?
        /// The name of the alert.
        public var alertName: Swift.String?
        /// The minimum severity for an anomaly to trigger the alert.
        public var alertSensitivityThreshold: Swift.Int
        /// The status of the alert.
        public var alertStatus: LookoutMetricsClientTypes.AlertStatus?
        /// The type of the alert.
        public var alertType: LookoutMetricsClientTypes.AlertType?
        /// The ARN of the detector to which the alert is attached.
        public var anomalyDetectorArn: Swift.String?
        /// The time at which the alert was created.
        public var creationTime: ClientRuntime.Date?
        /// The time at which the alert was last modified.
        public var lastModificationTime: ClientRuntime.Date?

        public init (
            action: LookoutMetricsClientTypes.Action? = nil,
            alertArn: Swift.String? = nil,
            alertDescription: Swift.String? = nil,
            alertName: Swift.String? = nil,
            alertSensitivityThreshold: Swift.Int = 0,
            alertStatus: LookoutMetricsClientTypes.AlertStatus? = nil,
            alertType: LookoutMetricsClientTypes.AlertType? = nil,
            anomalyDetectorArn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastModificationTime: ClientRuntime.Date? = nil
        )
        {
            self.action = action
            self.alertArn = alertArn
            self.alertDescription = alertDescription
            self.alertName = alertName
            self.alertSensitivityThreshold = alertSensitivityThreshold
            self.alertStatus = alertStatus
            self.alertType = alertType
            self.anomalyDetectorArn = anomalyDetectorArn
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
        }
    }

}

extension LookoutMetricsClientTypes {
    public enum AlertStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AlertStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlertStatus(rawValue: rawValue) ?? AlertStatus.sdkUnknown(rawValue)
        }
    }
}

extension LookoutMetricsClientTypes.AlertSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alertArn = "AlertArn"
        case alertName = "AlertName"
        case alertSensitivityThreshold = "AlertSensitivityThreshold"
        case alertStatus = "AlertStatus"
        case alertType = "AlertType"
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case creationTime = "CreationTime"
        case lastModificationTime = "LastModificationTime"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alertArn = alertArn {
            try encodeContainer.encode(alertArn, forKey: .alertArn)
        }
        if let alertName = alertName {
            try encodeContainer.encode(alertName, forKey: .alertName)
        }
        if alertSensitivityThreshold != 0 {
            try encodeContainer.encode(alertSensitivityThreshold, forKey: .alertSensitivityThreshold)
        }
        if let alertStatus = alertStatus {
            try encodeContainer.encode(alertStatus.rawValue, forKey: .alertStatus)
        }
        if let alertType = alertType {
            try encodeContainer.encode(alertType.rawValue, forKey: .alertType)
        }
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertArn)
        alertArn = alertArnDecoded
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let alertNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertName)
        alertName = alertNameDecoded
        let alertSensitivityThresholdDecoded = try containerValues.decode(Swift.Int.self, forKey: .alertSensitivityThreshold)
        alertSensitivityThreshold = alertSensitivityThresholdDecoded
        let alertTypeDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AlertType.self, forKey: .alertType)
        alertType = alertTypeDecoded
        let alertStatusDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AlertStatus.self, forKey: .alertStatus)
        alertStatus = alertStatusDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// Provides a summary of an alert's configuration.
    public struct AlertSummary: Swift.Equatable {
        /// The ARN of the alert.
        public var alertArn: Swift.String?
        /// The name of the alert.
        public var alertName: Swift.String?
        /// The minimum severity for an anomaly to trigger the alert.
        public var alertSensitivityThreshold: Swift.Int
        /// The status of the alert.
        public var alertStatus: LookoutMetricsClientTypes.AlertStatus?
        /// The type of the alert.
        public var alertType: LookoutMetricsClientTypes.AlertType?
        /// The ARN of the detector to which the alert is attached.
        public var anomalyDetectorArn: Swift.String?
        /// The time at which the alert was created.
        public var creationTime: ClientRuntime.Date?
        /// The time at which the alert was last modified.
        public var lastModificationTime: ClientRuntime.Date?
        /// The alert's [tags](https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html).
        public var tags: [Swift.String:Swift.String]?

        public init (
            alertArn: Swift.String? = nil,
            alertName: Swift.String? = nil,
            alertSensitivityThreshold: Swift.Int = 0,
            alertStatus: LookoutMetricsClientTypes.AlertStatus? = nil,
            alertType: LookoutMetricsClientTypes.AlertType? = nil,
            anomalyDetectorArn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.alertArn = alertArn
            self.alertName = alertName
            self.alertSensitivityThreshold = alertSensitivityThreshold
            self.alertStatus = alertStatus
            self.alertType = alertType
            self.anomalyDetectorArn = anomalyDetectorArn
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.tags = tags
        }
    }

}

extension LookoutMetricsClientTypes {
    public enum AlertType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lambda
        case sns
        case sdkUnknown(Swift.String)

        public static var allCases: [AlertType] {
            return [
                .lambda,
                .sns,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lambda: return "LAMBDA"
            case .sns: return "SNS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlertType(rawValue: rawValue) ?? AlertType.sdkUnknown(rawValue)
        }
    }
}

extension LookoutMetricsClientTypes {
    public enum AnomalyDetectionTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case failedToSchedule
        case inProgress
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalyDetectionTaskStatus] {
            return [
                .completed,
                .failed,
                .failedToSchedule,
                .inProgress,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .failedToSchedule: return "FAILED_TO_SCHEDULE"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnomalyDetectionTaskStatus(rawValue: rawValue) ?? AnomalyDetectionTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension LookoutMetricsClientTypes.AnomalyDetectorConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorFrequency = "AnomalyDetectorFrequency"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorFrequency = anomalyDetectorFrequency {
            try encodeContainer.encode(anomalyDetectorFrequency.rawValue, forKey: .anomalyDetectorFrequency)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorFrequencyDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.Frequency.self, forKey: .anomalyDetectorFrequency)
        anomalyDetectorFrequency = anomalyDetectorFrequencyDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about a detector's configuration.
    public struct AnomalyDetectorConfig: Swift.Equatable {
        /// The frequency at which the detector analyzes its source data.
        public var anomalyDetectorFrequency: LookoutMetricsClientTypes.Frequency?

        public init (
            anomalyDetectorFrequency: LookoutMetricsClientTypes.Frequency? = nil
        )
        {
            self.anomalyDetectorFrequency = anomalyDetectorFrequency
        }
    }

}

extension LookoutMetricsClientTypes.AnomalyDetectorConfigSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorFrequency = "AnomalyDetectorFrequency"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorFrequency = anomalyDetectorFrequency {
            try encodeContainer.encode(anomalyDetectorFrequency.rawValue, forKey: .anomalyDetectorFrequency)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorFrequencyDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.Frequency.self, forKey: .anomalyDetectorFrequency)
        anomalyDetectorFrequency = anomalyDetectorFrequencyDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about a detector's configuration.
    public struct AnomalyDetectorConfigSummary: Swift.Equatable {
        /// The interval at which the detector analyzes its source data.
        public var anomalyDetectorFrequency: LookoutMetricsClientTypes.Frequency?

        public init (
            anomalyDetectorFrequency: LookoutMetricsClientTypes.Frequency? = nil
        )
        {
            self.anomalyDetectorFrequency = anomalyDetectorFrequency
        }
    }

}

extension LookoutMetricsClientTypes {
    public enum AnomalyDetectorStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activating
        case active
        case backTestActivating
        case backTestActive
        case backTestComplete
        case deleting
        case failed
        case inactive
        case learning
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalyDetectorStatus] {
            return [
                .activating,
                .active,
                .backTestActivating,
                .backTestActive,
                .backTestComplete,
                .deleting,
                .failed,
                .inactive,
                .learning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .backTestActivating: return "BACK_TEST_ACTIVATING"
            case .backTestActive: return "BACK_TEST_ACTIVE"
            case .backTestComplete: return "BACK_TEST_COMPLETE"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case .learning: return "LEARNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnomalyDetectorStatus(rawValue: rawValue) ?? AnomalyDetectorStatus.sdkUnknown(rawValue)
        }
    }
}

extension LookoutMetricsClientTypes.AnomalyDetectorSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyDetectorDescription = "AnomalyDetectorDescription"
        case anomalyDetectorName = "AnomalyDetectorName"
        case creationTime = "CreationTime"
        case lastModificationTime = "LastModificationTime"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let anomalyDetectorDescription = anomalyDetectorDescription {
            try encodeContainer.encode(anomalyDetectorDescription, forKey: .anomalyDetectorDescription)
        }
        if let anomalyDetectorName = anomalyDetectorName {
            try encodeContainer.encode(anomalyDetectorName, forKey: .anomalyDetectorName)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let anomalyDetectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorName)
        anomalyDetectorName = anomalyDetectorNameDecoded
        let anomalyDetectorDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorDescription)
        anomalyDetectorDescription = anomalyDetectorDescriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyDetectorStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about an an anomaly detector.
    public struct AnomalyDetectorSummary: Swift.Equatable {
        /// The ARN of the detector.
        public var anomalyDetectorArn: Swift.String?
        /// A description of the detector.
        public var anomalyDetectorDescription: Swift.String?
        /// The name of the detector.
        public var anomalyDetectorName: Swift.String?
        /// The time at which the detector was created.
        public var creationTime: ClientRuntime.Date?
        /// The time at which the detector was last modified.
        public var lastModificationTime: ClientRuntime.Date?
        /// The status of detector.
        public var status: LookoutMetricsClientTypes.AnomalyDetectorStatus?
        /// The detector's [tags](https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html).
        public var tags: [Swift.String:Swift.String]?

        public init (
            anomalyDetectorArn: Swift.String? = nil,
            anomalyDetectorDescription: Swift.String? = nil,
            anomalyDetectorName: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            status: LookoutMetricsClientTypes.AnomalyDetectorStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.anomalyDetectorDescription = anomalyDetectorDescription
            self.anomalyDetectorName = anomalyDetectorName
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.status = status
            self.tags = tags
        }
    }

}

extension LookoutMetricsClientTypes.AnomalyGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyGroupId = "AnomalyGroupId"
        case anomalyGroupScore = "AnomalyGroupScore"
        case endTime = "EndTime"
        case metricLevelImpactList = "MetricLevelImpactList"
        case primaryMetricName = "PrimaryMetricName"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyGroupId = anomalyGroupId {
            try encodeContainer.encode(anomalyGroupId, forKey: .anomalyGroupId)
        }
        if let anomalyGroupScore = anomalyGroupScore {
            try encodeContainer.encode(anomalyGroupScore, forKey: .anomalyGroupScore)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let metricLevelImpactList = metricLevelImpactList {
            var metricLevelImpactListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricLevelImpactList)
            for metriclevelimpactlist0 in metricLevelImpactList {
                try metricLevelImpactListContainer.encode(metriclevelimpactlist0)
            }
        }
        if let primaryMetricName = primaryMetricName {
            try encodeContainer.encode(primaryMetricName, forKey: .primaryMetricName)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let anomalyGroupScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .anomalyGroupScore)
        anomalyGroupScore = anomalyGroupScoreDecoded
        let primaryMetricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryMetricName)
        primaryMetricName = primaryMetricNameDecoded
        let metricLevelImpactListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.MetricLevelImpact?].self, forKey: .metricLevelImpactList)
        var metricLevelImpactListDecoded0:[LookoutMetricsClientTypes.MetricLevelImpact]? = nil
        if let metricLevelImpactListContainer = metricLevelImpactListContainer {
            metricLevelImpactListDecoded0 = [LookoutMetricsClientTypes.MetricLevelImpact]()
            for structure0 in metricLevelImpactListContainer {
                if let structure0 = structure0 {
                    metricLevelImpactListDecoded0?.append(structure0)
                }
            }
        }
        metricLevelImpactList = metricLevelImpactListDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// A group of anomalous metrics
    public struct AnomalyGroup: Swift.Equatable {
        /// The ID of the anomaly group.
        public var anomalyGroupId: Swift.String?
        /// The severity score of the group.
        public var anomalyGroupScore: Swift.Double?
        /// The end time for the group.
        public var endTime: Swift.String?
        /// A list of measures affected by the anomaly.
        public var metricLevelImpactList: [LookoutMetricsClientTypes.MetricLevelImpact]?
        /// The name of the primary affected measure for the group.
        public var primaryMetricName: Swift.String?
        /// The start time for the group.
        public var startTime: Swift.String?

        public init (
            anomalyGroupId: Swift.String? = nil,
            anomalyGroupScore: Swift.Double? = nil,
            endTime: Swift.String? = nil,
            metricLevelImpactList: [LookoutMetricsClientTypes.MetricLevelImpact]? = nil,
            primaryMetricName: Swift.String? = nil,
            startTime: Swift.String? = nil
        )
        {
            self.anomalyGroupId = anomalyGroupId
            self.anomalyGroupScore = anomalyGroupScore
            self.endTime = endTime
            self.metricLevelImpactList = metricLevelImpactList
            self.primaryMetricName = primaryMetricName
            self.startTime = startTime
        }
    }

}

extension LookoutMetricsClientTypes.AnomalyGroupStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationStartDate = "EvaluationStartDate"
        case itemizedMetricStatsList = "ItemizedMetricStatsList"
        case totalCount = "TotalCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationStartDate = evaluationStartDate {
            try encodeContainer.encode(evaluationStartDate, forKey: .evaluationStartDate)
        }
        if let itemizedMetricStatsList = itemizedMetricStatsList {
            var itemizedMetricStatsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .itemizedMetricStatsList)
            for itemizedmetricstatslist0 in itemizedMetricStatsList {
                try itemizedMetricStatsListContainer.encode(itemizedmetricstatslist0)
            }
        }
        if totalCount != 0 {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationStartDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationStartDate)
        evaluationStartDate = evaluationStartDateDecoded
        let totalCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
        let itemizedMetricStatsListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.ItemizedMetricStats?].self, forKey: .itemizedMetricStatsList)
        var itemizedMetricStatsListDecoded0:[LookoutMetricsClientTypes.ItemizedMetricStats]? = nil
        if let itemizedMetricStatsListContainer = itemizedMetricStatsListContainer {
            itemizedMetricStatsListDecoded0 = [LookoutMetricsClientTypes.ItemizedMetricStats]()
            for structure0 in itemizedMetricStatsListContainer {
                if let structure0 = structure0 {
                    itemizedMetricStatsListDecoded0?.append(structure0)
                }
            }
        }
        itemizedMetricStatsList = itemizedMetricStatsListDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// Aggregated statistics for a group of anomalous metrics.
    public struct AnomalyGroupStatistics: Swift.Equatable {
        /// The start of the time range that was searched.
        public var evaluationStartDate: Swift.String?
        /// Statistics for individual metrics within the group.
        public var itemizedMetricStatsList: [LookoutMetricsClientTypes.ItemizedMetricStats]?
        /// The number of groups found.
        public var totalCount: Swift.Int

        public init (
            evaluationStartDate: Swift.String? = nil,
            itemizedMetricStatsList: [LookoutMetricsClientTypes.ItemizedMetricStats]? = nil,
            totalCount: Swift.Int = 0
        )
        {
            self.evaluationStartDate = evaluationStartDate
            self.itemizedMetricStatsList = itemizedMetricStatsList
            self.totalCount = totalCount
        }
    }

}

extension LookoutMetricsClientTypes.AnomalyGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyGroupId = "AnomalyGroupId"
        case anomalyGroupScore = "AnomalyGroupScore"
        case endTime = "EndTime"
        case primaryMetricName = "PrimaryMetricName"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyGroupId = anomalyGroupId {
            try encodeContainer.encode(anomalyGroupId, forKey: .anomalyGroupId)
        }
        if let anomalyGroupScore = anomalyGroupScore {
            try encodeContainer.encode(anomalyGroupScore, forKey: .anomalyGroupScore)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let primaryMetricName = primaryMetricName {
            try encodeContainer.encode(primaryMetricName, forKey: .primaryMetricName)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let anomalyGroupScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .anomalyGroupScore)
        anomalyGroupScore = anomalyGroupScoreDecoded
        let primaryMetricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryMetricName)
        primaryMetricName = primaryMetricNameDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Details about a group of anomalous metrics.
    public struct AnomalyGroupSummary: Swift.Equatable {
        /// The ID of the anomaly group.
        public var anomalyGroupId: Swift.String?
        /// The severity score of the group.
        public var anomalyGroupScore: Swift.Double?
        /// The end time for the group.
        public var endTime: Swift.String?
        /// The name of the primary affected measure for the group.
        public var primaryMetricName: Swift.String?
        /// The start time for the group.
        public var startTime: Swift.String?

        public init (
            anomalyGroupId: Swift.String? = nil,
            anomalyGroupScore: Swift.Double? = nil,
            endTime: Swift.String? = nil,
            primaryMetricName: Swift.String? = nil,
            startTime: Swift.String? = nil
        )
        {
            self.anomalyGroupId = anomalyGroupId
            self.anomalyGroupScore = anomalyGroupScore
            self.endTime = endTime
            self.primaryMetricName = primaryMetricName
            self.startTime = startTime
        }
    }

}

extension LookoutMetricsClientTypes.AnomalyGroupTimeSeries: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyGroupId = "AnomalyGroupId"
        case timeSeriesId = "TimeSeriesId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyGroupId = anomalyGroupId {
            try encodeContainer.encode(anomalyGroupId, forKey: .anomalyGroupId)
        }
        if let timeSeriesId = timeSeriesId {
            try encodeContainer.encode(timeSeriesId, forKey: .timeSeriesId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let timeSeriesIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeSeriesId)
        timeSeriesId = timeSeriesIdDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// An anomalous metric in an anomaly group.
    public struct AnomalyGroupTimeSeries: Swift.Equatable {
        /// The ID of the anomaly group.
        /// This member is required.
        public var anomalyGroupId: Swift.String?
        /// The ID of the metric.
        public var timeSeriesId: Swift.String?

        public init (
            anomalyGroupId: Swift.String? = nil,
            timeSeriesId: Swift.String? = nil
        )
        {
            self.anomalyGroupId = anomalyGroupId
            self.timeSeriesId = timeSeriesId
        }
    }

}

extension LookoutMetricsClientTypes.AnomalyGroupTimeSeriesFeedback: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyGroupId = "AnomalyGroupId"
        case isAnomaly = "IsAnomaly"
        case timeSeriesId = "TimeSeriesId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyGroupId = anomalyGroupId {
            try encodeContainer.encode(anomalyGroupId, forKey: .anomalyGroupId)
        }
        if let isAnomaly = isAnomaly {
            try encodeContainer.encode(isAnomaly, forKey: .isAnomaly)
        }
        if let timeSeriesId = timeSeriesId {
            try encodeContainer.encode(timeSeriesId, forKey: .timeSeriesId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let timeSeriesIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeSeriesId)
        timeSeriesId = timeSeriesIdDecoded
        let isAnomalyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAnomaly)
        isAnomaly = isAnomalyDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Feedback for an anomalous metric.
    public struct AnomalyGroupTimeSeriesFeedback: Swift.Equatable {
        /// The ID of the anomaly group.
        /// This member is required.
        public var anomalyGroupId: Swift.String?
        /// Feedback on whether the metric is a legitimate anomaly.
        /// This member is required.
        public var isAnomaly: Swift.Bool?
        /// The ID of the metric.
        /// This member is required.
        public var timeSeriesId: Swift.String?

        public init (
            anomalyGroupId: Swift.String? = nil,
            isAnomaly: Swift.Bool? = nil,
            timeSeriesId: Swift.String? = nil
        )
        {
            self.anomalyGroupId = anomalyGroupId
            self.isAnomaly = isAnomaly
            self.timeSeriesId = timeSeriesId
        }
    }

}

extension LookoutMetricsClientTypes.AppFlowConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName = "FlowName"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Details about an Amazon AppFlow flow datasource.
    public struct AppFlowConfig: Swift.Equatable {
        /// name of the flow.
        /// This member is required.
        public var flowName: Swift.String?
        /// An IAM role that gives Amazon Lookout for Metrics permission to access the flow.
        /// This member is required.
        public var roleArn: Swift.String?

        public init (
            flowName: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.flowName = flowName
            self.roleArn = roleArn
        }
    }

}

extension BackTestAnomalyDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
    }
}

extension BackTestAnomalyDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/BackTestAnomalyDetector"
    }
}

public struct BackTestAnomalyDetectorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

struct BackTestAnomalyDetectorInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
}

extension BackTestAnomalyDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

extension BackTestAnomalyDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BackTestAnomalyDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BackTestAnomalyDetectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BackTestAnomalyDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct BackTestAnomalyDetectorOutputResponse: Swift.Equatable {

}

extension LookoutMetricsClientTypes {
    public enum CSVFileCompression: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gzip
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [CSVFileCompression] {
            return [
                .gzip,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "GZIP"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CSVFileCompression(rawValue: rawValue) ?? CSVFileCompression.sdkUnknown(rawValue)
        }
    }
}

extension LookoutMetricsClientTypes.CloudWatchConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Details about an Amazon CloudWatch datasource.
    public struct CloudWatchConfig: Swift.Equatable {
        /// An IAM role that gives Amazon Lookout for Metrics permission to access data in Amazon CloudWatch.
        /// This member is required.
        public var roleArn: Swift.String?

        public init (
            roleArn: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was a conflict processing the request. Try your request again.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    public var resourceId: Swift.String?
    /// The type of the resource.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension LookoutMetricsClientTypes.ContributionMatrix: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionContributionList = "DimensionContributionList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionContributionList = dimensionContributionList {
            var dimensionContributionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionContributionList)
            for dimensioncontributionlist0 in dimensionContributionList {
                try dimensionContributionListContainer.encode(dimensioncontributionlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionContributionListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.DimensionContribution?].self, forKey: .dimensionContributionList)
        var dimensionContributionListDecoded0:[LookoutMetricsClientTypes.DimensionContribution]? = nil
        if let dimensionContributionListContainer = dimensionContributionListContainer {
            dimensionContributionListDecoded0 = [LookoutMetricsClientTypes.DimensionContribution]()
            for structure0 in dimensionContributionListContainer {
                if let structure0 = structure0 {
                    dimensionContributionListDecoded0?.append(structure0)
                }
            }
        }
        dimensionContributionList = dimensionContributionListDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// Details about dimensions that contributed to an anomaly.
    public struct ContributionMatrix: Swift.Equatable {
        /// A list of contributing dimensions.
        public var dimensionContributionList: [LookoutMetricsClientTypes.DimensionContribution]?

        public init (
            dimensionContributionList: [LookoutMetricsClientTypes.DimensionContribution]? = nil
        )
        {
            self.dimensionContributionList = dimensionContributionList
        }
    }

}

extension CreateAlertInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case alertDescription = "AlertDescription"
        case alertName = "AlertName"
        case alertSensitivityThreshold = "AlertSensitivityThreshold"
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let alertDescription = alertDescription {
            try encodeContainer.encode(alertDescription, forKey: .alertDescription)
        }
        if let alertName = alertName {
            try encodeContainer.encode(alertName, forKey: .alertName)
        }
        if alertSensitivityThreshold != 0 {
            try encodeContainer.encode(alertSensitivityThreshold, forKey: .alertSensitivityThreshold)
        }
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAlertInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateAlert"
    }
}

public struct CreateAlertInput: Swift.Equatable {
    /// Action that will be triggered when there is an alert.
    /// This member is required.
    public var action: LookoutMetricsClientTypes.Action?
    /// A description of the alert.
    public var alertDescription: Swift.String?
    /// The name of the alert.
    /// This member is required.
    public var alertName: Swift.String?
    /// An integer from 0 to 100 specifying the alert sensitivity threshold.
    /// This member is required.
    public var alertSensitivityThreshold: Swift.Int
    /// The ARN of the detector to which the alert is attached.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html) to apply to the alert.
    public var tags: [Swift.String:Swift.String]?

    public init (
        action: LookoutMetricsClientTypes.Action? = nil,
        alertDescription: Swift.String? = nil,
        alertName: Swift.String? = nil,
        alertSensitivityThreshold: Swift.Int = 0,
        anomalyDetectorArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.action = action
        self.alertDescription = alertDescription
        self.alertName = alertName
        self.alertSensitivityThreshold = alertSensitivityThreshold
        self.anomalyDetectorArn = anomalyDetectorArn
        self.tags = tags
    }
}

struct CreateAlertInputBody: Swift.Equatable {
    let alertName: Swift.String?
    let alertSensitivityThreshold: Swift.Int
    let alertDescription: Swift.String?
    let anomalyDetectorArn: Swift.String?
    let action: LookoutMetricsClientTypes.Action?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAlertInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case alertDescription = "AlertDescription"
        case alertName = "AlertName"
        case alertSensitivityThreshold = "AlertSensitivityThreshold"
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertName)
        alertName = alertNameDecoded
        let alertSensitivityThresholdDecoded = try containerValues.decode(Swift.Int.self, forKey: .alertSensitivityThreshold)
        alertSensitivityThreshold = alertSensitivityThresholdDecoded
        let alertDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertDescription)
        alertDescription = alertDescriptionDecoded
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let actionDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAlertOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAlertOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAlertOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAlertOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAlertOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alertArn = output.alertArn
        } else {
            self.alertArn = nil
        }
    }
}

public struct CreateAlertOutputResponse: Swift.Equatable {
    /// The ARN of the alert.
    public var alertArn: Swift.String?

    public init (
        alertArn: Swift.String? = nil
    )
    {
        self.alertArn = alertArn
    }
}

struct CreateAlertOutputResponseBody: Swift.Equatable {
    let alertArn: Swift.String?
}

extension CreateAlertOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alertArn = "AlertArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertArn)
        alertArn = alertArnDecoded
    }
}

extension CreateAnomalyDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorConfig = "AnomalyDetectorConfig"
        case anomalyDetectorDescription = "AnomalyDetectorDescription"
        case anomalyDetectorName = "AnomalyDetectorName"
        case kmsKeyArn = "KmsKeyArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorConfig = anomalyDetectorConfig {
            try encodeContainer.encode(anomalyDetectorConfig, forKey: .anomalyDetectorConfig)
        }
        if let anomalyDetectorDescription = anomalyDetectorDescription {
            try encodeContainer.encode(anomalyDetectorDescription, forKey: .anomalyDetectorDescription)
        }
        if let anomalyDetectorName = anomalyDetectorName {
            try encodeContainer.encode(anomalyDetectorName, forKey: .anomalyDetectorName)
        }
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAnomalyDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateAnomalyDetector"
    }
}

public struct CreateAnomalyDetectorInput: Swift.Equatable {
    /// Contains information about the configuration of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfig?
    /// A description of the detector.
    public var anomalyDetectorDescription: Swift.String?
    /// The name of the detector.
    /// This member is required.
    public var anomalyDetectorName: Swift.String?
    /// The ARN of the KMS key to use to encrypt your data.
    public var kmsKeyArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html) to apply to the anomaly detector.
    public var tags: [Swift.String:Swift.String]?

    public init (
        anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfig? = nil,
        anomalyDetectorDescription: Swift.String? = nil,
        anomalyDetectorName: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.anomalyDetectorConfig = anomalyDetectorConfig
        self.anomalyDetectorDescription = anomalyDetectorDescription
        self.anomalyDetectorName = anomalyDetectorName
        self.kmsKeyArn = kmsKeyArn
        self.tags = tags
    }
}

struct CreateAnomalyDetectorInputBody: Swift.Equatable {
    let anomalyDetectorName: Swift.String?
    let anomalyDetectorDescription: Swift.String?
    let anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfig?
    let kmsKeyArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAnomalyDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorConfig = "AnomalyDetectorConfig"
        case anomalyDetectorDescription = "AnomalyDetectorDescription"
        case anomalyDetectorName = "AnomalyDetectorName"
        case kmsKeyArn = "KmsKeyArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorName)
        anomalyDetectorName = anomalyDetectorNameDecoded
        let anomalyDetectorDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorDescription)
        anomalyDetectorDescription = anomalyDetectorDescriptionDecoded
        let anomalyDetectorConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyDetectorConfig.self, forKey: .anomalyDetectorConfig)
        anomalyDetectorConfig = anomalyDetectorConfigDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAnomalyDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAnomalyDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAnomalyDetectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAnomalyDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAnomalyDetectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyDetectorArn = output.anomalyDetectorArn
        } else {
            self.anomalyDetectorArn = nil
        }
    }
}

public struct CreateAnomalyDetectorOutputResponse: Swift.Equatable {
    /// The ARN of the detector.
    public var anomalyDetectorArn: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

struct CreateAnomalyDetectorOutputResponseBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
}

extension CreateAnomalyDetectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

extension CreateMetricSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case dimensionList = "DimensionList"
        case metricList = "MetricList"
        case metricSetDescription = "MetricSetDescription"
        case metricSetFrequency = "MetricSetFrequency"
        case metricSetName = "MetricSetName"
        case metricSource = "MetricSource"
        case offset = "Offset"
        case tags = "Tags"
        case timestampColumn = "TimestampColumn"
        case timezone = "Timezone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let dimensionList = dimensionList {
            var dimensionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionList)
            for dimensionlist0 in dimensionList {
                try dimensionListContainer.encode(dimensionlist0)
            }
        }
        if let metricList = metricList {
            var metricListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricList)
            for metriclist0 in metricList {
                try metricListContainer.encode(metriclist0)
            }
        }
        if let metricSetDescription = metricSetDescription {
            try encodeContainer.encode(metricSetDescription, forKey: .metricSetDescription)
        }
        if let metricSetFrequency = metricSetFrequency {
            try encodeContainer.encode(metricSetFrequency.rawValue, forKey: .metricSetFrequency)
        }
        if let metricSetName = metricSetName {
            try encodeContainer.encode(metricSetName, forKey: .metricSetName)
        }
        if let metricSource = metricSource {
            try encodeContainer.encode(metricSource, forKey: .metricSource)
        }
        if offset != 0 {
            try encodeContainer.encode(offset, forKey: .offset)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timestampColumn = timestampColumn {
            try encodeContainer.encode(timestampColumn, forKey: .timestampColumn)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
    }
}

extension CreateMetricSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateMetricSet"
    }
}

public struct CreateMetricSetInput: Swift.Equatable {
    /// The ARN of the anomaly detector that will use the dataset.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// A list of the fields you want to treat as dimensions.
    public var dimensionList: [Swift.String]?
    /// A list of metrics that the dataset will contain.
    /// This member is required.
    public var metricList: [LookoutMetricsClientTypes.Metric]?
    /// A description of the dataset you are creating.
    public var metricSetDescription: Swift.String?
    /// The frequency with which the source data will be analyzed for anomalies.
    public var metricSetFrequency: LookoutMetricsClientTypes.Frequency?
    /// The name of the dataset.
    /// This member is required.
    public var metricSetName: Swift.String?
    /// Contains information about how the source data should be interpreted.
    /// This member is required.
    public var metricSource: LookoutMetricsClientTypes.MetricSource?
    /// After an interval ends, the amount of seconds that the detector waits before importing data. Offset is only supported for S3 and Redshift datasources.
    public var offset: Swift.Int
    /// A list of [tags](https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html) to apply to the dataset.
    public var tags: [Swift.String:Swift.String]?
    /// Contains information about the column used for tracking time in your source data.
    public var timestampColumn: LookoutMetricsClientTypes.TimestampColumn?
    /// The time zone in which your source data was recorded.
    public var timezone: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        dimensionList: [Swift.String]? = nil,
        metricList: [LookoutMetricsClientTypes.Metric]? = nil,
        metricSetDescription: Swift.String? = nil,
        metricSetFrequency: LookoutMetricsClientTypes.Frequency? = nil,
        metricSetName: Swift.String? = nil,
        metricSource: LookoutMetricsClientTypes.MetricSource? = nil,
        offset: Swift.Int = 0,
        tags: [Swift.String:Swift.String]? = nil,
        timestampColumn: LookoutMetricsClientTypes.TimestampColumn? = nil,
        timezone: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.dimensionList = dimensionList
        self.metricList = metricList
        self.metricSetDescription = metricSetDescription
        self.metricSetFrequency = metricSetFrequency
        self.metricSetName = metricSetName
        self.metricSource = metricSource
        self.offset = offset
        self.tags = tags
        self.timestampColumn = timestampColumn
        self.timezone = timezone
    }
}

struct CreateMetricSetInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let metricSetName: Swift.String?
    let metricSetDescription: Swift.String?
    let metricList: [LookoutMetricsClientTypes.Metric]?
    let offset: Swift.Int
    let timestampColumn: LookoutMetricsClientTypes.TimestampColumn?
    let dimensionList: [Swift.String]?
    let metricSetFrequency: LookoutMetricsClientTypes.Frequency?
    let metricSource: LookoutMetricsClientTypes.MetricSource?
    let timezone: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateMetricSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case dimensionList = "DimensionList"
        case metricList = "MetricList"
        case metricSetDescription = "MetricSetDescription"
        case metricSetFrequency = "MetricSetFrequency"
        case metricSetName = "MetricSetName"
        case metricSource = "MetricSource"
        case offset = "Offset"
        case tags = "Tags"
        case timestampColumn = "TimestampColumn"
        case timezone = "Timezone"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let metricSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetName)
        metricSetName = metricSetNameDecoded
        let metricSetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetDescription)
        metricSetDescription = metricSetDescriptionDecoded
        let metricListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.Metric?].self, forKey: .metricList)
        var metricListDecoded0:[LookoutMetricsClientTypes.Metric]? = nil
        if let metricListContainer = metricListContainer {
            metricListDecoded0 = [LookoutMetricsClientTypes.Metric]()
            for structure0 in metricListContainer {
                if let structure0 = structure0 {
                    metricListDecoded0?.append(structure0)
                }
            }
        }
        metricList = metricListDecoded0
        let offsetDecoded = try containerValues.decode(Swift.Int.self, forKey: .offset)
        offset = offsetDecoded
        let timestampColumnDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.TimestampColumn.self, forKey: .timestampColumn)
        timestampColumn = timestampColumnDecoded
        let dimensionListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dimensionList)
        var dimensionListDecoded0:[Swift.String]? = nil
        if let dimensionListContainer = dimensionListContainer {
            dimensionListDecoded0 = [Swift.String]()
            for string0 in dimensionListContainer {
                if let string0 = string0 {
                    dimensionListDecoded0?.append(string0)
                }
            }
        }
        dimensionList = dimensionListDecoded0
        let metricSetFrequencyDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.Frequency.self, forKey: .metricSetFrequency)
        metricSetFrequency = metricSetFrequencyDecoded
        let metricSourceDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.MetricSource.self, forKey: .metricSource)
        metricSource = metricSourceDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMetricSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMetricSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMetricSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMetricSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMetricSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metricSetArn = output.metricSetArn
        } else {
            self.metricSetArn = nil
        }
    }
}

public struct CreateMetricSetOutputResponse: Swift.Equatable {
    /// The ARN of the dataset.
    public var metricSetArn: Swift.String?

    public init (
        metricSetArn: Swift.String? = nil
    )
    {
        self.metricSetArn = metricSetArn
    }
}

struct CreateMetricSetOutputResponseBody: Swift.Equatable {
    let metricSetArn: Swift.String?
}

extension CreateMetricSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricSetArn = "MetricSetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetArn)
        metricSetArn = metricSetArnDecoded
    }
}

extension LookoutMetricsClientTypes.CsvFormatDescriptor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case charset = "Charset"
        case containsHeader = "ContainsHeader"
        case delimiter = "Delimiter"
        case fileCompression = "FileCompression"
        case headerList = "HeaderList"
        case quoteSymbol = "QuoteSymbol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let charset = charset {
            try encodeContainer.encode(charset, forKey: .charset)
        }
        if let containsHeader = containsHeader {
            try encodeContainer.encode(containsHeader, forKey: .containsHeader)
        }
        if let delimiter = delimiter {
            try encodeContainer.encode(delimiter, forKey: .delimiter)
        }
        if let fileCompression = fileCompression {
            try encodeContainer.encode(fileCompression.rawValue, forKey: .fileCompression)
        }
        if let headerList = headerList {
            var headerListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .headerList)
            for headerlist0 in headerList {
                try headerListContainer.encode(headerlist0)
            }
        }
        if let quoteSymbol = quoteSymbol {
            try encodeContainer.encode(quoteSymbol, forKey: .quoteSymbol)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileCompressionDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.CSVFileCompression.self, forKey: .fileCompression)
        fileCompression = fileCompressionDecoded
        let charsetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .charset)
        charset = charsetDecoded
        let containsHeaderDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .containsHeader)
        containsHeader = containsHeaderDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let headerListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .headerList)
        var headerListDecoded0:[Swift.String]? = nil
        if let headerListContainer = headerListContainer {
            headerListDecoded0 = [Swift.String]()
            for string0 in headerListContainer {
                if let string0 = string0 {
                    headerListDecoded0?.append(string0)
                }
            }
        }
        headerList = headerListDecoded0
        let quoteSymbolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quoteSymbol)
        quoteSymbol = quoteSymbolDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about how a source CSV data file should be analyzed.
    public struct CsvFormatDescriptor: Swift.Equatable {
        /// The character set in which the source CSV file is written.
        public var charset: Swift.String?
        /// Whether or not the source CSV file contains a header.
        public var containsHeader: Swift.Bool?
        /// The character used to delimit the source CSV file.
        public var delimiter: Swift.String?
        /// The level of compression of the source CSV file.
        public var fileCompression: LookoutMetricsClientTypes.CSVFileCompression?
        /// A list of the source CSV file's headers, if any.
        public var headerList: [Swift.String]?
        /// The character used as a quote character.
        public var quoteSymbol: Swift.String?

        public init (
            charset: Swift.String? = nil,
            containsHeader: Swift.Bool? = nil,
            delimiter: Swift.String? = nil,
            fileCompression: LookoutMetricsClientTypes.CSVFileCompression? = nil,
            headerList: [Swift.String]? = nil,
            quoteSymbol: Swift.String? = nil
        )
        {
            self.charset = charset
            self.containsHeader = containsHeader
            self.delimiter = delimiter
            self.fileCompression = fileCompression
            self.headerList = headerList
            self.quoteSymbol = quoteSymbol
        }
    }

}

extension DeleteAlertInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alertArn = "AlertArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alertArn = alertArn {
            try encodeContainer.encode(alertArn, forKey: .alertArn)
        }
    }
}

extension DeleteAlertInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteAlert"
    }
}

public struct DeleteAlertInput: Swift.Equatable {
    /// The ARN of the alert to delete.
    /// This member is required.
    public var alertArn: Swift.String?

    public init (
        alertArn: Swift.String? = nil
    )
    {
        self.alertArn = alertArn
    }
}

struct DeleteAlertInputBody: Swift.Equatable {
    let alertArn: Swift.String?
}

extension DeleteAlertInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alertArn = "AlertArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertArn)
        alertArn = alertArnDecoded
    }
}

extension DeleteAlertOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAlertOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAlertOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAlertOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAlertOutputResponse: Swift.Equatable {

}

extension DeleteAnomalyDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
    }
}

extension DeleteAnomalyDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteAnomalyDetector"
    }
}

public struct DeleteAnomalyDetectorInput: Swift.Equatable {
    /// The ARN of the detector to delete.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

struct DeleteAnomalyDetectorInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
}

extension DeleteAnomalyDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

extension DeleteAnomalyDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAnomalyDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAnomalyDetectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAnomalyDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAnomalyDetectorOutputResponse: Swift.Equatable {

}

extension DescribeAlertInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alertArn = "AlertArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alertArn = alertArn {
            try encodeContainer.encode(alertArn, forKey: .alertArn)
        }
    }
}

extension DescribeAlertInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeAlert"
    }
}

public struct DescribeAlertInput: Swift.Equatable {
    /// The ARN of the alert to describe.
    /// This member is required.
    public var alertArn: Swift.String?

    public init (
        alertArn: Swift.String? = nil
    )
    {
        self.alertArn = alertArn
    }
}

struct DescribeAlertInputBody: Swift.Equatable {
    let alertArn: Swift.String?
}

extension DescribeAlertInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alertArn = "AlertArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertArn)
        alertArn = alertArnDecoded
    }
}

extension DescribeAlertOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAlertOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAlertOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAlertOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAlertOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alert = output.alert
        } else {
            self.alert = nil
        }
    }
}

public struct DescribeAlertOutputResponse: Swift.Equatable {
    /// Contains information about an alert.
    public var alert: LookoutMetricsClientTypes.Alert?

    public init (
        alert: LookoutMetricsClientTypes.Alert? = nil
    )
    {
        self.alert = alert
    }
}

struct DescribeAlertOutputResponseBody: Swift.Equatable {
    let alert: LookoutMetricsClientTypes.Alert?
}

extension DescribeAlertOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alert = "Alert"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.Alert.self, forKey: .alert)
        alert = alertDecoded
    }
}

extension DescribeAnomalyDetectionExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }
}

extension DescribeAnomalyDetectionExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeAnomalyDetectionExecutions"
    }
}

public struct DescribeAnomalyDetectionExecutionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The timestamp of the anomaly detection job.
    public var timestamp: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        timestamp: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timestamp = timestamp
    }
}

struct DescribeAnomalyDetectionExecutionsInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let timestamp: Swift.String?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeAnomalyDetectionExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timestamp = "Timestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAnomalyDetectionExecutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAnomalyDetectionExecutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAnomalyDetectionExecutionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAnomalyDetectionExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAnomalyDetectionExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.executionList = output.executionList
            self.nextToken = output.nextToken
        } else {
            self.executionList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAnomalyDetectionExecutionsOutputResponse: Swift.Equatable {
    /// A list of detection jobs.
    public var executionList: [LookoutMetricsClientTypes.ExecutionStatus]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        executionList: [LookoutMetricsClientTypes.ExecutionStatus]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.executionList = executionList
        self.nextToken = nextToken
    }
}

struct DescribeAnomalyDetectionExecutionsOutputResponseBody: Swift.Equatable {
    let executionList: [LookoutMetricsClientTypes.ExecutionStatus]?
    let nextToken: Swift.String?
}

extension DescribeAnomalyDetectionExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionList = "ExecutionList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.ExecutionStatus?].self, forKey: .executionList)
        var executionListDecoded0:[LookoutMetricsClientTypes.ExecutionStatus]? = nil
        if let executionListContainer = executionListContainer {
            executionListDecoded0 = [LookoutMetricsClientTypes.ExecutionStatus]()
            for structure0 in executionListContainer {
                if let structure0 = structure0 {
                    executionListDecoded0?.append(structure0)
                }
            }
        }
        executionList = executionListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAnomalyDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
    }
}

extension DescribeAnomalyDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeAnomalyDetector"
    }
}

public struct DescribeAnomalyDetectorInput: Swift.Equatable {
    /// The ARN of the detector to describe.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

struct DescribeAnomalyDetectorInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
}

extension DescribeAnomalyDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

extension DescribeAnomalyDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAnomalyDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAnomalyDetectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAnomalyDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAnomalyDetectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyDetectorArn = output.anomalyDetectorArn
            self.anomalyDetectorConfig = output.anomalyDetectorConfig
            self.anomalyDetectorDescription = output.anomalyDetectorDescription
            self.anomalyDetectorName = output.anomalyDetectorName
            self.creationTime = output.creationTime
            self.failureReason = output.failureReason
            self.kmsKeyArn = output.kmsKeyArn
            self.lastModificationTime = output.lastModificationTime
            self.status = output.status
        } else {
            self.anomalyDetectorArn = nil
            self.anomalyDetectorConfig = nil
            self.anomalyDetectorDescription = nil
            self.anomalyDetectorName = nil
            self.creationTime = nil
            self.failureReason = nil
            self.kmsKeyArn = nil
            self.lastModificationTime = nil
            self.status = nil
        }
    }
}

public struct DescribeAnomalyDetectorOutputResponse: Swift.Equatable {
    /// The ARN of the detector.
    public var anomalyDetectorArn: Swift.String?
    /// Contains information about the detector's configuration.
    public var anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfigSummary?
    /// A description of the detector.
    public var anomalyDetectorDescription: Swift.String?
    /// The name of the detector.
    public var anomalyDetectorName: Swift.String?
    /// The time at which the detector was created.
    public var creationTime: ClientRuntime.Date?
    /// The reason that the detector failed, if any.
    public var failureReason: Swift.String?
    /// The ARN of the KMS key to use to encrypt your data.
    public var kmsKeyArn: Swift.String?
    /// The time at which the detector was last modified.
    public var lastModificationTime: ClientRuntime.Date?
    /// The status of the detector.
    public var status: LookoutMetricsClientTypes.AnomalyDetectorStatus?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfigSummary? = nil,
        anomalyDetectorDescription: Swift.String? = nil,
        anomalyDetectorName: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        failureReason: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        status: LookoutMetricsClientTypes.AnomalyDetectorStatus? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyDetectorConfig = anomalyDetectorConfig
        self.anomalyDetectorDescription = anomalyDetectorDescription
        self.anomalyDetectorName = anomalyDetectorName
        self.creationTime = creationTime
        self.failureReason = failureReason
        self.kmsKeyArn = kmsKeyArn
        self.lastModificationTime = lastModificationTime
        self.status = status
    }
}

struct DescribeAnomalyDetectorOutputResponseBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let anomalyDetectorName: Swift.String?
    let anomalyDetectorDescription: Swift.String?
    let anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfigSummary?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let status: LookoutMetricsClientTypes.AnomalyDetectorStatus?
    let failureReason: Swift.String?
    let kmsKeyArn: Swift.String?
}

extension DescribeAnomalyDetectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyDetectorConfig = "AnomalyDetectorConfig"
        case anomalyDetectorDescription = "AnomalyDetectorDescription"
        case anomalyDetectorName = "AnomalyDetectorName"
        case creationTime = "CreationTime"
        case failureReason = "FailureReason"
        case kmsKeyArn = "KmsKeyArn"
        case lastModificationTime = "LastModificationTime"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let anomalyDetectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorName)
        anomalyDetectorName = anomalyDetectorNameDecoded
        let anomalyDetectorDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorDescription)
        anomalyDetectorDescription = anomalyDetectorDescriptionDecoded
        let anomalyDetectorConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyDetectorConfigSummary.self, forKey: .anomalyDetectorConfig)
        anomalyDetectorConfig = anomalyDetectorConfigDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyDetectorStatus.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension DescribeMetricSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricSetArn = "MetricSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricSetArn = metricSetArn {
            try encodeContainer.encode(metricSetArn, forKey: .metricSetArn)
        }
    }
}

extension DescribeMetricSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeMetricSet"
    }
}

public struct DescribeMetricSetInput: Swift.Equatable {
    /// The ARN of the dataset.
    /// This member is required.
    public var metricSetArn: Swift.String?

    public init (
        metricSetArn: Swift.String? = nil
    )
    {
        self.metricSetArn = metricSetArn
    }
}

struct DescribeMetricSetInputBody: Swift.Equatable {
    let metricSetArn: Swift.String?
}

extension DescribeMetricSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricSetArn = "MetricSetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetArn)
        metricSetArn = metricSetArnDecoded
    }
}

extension DescribeMetricSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMetricSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMetricSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMetricSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMetricSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyDetectorArn = output.anomalyDetectorArn
            self.creationTime = output.creationTime
            self.dimensionList = output.dimensionList
            self.lastModificationTime = output.lastModificationTime
            self.metricList = output.metricList
            self.metricSetArn = output.metricSetArn
            self.metricSetDescription = output.metricSetDescription
            self.metricSetFrequency = output.metricSetFrequency
            self.metricSetName = output.metricSetName
            self.metricSource = output.metricSource
            self.offset = output.offset
            self.timestampColumn = output.timestampColumn
            self.timezone = output.timezone
        } else {
            self.anomalyDetectorArn = nil
            self.creationTime = nil
            self.dimensionList = nil
            self.lastModificationTime = nil
            self.metricList = nil
            self.metricSetArn = nil
            self.metricSetDescription = nil
            self.metricSetFrequency = nil
            self.metricSetName = nil
            self.metricSource = nil
            self.offset = 0
            self.timestampColumn = nil
            self.timezone = nil
        }
    }
}

public struct DescribeMetricSetOutputResponse: Swift.Equatable {
    /// The ARN of the detector that contains the dataset.
    public var anomalyDetectorArn: Swift.String?
    /// The time at which the dataset was created.
    public var creationTime: ClientRuntime.Date?
    /// A list of the dimensions chosen for analysis.
    public var dimensionList: [Swift.String]?
    /// The time at which the dataset was last modified.
    public var lastModificationTime: ClientRuntime.Date?
    /// A list of the metrics defined by the dataset.
    public var metricList: [LookoutMetricsClientTypes.Metric]?
    /// The ARN of the dataset.
    public var metricSetArn: Swift.String?
    /// The dataset's description.
    public var metricSetDescription: Swift.String?
    /// The interval at which the data will be analyzed for anomalies.
    public var metricSetFrequency: LookoutMetricsClientTypes.Frequency?
    /// The name of the dataset.
    public var metricSetName: Swift.String?
    /// Contains information about the dataset's source data.
    public var metricSource: LookoutMetricsClientTypes.MetricSource?
    /// The offset in seconds. Only supported for S3 and Redshift datasources.
    public var offset: Swift.Int
    /// Contains information about the column used for tracking time in your source data.
    public var timestampColumn: LookoutMetricsClientTypes.TimestampColumn?
    /// The time zone in which the dataset's data was recorded.
    public var timezone: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        dimensionList: [Swift.String]? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        metricList: [LookoutMetricsClientTypes.Metric]? = nil,
        metricSetArn: Swift.String? = nil,
        metricSetDescription: Swift.String? = nil,
        metricSetFrequency: LookoutMetricsClientTypes.Frequency? = nil,
        metricSetName: Swift.String? = nil,
        metricSource: LookoutMetricsClientTypes.MetricSource? = nil,
        offset: Swift.Int = 0,
        timestampColumn: LookoutMetricsClientTypes.TimestampColumn? = nil,
        timezone: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.creationTime = creationTime
        self.dimensionList = dimensionList
        self.lastModificationTime = lastModificationTime
        self.metricList = metricList
        self.metricSetArn = metricSetArn
        self.metricSetDescription = metricSetDescription
        self.metricSetFrequency = metricSetFrequency
        self.metricSetName = metricSetName
        self.metricSource = metricSource
        self.offset = offset
        self.timestampColumn = timestampColumn
        self.timezone = timezone
    }
}

struct DescribeMetricSetOutputResponseBody: Swift.Equatable {
    let metricSetArn: Swift.String?
    let anomalyDetectorArn: Swift.String?
    let metricSetName: Swift.String?
    let metricSetDescription: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let offset: Swift.Int
    let metricList: [LookoutMetricsClientTypes.Metric]?
    let timestampColumn: LookoutMetricsClientTypes.TimestampColumn?
    let dimensionList: [Swift.String]?
    let metricSetFrequency: LookoutMetricsClientTypes.Frequency?
    let timezone: Swift.String?
    let metricSource: LookoutMetricsClientTypes.MetricSource?
}

extension DescribeMetricSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case creationTime = "CreationTime"
        case dimensionList = "DimensionList"
        case lastModificationTime = "LastModificationTime"
        case metricList = "MetricList"
        case metricSetArn = "MetricSetArn"
        case metricSetDescription = "MetricSetDescription"
        case metricSetFrequency = "MetricSetFrequency"
        case metricSetName = "MetricSetName"
        case metricSource = "MetricSource"
        case offset = "Offset"
        case timestampColumn = "TimestampColumn"
        case timezone = "Timezone"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetArn)
        metricSetArn = metricSetArnDecoded
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let metricSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetName)
        metricSetName = metricSetNameDecoded
        let metricSetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetDescription)
        metricSetDescription = metricSetDescriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let offsetDecoded = try containerValues.decode(Swift.Int.self, forKey: .offset)
        offset = offsetDecoded
        let metricListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.Metric?].self, forKey: .metricList)
        var metricListDecoded0:[LookoutMetricsClientTypes.Metric]? = nil
        if let metricListContainer = metricListContainer {
            metricListDecoded0 = [LookoutMetricsClientTypes.Metric]()
            for structure0 in metricListContainer {
                if let structure0 = structure0 {
                    metricListDecoded0?.append(structure0)
                }
            }
        }
        metricList = metricListDecoded0
        let timestampColumnDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.TimestampColumn.self, forKey: .timestampColumn)
        timestampColumn = timestampColumnDecoded
        let dimensionListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dimensionList)
        var dimensionListDecoded0:[Swift.String]? = nil
        if let dimensionListContainer = dimensionListContainer {
            dimensionListDecoded0 = [Swift.String]()
            for string0 in dimensionListContainer {
                if let string0 = string0 {
                    dimensionListDecoded0?.append(string0)
                }
            }
        }
        dimensionList = dimensionListDecoded0
        let metricSetFrequencyDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.Frequency.self, forKey: .metricSetFrequency)
        metricSetFrequency = metricSetFrequencyDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let metricSourceDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.MetricSource.self, forKey: .metricSource)
        metricSource = metricSourceDecoded
    }
}

extension LookoutMetricsClientTypes.DimensionContribution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionName = "DimensionName"
        case dimensionValueContributionList = "DimensionValueContributionList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionName = dimensionName {
            try encodeContainer.encode(dimensionName, forKey: .dimensionName)
        }
        if let dimensionValueContributionList = dimensionValueContributionList {
            var dimensionValueContributionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionValueContributionList)
            for dimensionvaluecontributionlist0 in dimensionValueContributionList {
                try dimensionValueContributionListContainer.encode(dimensionvaluecontributionlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionName)
        dimensionName = dimensionNameDecoded
        let dimensionValueContributionListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.DimensionValueContribution?].self, forKey: .dimensionValueContributionList)
        var dimensionValueContributionListDecoded0:[LookoutMetricsClientTypes.DimensionValueContribution]? = nil
        if let dimensionValueContributionListContainer = dimensionValueContributionListContainer {
            dimensionValueContributionListDecoded0 = [LookoutMetricsClientTypes.DimensionValueContribution]()
            for structure0 in dimensionValueContributionListContainer {
                if let structure0 = structure0 {
                    dimensionValueContributionListDecoded0?.append(structure0)
                }
            }
        }
        dimensionValueContributionList = dimensionValueContributionListDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// Details about a dimension that contributed to an anomaly.
    public struct DimensionContribution: Swift.Equatable {
        /// The name of the dimension.
        public var dimensionName: Swift.String?
        /// A list of dimension values that contributed to the anomaly.
        public var dimensionValueContributionList: [LookoutMetricsClientTypes.DimensionValueContribution]?

        public init (
            dimensionName: Swift.String? = nil,
            dimensionValueContributionList: [LookoutMetricsClientTypes.DimensionValueContribution]? = nil
        )
        {
            self.dimensionName = dimensionName
            self.dimensionValueContributionList = dimensionValueContributionList
        }
    }

}

extension LookoutMetricsClientTypes.DimensionNameValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionName = "DimensionName"
        case dimensionValue = "DimensionValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionName = dimensionName {
            try encodeContainer.encode(dimensionName, forKey: .dimensionName)
        }
        if let dimensionValue = dimensionValue {
            try encodeContainer.encode(dimensionValue, forKey: .dimensionValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionName)
        dimensionName = dimensionNameDecoded
        let dimensionValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionValue)
        dimensionValue = dimensionValueDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// A dimension name and value.
    public struct DimensionNameValue: Swift.Equatable {
        /// The name of the dimension.
        /// This member is required.
        public var dimensionName: Swift.String?
        /// The value of the dimension.
        /// This member is required.
        public var dimensionValue: Swift.String?

        public init (
            dimensionName: Swift.String? = nil,
            dimensionValue: Swift.String? = nil
        )
        {
            self.dimensionName = dimensionName
            self.dimensionValue = dimensionValue
        }
    }

}

extension LookoutMetricsClientTypes.DimensionValueContribution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contributionScore = "ContributionScore"
        case dimensionValue = "DimensionValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contributionScore = contributionScore {
            try encodeContainer.encode(contributionScore, forKey: .contributionScore)
        }
        if let dimensionValue = dimensionValue {
            try encodeContainer.encode(dimensionValue, forKey: .dimensionValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionValue)
        dimensionValue = dimensionValueDecoded
        let contributionScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .contributionScore)
        contributionScore = contributionScoreDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// The severity of a value of a dimension that contributed to an anomaly.
    public struct DimensionValueContribution: Swift.Equatable {
        /// The severity score of the value.
        public var contributionScore: Swift.Double?
        /// The value of the dimension.
        public var dimensionValue: Swift.String?

        public init (
            contributionScore: Swift.Double? = nil,
            dimensionValue: Swift.String? = nil
        )
        {
            self.contributionScore = contributionScore
            self.dimensionValue = dimensionValue
        }
    }

}

extension LookoutMetricsClientTypes.ExecutionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureReason = "FailureReason"
        case status = "Status"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyDetectionTaskStatus.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// The status of an anomaly detector run.
    public struct ExecutionStatus: Swift.Equatable {
        /// The reason that the run failed, if applicable.
        public var failureReason: Swift.String?
        /// The run's status.
        public var status: LookoutMetricsClientTypes.AnomalyDetectionTaskStatus?
        /// The run's timestamp.
        public var timestamp: Swift.String?

        public init (
            failureReason: Swift.String? = nil,
            status: LookoutMetricsClientTypes.AnomalyDetectionTaskStatus? = nil,
            timestamp: Swift.String? = nil
        )
        {
            self.failureReason = failureReason
            self.status = status
            self.timestamp = timestamp
        }
    }

}

extension LookoutMetricsClientTypes.FileFormatDescriptor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csvFormatDescriptor = "CsvFormatDescriptor"
        case jsonFormatDescriptor = "JsonFormatDescriptor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csvFormatDescriptor = csvFormatDescriptor {
            try encodeContainer.encode(csvFormatDescriptor, forKey: .csvFormatDescriptor)
        }
        if let jsonFormatDescriptor = jsonFormatDescriptor {
            try encodeContainer.encode(jsonFormatDescriptor, forKey: .jsonFormatDescriptor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let csvFormatDescriptorDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.CsvFormatDescriptor.self, forKey: .csvFormatDescriptor)
        csvFormatDescriptor = csvFormatDescriptorDecoded
        let jsonFormatDescriptorDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.JsonFormatDescriptor.self, forKey: .jsonFormatDescriptor)
        jsonFormatDescriptor = jsonFormatDescriptorDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about a source file's formatting.
    public struct FileFormatDescriptor: Swift.Equatable {
        /// Contains information about how a source CSV data file should be analyzed.
        public var csvFormatDescriptor: LookoutMetricsClientTypes.CsvFormatDescriptor?
        /// Contains information about how a source JSON data file should be analyzed.
        public var jsonFormatDescriptor: LookoutMetricsClientTypes.JsonFormatDescriptor?

        public init (
            csvFormatDescriptor: LookoutMetricsClientTypes.CsvFormatDescriptor? = nil,
            jsonFormatDescriptor: LookoutMetricsClientTypes.JsonFormatDescriptor? = nil
        )
        {
            self.csvFormatDescriptor = csvFormatDescriptor
            self.jsonFormatDescriptor = jsonFormatDescriptor
        }
    }

}

extension LookoutMetricsClientTypes {
    public enum Frequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case p1d
        case pt10m
        case pt1h
        case pt5m
        case sdkUnknown(Swift.String)

        public static var allCases: [Frequency] {
            return [
                .p1d,
                .pt10m,
                .pt1h,
                .pt5m,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .p1d: return "P1D"
            case .pt10m: return "PT10M"
            case .pt1h: return "PT1H"
            case .pt5m: return "PT5M"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Frequency(rawValue: rawValue) ?? Frequency.sdkUnknown(rawValue)
        }
    }
}

extension GetAnomalyGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupId = "AnomalyGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let anomalyGroupId = anomalyGroupId {
            try encodeContainer.encode(anomalyGroupId, forKey: .anomalyGroupId)
        }
    }
}

extension GetAnomalyGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetAnomalyGroup"
    }
}

public struct GetAnomalyGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// The ID of the anomaly group.
    /// This member is required.
    public var anomalyGroupId: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        anomalyGroupId: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyGroupId = anomalyGroupId
    }
}

struct GetAnomalyGroupInputBody: Swift.Equatable {
    let anomalyGroupId: Swift.String?
    let anomalyDetectorArn: Swift.String?
}

extension GetAnomalyGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupId = "AnomalyGroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

extension GetAnomalyGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAnomalyGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAnomalyGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAnomalyGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAnomalyGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyGroup = output.anomalyGroup
        } else {
            self.anomalyGroup = nil
        }
    }
}

public struct GetAnomalyGroupOutputResponse: Swift.Equatable {
    /// Details about the anomaly group.
    public var anomalyGroup: LookoutMetricsClientTypes.AnomalyGroup?

    public init (
        anomalyGroup: LookoutMetricsClientTypes.AnomalyGroup? = nil
    )
    {
        self.anomalyGroup = anomalyGroup
    }
}

struct GetAnomalyGroupOutputResponseBody: Swift.Equatable {
    let anomalyGroup: LookoutMetricsClientTypes.AnomalyGroup?
}

extension GetAnomalyGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyGroup = "AnomalyGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyGroup.self, forKey: .anomalyGroup)
        anomalyGroup = anomalyGroupDecoded
    }
}

extension GetFeedbackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback {
            try encodeContainer.encode(anomalyGroupTimeSeriesFeedback, forKey: .anomalyGroupTimeSeriesFeedback)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetFeedbackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetFeedback"
    }
}

public struct GetFeedbackInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// The anomalous metric and group ID.
    /// This member is required.
    public var anomalyGroupTimeSeriesFeedback: LookoutMetricsClientTypes.AnomalyGroupTimeSeries?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        anomalyGroupTimeSeriesFeedback: LookoutMetricsClientTypes.AnomalyGroupTimeSeries? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetFeedbackInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let anomalyGroupTimeSeriesFeedback: LookoutMetricsClientTypes.AnomalyGroupTimeSeries?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension GetFeedbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let anomalyGroupTimeSeriesFeedbackDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyGroupTimeSeries.self, forKey: .anomalyGroupTimeSeriesFeedback)
        anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedbackDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetFeedbackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFeedbackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFeedbackOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFeedbackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFeedbackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyGroupTimeSeriesFeedback = output.anomalyGroupTimeSeriesFeedback
            self.nextToken = output.nextToken
        } else {
            self.anomalyGroupTimeSeriesFeedback = nil
            self.nextToken = nil
        }
    }
}

public struct GetFeedbackOutputResponse: Swift.Equatable {
    /// Feedback for an anomalous metric.
    public var anomalyGroupTimeSeriesFeedback: [LookoutMetricsClientTypes.TimeSeriesFeedback]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        anomalyGroupTimeSeriesFeedback: [LookoutMetricsClientTypes.TimeSeriesFeedback]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback
        self.nextToken = nextToken
    }
}

struct GetFeedbackOutputResponseBody: Swift.Equatable {
    let anomalyGroupTimeSeriesFeedback: [LookoutMetricsClientTypes.TimeSeriesFeedback]?
    let nextToken: Swift.String?
}

extension GetFeedbackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupTimeSeriesFeedbackContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.TimeSeriesFeedback?].self, forKey: .anomalyGroupTimeSeriesFeedback)
        var anomalyGroupTimeSeriesFeedbackDecoded0:[LookoutMetricsClientTypes.TimeSeriesFeedback]? = nil
        if let anomalyGroupTimeSeriesFeedbackContainer = anomalyGroupTimeSeriesFeedbackContainer {
            anomalyGroupTimeSeriesFeedbackDecoded0 = [LookoutMetricsClientTypes.TimeSeriesFeedback]()
            for structure0 in anomalyGroupTimeSeriesFeedbackContainer {
                if let structure0 = structure0 {
                    anomalyGroupTimeSeriesFeedbackDecoded0?.append(structure0)
                }
            }
        }
        anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedbackDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetSampleDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3SourceConfig = "S3SourceConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3SourceConfig = s3SourceConfig {
            try encodeContainer.encode(s3SourceConfig, forKey: .s3SourceConfig)
        }
    }
}

extension GetSampleDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetSampleData"
    }
}

public struct GetSampleDataInput: Swift.Equatable {
    /// A datasource bucket in Amazon S3.
    public var s3SourceConfig: LookoutMetricsClientTypes.SampleDataS3SourceConfig?

    public init (
        s3SourceConfig: LookoutMetricsClientTypes.SampleDataS3SourceConfig? = nil
    )
    {
        self.s3SourceConfig = s3SourceConfig
    }
}

struct GetSampleDataInputBody: Swift.Equatable {
    let s3SourceConfig: LookoutMetricsClientTypes.SampleDataS3SourceConfig?
}

extension GetSampleDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3SourceConfig = "S3SourceConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3SourceConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.SampleDataS3SourceConfig.self, forKey: .s3SourceConfig)
        s3SourceConfig = s3SourceConfigDecoded
    }
}

extension GetSampleDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSampleDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSampleDataOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSampleDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSampleDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.headerValues = output.headerValues
            self.sampleRows = output.sampleRows
        } else {
            self.headerValues = nil
            self.sampleRows = nil
        }
    }
}

public struct GetSampleDataOutputResponse: Swift.Equatable {
    /// A list of header labels for the records.
    public var headerValues: [Swift.String]?
    /// A list of records.
    public var sampleRows: [[Swift.String]]?

    public init (
        headerValues: [Swift.String]? = nil,
        sampleRows: [[Swift.String]]? = nil
    )
    {
        self.headerValues = headerValues
        self.sampleRows = sampleRows
    }
}

struct GetSampleDataOutputResponseBody: Swift.Equatable {
    let headerValues: [Swift.String]?
    let sampleRows: [[Swift.String]]?
}

extension GetSampleDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerValues = "HeaderValues"
        case sampleRows = "SampleRows"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .headerValues)
        var headerValuesDecoded0:[Swift.String]? = nil
        if let headerValuesContainer = headerValuesContainer {
            headerValuesDecoded0 = [Swift.String]()
            for string0 in headerValuesContainer {
                if let string0 = string0 {
                    headerValuesDecoded0?.append(string0)
                }
            }
        }
        headerValues = headerValuesDecoded0
        let sampleRowsContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .sampleRows)
        var sampleRowsDecoded0:[[Swift.String]]? = nil
        if let sampleRowsContainer = sampleRowsContainer {
            sampleRowsDecoded0 = [[Swift.String]]()
            for list0 in sampleRowsContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    sampleRowsDecoded0?.append(list0Decoded0)
                }
            }
        }
        sampleRows = sampleRowsDecoded0
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request processing has failed because of an unknown error, exception, or failure.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LookoutMetricsClientTypes.ItemizedMetricStats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricName = "MetricName"
        case occurrenceCount = "OccurrenceCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if occurrenceCount != 0 {
            try encodeContainer.encode(occurrenceCount, forKey: .occurrenceCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let occurrenceCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .occurrenceCount)
        occurrenceCount = occurrenceCountDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Aggregated statistics about a measure affected by an anomaly.
    public struct ItemizedMetricStats: Swift.Equatable {
        /// The name of the measure.
        public var metricName: Swift.String?
        /// The number of times that the measure appears.
        public var occurrenceCount: Swift.Int

        public init (
            metricName: Swift.String? = nil,
            occurrenceCount: Swift.Int = 0
        )
        {
            self.metricName = metricName
            self.occurrenceCount = occurrenceCount
        }
    }

}

extension LookoutMetricsClientTypes {
    public enum JsonFileCompression: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gzip
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [JsonFileCompression] {
            return [
                .gzip,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "GZIP"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JsonFileCompression(rawValue: rawValue) ?? JsonFileCompression.sdkUnknown(rawValue)
        }
    }
}

extension LookoutMetricsClientTypes.JsonFormatDescriptor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case charset = "Charset"
        case fileCompression = "FileCompression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let charset = charset {
            try encodeContainer.encode(charset, forKey: .charset)
        }
        if let fileCompression = fileCompression {
            try encodeContainer.encode(fileCompression.rawValue, forKey: .fileCompression)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileCompressionDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.JsonFileCompression.self, forKey: .fileCompression)
        fileCompression = fileCompressionDecoded
        let charsetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .charset)
        charset = charsetDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about how a source JSON data file should be analyzed.
    public struct JsonFormatDescriptor: Swift.Equatable {
        /// The character set in which the source JSON file is written.
        public var charset: Swift.String?
        /// The level of compression of the source CSV file.
        public var fileCompression: LookoutMetricsClientTypes.JsonFileCompression?

        public init (
            charset: Swift.String? = nil,
            fileCompression: LookoutMetricsClientTypes.JsonFileCompression? = nil
        )
        {
            self.charset = charset
            self.fileCompression = fileCompression
        }
    }

}

extension LookoutMetricsClientTypes.LambdaConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaArn = "LambdaArn"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaArn = lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let lambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about a Lambda configuration.
    public struct LambdaConfiguration: Swift.Equatable {
        /// The ARN of the Lambda function.
        /// This member is required.
        public var lambdaArn: Swift.String?
        /// The ARN of an IAM role that has permission to invoke the Lambda function.
        /// This member is required.
        public var roleArn: Swift.String?

        public init (
            lambdaArn: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.lambdaArn = lambdaArn
            self.roleArn = roleArn
        }
    }

}

extension ListAlertsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAlertsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListAlerts"
    }
}

public struct ListAlertsInput: Swift.Equatable {
    /// The ARN of the alert's detector.
    public var anomalyDetectorArn: Swift.String?
    /// The maximum number of results that will be displayed by the request.
    public var maxResults: Swift.Int
    /// If the result of the previous request is truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAlertsInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListAlertsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAlertsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAlertsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAlertsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAlertsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAlertsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alertSummaryList = output.alertSummaryList
            self.nextToken = output.nextToken
        } else {
            self.alertSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAlertsOutputResponse: Swift.Equatable {
    /// Contains information about an alert.
    public var alertSummaryList: [LookoutMetricsClientTypes.AlertSummary]?
    /// If the response is truncated, the service returns this token. To retrieve the next set of results, use this token in the next request.
    public var nextToken: Swift.String?

    public init (
        alertSummaryList: [LookoutMetricsClientTypes.AlertSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alertSummaryList = alertSummaryList
        self.nextToken = nextToken
    }
}

struct ListAlertsOutputResponseBody: Swift.Equatable {
    let alertSummaryList: [LookoutMetricsClientTypes.AlertSummary]?
    let nextToken: Swift.String?
}

extension ListAlertsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alertSummaryList = "AlertSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertSummaryListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.AlertSummary?].self, forKey: .alertSummaryList)
        var alertSummaryListDecoded0:[LookoutMetricsClientTypes.AlertSummary]? = nil
        if let alertSummaryListContainer = alertSummaryListContainer {
            alertSummaryListDecoded0 = [LookoutMetricsClientTypes.AlertSummary]()
            for structure0 in alertSummaryListContainer {
                if let structure0 = structure0 {
                    alertSummaryListDecoded0?.append(structure0)
                }
            }
        }
        alertSummaryList = alertSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnomalyDetectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAnomalyDetectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListAnomalyDetectors"
    }
}

public struct ListAnomalyDetectorsInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAnomalyDetectorsInputBody: Swift.Equatable {
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension ListAnomalyDetectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnomalyDetectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnomalyDetectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAnomalyDetectorsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnomalyDetectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAnomalyDetectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyDetectorSummaryList = output.anomalyDetectorSummaryList
            self.nextToken = output.nextToken
        } else {
            self.anomalyDetectorSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAnomalyDetectorsOutputResponse: Swift.Equatable {
    /// A list of anomaly detectors in the account in the current region.
    public var anomalyDetectorSummaryList: [LookoutMetricsClientTypes.AnomalyDetectorSummary]?
    /// If the response is truncated, the service returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        anomalyDetectorSummaryList: [LookoutMetricsClientTypes.AnomalyDetectorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyDetectorSummaryList = anomalyDetectorSummaryList
        self.nextToken = nextToken
    }
}

struct ListAnomalyDetectorsOutputResponseBody: Swift.Equatable {
    let anomalyDetectorSummaryList: [LookoutMetricsClientTypes.AnomalyDetectorSummary]?
    let nextToken: Swift.String?
}

extension ListAnomalyDetectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorSummaryList = "AnomalyDetectorSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorSummaryListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.AnomalyDetectorSummary?].self, forKey: .anomalyDetectorSummaryList)
        var anomalyDetectorSummaryListDecoded0:[LookoutMetricsClientTypes.AnomalyDetectorSummary]? = nil
        if let anomalyDetectorSummaryListContainer = anomalyDetectorSummaryListContainer {
            anomalyDetectorSummaryListDecoded0 = [LookoutMetricsClientTypes.AnomalyDetectorSummary]()
            for structure0 in anomalyDetectorSummaryListContainer {
                if let structure0 = structure0 {
                    anomalyDetectorSummaryListDecoded0?.append(structure0)
                }
            }
        }
        anomalyDetectorSummaryList = anomalyDetectorSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnomalyGroupSummariesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sensitivityThreshold = "SensitivityThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if sensitivityThreshold != 0 {
            try encodeContainer.encode(sensitivityThreshold, forKey: .sensitivityThreshold)
        }
    }
}

extension ListAnomalyGroupSummariesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListAnomalyGroupSummaries"
    }
}

public struct ListAnomalyGroupSummariesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The minimum severity score for inclusion in the output.
    /// This member is required.
    public var sensitivityThreshold: Swift.Int

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        sensitivityThreshold: Swift.Int = 0
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sensitivityThreshold = sensitivityThreshold
    }
}

struct ListAnomalyGroupSummariesInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let sensitivityThreshold: Swift.Int
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension ListAnomalyGroupSummariesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sensitivityThreshold = "SensitivityThreshold"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let sensitivityThresholdDecoded = try containerValues.decode(Swift.Int.self, forKey: .sensitivityThreshold)
        sensitivityThreshold = sensitivityThresholdDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnomalyGroupSummariesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnomalyGroupSummariesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAnomalyGroupSummariesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnomalyGroupSummariesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAnomalyGroupSummariesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyGroupStatistics = output.anomalyGroupStatistics
            self.anomalyGroupSummaryList = output.anomalyGroupSummaryList
            self.nextToken = output.nextToken
        } else {
            self.anomalyGroupStatistics = nil
            self.anomalyGroupSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAnomalyGroupSummariesOutputResponse: Swift.Equatable {
    /// Aggregated details about the anomaly groups.
    public var anomalyGroupStatistics: LookoutMetricsClientTypes.AnomalyGroupStatistics?
    /// A list of anomaly group summaries.
    public var anomalyGroupSummaryList: [LookoutMetricsClientTypes.AnomalyGroupSummary]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        anomalyGroupStatistics: LookoutMetricsClientTypes.AnomalyGroupStatistics? = nil,
        anomalyGroupSummaryList: [LookoutMetricsClientTypes.AnomalyGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyGroupStatistics = anomalyGroupStatistics
        self.anomalyGroupSummaryList = anomalyGroupSummaryList
        self.nextToken = nextToken
    }
}

struct ListAnomalyGroupSummariesOutputResponseBody: Swift.Equatable {
    let anomalyGroupSummaryList: [LookoutMetricsClientTypes.AnomalyGroupSummary]?
    let anomalyGroupStatistics: LookoutMetricsClientTypes.AnomalyGroupStatistics?
    let nextToken: Swift.String?
}

extension ListAnomalyGroupSummariesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyGroupStatistics = "AnomalyGroupStatistics"
        case anomalyGroupSummaryList = "AnomalyGroupSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupSummaryListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.AnomalyGroupSummary?].self, forKey: .anomalyGroupSummaryList)
        var anomalyGroupSummaryListDecoded0:[LookoutMetricsClientTypes.AnomalyGroupSummary]? = nil
        if let anomalyGroupSummaryListContainer = anomalyGroupSummaryListContainer {
            anomalyGroupSummaryListDecoded0 = [LookoutMetricsClientTypes.AnomalyGroupSummary]()
            for structure0 in anomalyGroupSummaryListContainer {
                if let structure0 = structure0 {
                    anomalyGroupSummaryListDecoded0?.append(structure0)
                }
            }
        }
        anomalyGroupSummaryList = anomalyGroupSummaryListDecoded0
        let anomalyGroupStatisticsDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyGroupStatistics.self, forKey: .anomalyGroupStatistics)
        anomalyGroupStatistics = anomalyGroupStatisticsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnomalyGroupTimeSeriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupId = "AnomalyGroupId"
        case maxResults = "MaxResults"
        case metricName = "MetricName"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let anomalyGroupId = anomalyGroupId {
            try encodeContainer.encode(anomalyGroupId, forKey: .anomalyGroupId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAnomalyGroupTimeSeriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListAnomalyGroupTimeSeries"
    }
}

public struct ListAnomalyGroupTimeSeriesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// The ID of the anomaly group.
    /// This member is required.
    public var anomalyGroupId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int
    /// The name of the measure field.
    /// This member is required.
    public var metricName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        anomalyGroupId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        metricName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyGroupId = anomalyGroupId
        self.maxResults = maxResults
        self.metricName = metricName
        self.nextToken = nextToken
    }
}

struct ListAnomalyGroupTimeSeriesInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let anomalyGroupId: Swift.String?
    let metricName: Swift.String?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension ListAnomalyGroupTimeSeriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupId = "AnomalyGroupId"
        case maxResults = "MaxResults"
        case metricName = "MetricName"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnomalyGroupTimeSeriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnomalyGroupTimeSeriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAnomalyGroupTimeSeriesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnomalyGroupTimeSeriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAnomalyGroupTimeSeriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyGroupId = output.anomalyGroupId
            self.metricName = output.metricName
            self.nextToken = output.nextToken
            self.timeSeriesList = output.timeSeriesList
            self.timestampList = output.timestampList
        } else {
            self.anomalyGroupId = nil
            self.metricName = nil
            self.nextToken = nil
            self.timeSeriesList = nil
            self.timestampList = nil
        }
    }
}

public struct ListAnomalyGroupTimeSeriesOutputResponse: Swift.Equatable {
    /// The ID of the anomaly group.
    public var anomalyGroupId: Swift.String?
    /// The name of the measure field.
    public var metricName: Swift.String?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of anomalous metrics.
    public var timeSeriesList: [LookoutMetricsClientTypes.TimeSeries]?
    /// Timestamps for the anomalous metrics.
    public var timestampList: [Swift.String]?

    public init (
        anomalyGroupId: Swift.String? = nil,
        metricName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        timeSeriesList: [LookoutMetricsClientTypes.TimeSeries]? = nil,
        timestampList: [Swift.String]? = nil
    )
    {
        self.anomalyGroupId = anomalyGroupId
        self.metricName = metricName
        self.nextToken = nextToken
        self.timeSeriesList = timeSeriesList
        self.timestampList = timestampList
    }
}

struct ListAnomalyGroupTimeSeriesOutputResponseBody: Swift.Equatable {
    let anomalyGroupId: Swift.String?
    let metricName: Swift.String?
    let timestampList: [Swift.String]?
    let nextToken: Swift.String?
    let timeSeriesList: [LookoutMetricsClientTypes.TimeSeries]?
}

extension ListAnomalyGroupTimeSeriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyGroupId = "AnomalyGroupId"
        case metricName = "MetricName"
        case nextToken = "NextToken"
        case timeSeriesList = "TimeSeriesList"
        case timestampList = "TimestampList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let timestampListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .timestampList)
        var timestampListDecoded0:[Swift.String]? = nil
        if let timestampListContainer = timestampListContainer {
            timestampListDecoded0 = [Swift.String]()
            for string0 in timestampListContainer {
                if let string0 = string0 {
                    timestampListDecoded0?.append(string0)
                }
            }
        }
        timestampList = timestampListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let timeSeriesListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.TimeSeries?].self, forKey: .timeSeriesList)
        var timeSeriesListDecoded0:[LookoutMetricsClientTypes.TimeSeries]? = nil
        if let timeSeriesListContainer = timeSeriesListContainer {
            timeSeriesListDecoded0 = [LookoutMetricsClientTypes.TimeSeries]()
            for structure0 in timeSeriesListContainer {
                if let structure0 = structure0 {
                    timeSeriesListDecoded0?.append(structure0)
                }
            }
        }
        timeSeriesList = timeSeriesListDecoded0
    }
}

extension ListMetricSetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMetricSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListMetricSets"
    }
}

public struct ListMetricSetsInput: Swift.Equatable {
    /// The ARN of the anomaly detector containing the metrics sets to list.
    public var anomalyDetectorArn: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMetricSetsInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension ListMetricSetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMetricSetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMetricSetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMetricSetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMetricSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMetricSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metricSetSummaryList = output.metricSetSummaryList
            self.nextToken = output.nextToken
        } else {
            self.metricSetSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListMetricSetsOutputResponse: Swift.Equatable {
    /// A list of the datasets in the AWS Region, with configuration details for each.
    public var metricSetSummaryList: [LookoutMetricsClientTypes.MetricSetSummary]?
    /// If the response is truncated, the list call returns this token. To retrieve the next set of results, use the token in the next list request.
    public var nextToken: Swift.String?

    public init (
        metricSetSummaryList: [LookoutMetricsClientTypes.MetricSetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metricSetSummaryList = metricSetSummaryList
        self.nextToken = nextToken
    }
}

struct ListMetricSetsOutputResponseBody: Swift.Equatable {
    let metricSetSummaryList: [LookoutMetricsClientTypes.MetricSetSummary]?
    let nextToken: Swift.String?
}

extension ListMetricSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricSetSummaryList = "MetricSetSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetSummaryListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.MetricSetSummary?].self, forKey: .metricSetSummaryList)
        var metricSetSummaryListDecoded0:[LookoutMetricsClientTypes.MetricSetSummary]? = nil
        if let metricSetSummaryListContainer = metricSetSummaryListContainer {
            metricSetSummaryListDecoded0 = [LookoutMetricsClientTypes.MetricSetSummary]()
            for structure0 in metricSetSummaryListContainer {
                if let structure0 = structure0 {
                    metricSetSummaryListDecoded0?.append(structure0)
                }
            }
        }
        metricSetSummaryList = metricSetSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The resource's tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LookoutMetricsClientTypes.Metric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationFunction = "AggregationFunction"
        case metricName = "MetricName"
        case namespace = "Namespace"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationFunction = aggregationFunction {
            try encodeContainer.encode(aggregationFunction.rawValue, forKey: .aggregationFunction)
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let aggregationFunctionDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AggregationFunction.self, forKey: .aggregationFunction)
        aggregationFunction = aggregationFunctionDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// A calculation made by contrasting a measure and a dimension from your source data.
    public struct Metric: Swift.Equatable {
        /// The function with which the metric is calculated.
        /// This member is required.
        public var aggregationFunction: LookoutMetricsClientTypes.AggregationFunction?
        /// The name of the metric.
        /// This member is required.
        public var metricName: Swift.String?
        /// The namespace for the metric.
        public var namespace: Swift.String?

        public init (
            aggregationFunction: LookoutMetricsClientTypes.AggregationFunction? = nil,
            metricName: Swift.String? = nil,
            namespace: Swift.String? = nil
        )
        {
            self.aggregationFunction = aggregationFunction
            self.metricName = metricName
            self.namespace = namespace
        }
    }

}

extension LookoutMetricsClientTypes.MetricLevelImpact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contributionMatrix = "ContributionMatrix"
        case metricName = "MetricName"
        case numTimeSeries = "NumTimeSeries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contributionMatrix = contributionMatrix {
            try encodeContainer.encode(contributionMatrix, forKey: .contributionMatrix)
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if numTimeSeries != 0 {
            try encodeContainer.encode(numTimeSeries, forKey: .numTimeSeries)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let numTimeSeriesDecoded = try containerValues.decode(Swift.Int.self, forKey: .numTimeSeries)
        numTimeSeries = numTimeSeriesDecoded
        let contributionMatrixDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.ContributionMatrix.self, forKey: .contributionMatrix)
        contributionMatrix = contributionMatrixDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Details about a measure affected by an anomaly.
    public struct MetricLevelImpact: Swift.Equatable {
        /// Details about the dimensions that contributed to the anomaly.
        public var contributionMatrix: LookoutMetricsClientTypes.ContributionMatrix?
        /// The name of the measure.
        public var metricName: Swift.String?
        /// The number of anomalous metrics for the measure.
        public var numTimeSeries: Swift.Int

        public init (
            contributionMatrix: LookoutMetricsClientTypes.ContributionMatrix? = nil,
            metricName: Swift.String? = nil,
            numTimeSeries: Swift.Int = 0
        )
        {
            self.contributionMatrix = contributionMatrix
            self.metricName = metricName
            self.numTimeSeries = numTimeSeries
        }
    }

}

extension LookoutMetricsClientTypes.MetricSetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case creationTime = "CreationTime"
        case lastModificationTime = "LastModificationTime"
        case metricSetArn = "MetricSetArn"
        case metricSetDescription = "MetricSetDescription"
        case metricSetName = "MetricSetName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let metricSetArn = metricSetArn {
            try encodeContainer.encode(metricSetArn, forKey: .metricSetArn)
        }
        if let metricSetDescription = metricSetDescription {
            try encodeContainer.encode(metricSetDescription, forKey: .metricSetDescription)
        }
        if let metricSetName = metricSetName {
            try encodeContainer.encode(metricSetName, forKey: .metricSetName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetArn)
        metricSetArn = metricSetArnDecoded
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let metricSetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetDescription)
        metricSetDescription = metricSetDescriptionDecoded
        let metricSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetName)
        metricSetName = metricSetNameDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about a dataset.
    public struct MetricSetSummary: Swift.Equatable {
        /// The ARN of the detector to which the dataset belongs.
        public var anomalyDetectorArn: Swift.String?
        /// The time at which the dataset was created.
        public var creationTime: ClientRuntime.Date?
        /// The time at which the dataset was last modified.
        public var lastModificationTime: ClientRuntime.Date?
        /// The ARN of the dataset.
        public var metricSetArn: Swift.String?
        /// The description of the dataset.
        public var metricSetDescription: Swift.String?
        /// The name of the dataset.
        public var metricSetName: Swift.String?
        /// The dataset's [tags](https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html).
        public var tags: [Swift.String:Swift.String]?

        public init (
            anomalyDetectorArn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            metricSetArn: Swift.String? = nil,
            metricSetDescription: Swift.String? = nil,
            metricSetName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.metricSetArn = metricSetArn
            self.metricSetDescription = metricSetDescription
            self.metricSetName = metricSetName
            self.tags = tags
        }
    }

}

extension LookoutMetricsClientTypes.MetricSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appFlowConfig = "AppFlowConfig"
        case cloudWatchConfig = "CloudWatchConfig"
        case rDSSourceConfig = "RDSSourceConfig"
        case redshiftSourceConfig = "RedshiftSourceConfig"
        case s3SourceConfig = "S3SourceConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appFlowConfig = appFlowConfig {
            try encodeContainer.encode(appFlowConfig, forKey: .appFlowConfig)
        }
        if let cloudWatchConfig = cloudWatchConfig {
            try encodeContainer.encode(cloudWatchConfig, forKey: .cloudWatchConfig)
        }
        if let rDSSourceConfig = rDSSourceConfig {
            try encodeContainer.encode(rDSSourceConfig, forKey: .rDSSourceConfig)
        }
        if let redshiftSourceConfig = redshiftSourceConfig {
            try encodeContainer.encode(redshiftSourceConfig, forKey: .redshiftSourceConfig)
        }
        if let s3SourceConfig = s3SourceConfig {
            try encodeContainer.encode(s3SourceConfig, forKey: .s3SourceConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3SourceConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.S3SourceConfig.self, forKey: .s3SourceConfig)
        s3SourceConfig = s3SourceConfigDecoded
        let appFlowConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AppFlowConfig.self, forKey: .appFlowConfig)
        appFlowConfig = appFlowConfigDecoded
        let cloudWatchConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.CloudWatchConfig.self, forKey: .cloudWatchConfig)
        cloudWatchConfig = cloudWatchConfigDecoded
        let rDSSourceConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.RDSSourceConfig.self, forKey: .rDSSourceConfig)
        rDSSourceConfig = rDSSourceConfigDecoded
        let redshiftSourceConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.RedshiftSourceConfig.self, forKey: .redshiftSourceConfig)
        redshiftSourceConfig = redshiftSourceConfigDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about source data used to generate a metric.
    public struct MetricSource: Swift.Equatable {
        /// An object containing information about the AppFlow configuration.
        public var appFlowConfig: LookoutMetricsClientTypes.AppFlowConfig?
        /// An object containing information about the Amazon CloudWatch monitoring configuration.
        public var cloudWatchConfig: LookoutMetricsClientTypes.CloudWatchConfig?
        /// An object containing information about the Amazon Relational Database Service (RDS) configuration.
        public var rDSSourceConfig: LookoutMetricsClientTypes.RDSSourceConfig?
        /// An object containing information about the Amazon Redshift database configuration.
        public var redshiftSourceConfig: LookoutMetricsClientTypes.RedshiftSourceConfig?
        /// Contains information about the configuration of the S3 bucket that contains source files.
        public var s3SourceConfig: LookoutMetricsClientTypes.S3SourceConfig?

        public init (
            appFlowConfig: LookoutMetricsClientTypes.AppFlowConfig? = nil,
            cloudWatchConfig: LookoutMetricsClientTypes.CloudWatchConfig? = nil,
            rDSSourceConfig: LookoutMetricsClientTypes.RDSSourceConfig? = nil,
            redshiftSourceConfig: LookoutMetricsClientTypes.RedshiftSourceConfig? = nil,
            s3SourceConfig: LookoutMetricsClientTypes.S3SourceConfig? = nil
        )
        {
            self.appFlowConfig = appFlowConfig
            self.cloudWatchConfig = cloudWatchConfig
            self.rDSSourceConfig = rDSSourceConfig
            self.redshiftSourceConfig = redshiftSourceConfig
            self.s3SourceConfig = s3SourceConfig
        }
    }

}

extension PutFeedbackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback {
            try encodeContainer.encode(anomalyGroupTimeSeriesFeedback, forKey: .anomalyGroupTimeSeriesFeedback)
        }
    }
}

extension PutFeedbackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/PutFeedback"
    }
}

public struct PutFeedbackInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// Feedback for an anomalous metric.
    /// This member is required.
    public var anomalyGroupTimeSeriesFeedback: LookoutMetricsClientTypes.AnomalyGroupTimeSeriesFeedback?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        anomalyGroupTimeSeriesFeedback: LookoutMetricsClientTypes.AnomalyGroupTimeSeriesFeedback? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback
    }
}

struct PutFeedbackInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let anomalyGroupTimeSeriesFeedback: LookoutMetricsClientTypes.AnomalyGroupTimeSeriesFeedback?
}

extension PutFeedbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let anomalyGroupTimeSeriesFeedbackDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyGroupTimeSeriesFeedback.self, forKey: .anomalyGroupTimeSeriesFeedback)
        anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedbackDecoded
    }
}

extension PutFeedbackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFeedbackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutFeedbackOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFeedbackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutFeedbackOutputResponse: Swift.Equatable {

}

extension LookoutMetricsClientTypes.RDSSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case databaseHost = "DatabaseHost"
        case databaseName = "DatabaseName"
        case databasePort = "DatabasePort"
        case roleArn = "RoleArn"
        case secretManagerArn = "SecretManagerArn"
        case tableName = "TableName"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try encodeContainer.encode(dBInstanceIdentifier, forKey: .dBInstanceIdentifier)
        }
        if let databaseHost = databaseHost {
            try encodeContainer.encode(databaseHost, forKey: .databaseHost)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if databasePort != 0 {
            try encodeContainer.encode(databasePort, forKey: .databasePort)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let secretManagerArn = secretManagerArn {
            try encodeContainer.encode(secretManagerArn, forKey: .secretManagerArn)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let vpcConfiguration = vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let databaseHostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseHost)
        databaseHost = databaseHostDecoded
        let databasePortDecoded = try containerValues.decode(Swift.Int.self, forKey: .databasePort)
        databasePort = databasePortDecoded
        let secretManagerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretManagerArn)
        secretManagerArn = secretManagerArnDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about the Amazon Relational Database Service (RDS) configuration.
    public struct RDSSourceConfig: Swift.Equatable {
        /// A string identifying the database instance.
        /// This member is required.
        public var dBInstanceIdentifier: Swift.String?
        /// The host name of the database.
        /// This member is required.
        public var databaseHost: Swift.String?
        /// The name of the RDS database.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The port number where the database can be accessed.
        /// This member is required.
        public var databasePort: Swift.Int
        /// The Amazon Resource Name (ARN) of the role.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager role.
        /// This member is required.
        public var secretManagerArn: Swift.String?
        /// The name of the table in the database.
        /// This member is required.
        public var tableName: Swift.String?
        /// An object containing information about the Amazon Virtual Private Cloud (VPC) configuration.
        /// This member is required.
        public var vpcConfiguration: LookoutMetricsClientTypes.VpcConfiguration?

        public init (
            dBInstanceIdentifier: Swift.String? = nil,
            databaseHost: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            databasePort: Swift.Int = 0,
            roleArn: Swift.String? = nil,
            secretManagerArn: Swift.String? = nil,
            tableName: Swift.String? = nil,
            vpcConfiguration: LookoutMetricsClientTypes.VpcConfiguration? = nil
        )
        {
            self.dBInstanceIdentifier = dBInstanceIdentifier
            self.databaseHost = databaseHost
            self.databaseName = databaseName
            self.databasePort = databasePort
            self.roleArn = roleArn
            self.secretManagerArn = secretManagerArn
            self.tableName = tableName
            self.vpcConfiguration = vpcConfiguration
        }
    }

}

extension LookoutMetricsClientTypes.RedshiftSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case databaseHost = "DatabaseHost"
        case databaseName = "DatabaseName"
        case databasePort = "DatabasePort"
        case roleArn = "RoleArn"
        case secretManagerArn = "SecretManagerArn"
        case tableName = "TableName"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterIdentifier = clusterIdentifier {
            try encodeContainer.encode(clusterIdentifier, forKey: .clusterIdentifier)
        }
        if let databaseHost = databaseHost {
            try encodeContainer.encode(databaseHost, forKey: .databaseHost)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if databasePort != 0 {
            try encodeContainer.encode(databasePort, forKey: .databasePort)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let secretManagerArn = secretManagerArn {
            try encodeContainer.encode(secretManagerArn, forKey: .secretManagerArn)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let vpcConfiguration = vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let databaseHostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseHost)
        databaseHost = databaseHostDecoded
        let databasePortDecoded = try containerValues.decode(Swift.Int.self, forKey: .databasePort)
        databasePort = databasePortDecoded
        let secretManagerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretManagerArn)
        secretManagerArn = secretManagerArnDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Provides information about the Amazon Redshift database configuration.
    public struct RedshiftSourceConfig: Swift.Equatable {
        /// A string identifying the Redshift cluster.
        /// This member is required.
        public var clusterIdentifier: Swift.String?
        /// The name of the database host.
        /// This member is required.
        public var databaseHost: Swift.String?
        /// The Redshift database name.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The port number where the database can be accessed.
        /// This member is required.
        public var databasePort: Swift.Int
        /// The Amazon Resource Name (ARN) of the role providing access to the database.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager role.
        /// This member is required.
        public var secretManagerArn: Swift.String?
        /// The table name of the Redshift database.
        /// This member is required.
        public var tableName: Swift.String?
        /// Contains information about the Amazon Virtual Private Cloud (VPC) configuration.
        /// This member is required.
        public var vpcConfiguration: LookoutMetricsClientTypes.VpcConfiguration?

        public init (
            clusterIdentifier: Swift.String? = nil,
            databaseHost: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            databasePort: Swift.Int = 0,
            roleArn: Swift.String? = nil,
            secretManagerArn: Swift.String? = nil,
            tableName: Swift.String? = nil,
            vpcConfiguration: LookoutMetricsClientTypes.VpcConfiguration? = nil
        )
        {
            self.clusterIdentifier = clusterIdentifier
            self.databaseHost = databaseHost
            self.databaseName = databaseName
            self.databasePort = databasePort
            self.roleArn = roleArn
            self.secretManagerArn = secretManagerArn
            self.tableName = tableName
            self.vpcConfiguration = vpcConfiguration
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource cannot be found. Check the ARN of the resource and try again.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    public var resourceId: Swift.String?
    /// The type of the resource.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension LookoutMetricsClientTypes.S3SourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileFormatDescriptor = "FileFormatDescriptor"
        case historicalDataPathList = "HistoricalDataPathList"
        case roleArn = "RoleArn"
        case templatedPathList = "TemplatedPathList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileFormatDescriptor = fileFormatDescriptor {
            try encodeContainer.encode(fileFormatDescriptor, forKey: .fileFormatDescriptor)
        }
        if let historicalDataPathList = historicalDataPathList {
            var historicalDataPathListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .historicalDataPathList)
            for historicaldatapathlist0 in historicalDataPathList {
                try historicalDataPathListContainer.encode(historicaldatapathlist0)
            }
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let templatedPathList = templatedPathList {
            var templatedPathListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .templatedPathList)
            for templatedpathlist0 in templatedPathList {
                try templatedPathListContainer.encode(templatedpathlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let templatedPathListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .templatedPathList)
        var templatedPathListDecoded0:[Swift.String]? = nil
        if let templatedPathListContainer = templatedPathListContainer {
            templatedPathListDecoded0 = [Swift.String]()
            for string0 in templatedPathListContainer {
                if let string0 = string0 {
                    templatedPathListDecoded0?.append(string0)
                }
            }
        }
        templatedPathList = templatedPathListDecoded0
        let historicalDataPathListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .historicalDataPathList)
        var historicalDataPathListDecoded0:[Swift.String]? = nil
        if let historicalDataPathListContainer = historicalDataPathListContainer {
            historicalDataPathListDecoded0 = [Swift.String]()
            for string0 in historicalDataPathListContainer {
                if let string0 = string0 {
                    historicalDataPathListDecoded0?.append(string0)
                }
            }
        }
        historicalDataPathList = historicalDataPathListDecoded0
        let fileFormatDescriptorDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.FileFormatDescriptor.self, forKey: .fileFormatDescriptor)
        fileFormatDescriptor = fileFormatDescriptorDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about the configuration of the S3 bucket that contains source files.
    public struct S3SourceConfig: Swift.Equatable {
        /// Contains information about a source file's formatting.
        public var fileFormatDescriptor: LookoutMetricsClientTypes.FileFormatDescriptor?
        /// A list of paths to the historical data files.
        public var historicalDataPathList: [Swift.String]?
        /// The ARN of an IAM role that has read and write access permissions to the source S3 bucket.
        /// This member is required.
        public var roleArn: Swift.String?
        /// A list of templated paths to the source files.
        public var templatedPathList: [Swift.String]?

        public init (
            fileFormatDescriptor: LookoutMetricsClientTypes.FileFormatDescriptor? = nil,
            historicalDataPathList: [Swift.String]? = nil,
            roleArn: Swift.String? = nil,
            templatedPathList: [Swift.String]? = nil
        )
        {
            self.fileFormatDescriptor = fileFormatDescriptor
            self.historicalDataPathList = historicalDataPathList
            self.roleArn = roleArn
            self.templatedPathList = templatedPathList
        }
    }

}

extension LookoutMetricsClientTypes.SNSConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
        case snsTopicArn = "SnsTopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about the SNS topic to which you want to send your alerts and the IAM role that has access to that topic.
    public struct SNSConfiguration: Swift.Equatable {
        /// The ARN of the IAM role that has access to the target SNS topic.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The ARN of the target SNS topic.
        /// This member is required.
        public var snsTopicArn: Swift.String?

        public init (
            roleArn: Swift.String? = nil,
            snsTopicArn: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.snsTopicArn = snsTopicArn
        }
    }

}

extension LookoutMetricsClientTypes.SampleDataS3SourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileFormatDescriptor = "FileFormatDescriptor"
        case historicalDataPathList = "HistoricalDataPathList"
        case roleArn = "RoleArn"
        case templatedPathList = "TemplatedPathList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileFormatDescriptor = fileFormatDescriptor {
            try encodeContainer.encode(fileFormatDescriptor, forKey: .fileFormatDescriptor)
        }
        if let historicalDataPathList = historicalDataPathList {
            var historicalDataPathListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .historicalDataPathList)
            for historicaldatapathlist0 in historicalDataPathList {
                try historicalDataPathListContainer.encode(historicaldatapathlist0)
            }
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let templatedPathList = templatedPathList {
            var templatedPathListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .templatedPathList)
            for templatedpathlist0 in templatedPathList {
                try templatedPathListContainer.encode(templatedpathlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let templatedPathListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .templatedPathList)
        var templatedPathListDecoded0:[Swift.String]? = nil
        if let templatedPathListContainer = templatedPathListContainer {
            templatedPathListDecoded0 = [Swift.String]()
            for string0 in templatedPathListContainer {
                if let string0 = string0 {
                    templatedPathListDecoded0?.append(string0)
                }
            }
        }
        templatedPathList = templatedPathListDecoded0
        let historicalDataPathListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .historicalDataPathList)
        var historicalDataPathListDecoded0:[Swift.String]? = nil
        if let historicalDataPathListContainer = historicalDataPathListContainer {
            historicalDataPathListDecoded0 = [Swift.String]()
            for string0 in historicalDataPathListContainer {
                if let string0 = string0 {
                    historicalDataPathListDecoded0?.append(string0)
                }
            }
        }
        historicalDataPathList = historicalDataPathListDecoded0
        let fileFormatDescriptorDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.FileFormatDescriptor.self, forKey: .fileFormatDescriptor)
        fileFormatDescriptor = fileFormatDescriptorDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about the source configuration in Amazon S3.
    public struct SampleDataS3SourceConfig: Swift.Equatable {
        /// Contains information about a source file's formatting.
        /// This member is required.
        public var fileFormatDescriptor: LookoutMetricsClientTypes.FileFormatDescriptor?
        /// An array of strings containing the historical set of data paths.
        public var historicalDataPathList: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the role.
        /// This member is required.
        public var roleArn: Swift.String?
        /// An array of strings containing the list of templated paths.
        public var templatedPathList: [Swift.String]?

        public init (
            fileFormatDescriptor: LookoutMetricsClientTypes.FileFormatDescriptor? = nil,
            historicalDataPathList: [Swift.String]? = nil,
            roleArn: Swift.String? = nil,
            templatedPathList: [Swift.String]? = nil
        )
        {
            self.fileFormatDescriptor = fileFormatDescriptor
            self.historicalDataPathList = historicalDataPathList
            self.roleArn = roleArn
            self.templatedPathList = templatedPathList
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeded the service's quotas. Check the service quotas and try again.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The quota code.
    public var quotaCode: Swift.String?
    /// The ID of the resource.
    public var resourceId: Swift.String?
    /// The type of the resource.
    public var resourceType: Swift.String?
    /// The service code.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags to apply to the resource. Tag keys and values can contain letters, numbers, spaces, and the following symbols: _.:/=+@-
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension LookoutMetricsClientTypes.TimeSeries: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionList = "DimensionList"
        case metricValueList = "MetricValueList"
        case timeSeriesId = "TimeSeriesId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionList = dimensionList {
            var dimensionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionList)
            for dimensionnamevaluelist0 in dimensionList {
                try dimensionListContainer.encode(dimensionnamevaluelist0)
            }
        }
        if let metricValueList = metricValueList {
            var metricValueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricValueList)
            for metricvaluelist0 in metricValueList {
                try metricValueListContainer.encode(metricvaluelist0)
            }
        }
        if let timeSeriesId = timeSeriesId {
            try encodeContainer.encode(timeSeriesId, forKey: .timeSeriesId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeSeriesIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeSeriesId)
        timeSeriesId = timeSeriesIdDecoded
        let dimensionListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.DimensionNameValue?].self, forKey: .dimensionList)
        var dimensionListDecoded0:[LookoutMetricsClientTypes.DimensionNameValue]? = nil
        if let dimensionListContainer = dimensionListContainer {
            dimensionListDecoded0 = [LookoutMetricsClientTypes.DimensionNameValue]()
            for structure0 in dimensionListContainer {
                if let structure0 = structure0 {
                    dimensionListDecoded0?.append(structure0)
                }
            }
        }
        dimensionList = dimensionListDecoded0
        let metricValueListContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .metricValueList)
        var metricValueListDecoded0:[Swift.Double]? = nil
        if let metricValueListContainer = metricValueListContainer {
            metricValueListDecoded0 = [Swift.Double]()
            for double0 in metricValueListContainer {
                if let double0 = double0 {
                    metricValueListDecoded0?.append(double0)
                }
            }
        }
        metricValueList = metricValueListDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// Details about a metric. A metric is an aggregation of the values of a measure for a dimension value, such as availability in the us-east-1 Region.
    public struct TimeSeries: Swift.Equatable {
        /// The dimensions of the metric.
        /// This member is required.
        public var dimensionList: [LookoutMetricsClientTypes.DimensionNameValue]?
        /// The values for the metric.
        /// This member is required.
        public var metricValueList: [Swift.Double]?
        /// The ID of the metric.
        /// This member is required.
        public var timeSeriesId: Swift.String?

        public init (
            dimensionList: [LookoutMetricsClientTypes.DimensionNameValue]? = nil,
            metricValueList: [Swift.Double]? = nil,
            timeSeriesId: Swift.String? = nil
        )
        {
            self.dimensionList = dimensionList
            self.metricValueList = metricValueList
            self.timeSeriesId = timeSeriesId
        }
    }

}

extension LookoutMetricsClientTypes.TimeSeriesFeedback: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isAnomaly = "IsAnomaly"
        case timeSeriesId = "TimeSeriesId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isAnomaly = isAnomaly {
            try encodeContainer.encode(isAnomaly, forKey: .isAnomaly)
        }
        if let timeSeriesId = timeSeriesId {
            try encodeContainer.encode(timeSeriesId, forKey: .timeSeriesId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeSeriesIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeSeriesId)
        timeSeriesId = timeSeriesIdDecoded
        let isAnomalyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAnomaly)
        isAnomaly = isAnomalyDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Details about feedback submitted for an anomalous metric.
    public struct TimeSeriesFeedback: Swift.Equatable {
        /// Feedback on whether the metric is a legitimate anomaly.
        public var isAnomaly: Swift.Bool?
        /// The ID of the metric.
        public var timeSeriesId: Swift.String?

        public init (
            isAnomaly: Swift.Bool? = nil,
            timeSeriesId: Swift.String? = nil
        )
        {
            self.isAnomaly = isAnomaly
            self.timeSeriesId = timeSeriesId
        }
    }

}

extension LookoutMetricsClientTypes.TimestampColumn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnFormat = "ColumnFormat"
        case columnName = "ColumnName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnFormat = columnFormat {
            try encodeContainer.encode(columnFormat, forKey: .columnFormat)
        }
        if let columnName = columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let columnFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnFormat)
        columnFormat = columnFormatDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about the column used to track time in a source data file.
    public struct TimestampColumn: Swift.Equatable {
        /// The format of the timestamp column.
        public var columnFormat: Swift.String?
        /// The name of the timestamp column.
        public var columnName: Swift.String?

        public init (
            columnFormat: Swift.String? = nil,
            columnName: Swift.String? = nil
        )
        {
            self.columnFormat = columnFormat
            self.columnName = columnName
        }
    }

}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to too many requests being submitted at the same time.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys to remove from the resource's tags.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateAnomalyDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyDetectorConfig = "AnomalyDetectorConfig"
        case anomalyDetectorDescription = "AnomalyDetectorDescription"
        case kmsKeyArn = "KmsKeyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let anomalyDetectorConfig = anomalyDetectorConfig {
            try encodeContainer.encode(anomalyDetectorConfig, forKey: .anomalyDetectorConfig)
        }
        if let anomalyDetectorDescription = anomalyDetectorDescription {
            try encodeContainer.encode(anomalyDetectorDescription, forKey: .anomalyDetectorDescription)
        }
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }
}

extension UpdateAnomalyDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateAnomalyDetector"
    }
}

public struct UpdateAnomalyDetectorInput: Swift.Equatable {
    /// The ARN of the detector to update.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// Contains information about the configuration to which the detector will be updated.
    public var anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfig?
    /// The updated detector description.
    public var anomalyDetectorDescription: Swift.String?
    /// The Amazon Resource Name (ARN) of an AWS KMS encryption key.
    public var kmsKeyArn: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfig? = nil,
        anomalyDetectorDescription: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyDetectorConfig = anomalyDetectorConfig
        self.anomalyDetectorDescription = anomalyDetectorDescription
        self.kmsKeyArn = kmsKeyArn
    }
}

struct UpdateAnomalyDetectorInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let kmsKeyArn: Swift.String?
    let anomalyDetectorDescription: Swift.String?
    let anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfig?
}

extension UpdateAnomalyDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyDetectorConfig = "AnomalyDetectorConfig"
        case anomalyDetectorDescription = "AnomalyDetectorDescription"
        case kmsKeyArn = "KmsKeyArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let anomalyDetectorDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorDescription)
        anomalyDetectorDescription = anomalyDetectorDescriptionDecoded
        let anomalyDetectorConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyDetectorConfig.self, forKey: .anomalyDetectorConfig)
        anomalyDetectorConfig = anomalyDetectorConfigDecoded
    }
}

extension UpdateAnomalyDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAnomalyDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAnomalyDetectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAnomalyDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAnomalyDetectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyDetectorArn = output.anomalyDetectorArn
        } else {
            self.anomalyDetectorArn = nil
        }
    }
}

public struct UpdateAnomalyDetectorOutputResponse: Swift.Equatable {
    /// The ARN of the updated detector.
    public var anomalyDetectorArn: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

struct UpdateAnomalyDetectorOutputResponseBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
}

extension UpdateAnomalyDetectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

extension UpdateMetricSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionList = "DimensionList"
        case metricList = "MetricList"
        case metricSetArn = "MetricSetArn"
        case metricSetDescription = "MetricSetDescription"
        case metricSetFrequency = "MetricSetFrequency"
        case metricSource = "MetricSource"
        case offset = "Offset"
        case timestampColumn = "TimestampColumn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionList = dimensionList {
            var dimensionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionList)
            for dimensionlist0 in dimensionList {
                try dimensionListContainer.encode(dimensionlist0)
            }
        }
        if let metricList = metricList {
            var metricListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricList)
            for metriclist0 in metricList {
                try metricListContainer.encode(metriclist0)
            }
        }
        if let metricSetArn = metricSetArn {
            try encodeContainer.encode(metricSetArn, forKey: .metricSetArn)
        }
        if let metricSetDescription = metricSetDescription {
            try encodeContainer.encode(metricSetDescription, forKey: .metricSetDescription)
        }
        if let metricSetFrequency = metricSetFrequency {
            try encodeContainer.encode(metricSetFrequency.rawValue, forKey: .metricSetFrequency)
        }
        if let metricSource = metricSource {
            try encodeContainer.encode(metricSource, forKey: .metricSource)
        }
        if offset != 0 {
            try encodeContainer.encode(offset, forKey: .offset)
        }
        if let timestampColumn = timestampColumn {
            try encodeContainer.encode(timestampColumn, forKey: .timestampColumn)
        }
    }
}

extension UpdateMetricSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateMetricSet"
    }
}

public struct UpdateMetricSetInput: Swift.Equatable {
    /// The dimension list.
    public var dimensionList: [Swift.String]?
    /// The metric list.
    public var metricList: [LookoutMetricsClientTypes.Metric]?
    /// The ARN of the dataset to update.
    /// This member is required.
    public var metricSetArn: Swift.String?
    /// The dataset's description.
    public var metricSetDescription: Swift.String?
    /// The dataset's interval.
    public var metricSetFrequency: LookoutMetricsClientTypes.Frequency?
    /// Contains information about source data used to generate a metric.
    public var metricSource: LookoutMetricsClientTypes.MetricSource?
    /// After an interval ends, the amount of seconds that the detector waits before importing data. Offset is only supported for S3 and Redshift datasources.
    public var offset: Swift.Int
    /// The timestamp column.
    public var timestampColumn: LookoutMetricsClientTypes.TimestampColumn?

    public init (
        dimensionList: [Swift.String]? = nil,
        metricList: [LookoutMetricsClientTypes.Metric]? = nil,
        metricSetArn: Swift.String? = nil,
        metricSetDescription: Swift.String? = nil,
        metricSetFrequency: LookoutMetricsClientTypes.Frequency? = nil,
        metricSource: LookoutMetricsClientTypes.MetricSource? = nil,
        offset: Swift.Int = 0,
        timestampColumn: LookoutMetricsClientTypes.TimestampColumn? = nil
    )
    {
        self.dimensionList = dimensionList
        self.metricList = metricList
        self.metricSetArn = metricSetArn
        self.metricSetDescription = metricSetDescription
        self.metricSetFrequency = metricSetFrequency
        self.metricSource = metricSource
        self.offset = offset
        self.timestampColumn = timestampColumn
    }
}

struct UpdateMetricSetInputBody: Swift.Equatable {
    let metricSetArn: Swift.String?
    let metricSetDescription: Swift.String?
    let metricList: [LookoutMetricsClientTypes.Metric]?
    let offset: Swift.Int
    let timestampColumn: LookoutMetricsClientTypes.TimestampColumn?
    let dimensionList: [Swift.String]?
    let metricSetFrequency: LookoutMetricsClientTypes.Frequency?
    let metricSource: LookoutMetricsClientTypes.MetricSource?
}

extension UpdateMetricSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionList = "DimensionList"
        case metricList = "MetricList"
        case metricSetArn = "MetricSetArn"
        case metricSetDescription = "MetricSetDescription"
        case metricSetFrequency = "MetricSetFrequency"
        case metricSource = "MetricSource"
        case offset = "Offset"
        case timestampColumn = "TimestampColumn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetArn)
        metricSetArn = metricSetArnDecoded
        let metricSetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetDescription)
        metricSetDescription = metricSetDescriptionDecoded
        let metricListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.Metric?].self, forKey: .metricList)
        var metricListDecoded0:[LookoutMetricsClientTypes.Metric]? = nil
        if let metricListContainer = metricListContainer {
            metricListDecoded0 = [LookoutMetricsClientTypes.Metric]()
            for structure0 in metricListContainer {
                if let structure0 = structure0 {
                    metricListDecoded0?.append(structure0)
                }
            }
        }
        metricList = metricListDecoded0
        let offsetDecoded = try containerValues.decode(Swift.Int.self, forKey: .offset)
        offset = offsetDecoded
        let timestampColumnDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.TimestampColumn.self, forKey: .timestampColumn)
        timestampColumn = timestampColumnDecoded
        let dimensionListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dimensionList)
        var dimensionListDecoded0:[Swift.String]? = nil
        if let dimensionListContainer = dimensionListContainer {
            dimensionListDecoded0 = [Swift.String]()
            for string0 in dimensionListContainer {
                if let string0 = string0 {
                    dimensionListDecoded0?.append(string0)
                }
            }
        }
        dimensionList = dimensionListDecoded0
        let metricSetFrequencyDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.Frequency.self, forKey: .metricSetFrequency)
        metricSetFrequency = metricSetFrequencyDecoded
        let metricSourceDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.MetricSource.self, forKey: .metricSource)
        metricSource = metricSourceDecoded
    }
}

extension UpdateMetricSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMetricSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMetricSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMetricSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateMetricSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metricSetArn = output.metricSetArn
        } else {
            self.metricSetArn = nil
        }
    }
}

public struct UpdateMetricSetOutputResponse: Swift.Equatable {
    /// The ARN of the dataset.
    public var metricSetArn: Swift.String?

    public init (
        metricSetArn: Swift.String? = nil
    )
    {
        self.metricSetArn = metricSetArn
    }
}

struct UpdateMetricSetOutputResponseBody: Swift.Equatable {
    let metricSetArn: Swift.String?
}

extension UpdateMetricSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricSetArn = "MetricSetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetArn)
        metricSetArn = metricSetArnDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by the AWS service. Check your input values and try again.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Fields that failed validation.
    public var fields: [LookoutMetricsClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// The reason that validation failed.
    public var reason: LookoutMetricsClientTypes.ValidationExceptionReason?

    public init (
        fields: [LookoutMetricsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: LookoutMetricsClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: LookoutMetricsClientTypes.ValidationExceptionReason?
    let fields: [LookoutMetricsClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[LookoutMetricsClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [LookoutMetricsClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension LookoutMetricsClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about a a field in a validation exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message with more information about the validation exception.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension LookoutMetricsClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension LookoutMetricsClientTypes.VpcConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIdList = "SecurityGroupIdList"
        case subnetIdList = "SubnetIdList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIdList = securityGroupIdList {
            var securityGroupIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIdList)
            for securitygroupidlist0 in securityGroupIdList {
                try securityGroupIdListContainer.encode(securitygroupidlist0)
            }
        }
        if let subnetIdList = subnetIdList {
            var subnetIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIdList)
            for subnetidlist0 in subnetIdList {
                try subnetIdListContainer.encode(subnetidlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIdList)
        var subnetIdListDecoded0:[Swift.String]? = nil
        if let subnetIdListContainer = subnetIdListContainer {
            subnetIdListDecoded0 = [Swift.String]()
            for string0 in subnetIdListContainer {
                if let string0 = string0 {
                    subnetIdListDecoded0?.append(string0)
                }
            }
        }
        subnetIdList = subnetIdListDecoded0
        let securityGroupIdListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIdList)
        var securityGroupIdListDecoded0:[Swift.String]? = nil
        if let securityGroupIdListContainer = securityGroupIdListContainer {
            securityGroupIdListDecoded0 = [Swift.String]()
            for string0 in securityGroupIdListContainer {
                if let string0 = string0 {
                    securityGroupIdListDecoded0?.append(string0)
                }
            }
        }
        securityGroupIdList = securityGroupIdListDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// Contains configuration information about the Amazon Virtual Private Cloud (VPC).
    public struct VpcConfiguration: Swift.Equatable {
        /// An array of strings containing the list of security groups.
        /// This member is required.
        public var securityGroupIdList: [Swift.String]?
        /// An array of strings containing the Amazon VPC subnet IDs (e.g., subnet-0bb1c79de3EXAMPLE.
        /// This member is required.
        public var subnetIdList: [Swift.String]?

        public init (
            securityGroupIdList: [Swift.String]? = nil,
            subnetIdList: [Swift.String]? = nil
        )
        {
            self.securityGroupIdList = securityGroupIdList
            self.subnetIdList = subnetIdList
        }
    }

}
