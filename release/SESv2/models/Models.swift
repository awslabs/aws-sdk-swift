// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalContactEmailAddresses = "AdditionalContactEmailAddresses"
        case contactLanguage = "ContactLanguage"
        case mailType = "MailType"
        case reviewDetails = "ReviewDetails"
        case useCaseDescription = "UseCaseDescription"
        case websiteURL = "WebsiteURL"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalContactEmailAddresses = additionalContactEmailAddresses {
            var additionalContactEmailAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalContactEmailAddresses)
            for additionalcontactemailaddresses0 in additionalContactEmailAddresses {
                try additionalContactEmailAddressesContainer.encode(additionalcontactemailaddresses0)
            }
        }
        if let contactLanguage = contactLanguage {
            try encodeContainer.encode(contactLanguage.rawValue, forKey: .contactLanguage)
        }
        if let mailType = mailType {
            try encodeContainer.encode(mailType.rawValue, forKey: .mailType)
        }
        if let reviewDetails = reviewDetails {
            try encodeContainer.encode(reviewDetails, forKey: .reviewDetails)
        }
        if let useCaseDescription = useCaseDescription {
            try encodeContainer.encode(useCaseDescription, forKey: .useCaseDescription)
        }
        if let websiteURL = websiteURL {
            try encodeContainer.encode(websiteURL, forKey: .websiteURL)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mailTypeDecoded = try containerValues.decodeIfPresent(MailType.self, forKey: .mailType)
        mailType = mailTypeDecoded
        let websiteURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .websiteURL)
        websiteURL = websiteURLDecoded
        let contactLanguageDecoded = try containerValues.decodeIfPresent(ContactLanguage.self, forKey: .contactLanguage)
        contactLanguage = contactLanguageDecoded
        let useCaseDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .useCaseDescription)
        useCaseDescription = useCaseDescriptionDecoded
        let additionalContactEmailAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .additionalContactEmailAddresses)
        var additionalContactEmailAddressesDecoded0:[String]? = nil
        if let additionalContactEmailAddressesContainer = additionalContactEmailAddressesContainer {
            additionalContactEmailAddressesDecoded0 = [String]()
            for string0 in additionalContactEmailAddressesContainer {
                if let string0 = string0 {
                    additionalContactEmailAddressesDecoded0?.append(string0)
                }
            }
        }
        additionalContactEmailAddresses = additionalContactEmailAddressesDecoded0
        let reviewDetailsDecoded = try containerValues.decodeIfPresent(ReviewDetails.self, forKey: .reviewDetails)
        reviewDetails = reviewDetailsDecoded
    }
}

extension AccountDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountDetails(additionalContactEmailAddresses: \(String(describing: additionalContactEmailAddresses)), contactLanguage: \(String(describing: contactLanguage)), mailType: \(String(describing: mailType)), reviewDetails: \(String(describing: reviewDetails)), useCaseDescription: \(String(describing: useCaseDescription)), websiteURL: \(String(describing: websiteURL)))"}
}

/// <p>An object that contains information about your account details.</p>
public struct AccountDetails: Equatable {
    /// <p>Additional email addresses where updates are sent about your account review
    ///             process.</p>
    public let additionalContactEmailAddresses: [String]?
    /// <p>The language you would prefer for the case. The contact language can be one of
    ///                 <code>ENGLISH</code> or <code>JAPANESE</code>.</p>
    public let contactLanguage: ContactLanguage?
    /// <p>The type of email your account is sending. The mail type can be one of the
    ///             following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>MARKETING</code> – Most of your sending traffic is to keep your
    ///                     customers informed of your latest offering.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>TRANSACTIONAL</code> – Most of your sending traffic is to
    ///                     communicate during a transaction with a customer.</p>
    ///             </li>
    ///          </ul>
    public let mailType: MailType?
    /// <p>Information about the review of the latest details you submitted.</p>
    public let reviewDetails: ReviewDetails?
    /// <p>A description of the types of email that you plan to send.</p>
    public let useCaseDescription: String?
    /// <p>The URL of your website. This information helps us better understand the type of
    ///             content that you plan to send.</p>
    public let websiteURL: String?

    public init (
        additionalContactEmailAddresses: [String]? = nil,
        contactLanguage: ContactLanguage? = nil,
        mailType: MailType? = nil,
        reviewDetails: ReviewDetails? = nil,
        useCaseDescription: String? = nil,
        websiteURL: String? = nil
    )
    {
        self.additionalContactEmailAddresses = additionalContactEmailAddresses
        self.contactLanguage = contactLanguage
        self.mailType = mailType
        self.reviewDetails = reviewDetails
        self.useCaseDescription = useCaseDescription
        self.websiteURL = websiteURL
    }
}

extension AccountSuspendedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountSuspendedException(message: \(String(describing: message)))"}
}

extension AccountSuspendedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccountSuspendedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The message can't be sent because the account's ability to send email has been
///             permanently restricted.</p>
public struct AccountSuspendedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccountSuspendedExceptionBody: Equatable {
    public let message: String?
}

extension AccountSuspendedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlreadyExistsException(message: \(String(describing: message)))"}
}

extension AlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource specified in your request already exists.</p>
public struct AlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension AlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input you provided is invalid.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

/// <p>The action that you want to take if the required MX record can't be found when you
///             send an email. When you set this value to <code>UseDefaultValue</code>, the mail is sent
///             using <i>amazonses.com</i> as the MAIL FROM domain. When you set this
///             value to <code>RejectMessage</code>, the Amazon SES API v2 returns a
///                 <code>MailFromDomainNotVerified</code> error, and doesn't attempt to deliver the
///             email.</p>
///         <p>These behaviors are taken when the custom MAIL FROM domain configuration is in the
///                 <code>Pending</code>, <code>Failed</code>, and <code>TemporaryFailure</code>
///             states.</p>
public enum BehaviorOnMxFailure {
    case rejectMessage
    case useDefaultValue
    case sdkUnknown(String)
}

extension BehaviorOnMxFailure : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BehaviorOnMxFailure] {
        return [
            .rejectMessage,
            .useDefaultValue,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .rejectMessage: return "REJECT_MESSAGE"
        case .useDefaultValue: return "USE_DEFAULT_VALUE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BehaviorOnMxFailure(rawValue: rawValue) ?? BehaviorOnMxFailure.sdkUnknown(rawValue)
    }
}

extension BlacklistEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case listingTime = "ListingTime"
        case rblName = "RblName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let listingTime = listingTime {
            try encodeContainer.encode(listingTime.timeIntervalSince1970, forKey: .listingTime)
        }
        if let rblName = rblName {
            try encodeContainer.encode(rblName, forKey: .rblName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rblNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rblName)
        rblName = rblNameDecoded
        let listingTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .listingTime)
        listingTime = listingTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension BlacklistEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BlacklistEntry(description: \(String(describing: description)), listingTime: \(String(describing: listingTime)), rblName: \(String(describing: rblName)))"}
}

/// <p>An object that contains information about a blacklisting event that impacts one of the
///             dedicated IP addresses that is associated with your account.</p>
public struct BlacklistEntry: Equatable {
    /// <p>Additional information about the blacklisting event, as provided by the blacklist
    ///             maintainer.</p>
    public let description: String?
    /// <p>The time when the blacklisting event occurred, shown in Unix time format.</p>
    public let listingTime: Date?
    /// <p>The name of the blacklist that the IP address appears on.</p>
    public let rblName: String?

    public init (
        description: String? = nil,
        listingTime: Date? = nil,
        rblName: String? = nil
    )
    {
        self.description = description
        self.listingTime = listingTime
        self.rblName = rblName
    }
}

extension Body: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case html = "Html"
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let html = html {
            try encodeContainer.encode(html, forKey: .html)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Content.self, forKey: .text)
        text = textDecoded
        let htmlDecoded = try containerValues.decodeIfPresent(Content.self, forKey: .html)
        html = htmlDecoded
    }
}

extension Body: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Body(html: \(String(describing: html)), text: \(String(describing: text)))"}
}

/// <p>Represents the body of the email message.</p>
public struct Body: Equatable {
    /// <p>An object that represents the version of the message that is displayed in email
    ///             clients that support HTML. HTML messages can include formatted text, hyperlinks, images,
    ///             and more. </p>
    public let html: Content?
    /// <p>An object that represents the version of the message that is displayed in email
    ///             clients that don't support HTML, or clients where the recipient has disabled HTML
    ///             rendering.</p>
    public let text: Content?

    public init (
        html: Content? = nil,
        text: Content? = nil
    )
    {
        self.html = html
        self.text = text
    }
}

extension BulkEmailContent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case template = "Template"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let template = template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(Template.self, forKey: .template)
        template = templateDecoded
    }
}

extension BulkEmailContent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BulkEmailContent(template: \(String(describing: template)))"}
}

/// <p>An object that contains the body of the message. You can specify a template
///             message.</p>
public struct BulkEmailContent: Equatable {
    /// <p>The template to use for the bulk email message.</p>
    public let template: Template?

    public init (
        template: Template? = nil
    )
    {
        self.template = template
    }
}

extension BulkEmailEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destination = "Destination"
        case replacementEmailContent = "ReplacementEmailContent"
        case replacementTags = "ReplacementTags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let replacementEmailContent = replacementEmailContent {
            try encodeContainer.encode(replacementEmailContent, forKey: .replacementEmailContent)
        }
        if let replacementTags = replacementTags {
            var replacementTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replacementTags)
            for messagetaglist0 in replacementTags {
                try replacementTagsContainer.encode(messagetaglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(Destination.self, forKey: .destination)
        destination = destinationDecoded
        let replacementTagsContainer = try containerValues.decodeIfPresent([MessageTag?].self, forKey: .replacementTags)
        var replacementTagsDecoded0:[MessageTag]? = nil
        if let replacementTagsContainer = replacementTagsContainer {
            replacementTagsDecoded0 = [MessageTag]()
            for structure0 in replacementTagsContainer {
                if let structure0 = structure0 {
                    replacementTagsDecoded0?.append(structure0)
                }
            }
        }
        replacementTags = replacementTagsDecoded0
        let replacementEmailContentDecoded = try containerValues.decodeIfPresent(ReplacementEmailContent.self, forKey: .replacementEmailContent)
        replacementEmailContent = replacementEmailContentDecoded
    }
}

extension BulkEmailEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BulkEmailEntry(destination: \(String(describing: destination)), replacementEmailContent: \(String(describing: replacementEmailContent)), replacementTags: \(String(describing: replacementTags)))"}
}

public struct BulkEmailEntry: Equatable {
    /// <p>Represents the destination of the message, consisting of To:, CC:, and BCC:
    ///             fields.</p>
    ///         <note>
    ///             <p>Amazon SES does not support the SMTPUTF8 extension, as described in <a href="https://tools.ietf.org/html/rfc6531">RFC6531</a>. For this reason, the
    ///                 local part of a destination email address (the part of the email address that
    ///                 precedes the @ sign) may only contain <a href="https://en.wikipedia.org/wiki/Email_address#Local-part">7-bit ASCII
    ///                     characters</a>. If the domain part of an address (the part after the @ sign)
    ///                 contains non-ASCII characters, they must be encoded using Punycode, as described in
    ///                     <a href="https://tools.ietf.org/html/rfc3492.html">RFC3492</a>.</p>
    ///         </note>
    public let destination: Destination?
    /// <p>The <code>ReplacementEmailContent</code> associated with a
    ///             <code>BulkEmailEntry</code>.</p>
    public let replacementEmailContent: ReplacementEmailContent?
    /// <p>A list of tags, in the form of name/value pairs, to apply to an email that you send
    ///             using the <code>SendBulkTemplatedEmail</code> operation. Tags correspond to
    ///             characteristics of the email that you define, so that you can publish email sending
    ///             events.</p>
    public let replacementTags: [MessageTag]?

    public init (
        destination: Destination? = nil,
        replacementEmailContent: ReplacementEmailContent? = nil,
        replacementTags: [MessageTag]? = nil
    )
    {
        self.destination = destination
        self.replacementEmailContent = replacementEmailContent
        self.replacementTags = replacementTags
    }
}

extension BulkEmailEntryResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case error = "Error"
        case messageId = "MessageId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(BulkEmailStatus.self, forKey: .status)
        status = statusDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension BulkEmailEntryResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BulkEmailEntryResult(error: \(String(describing: error)), messageId: \(String(describing: messageId)), status: \(String(describing: status)))"}
}

/// <p>The result of the <code>SendBulkEmail</code> operation of each specified
///                 <code>BulkEmailEntry</code>.</p>
public struct BulkEmailEntryResult: Equatable {
    /// <p>A description of an error that prevented a message being sent using the
    ///                 <code>SendBulkTemplatedEmail</code> operation.</p>
    public let error: String?
    /// <p>The unique message identifier returned from the <code>SendBulkTemplatedEmail</code>
    ///             operation.</p>
    public let messageId: String?
    /// <p>The status of a message sent using the <code>SendBulkTemplatedEmail</code>
    ///             operation.</p>
    ///         <p>Possible values for this parameter include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>SUCCESS: Amazon SES accepted the message, and will attempt to deliver it to
    ///                     the recipients.</p>
    ///             </li>
    ///             <li>
    ///                 <p>MESSAGE_REJECTED: The message was rejected because it contained a
    ///                     virus.</p>
    ///             </li>
    ///             <li>
    ///                 <p>MAIL_FROM_DOMAIN_NOT_VERIFIED: The sender's email address or domain was not
    ///                     verified.</p>
    ///             </li>
    ///             <li>
    ///                 <p>CONFIGURATION_SET_DOES_NOT_EXIST: The configuration set you specified does not
    ///                     exist.</p>
    ///             </li>
    ///             <li>
    ///                 <p>TEMPLATE_DOES_NOT_EXIST: The template you specified does not exist.</p>
    ///             </li>
    ///             <li>
    ///                 <p>ACCOUNT_SUSPENDED: Your account has been shut down because of issues related
    ///                     to your email sending practices.</p>
    ///             </li>
    ///             <li>
    ///                 <p>ACCOUNT_THROTTLED: The number of emails you can send has been reduced because
    ///                     your account has exceeded its allocated sending limit.</p>
    ///             </li>
    ///             <li>
    ///                 <p>ACCOUNT_DAILY_QUOTA_EXCEEDED: You have reached or exceeded the maximum number
    ///                     of emails you can send from your account in a 24-hour period.</p>
    ///             </li>
    ///             <li>
    ///                 <p>INVALID_SENDING_POOL_NAME: The configuration set you specified refers to an IP
    ///                     pool that does not exist.</p>
    ///             </li>
    ///             <li>
    ///                 <p>ACCOUNT_SENDING_PAUSED: Email sending for the Amazon SES account was disabled
    ///                     using the <a href="https://docs.aws.amazon.com/ses/latest/APIReference/API_UpdateAccountSendingEnabled.html">UpdateAccountSendingEnabled</a> operation.</p>
    ///             </li>
    ///             <li>
    ///                 <p>CONFIGURATION_SET_SENDING_PAUSED: Email sending for this configuration set was
    ///                     disabled using the <a href="https://docs.aws.amazon.com/ses/latest/APIReference/API_UpdateConfigurationSetSendingEnabled.html">UpdateConfigurationSetSendingEnabled</a> operation.</p>
    ///             </li>
    ///             <li>
    ///                 <p>INVALID_PARAMETER_VALUE: One or more of the parameters you specified when
    ///                     calling this operation was invalid. See the error message for additional
    ///                     information.</p>
    ///             </li>
    ///             <li>
    ///                 <p>TRANSIENT_FAILURE: Amazon SES was unable to process your request because of a
    ///                     temporary issue.</p>
    ///             </li>
    ///             <li>
    ///                 <p>FAILED: Amazon SES was unable to process your request. See the error message
    ///                     for additional information.</p>
    ///             </li>
    ///          </ul>
    public let status: BulkEmailStatus?

    public init (
        error: String? = nil,
        messageId: String? = nil,
        status: BulkEmailStatus? = nil
    )
    {
        self.error = error
        self.messageId = messageId
        self.status = status
    }
}

public enum BulkEmailStatus {
    case accountDailyQuotaExceeded
    case accountSendingPaused
    case accountSuspended
    case accountThrottled
    case configurationSetNotFound
    case configurationSetSendingPaused
    case failed
    case invalidParameter
    case invalidSendingPoolName
    case mailFromDomainNotVerified
    case messageRejected
    case success
    case templateNotFound
    case transientFailure
    case sdkUnknown(String)
}

extension BulkEmailStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BulkEmailStatus] {
        return [
            .accountDailyQuotaExceeded,
            .accountSendingPaused,
            .accountSuspended,
            .accountThrottled,
            .configurationSetNotFound,
            .configurationSetSendingPaused,
            .failed,
            .invalidParameter,
            .invalidSendingPoolName,
            .mailFromDomainNotVerified,
            .messageRejected,
            .success,
            .templateNotFound,
            .transientFailure,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountDailyQuotaExceeded: return "ACCOUNT_DAILY_QUOTA_EXCEEDED"
        case .accountSendingPaused: return "ACCOUNT_SENDING_PAUSED"
        case .accountSuspended: return "ACCOUNT_SUSPENDED"
        case .accountThrottled: return "ACCOUNT_THROTTLED"
        case .configurationSetNotFound: return "CONFIGURATION_SET_NOT_FOUND"
        case .configurationSetSendingPaused: return "CONFIGURATION_SET_SENDING_PAUSED"
        case .failed: return "FAILED"
        case .invalidParameter: return "INVALID_PARAMETER"
        case .invalidSendingPoolName: return "INVALID_SENDING_POOL_NAME"
        case .mailFromDomainNotVerified: return "MAIL_FROM_DOMAIN_NOT_VERIFIED"
        case .messageRejected: return "MESSAGE_REJECTED"
        case .success: return "SUCCESS"
        case .templateNotFound: return "TEMPLATE_NOT_FOUND"
        case .transientFailure: return "TRANSIENT_FAILURE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BulkEmailStatus(rawValue: rawValue) ?? BulkEmailStatus.sdkUnknown(rawValue)
    }
}

extension CloudWatchDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensionConfigurations = "DimensionConfigurations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionConfigurations = dimensionConfigurations {
            var dimensionConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionConfigurations)
            for cloudwatchdimensionconfigurations0 in dimensionConfigurations {
                try dimensionConfigurationsContainer.encode(cloudwatchdimensionconfigurations0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionConfigurationsContainer = try containerValues.decodeIfPresent([CloudWatchDimensionConfiguration?].self, forKey: .dimensionConfigurations)
        var dimensionConfigurationsDecoded0:[CloudWatchDimensionConfiguration]? = nil
        if let dimensionConfigurationsContainer = dimensionConfigurationsContainer {
            dimensionConfigurationsDecoded0 = [CloudWatchDimensionConfiguration]()
            for structure0 in dimensionConfigurationsContainer {
                if let structure0 = structure0 {
                    dimensionConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        dimensionConfigurations = dimensionConfigurationsDecoded0
    }
}

extension CloudWatchDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchDestination(dimensionConfigurations: \(String(describing: dimensionConfigurations)))"}
}

/// <p>An object that defines an Amazon CloudWatch destination for email events. You can use Amazon CloudWatch to
///             monitor and gain insights on your email sending metrics.</p>
public struct CloudWatchDestination: Equatable {
    /// <p>An array of objects that define the dimensions to use when you send email events to
    ///             Amazon CloudWatch.</p>
    public let dimensionConfigurations: [CloudWatchDimensionConfiguration]?

    public init (
        dimensionConfigurations: [CloudWatchDimensionConfiguration]? = nil
    )
    {
        self.dimensionConfigurations = dimensionConfigurations
    }
}

extension CloudWatchDimensionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultDimensionValue = "DefaultDimensionValue"
        case dimensionName = "DimensionName"
        case dimensionValueSource = "DimensionValueSource"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultDimensionValue = defaultDimensionValue {
            try encodeContainer.encode(defaultDimensionValue, forKey: .defaultDimensionValue)
        }
        if let dimensionName = dimensionName {
            try encodeContainer.encode(dimensionName, forKey: .dimensionName)
        }
        if let dimensionValueSource = dimensionValueSource {
            try encodeContainer.encode(dimensionValueSource.rawValue, forKey: .dimensionValueSource)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dimensionName)
        dimensionName = dimensionNameDecoded
        let dimensionValueSourceDecoded = try containerValues.decodeIfPresent(DimensionValueSource.self, forKey: .dimensionValueSource)
        dimensionValueSource = dimensionValueSourceDecoded
        let defaultDimensionValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultDimensionValue)
        defaultDimensionValue = defaultDimensionValueDecoded
    }
}

extension CloudWatchDimensionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchDimensionConfiguration(defaultDimensionValue: \(String(describing: defaultDimensionValue)), dimensionName: \(String(describing: dimensionName)), dimensionValueSource: \(String(describing: dimensionValueSource)))"}
}

/// <p>An object that defines the dimension configuration to use when you send email events
///             to Amazon CloudWatch.</p>
public struct CloudWatchDimensionConfiguration: Equatable {
    /// <p>The default value of the dimension that is published to Amazon CloudWatch if you don't provide the
    ///             value of the dimension when you send an email. This value has to meet the following
    ///             criteria:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>It can only contain ASCII letters (a–z, A–Z), numbers (0–9),
    ///                     underscores (_), or dashes (-).</p>
    ///             </li>
    ///             <li>
    ///                 <p>It can contain no more than 256 characters.</p>
    ///             </li>
    ///          </ul>
    public let defaultDimensionValue: String?
    /// <p>The name of an Amazon CloudWatch dimension associated with an email sending metric. The name has to
    ///             meet the following criteria:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>It can only contain ASCII letters (a–z, A–Z), numbers (0–9),
    ///                     underscores (_), or dashes (-).</p>
    ///             </li>
    ///             <li>
    ///                 <p>It can contain no more than 256 characters.</p>
    ///             </li>
    ///          </ul>
    public let dimensionName: String?
    /// <p>The location where the Amazon SES API v2 finds the value of a dimension to publish to Amazon CloudWatch. If
    ///             you want to use the message tags that you specify using an
    ///                 <code>X-SES-MESSAGE-TAGS</code> header or a parameter to the <code>SendEmail</code>
    ///             or <code>SendRawEmail</code> API, choose <code>messageTag</code>. If you want to use
    ///             your own email headers, choose <code>emailHeader</code>. If you want to use link tags,
    ///             choose <code>linkTags</code>.</p>
    public let dimensionValueSource: DimensionValueSource?

    public init (
        defaultDimensionValue: String? = nil,
        dimensionName: String? = nil,
        dimensionValueSource: DimensionValueSource? = nil
    )
    {
        self.defaultDimensionValue = defaultDimensionValue
        self.dimensionName = dimensionName
        self.dimensionValueSource = dimensionValueSource
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource is being modified by another operation or thread.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>If there is already an ongoing account details update under review.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Contact: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emailAddress = "EmailAddress"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case topicDefaultPreferences = "TopicDefaultPreferences"
        case topicPreferences = "TopicPreferences"
        case unsubscribeAll = "UnsubscribeAll"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let topicDefaultPreferences = topicDefaultPreferences {
            var topicDefaultPreferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topicDefaultPreferences)
            for topicpreferencelist0 in topicDefaultPreferences {
                try topicDefaultPreferencesContainer.encode(topicpreferencelist0)
            }
        }
        if let topicPreferences = topicPreferences {
            var topicPreferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topicPreferences)
            for topicpreferencelist0 in topicPreferences {
                try topicPreferencesContainer.encode(topicpreferencelist0)
            }
        }
        if unsubscribeAll != false {
            try encodeContainer.encode(unsubscribeAll, forKey: .unsubscribeAll)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let topicPreferencesContainer = try containerValues.decodeIfPresent([TopicPreference?].self, forKey: .topicPreferences)
        var topicPreferencesDecoded0:[TopicPreference]? = nil
        if let topicPreferencesContainer = topicPreferencesContainer {
            topicPreferencesDecoded0 = [TopicPreference]()
            for structure0 in topicPreferencesContainer {
                if let structure0 = structure0 {
                    topicPreferencesDecoded0?.append(structure0)
                }
            }
        }
        topicPreferences = topicPreferencesDecoded0
        let topicDefaultPreferencesContainer = try containerValues.decodeIfPresent([TopicPreference?].self, forKey: .topicDefaultPreferences)
        var topicDefaultPreferencesDecoded0:[TopicPreference]? = nil
        if let topicDefaultPreferencesContainer = topicDefaultPreferencesContainer {
            topicDefaultPreferencesDecoded0 = [TopicPreference]()
            for structure0 in topicDefaultPreferencesContainer {
                if let structure0 = structure0 {
                    topicDefaultPreferencesDecoded0?.append(structure0)
                }
            }
        }
        topicDefaultPreferences = topicDefaultPreferencesDecoded0
        let unsubscribeAllDecoded = try containerValues.decode(Bool.self, forKey: .unsubscribeAll)
        unsubscribeAll = unsubscribeAllDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
    }
}

extension Contact: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Contact(emailAddress: \(String(describing: emailAddress)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), topicDefaultPreferences: \(String(describing: topicDefaultPreferences)), topicPreferences: \(String(describing: topicPreferences)), unsubscribeAll: \(String(describing: unsubscribeAll)))"}
}

/// <p>A contact is the end-user who is receiving the email.</p>
public struct Contact: Equatable {
    /// <p>The contact's email address.</p>
    public let emailAddress: String?
    /// <p>A timestamp noting the last time the contact's information was updated.</p>
    public let lastUpdatedTimestamp: Date?
    /// <p>The default topic preferences applied to the contact.</p>
    public let topicDefaultPreferences: [TopicPreference]?
    /// <p>The contact's preference for being opted-in to or opted-out of a topic.</p>
    public let topicPreferences: [TopicPreference]?
    /// <p>A boolean value status noting if the contact is unsubscribed from all contact list
    ///             topics.</p>
    public let unsubscribeAll: Bool

    public init (
        emailAddress: String? = nil,
        lastUpdatedTimestamp: Date? = nil,
        topicDefaultPreferences: [TopicPreference]? = nil,
        topicPreferences: [TopicPreference]? = nil,
        unsubscribeAll: Bool = false
    )
    {
        self.emailAddress = emailAddress
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.topicDefaultPreferences = topicDefaultPreferences
        self.topicPreferences = topicPreferences
        self.unsubscribeAll = unsubscribeAll
    }
}

public enum ContactLanguage {
    case en
    case ja
    case sdkUnknown(String)
}

extension ContactLanguage : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ContactLanguage] {
        return [
            .en,
            .ja,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .en: return "EN"
        case .ja: return "JA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ContactLanguage(rawValue: rawValue) ?? ContactLanguage.sdkUnknown(rawValue)
    }
}

extension ContactList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactListName = "ContactListName"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactListName = contactListName {
            try encodeContainer.encode(contactListName, forKey: .contactListName)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactListNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactListName)
        contactListName = contactListNameDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
    }
}

extension ContactList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContactList(contactListName: \(String(describing: contactListName)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)))"}
}

/// <p>A list that contains contacts that have subscribed to a particular topic or
///             topics.</p>
public struct ContactList: Equatable {
    /// <p>The name of the contact list.</p>
    public let contactListName: String?
    /// <p>A timestamp noting the last time the contact list was updated.</p>
    public let lastUpdatedTimestamp: Date?

    public init (
        contactListName: String? = nil,
        lastUpdatedTimestamp: Date? = nil
    )
    {
        self.contactListName = contactListName
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
    }
}

extension ContactListDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactListImportAction = "ContactListImportAction"
        case contactListName = "ContactListName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactListImportAction = contactListImportAction {
            try encodeContainer.encode(contactListImportAction.rawValue, forKey: .contactListImportAction)
        }
        if let contactListName = contactListName {
            try encodeContainer.encode(contactListName, forKey: .contactListName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactListNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactListName)
        contactListName = contactListNameDecoded
        let contactListImportActionDecoded = try containerValues.decodeIfPresent(ContactListImportAction.self, forKey: .contactListImportAction)
        contactListImportAction = contactListImportActionDecoded
    }
}

extension ContactListDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContactListDestination(contactListImportAction: \(String(describing: contactListImportAction)), contactListName: \(String(describing: contactListName)))"}
}

/// <p>An object that contains details about the action of a contact list.</p>
public struct ContactListDestination: Equatable {
    /// <p>>The type of action that you want to perform on the addresses. Acceptable
    ///             values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>PUT: add the addresses to the contact list. If the record already exists, it
    ///                     will override it with the new value.</p>
    ///             </li>
    ///             <li>
    ///                 <p>DELETE: remove the addresses from the contact list.</p>
    ///             </li>
    ///          </ul>
    public let contactListImportAction: ContactListImportAction?
    /// <p>The name of the contact list.</p>
    public let contactListName: String?

    public init (
        contactListImportAction: ContactListImportAction? = nil,
        contactListName: String? = nil
    )
    {
        self.contactListImportAction = contactListImportAction
        self.contactListName = contactListName
    }
}

public enum ContactListImportAction {
    case delete
    case put
    case sdkUnknown(String)
}

extension ContactListImportAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ContactListImportAction] {
        return [
            .delete,
            .put,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .delete: return "DELETE"
        case .put: return "PUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ContactListImportAction(rawValue: rawValue) ?? ContactListImportAction.sdkUnknown(rawValue)
    }
}

extension Content: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case charset = "Charset"
        case data = "Data"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let charset = charset {
            try encodeContainer.encode(charset, forKey: .charset)
        }
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .data)
        data = dataDecoded
        let charsetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .charset)
        charset = charsetDecoded
    }
}

extension Content: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Content(charset: \(String(describing: charset)), data: \(String(describing: data)))"}
}

/// <p>An object that represents the content of the email, and optionally a character set
///             specification.</p>
public struct Content: Equatable {
    /// <p>The character set for the content. Because of the constraints of the SMTP protocol,
    ///             Amazon SES uses 7-bit ASCII by default. If the text includes characters outside of the ASCII
    ///             range, you have to specify a character set. For example, you could specify
    ///                 <code>UTF-8</code>, <code>ISO-8859-1</code>, or <code>Shift_JIS</code>.</p>
    public let charset: String?
    /// <p>The content of the message itself.</p>
    public let data: String?

    public init (
        charset: String? = nil,
        data: String? = nil
    )
    {
        self.charset = charset
        self.data = data
    }
}

public struct CreateConfigurationSetEventDestinationInputBodyMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetEventDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetEventDestinationOutputError>
}

extension CreateConfigurationSetEventDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationSetEventDestinationInput(configurationSetName: \(String(describing: configurationSetName)), eventDestination: \(String(describing: eventDestination)), eventDestinationName: \(String(describing: eventDestinationName)))"}
}

extension CreateConfigurationSetEventDestinationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventDestination = "EventDestination"
        case eventDestinationName = "EventDestinationName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDestination = eventDestination {
            try encodeContainer.encode(eventDestination, forKey: .eventDestination)
        }
        if let eventDestinationName = eventDestinationName {
            try encodeContainer.encode(eventDestinationName, forKey: .eventDestinationName)
        }
    }
}

public struct CreateConfigurationSetEventDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetEventDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetEventDestinationOutputError>
}

public struct CreateConfigurationSetEventDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetEventDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetEventDestinationOutputError>
}

/// <p>A request to add an event destination to a configuration set.</p>
public struct CreateConfigurationSetEventDestinationInput: Equatable {
    /// <p>The name of the configuration set that you want to add an event destination to.</p>
    public let configurationSetName: String?
    /// <p>An object that defines the event destination.</p>
    public let eventDestination: EventDestinationDefinition?
    /// <p>A name that identifies the event destination within the configuration set.</p>
    public let eventDestinationName: String?

    public init (
        configurationSetName: String? = nil,
        eventDestination: EventDestinationDefinition? = nil,
        eventDestinationName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
        self.eventDestinationName = eventDestinationName
    }
}

struct CreateConfigurationSetEventDestinationInputBody: Equatable {
    public let eventDestinationName: String?
    public let eventDestination: EventDestinationDefinition?
}

extension CreateConfigurationSetEventDestinationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventDestination = "EventDestination"
        case eventDestinationName = "EventDestinationName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDestinationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventDestinationName)
        eventDestinationName = eventDestinationNameDecoded
        let eventDestinationDecoded = try containerValues.decodeIfPresent(EventDestinationDefinition.self, forKey: .eventDestination)
        eventDestination = eventDestinationDecoded
    }
}

extension CreateConfigurationSetEventDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigurationSetEventDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationSetEventDestinationOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationSetEventDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationSetEventDestinationOutputResponse()"}
}

extension CreateConfigurationSetEventDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct CreateConfigurationSetEventDestinationOutputResponse: Equatable {

    public init() {}
}

struct CreateConfigurationSetEventDestinationOutputResponseBody: Equatable {
}

extension CreateConfigurationSetEventDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateConfigurationSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetOutputError>
}

extension CreateConfigurationSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationSetInput(configurationSetName: \(String(describing: configurationSetName)), deliveryOptions: \(String(describing: deliveryOptions)), reputationOptions: \(String(describing: reputationOptions)), sendingOptions: \(String(describing: sendingOptions)), suppressionOptions: \(String(describing: suppressionOptions)), tags: \(String(describing: tags)), trackingOptions: \(String(describing: trackingOptions)))"}
}

extension CreateConfigurationSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case deliveryOptions = "DeliveryOptions"
        case reputationOptions = "ReputationOptions"
        case sendingOptions = "SendingOptions"
        case suppressionOptions = "SuppressionOptions"
        case tags = "Tags"
        case trackingOptions = "TrackingOptions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let deliveryOptions = deliveryOptions {
            try encodeContainer.encode(deliveryOptions, forKey: .deliveryOptions)
        }
        if let reputationOptions = reputationOptions {
            try encodeContainer.encode(reputationOptions, forKey: .reputationOptions)
        }
        if let sendingOptions = sendingOptions {
            try encodeContainer.encode(sendingOptions, forKey: .sendingOptions)
        }
        if let suppressionOptions = suppressionOptions {
            try encodeContainer.encode(suppressionOptions, forKey: .suppressionOptions)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let trackingOptions = trackingOptions {
            try encodeContainer.encode(trackingOptions, forKey: .trackingOptions)
        }
    }
}

public struct CreateConfigurationSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetOutputError>
}

public struct CreateConfigurationSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetOutputError>
}

/// <p>A request to create a configuration set.</p>
public struct CreateConfigurationSetInput: Equatable {
    /// <p>The name of the configuration set.</p>
    public let configurationSetName: String?
    /// <p>An object that defines the dedicated IP pool that is used to send emails that you send
    ///             using the configuration set.</p>
    public let deliveryOptions: DeliveryOptions?
    /// <p>An object that defines whether or not Amazon SES collects reputation metrics for the emails
    ///             that you send that use the configuration set.</p>
    public let reputationOptions: ReputationOptions?
    /// <p>An object that defines whether or not Amazon SES can send email that you send using the
    ///             configuration set.</p>
    public let sendingOptions: SendingOptions?
    /// <p>An object that contains information about the suppression list preferences for your
    ///             account.</p>
    public let suppressionOptions: SuppressionOptions?
    /// <p>An array of objects that define the tags (keys and values) that you want to associate
    ///             with the configuration set.</p>
    public let tags: [Tag]?
    /// <p>An object that defines the open and click tracking options for emails that you send
    ///             using the configuration set.</p>
    public let trackingOptions: TrackingOptions?

    public init (
        configurationSetName: String? = nil,
        deliveryOptions: DeliveryOptions? = nil,
        reputationOptions: ReputationOptions? = nil,
        sendingOptions: SendingOptions? = nil,
        suppressionOptions: SuppressionOptions? = nil,
        tags: [Tag]? = nil,
        trackingOptions: TrackingOptions? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.deliveryOptions = deliveryOptions
        self.reputationOptions = reputationOptions
        self.sendingOptions = sendingOptions
        self.suppressionOptions = suppressionOptions
        self.tags = tags
        self.trackingOptions = trackingOptions
    }
}

struct CreateConfigurationSetInputBody: Equatable {
    public let configurationSetName: String?
    public let trackingOptions: TrackingOptions?
    public let deliveryOptions: DeliveryOptions?
    public let reputationOptions: ReputationOptions?
    public let sendingOptions: SendingOptions?
    public let tags: [Tag]?
    public let suppressionOptions: SuppressionOptions?
}

extension CreateConfigurationSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case deliveryOptions = "DeliveryOptions"
        case reputationOptions = "ReputationOptions"
        case sendingOptions = "SendingOptions"
        case suppressionOptions = "SuppressionOptions"
        case tags = "Tags"
        case trackingOptions = "TrackingOptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let trackingOptionsDecoded = try containerValues.decodeIfPresent(TrackingOptions.self, forKey: .trackingOptions)
        trackingOptions = trackingOptionsDecoded
        let deliveryOptionsDecoded = try containerValues.decodeIfPresent(DeliveryOptions.self, forKey: .deliveryOptions)
        deliveryOptions = deliveryOptionsDecoded
        let reputationOptionsDecoded = try containerValues.decodeIfPresent(ReputationOptions.self, forKey: .reputationOptions)
        reputationOptions = reputationOptionsDecoded
        let sendingOptionsDecoded = try containerValues.decodeIfPresent(SendingOptions.self, forKey: .sendingOptions)
        sendingOptions = sendingOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let suppressionOptionsDecoded = try containerValues.decodeIfPresent(SuppressionOptions.self, forKey: .suppressionOptions)
        suppressionOptions = suppressionOptionsDecoded
    }
}

extension CreateConfigurationSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigurationSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationSetOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationSetOutputResponse()"}
}

extension CreateConfigurationSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct CreateConfigurationSetOutputResponse: Equatable {

    public init() {}
}

struct CreateConfigurationSetOutputResponseBody: Equatable {
}

extension CreateConfigurationSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateContactInputBodyMiddleware: Middleware {
    public let id: String = "CreateContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContactInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContactInput>
    public typealias MOutput = OperationOutput<CreateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContactOutputError>
}

extension CreateContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateContactInput(attributesData: \(String(describing: attributesData)), contactListName: \(String(describing: contactListName)), emailAddress: \(String(describing: emailAddress)), topicPreferences: \(String(describing: topicPreferences)), unsubscribeAll: \(String(describing: unsubscribeAll)))"}
}

extension CreateContactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributesData = "AttributesData"
        case emailAddress = "EmailAddress"
        case topicPreferences = "TopicPreferences"
        case unsubscribeAll = "UnsubscribeAll"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributesData = attributesData {
            try encodeContainer.encode(attributesData, forKey: .attributesData)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let topicPreferences = topicPreferences {
            var topicPreferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topicPreferences)
            for topicpreferencelist0 in topicPreferences {
                try topicPreferencesContainer.encode(topicpreferencelist0)
            }
        }
        if unsubscribeAll != false {
            try encodeContainer.encode(unsubscribeAll, forKey: .unsubscribeAll)
        }
    }
}

public struct CreateContactInputHeadersMiddleware: Middleware {
    public let id: String = "CreateContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContactInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContactInput>
    public typealias MOutput = OperationOutput<CreateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContactOutputError>
}

public struct CreateContactInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContactInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContactInput>
    public typealias MOutput = OperationOutput<CreateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContactOutputError>
}

public struct CreateContactInput: Equatable {
    /// <p>The attribute data attached to a contact.</p>
    public let attributesData: String?
    /// <p>The name of the contact list to which the contact should be added.</p>
    public let contactListName: String?
    /// <p>The contact's email address.</p>
    public let emailAddress: String?
    /// <p>The contact's preferences for being opted-in to or opted-out of topics.</p>
    public let topicPreferences: [TopicPreference]?
    /// <p>A boolean value status noting if the contact is unsubscribed from all contact list
    ///             topics.</p>
    public let unsubscribeAll: Bool

    public init (
        attributesData: String? = nil,
        contactListName: String? = nil,
        emailAddress: String? = nil,
        topicPreferences: [TopicPreference]? = nil,
        unsubscribeAll: Bool = false
    )
    {
        self.attributesData = attributesData
        self.contactListName = contactListName
        self.emailAddress = emailAddress
        self.topicPreferences = topicPreferences
        self.unsubscribeAll = unsubscribeAll
    }
}

struct CreateContactInputBody: Equatable {
    public let emailAddress: String?
    public let topicPreferences: [TopicPreference]?
    public let unsubscribeAll: Bool
    public let attributesData: String?
}

extension CreateContactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributesData = "AttributesData"
        case emailAddress = "EmailAddress"
        case topicPreferences = "TopicPreferences"
        case unsubscribeAll = "UnsubscribeAll"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let topicPreferencesContainer = try containerValues.decodeIfPresent([TopicPreference?].self, forKey: .topicPreferences)
        var topicPreferencesDecoded0:[TopicPreference]? = nil
        if let topicPreferencesContainer = topicPreferencesContainer {
            topicPreferencesDecoded0 = [TopicPreference]()
            for structure0 in topicPreferencesContainer {
                if let structure0 = structure0 {
                    topicPreferencesDecoded0?.append(structure0)
                }
            }
        }
        topicPreferences = topicPreferencesDecoded0
        let unsubscribeAllDecoded = try containerValues.decode(Bool.self, forKey: .unsubscribeAll)
        unsubscribeAll = unsubscribeAllDecoded
        let attributesDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributesData)
        attributesData = attributesDataDecoded
    }
}

public struct CreateContactListInputBodyMiddleware: Middleware {
    public let id: String = "CreateContactListInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContactListInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContactListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContactListInput>
    public typealias MOutput = OperationOutput<CreateContactListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContactListOutputError>
}

extension CreateContactListInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateContactListInput(contactListName: \(String(describing: contactListName)), description: \(String(describing: description)), tags: \(String(describing: tags)), topics: \(String(describing: topics)))"}
}

extension CreateContactListInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactListName = "ContactListName"
        case description = "Description"
        case tags = "Tags"
        case topics = "Topics"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactListName = contactListName {
            try encodeContainer.encode(contactListName, forKey: .contactListName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let topics = topics {
            var topicsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topics)
            for topics0 in topics {
                try topicsContainer.encode(topics0)
            }
        }
    }
}

public struct CreateContactListInputHeadersMiddleware: Middleware {
    public let id: String = "CreateContactListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContactListInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContactListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContactListInput>
    public typealias MOutput = OperationOutput<CreateContactListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContactListOutputError>
}

public struct CreateContactListInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateContactListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContactListInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContactListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContactListInput>
    public typealias MOutput = OperationOutput<CreateContactListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContactListOutputError>
}

public struct CreateContactListInput: Equatable {
    /// <p>The name of the contact list.</p>
    public let contactListName: String?
    /// <p>A description of what the contact list is about.</p>
    public let description: String?
    /// <p>The tags associated with a contact list.</p>
    public let tags: [Tag]?
    /// <p>An interest group, theme, or label within a list. A contact list can have multiple
    ///             topics.</p>
    public let topics: [Topic]?

    public init (
        contactListName: String? = nil,
        description: String? = nil,
        tags: [Tag]? = nil,
        topics: [Topic]? = nil
    )
    {
        self.contactListName = contactListName
        self.description = description
        self.tags = tags
        self.topics = topics
    }
}

struct CreateContactListInputBody: Equatable {
    public let contactListName: String?
    public let topics: [Topic]?
    public let description: String?
    public let tags: [Tag]?
}

extension CreateContactListInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactListName = "ContactListName"
        case description = "Description"
        case tags = "Tags"
        case topics = "Topics"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactListNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactListName)
        contactListName = contactListNameDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Topic?].self, forKey: .topics)
        var topicsDecoded0:[Topic]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Topic]()
            for structure0 in topicsContainer {
                if let structure0 = structure0 {
                    topicsDecoded0?.append(structure0)
                }
            }
        }
        topics = topicsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateContactListOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateContactListOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateContactListOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateContactListOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateContactListOutputResponse()"}
}

extension CreateContactListOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateContactListOutputResponse: Equatable {

    public init() {}
}

struct CreateContactListOutputResponseBody: Equatable {
}

extension CreateContactListOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreateContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateContactOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateContactOutputResponse()"}
}

extension CreateContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateContactOutputResponse: Equatable {

    public init() {}
}

struct CreateContactOutputResponseBody: Equatable {
}

extension CreateContactOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateCustomVerificationEmailTemplateInputBodyMiddleware: Middleware {
    public let id: String = "CreateCustomVerificationEmailTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<CreateCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomVerificationEmailTemplateOutputError>
}

extension CreateCustomVerificationEmailTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomVerificationEmailTemplateInput(failureRedirectionURL: \(String(describing: failureRedirectionURL)), fromEmailAddress: \(String(describing: fromEmailAddress)), successRedirectionURL: \(String(describing: successRedirectionURL)), templateContent: \(String(describing: templateContent)), templateName: \(String(describing: templateName)), templateSubject: \(String(describing: templateSubject)))"}
}

extension CreateCustomVerificationEmailTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failureRedirectionURL = "FailureRedirectionURL"
        case fromEmailAddress = "FromEmailAddress"
        case successRedirectionURL = "SuccessRedirectionURL"
        case templateContent = "TemplateContent"
        case templateName = "TemplateName"
        case templateSubject = "TemplateSubject"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureRedirectionURL = failureRedirectionURL {
            try encodeContainer.encode(failureRedirectionURL, forKey: .failureRedirectionURL)
        }
        if let fromEmailAddress = fromEmailAddress {
            try encodeContainer.encode(fromEmailAddress, forKey: .fromEmailAddress)
        }
        if let successRedirectionURL = successRedirectionURL {
            try encodeContainer.encode(successRedirectionURL, forKey: .successRedirectionURL)
        }
        if let templateContent = templateContent {
            try encodeContainer.encode(templateContent, forKey: .templateContent)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateSubject = templateSubject {
            try encodeContainer.encode(templateSubject, forKey: .templateSubject)
        }
    }
}

public struct CreateCustomVerificationEmailTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCustomVerificationEmailTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<CreateCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomVerificationEmailTemplateOutputError>
}

public struct CreateCustomVerificationEmailTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCustomVerificationEmailTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<CreateCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomVerificationEmailTemplateOutputError>
}

/// <p>Represents a request to create a custom verification email template.</p>
public struct CreateCustomVerificationEmailTemplateInput: Equatable {
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    ///             is not successfully verified.</p>
    public let failureRedirectionURL: String?
    /// <p>The email address that the custom verification email is sent from.</p>
    public let fromEmailAddress: String?
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    ///             is successfully verified.</p>
    public let successRedirectionURL: String?
    /// <p>The content of the custom verification email. The total size of the email must be less
    ///             than 10 MB. The message body may contain HTML, with some limitations. For more
    ///             information, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-verify-address-custom.html#custom-verification-emails-faq">Custom Verification Email Frequently Asked Questions</a> in the <i>Amazon SES
    ///                 Developer Guide</i>.</p>
    public let templateContent: String?
    /// <p>The name of the custom verification email template.</p>
    public let templateName: String?
    /// <p>The subject line of the custom verification email.</p>
    public let templateSubject: String?

    public init (
        failureRedirectionURL: String? = nil,
        fromEmailAddress: String? = nil,
        successRedirectionURL: String? = nil,
        templateContent: String? = nil,
        templateName: String? = nil,
        templateSubject: String? = nil
    )
    {
        self.failureRedirectionURL = failureRedirectionURL
        self.fromEmailAddress = fromEmailAddress
        self.successRedirectionURL = successRedirectionURL
        self.templateContent = templateContent
        self.templateName = templateName
        self.templateSubject = templateSubject
    }
}

struct CreateCustomVerificationEmailTemplateInputBody: Equatable {
    public let templateName: String?
    public let fromEmailAddress: String?
    public let templateSubject: String?
    public let templateContent: String?
    public let successRedirectionURL: String?
    public let failureRedirectionURL: String?
}

extension CreateCustomVerificationEmailTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failureRedirectionURL = "FailureRedirectionURL"
        case fromEmailAddress = "FromEmailAddress"
        case successRedirectionURL = "SuccessRedirectionURL"
        case templateContent = "TemplateContent"
        case templateName = "TemplateName"
        case templateSubject = "TemplateSubject"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let fromEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromEmailAddress)
        fromEmailAddress = fromEmailAddressDecoded
        let templateSubjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateSubject)
        templateSubject = templateSubjectDecoded
        let templateContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateContent)
        templateContent = templateContentDecoded
        let successRedirectionURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .successRedirectionURL)
        successRedirectionURL = successRedirectionURLDecoded
        let failureRedirectionURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureRedirectionURL)
        failureRedirectionURL = failureRedirectionURLDecoded
    }
}

extension CreateCustomVerificationEmailTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCustomVerificationEmailTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCustomVerificationEmailTemplateOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomVerificationEmailTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomVerificationEmailTemplateOutputResponse()"}
}

extension CreateCustomVerificationEmailTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>If the action is successful, the service sends back an HTTP 200 response with an empty
///             HTTP body.</p>
public struct CreateCustomVerificationEmailTemplateOutputResponse: Equatable {

    public init() {}
}

struct CreateCustomVerificationEmailTemplateOutputResponseBody: Equatable {
}

extension CreateCustomVerificationEmailTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateDedicatedIpPoolInputBodyMiddleware: Middleware {
    public let id: String = "CreateDedicatedIpPoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDedicatedIpPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDedicatedIpPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDedicatedIpPoolInput>
    public typealias MOutput = OperationOutput<CreateDedicatedIpPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDedicatedIpPoolOutputError>
}

extension CreateDedicatedIpPoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDedicatedIpPoolInput(poolName: \(String(describing: poolName)), tags: \(String(describing: tags)))"}
}

extension CreateDedicatedIpPoolInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case poolName = "PoolName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let poolName = poolName {
            try encodeContainer.encode(poolName, forKey: .poolName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDedicatedIpPoolInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDedicatedIpPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDedicatedIpPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDedicatedIpPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDedicatedIpPoolInput>
    public typealias MOutput = OperationOutput<CreateDedicatedIpPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDedicatedIpPoolOutputError>
}

public struct CreateDedicatedIpPoolInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDedicatedIpPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDedicatedIpPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDedicatedIpPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDedicatedIpPoolInput>
    public typealias MOutput = OperationOutput<CreateDedicatedIpPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDedicatedIpPoolOutputError>
}

/// <p>A request to create a new dedicated IP pool.</p>
public struct CreateDedicatedIpPoolInput: Equatable {
    /// <p>The name of the dedicated IP pool.</p>
    public let poolName: String?
    /// <p>An object that defines the tags (keys and values) that you want to associate with the
    ///             pool.</p>
    public let tags: [Tag]?

    public init (
        poolName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.poolName = poolName
        self.tags = tags
    }
}

struct CreateDedicatedIpPoolInputBody: Equatable {
    public let poolName: String?
    public let tags: [Tag]?
}

extension CreateDedicatedIpPoolInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case poolName = "PoolName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .poolName)
        poolName = poolNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDedicatedIpPoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDedicatedIpPoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDedicatedIpPoolOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDedicatedIpPoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDedicatedIpPoolOutputResponse()"}
}

extension CreateDedicatedIpPoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct CreateDedicatedIpPoolOutputResponse: Equatable {

    public init() {}
}

struct CreateDedicatedIpPoolOutputResponseBody: Equatable {
}

extension CreateDedicatedIpPoolOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateDeliverabilityTestReportInputBodyMiddleware: Middleware {
    public let id: String = "CreateDeliverabilityTestReportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeliverabilityTestReportInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeliverabilityTestReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeliverabilityTestReportInput>
    public typealias MOutput = OperationOutput<CreateDeliverabilityTestReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeliverabilityTestReportOutputError>
}

extension CreateDeliverabilityTestReportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeliverabilityTestReportInput(content: \(String(describing: content)), fromEmailAddress: \(String(describing: fromEmailAddress)), reportName: \(String(describing: reportName)), tags: \(String(describing: tags)))"}
}

extension CreateDeliverabilityTestReportInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
        case fromEmailAddress = "FromEmailAddress"
        case reportName = "ReportName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let fromEmailAddress = fromEmailAddress {
            try encodeContainer.encode(fromEmailAddress, forKey: .fromEmailAddress)
        }
        if let reportName = reportName {
            try encodeContainer.encode(reportName, forKey: .reportName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDeliverabilityTestReportInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDeliverabilityTestReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeliverabilityTestReportInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeliverabilityTestReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeliverabilityTestReportInput>
    public typealias MOutput = OperationOutput<CreateDeliverabilityTestReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeliverabilityTestReportOutputError>
}

public struct CreateDeliverabilityTestReportInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDeliverabilityTestReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeliverabilityTestReportInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeliverabilityTestReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeliverabilityTestReportInput>
    public typealias MOutput = OperationOutput<CreateDeliverabilityTestReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeliverabilityTestReportOutputError>
}

/// <p>A request to perform a predictive inbox placement test. Predictive inbox placement tests can help you predict how your messages will
///             be handled by various email providers around the world. When you perform a predictive inbox placement test, you
///             provide a sample message that contains the content that you plan to send to your
///             customers. We send that message to special email addresses spread across several major
///             email providers around the world. The test takes about 24 hours to complete. When the
///             test is complete, you can use the <code>GetDeliverabilityTestReport</code> operation to
///             view the results of the test.</p>
public struct CreateDeliverabilityTestReportInput: Equatable {
    /// <p>The HTML body of the message that you sent when you performed the predictive inbox placement test.</p>
    public let content: EmailContent?
    /// <p>The email address that the predictive inbox placement test email was sent from.</p>
    public let fromEmailAddress: String?
    /// <p>A unique name that helps you to identify the predictive inbox placement test when you retrieve the
    ///             results.</p>
    public let reportName: String?
    /// <p>An array of objects that define the tags (keys and values) that you want to associate
    ///             with the predictive inbox placement test.</p>
    public let tags: [Tag]?

    public init (
        content: EmailContent? = nil,
        fromEmailAddress: String? = nil,
        reportName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.content = content
        self.fromEmailAddress = fromEmailAddress
        self.reportName = reportName
        self.tags = tags
    }
}

struct CreateDeliverabilityTestReportInputBody: Equatable {
    public let reportName: String?
    public let fromEmailAddress: String?
    public let content: EmailContent?
    public let tags: [Tag]?
}

extension CreateDeliverabilityTestReportInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
        case fromEmailAddress = "FromEmailAddress"
        case reportName = "ReportName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportName)
        reportName = reportNameDecoded
        let fromEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromEmailAddress)
        fromEmailAddress = fromEmailAddressDecoded
        let contentDecoded = try containerValues.decodeIfPresent(EmailContent.self, forKey: .content)
        content = contentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDeliverabilityTestReportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeliverabilityTestReportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccountSuspendedException" : self = .accountSuspendedException(try AccountSuspendedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailFromDomainNotVerifiedException" : self = .mailFromDomainNotVerifiedException(try MailFromDomainNotVerifiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MessageRejected" : self = .messageRejected(try MessageRejected(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SendingPausedException" : self = .sendingPausedException(try SendingPausedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeliverabilityTestReportOutputError: Equatable {
    case accountSuspendedException(AccountSuspendedException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case mailFromDomainNotVerifiedException(MailFromDomainNotVerifiedException)
    case messageRejected(MessageRejected)
    case notFoundException(NotFoundException)
    case sendingPausedException(SendingPausedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeliverabilityTestReportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeliverabilityTestReportOutputResponse(deliverabilityTestStatus: \(String(describing: deliverabilityTestStatus)), reportId: \(String(describing: reportId)))"}
}

extension CreateDeliverabilityTestReportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDeliverabilityTestReportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deliverabilityTestStatus = output.deliverabilityTestStatus
            self.reportId = output.reportId
        } else {
            self.deliverabilityTestStatus = nil
            self.reportId = nil
        }
    }
}

/// <p>Information about the predictive inbox placement test that you created.</p>
public struct CreateDeliverabilityTestReportOutputResponse: Equatable {
    /// <p>The status of the predictive inbox placement test. If the status is <code>IN_PROGRESS</code>, then the predictive inbox placement test
    ///             is currently running. Predictive inbox placement tests are usually complete within 24 hours of creating the
    ///             test. If the status is <code>COMPLETE</code>, then the test is finished, and you can use
    ///             the <code>GetDeliverabilityTestReport</code> to view the results of the test.</p>
    public let deliverabilityTestStatus: DeliverabilityTestStatus?
    /// <p>A unique string that identifies the predictive inbox placement test.</p>
    public let reportId: String?

    public init (
        deliverabilityTestStatus: DeliverabilityTestStatus? = nil,
        reportId: String? = nil
    )
    {
        self.deliverabilityTestStatus = deliverabilityTestStatus
        self.reportId = reportId
    }
}

struct CreateDeliverabilityTestReportOutputResponseBody: Equatable {
    public let reportId: String?
    public let deliverabilityTestStatus: DeliverabilityTestStatus?
}

extension CreateDeliverabilityTestReportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deliverabilityTestStatus = "DeliverabilityTestStatus"
        case reportId = "ReportId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let deliverabilityTestStatusDecoded = try containerValues.decodeIfPresent(DeliverabilityTestStatus.self, forKey: .deliverabilityTestStatus)
        deliverabilityTestStatus = deliverabilityTestStatusDecoded
    }
}

public struct CreateEmailIdentityInputBodyMiddleware: Middleware {
    public let id: String = "CreateEmailIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEmailIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEmailIdentityInput>
    public typealias MOutput = OperationOutput<CreateEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEmailIdentityOutputError>
}

extension CreateEmailIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEmailIdentityInput(configurationSetName: \(String(describing: configurationSetName)), dkimSigningAttributes: \(String(describing: dkimSigningAttributes)), emailIdentity: \(String(describing: emailIdentity)), tags: \(String(describing: tags)))"}
}

extension CreateEmailIdentityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case dkimSigningAttributes = "DkimSigningAttributes"
        case emailIdentity = "EmailIdentity"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let dkimSigningAttributes = dkimSigningAttributes {
            try encodeContainer.encode(dkimSigningAttributes, forKey: .dkimSigningAttributes)
        }
        if let emailIdentity = emailIdentity {
            try encodeContainer.encode(emailIdentity, forKey: .emailIdentity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateEmailIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEmailIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEmailIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEmailIdentityInput>
    public typealias MOutput = OperationOutput<CreateEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEmailIdentityOutputError>
}

public struct CreateEmailIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEmailIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEmailIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEmailIdentityInput>
    public typealias MOutput = OperationOutput<CreateEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEmailIdentityOutputError>
}

/// <p>A request to begin the verification process for an email identity (an email address or
///             domain).</p>
public struct CreateEmailIdentityInput: Equatable {
    /// <p>The configuration set to use by default when sending from this identity.
    ///             Note that any configuration set defined in the email sending request takes precedence.
    ///         </p>
    public let configurationSetName: String?
    /// <p>If your request includes this object, Amazon SES configures the identity to use Bring Your
    ///             Own DKIM (BYODKIM) for DKIM authentication purposes, as opposed to the default method,
    ///                 <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html">Easy
    ///                 DKIM</a>.</p>
    ///         <p>You can only specify this object if the email identity is a domain, as opposed to an
    ///             address.</p>
    public let dkimSigningAttributes: DkimSigningAttributes?
    /// <p>The email address or domain that you want to verify.</p>
    public let emailIdentity: String?
    /// <p>An array of objects that define the tags (keys and values) that you want to associate
    ///             with the email identity.</p>
    public let tags: [Tag]?

    public init (
        configurationSetName: String? = nil,
        dkimSigningAttributes: DkimSigningAttributes? = nil,
        emailIdentity: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.dkimSigningAttributes = dkimSigningAttributes
        self.emailIdentity = emailIdentity
        self.tags = tags
    }
}

struct CreateEmailIdentityInputBody: Equatable {
    public let emailIdentity: String?
    public let tags: [Tag]?
    public let dkimSigningAttributes: DkimSigningAttributes?
    public let configurationSetName: String?
}

extension CreateEmailIdentityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case dkimSigningAttributes = "DkimSigningAttributes"
        case emailIdentity = "EmailIdentity"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailIdentityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailIdentity)
        emailIdentity = emailIdentityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let dkimSigningAttributesDecoded = try containerValues.decodeIfPresent(DkimSigningAttributes.self, forKey: .dkimSigningAttributes)
        dkimSigningAttributes = dkimSigningAttributesDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
    }
}

extension CreateEmailIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEmailIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEmailIdentityOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEmailIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEmailIdentityOutputResponse(dkimAttributes: \(String(describing: dkimAttributes)), identityType: \(String(describing: identityType)), verifiedForSendingStatus: \(String(describing: verifiedForSendingStatus)))"}
}

extension CreateEmailIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateEmailIdentityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dkimAttributes = output.dkimAttributes
            self.identityType = output.identityType
            self.verifiedForSendingStatus = output.verifiedForSendingStatus
        } else {
            self.dkimAttributes = nil
            self.identityType = nil
            self.verifiedForSendingStatus = false
        }
    }
}

/// <p>If the email identity is a domain, this object contains information about the DKIM
///             verification status for the domain.</p>
///         <p>If the email identity is an email address, this object is empty. </p>
public struct CreateEmailIdentityOutputResponse: Equatable {
    /// <p>An object that contains information about the DKIM attributes for the identity.</p>
    public let dkimAttributes: DkimAttributes?
    /// <p>The email identity type.</p>
    public let identityType: IdentityType?
    /// <p>Specifies whether or not the identity is verified. You can only send email from
    ///             verified email addresses or domains. For more information about verifying identities,
    ///             see the <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-email-manage-verify.html">Amazon Pinpoint User Guide</a>.</p>
    public let verifiedForSendingStatus: Bool

    public init (
        dkimAttributes: DkimAttributes? = nil,
        identityType: IdentityType? = nil,
        verifiedForSendingStatus: Bool = false
    )
    {
        self.dkimAttributes = dkimAttributes
        self.identityType = identityType
        self.verifiedForSendingStatus = verifiedForSendingStatus
    }
}

struct CreateEmailIdentityOutputResponseBody: Equatable {
    public let identityType: IdentityType?
    public let verifiedForSendingStatus: Bool
    public let dkimAttributes: DkimAttributes?
}

extension CreateEmailIdentityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dkimAttributes = "DkimAttributes"
        case identityType = "IdentityType"
        case verifiedForSendingStatus = "VerifiedForSendingStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityTypeDecoded = try containerValues.decodeIfPresent(IdentityType.self, forKey: .identityType)
        identityType = identityTypeDecoded
        let verifiedForSendingStatusDecoded = try containerValues.decode(Bool.self, forKey: .verifiedForSendingStatus)
        verifiedForSendingStatus = verifiedForSendingStatusDecoded
        let dkimAttributesDecoded = try containerValues.decodeIfPresent(DkimAttributes.self, forKey: .dkimAttributes)
        dkimAttributes = dkimAttributesDecoded
    }
}

public struct CreateEmailIdentityPolicyInputBodyMiddleware: Middleware {
    public let id: String = "CreateEmailIdentityPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEmailIdentityPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEmailIdentityPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEmailIdentityPolicyInput>
    public typealias MOutput = OperationOutput<CreateEmailIdentityPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEmailIdentityPolicyOutputError>
}

extension CreateEmailIdentityPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEmailIdentityPolicyInput(emailIdentity: \(String(describing: emailIdentity)), policy: \(String(describing: policy)), policyName: \(String(describing: policyName)))"}
}

extension CreateEmailIdentityPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct CreateEmailIdentityPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEmailIdentityPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEmailIdentityPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEmailIdentityPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEmailIdentityPolicyInput>
    public typealias MOutput = OperationOutput<CreateEmailIdentityPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEmailIdentityPolicyOutputError>
}

public struct CreateEmailIdentityPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEmailIdentityPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEmailIdentityPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEmailIdentityPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEmailIdentityPolicyInput>
    public typealias MOutput = OperationOutput<CreateEmailIdentityPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEmailIdentityPolicyOutputError>
}

/// <p>Represents a request to create a sending authorization policy for an identity. Sending
///             authorization is an Amazon SES feature that enables you to authorize other senders to use
///             your identities. For information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization-identity-owner-tasks-management.html">Amazon SES Developer Guide</a>.</p>
public struct CreateEmailIdentityPolicyInput: Equatable {
    /// <p>The email identity for which you want to create a policy.</p>
    public let emailIdentity: String?
    /// <p>The text of the policy in JSON format. The policy cannot exceed 4 KB.</p>
    ///         <p>For information about the syntax of sending authorization policies, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization-policies.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    public let policy: String?
    /// <p>The name of the policy.</p>
    ///
    ///         <p>The policy name cannot exceed 64 characters and can only include alphanumeric
    ///             characters, dashes, and underscores.</p>
    public let policyName: String?

    public init (
        emailIdentity: String? = nil,
        policy: String? = nil,
        policyName: String? = nil
    )
    {
        self.emailIdentity = emailIdentity
        self.policy = policy
        self.policyName = policyName
    }
}

struct CreateEmailIdentityPolicyInputBody: Equatable {
    public let policy: String?
}

extension CreateEmailIdentityPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension CreateEmailIdentityPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEmailIdentityPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEmailIdentityPolicyOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEmailIdentityPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEmailIdentityPolicyOutputResponse()"}
}

extension CreateEmailIdentityPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct CreateEmailIdentityPolicyOutputResponse: Equatable {

    public init() {}
}

struct CreateEmailIdentityPolicyOutputResponseBody: Equatable {
}

extension CreateEmailIdentityPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateEmailTemplateInputBodyMiddleware: Middleware {
    public let id: String = "CreateEmailTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEmailTemplateInput>
    public typealias MOutput = OperationOutput<CreateEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEmailTemplateOutputError>
}

extension CreateEmailTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEmailTemplateInput(templateContent: \(String(describing: templateContent)), templateName: \(String(describing: templateName)))"}
}

extension CreateEmailTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case templateContent = "TemplateContent"
        case templateName = "TemplateName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateContent = templateContent {
            try encodeContainer.encode(templateContent, forKey: .templateContent)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

public struct CreateEmailTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEmailTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEmailTemplateInput>
    public typealias MOutput = OperationOutput<CreateEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEmailTemplateOutputError>
}

public struct CreateEmailTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEmailTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEmailTemplateInput>
    public typealias MOutput = OperationOutput<CreateEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEmailTemplateOutputError>
}

/// <p>Represents a request to create an email template. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-personalized-email-api.html">Amazon SES
///                 Developer Guide</a>.</p>
public struct CreateEmailTemplateInput: Equatable {
    /// <p>The content of the email template, composed of a subject line, an HTML part, and a
    ///             text-only part.</p>
    public let templateContent: EmailTemplateContent?
    /// <p>The name of the template you want to create.</p>
    public let templateName: String?

    public init (
        templateContent: EmailTemplateContent? = nil,
        templateName: String? = nil
    )
    {
        self.templateContent = templateContent
        self.templateName = templateName
    }
}

struct CreateEmailTemplateInputBody: Equatable {
    public let templateName: String?
    public let templateContent: EmailTemplateContent?
}

extension CreateEmailTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case templateContent = "TemplateContent"
        case templateName = "TemplateName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateContentDecoded = try containerValues.decodeIfPresent(EmailTemplateContent.self, forKey: .templateContent)
        templateContent = templateContentDecoded
    }
}

extension CreateEmailTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEmailTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEmailTemplateOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEmailTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEmailTemplateOutputResponse()"}
}

extension CreateEmailTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>If the action is successful, the service sends back an HTTP 200 response with an empty
///             HTTP body.</p>
public struct CreateEmailTemplateOutputResponse: Equatable {

    public init() {}
}

struct CreateEmailTemplateOutputResponseBody: Equatable {
}

extension CreateEmailTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateImportJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImportJobInput>
    public typealias MOutput = OperationOutput<CreateImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImportJobOutputError>
}

extension CreateImportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateImportJobInput(importDataSource: \(String(describing: importDataSource)), importDestination: \(String(describing: importDestination)))"}
}

extension CreateImportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case importDataSource = "ImportDataSource"
        case importDestination = "ImportDestination"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let importDataSource = importDataSource {
            try encodeContainer.encode(importDataSource, forKey: .importDataSource)
        }
        if let importDestination = importDestination {
            try encodeContainer.encode(importDestination, forKey: .importDestination)
        }
    }
}

public struct CreateImportJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImportJobInput>
    public typealias MOutput = OperationOutput<CreateImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImportJobOutputError>
}

public struct CreateImportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImportJobInput>
    public typealias MOutput = OperationOutput<CreateImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImportJobOutputError>
}

/// <p>Represents a request to create an import job from a data source for a data
///             destination.</p>
public struct CreateImportJobInput: Equatable {
    /// <p>The data source for the import job.</p>
    public let importDataSource: ImportDataSource?
    /// <p>The destination for the import job.</p>
    public let importDestination: ImportDestination?

    public init (
        importDataSource: ImportDataSource? = nil,
        importDestination: ImportDestination? = nil
    )
    {
        self.importDataSource = importDataSource
        self.importDestination = importDestination
    }
}

struct CreateImportJobInputBody: Equatable {
    public let importDestination: ImportDestination?
    public let importDataSource: ImportDataSource?
}

extension CreateImportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case importDataSource = "ImportDataSource"
        case importDestination = "ImportDestination"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importDestinationDecoded = try containerValues.decodeIfPresent(ImportDestination.self, forKey: .importDestination)
        importDestination = importDestinationDecoded
        let importDataSourceDecoded = try containerValues.decodeIfPresent(ImportDataSource.self, forKey: .importDataSource)
        importDataSource = importDataSourceDecoded
    }
}

extension CreateImportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateImportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateImportJobOutputError: Equatable {
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateImportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateImportJobOutputResponse(jobId: \(String(describing: jobId)))"}
}

extension CreateImportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateImportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct CreateImportJobOutputResponse: Equatable {
    /// <p>A string that represents the import job ID.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CreateImportJobOutputResponseBody: Equatable {
    public let jobId: String?
}

extension CreateImportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension CustomVerificationEmailTemplateMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failureRedirectionURL = "FailureRedirectionURL"
        case fromEmailAddress = "FromEmailAddress"
        case successRedirectionURL = "SuccessRedirectionURL"
        case templateName = "TemplateName"
        case templateSubject = "TemplateSubject"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureRedirectionURL = failureRedirectionURL {
            try encodeContainer.encode(failureRedirectionURL, forKey: .failureRedirectionURL)
        }
        if let fromEmailAddress = fromEmailAddress {
            try encodeContainer.encode(fromEmailAddress, forKey: .fromEmailAddress)
        }
        if let successRedirectionURL = successRedirectionURL {
            try encodeContainer.encode(successRedirectionURL, forKey: .successRedirectionURL)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateSubject = templateSubject {
            try encodeContainer.encode(templateSubject, forKey: .templateSubject)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let fromEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromEmailAddress)
        fromEmailAddress = fromEmailAddressDecoded
        let templateSubjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateSubject)
        templateSubject = templateSubjectDecoded
        let successRedirectionURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .successRedirectionURL)
        successRedirectionURL = successRedirectionURLDecoded
        let failureRedirectionURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureRedirectionURL)
        failureRedirectionURL = failureRedirectionURLDecoded
    }
}

extension CustomVerificationEmailTemplateMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomVerificationEmailTemplateMetadata(failureRedirectionURL: \(String(describing: failureRedirectionURL)), fromEmailAddress: \(String(describing: fromEmailAddress)), successRedirectionURL: \(String(describing: successRedirectionURL)), templateName: \(String(describing: templateName)), templateSubject: \(String(describing: templateSubject)))"}
}

/// <p>Contains information about a custom verification email template.</p>
public struct CustomVerificationEmailTemplateMetadata: Equatable {
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    ///             is not successfully verified.</p>
    public let failureRedirectionURL: String?
    /// <p>The email address that the custom verification email is sent from.</p>
    public let fromEmailAddress: String?
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    ///             is successfully verified.</p>
    public let successRedirectionURL: String?
    /// <p>The name of the custom verification email template.</p>
    public let templateName: String?
    /// <p>The subject line of the custom verification email.</p>
    public let templateSubject: String?

    public init (
        failureRedirectionURL: String? = nil,
        fromEmailAddress: String? = nil,
        successRedirectionURL: String? = nil,
        templateName: String? = nil,
        templateSubject: String? = nil
    )
    {
        self.failureRedirectionURL = failureRedirectionURL
        self.fromEmailAddress = fromEmailAddress
        self.successRedirectionURL = successRedirectionURL
        self.templateName = templateName
        self.templateSubject = templateSubject
    }
}

extension DailyVolume: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainIspPlacements = "DomainIspPlacements"
        case startDate = "StartDate"
        case volumeStatistics = "VolumeStatistics"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainIspPlacements = domainIspPlacements {
            var domainIspPlacementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainIspPlacements)
            for domainispplacements0 in domainIspPlacements {
                try domainIspPlacementsContainer.encode(domainispplacements0)
            }
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate.timeIntervalSince1970, forKey: .startDate)
        }
        if let volumeStatistics = volumeStatistics {
            try encodeContainer.encode(volumeStatistics, forKey: .volumeStatistics)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startDate)
        startDate = startDateDecoded
        let volumeStatisticsDecoded = try containerValues.decodeIfPresent(VolumeStatistics.self, forKey: .volumeStatistics)
        volumeStatistics = volumeStatisticsDecoded
        let domainIspPlacementsContainer = try containerValues.decodeIfPresent([DomainIspPlacement?].self, forKey: .domainIspPlacements)
        var domainIspPlacementsDecoded0:[DomainIspPlacement]? = nil
        if let domainIspPlacementsContainer = domainIspPlacementsContainer {
            domainIspPlacementsDecoded0 = [DomainIspPlacement]()
            for structure0 in domainIspPlacementsContainer {
                if let structure0 = structure0 {
                    domainIspPlacementsDecoded0?.append(structure0)
                }
            }
        }
        domainIspPlacements = domainIspPlacementsDecoded0
    }
}

extension DailyVolume: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DailyVolume(domainIspPlacements: \(String(describing: domainIspPlacements)), startDate: \(String(describing: startDate)), volumeStatistics: \(String(describing: volumeStatistics)))"}
}

/// <p>An object that contains information about the volume of email sent on each day of the
///             analysis period.</p>
public struct DailyVolume: Equatable {
    /// <p>An object that contains inbox placement metrics for a specified day in the analysis
    ///             period, broken out by the recipient's email provider.</p>
    public let domainIspPlacements: [DomainIspPlacement]?
    /// <p>The date that the DailyVolume metrics apply to, in Unix time.</p>
    public let startDate: Date?
    /// <p>An object that contains inbox placement metrics for a specific day in the analysis
    ///             period.</p>
    public let volumeStatistics: VolumeStatistics?

    public init (
        domainIspPlacements: [DomainIspPlacement]? = nil,
        startDate: Date? = nil,
        volumeStatistics: VolumeStatistics? = nil
    )
    {
        self.domainIspPlacements = domainIspPlacements
        self.startDate = startDate
        self.volumeStatistics = volumeStatistics
    }
}

/// <p>The data format of the import job's data source.</p>
public enum DataFormat {
    case csv
    case json
    case sdkUnknown(String)
}

extension DataFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataFormat] {
        return [
            .csv,
            .json,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "CSV"
        case .json: return "JSON"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataFormat(rawValue: rawValue) ?? DataFormat.sdkUnknown(rawValue)
    }
}

extension DedicatedIp: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ip = "Ip"
        case poolName = "PoolName"
        case warmupPercentage = "WarmupPercentage"
        case warmupStatus = "WarmupStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ip = ip {
            try encodeContainer.encode(ip, forKey: .ip)
        }
        if let poolName = poolName {
            try encodeContainer.encode(poolName, forKey: .poolName)
        }
        if let warmupPercentage = warmupPercentage {
            try encodeContainer.encode(warmupPercentage, forKey: .warmupPercentage)
        }
        if let warmupStatus = warmupStatus {
            try encodeContainer.encode(warmupStatus.rawValue, forKey: .warmupStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ip)
        ip = ipDecoded
        let warmupStatusDecoded = try containerValues.decodeIfPresent(WarmupStatus.self, forKey: .warmupStatus)
        warmupStatus = warmupStatusDecoded
        let warmupPercentageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .warmupPercentage)
        warmupPercentage = warmupPercentageDecoded
        let poolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .poolName)
        poolName = poolNameDecoded
    }
}

extension DedicatedIp: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DedicatedIp(ip: \(String(describing: ip)), poolName: \(String(describing: poolName)), warmupPercentage: \(String(describing: warmupPercentage)), warmupStatus: \(String(describing: warmupStatus)))"}
}

/// <p>Contains information about a dedicated IP address that is associated with your Amazon SES
///             account.</p>
///         <p>To learn more about requesting dedicated IP addresses, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/dedicated-ip-case.html">Requesting and Relinquishing
///                 Dedicated IP Addresses</a> in the <i>Amazon SES Developer
///             Guide</i>.</p>
public struct DedicatedIp: Equatable {
    /// <p>An IPv4 address.</p>
    public let ip: String?
    /// <p>The name of the dedicated IP pool that the IP address is associated with.</p>
    public let poolName: String?
    /// <p>Indicates how complete the dedicated IP warm-up process is. When this value equals 1,
    ///             the address has completed the warm-up process and is ready for use.</p>
    public let warmupPercentage: Int?
    /// <p>The warm-up status of a dedicated IP address. The status can have one of the following
    ///             values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>IN_PROGRESS</code> – The IP address isn't ready to use because the
    ///                     dedicated IP warm-up process is ongoing.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DONE</code> – The dedicated IP warm-up process is complete, and
    ///                     the IP address is ready to use.</p>
    ///             </li>
    ///          </ul>
    public let warmupStatus: WarmupStatus?

    public init (
        ip: String? = nil,
        poolName: String? = nil,
        warmupPercentage: Int? = nil,
        warmupStatus: WarmupStatus? = nil
    )
    {
        self.ip = ip
        self.poolName = poolName
        self.warmupPercentage = warmupPercentage
        self.warmupStatus = warmupStatus
    }
}

extension DeleteConfigurationSetEventDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationSetEventDestinationInput(configurationSetName: \(String(describing: configurationSetName)), eventDestinationName: \(String(describing: eventDestinationName)))"}
}

extension DeleteConfigurationSetEventDestinationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteConfigurationSetEventDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetEventDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetEventDestinationOutputError>
}

public struct DeleteConfigurationSetEventDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetEventDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetEventDestinationOutputError>
}

/// <p>A request to delete an event destination from a configuration set.</p>
public struct DeleteConfigurationSetEventDestinationInput: Equatable {
    /// <p>The name of the configuration set that contains the event destination that you want to
    ///             delete.</p>
    public let configurationSetName: String?
    /// <p>The name of the event destination that you want to delete.</p>
    public let eventDestinationName: String?

    public init (
        configurationSetName: String? = nil,
        eventDestinationName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestinationName = eventDestinationName
    }
}

struct DeleteConfigurationSetEventDestinationInputBody: Equatable {
}

extension DeleteConfigurationSetEventDestinationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteConfigurationSetEventDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigurationSetEventDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationSetEventDestinationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationSetEventDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationSetEventDestinationOutputResponse()"}
}

extension DeleteConfigurationSetEventDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct DeleteConfigurationSetEventDestinationOutputResponse: Equatable {

    public init() {}
}

struct DeleteConfigurationSetEventDestinationOutputResponseBody: Equatable {
}

extension DeleteConfigurationSetEventDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteConfigurationSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationSetInput(configurationSetName: \(String(describing: configurationSetName)))"}
}

extension DeleteConfigurationSetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteConfigurationSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetOutputError>
}

public struct DeleteConfigurationSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetOutputError>
}

/// <p>A request to delete a configuration set.</p>
public struct DeleteConfigurationSetInput: Equatable {
    /// <p>The name of the configuration set that you want to delete.</p>
    public let configurationSetName: String?

    public init (
        configurationSetName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct DeleteConfigurationSetInputBody: Equatable {
}

extension DeleteConfigurationSetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteConfigurationSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigurationSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationSetOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationSetOutputResponse()"}
}

extension DeleteConfigurationSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct DeleteConfigurationSetOutputResponse: Equatable {

    public init() {}
}

struct DeleteConfigurationSetOutputResponseBody: Equatable {
}

extension DeleteConfigurationSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteContactInput(contactListName: \(String(describing: contactListName)), emailAddress: \(String(describing: emailAddress)))"}
}

extension DeleteContactInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteContactInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContactInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContactInput>
    public typealias MOutput = OperationOutput<DeleteContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContactOutputError>
}

public struct DeleteContactInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContactInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContactInput>
    public typealias MOutput = OperationOutput<DeleteContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContactOutputError>
}

public struct DeleteContactInput: Equatable {
    /// <p>The name of the contact list from which the contact should be removed.</p>
    public let contactListName: String?
    /// <p>The contact's email address.</p>
    public let emailAddress: String?

    public init (
        contactListName: String? = nil,
        emailAddress: String? = nil
    )
    {
        self.contactListName = contactListName
        self.emailAddress = emailAddress
    }
}

struct DeleteContactInputBody: Equatable {
}

extension DeleteContactInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteContactListInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteContactListInput(contactListName: \(String(describing: contactListName)))"}
}

extension DeleteContactListInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteContactListInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteContactListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContactListInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContactListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContactListInput>
    public typealias MOutput = OperationOutput<DeleteContactListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContactListOutputError>
}

public struct DeleteContactListInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteContactListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContactListInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContactListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContactListInput>
    public typealias MOutput = OperationOutput<DeleteContactListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContactListOutputError>
}

public struct DeleteContactListInput: Equatable {
    /// <p>The name of the contact list.</p>
    public let contactListName: String?

    public init (
        contactListName: String? = nil
    )
    {
        self.contactListName = contactListName
    }
}

struct DeleteContactListInputBody: Equatable {
}

extension DeleteContactListInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteContactListOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContactListOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteContactListOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContactListOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteContactListOutputResponse()"}
}

extension DeleteContactListOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteContactListOutputResponse: Equatable {

    public init() {}
}

struct DeleteContactListOutputResponseBody: Equatable {
}

extension DeleteContactListOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteContactOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteContactOutputResponse()"}
}

extension DeleteContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteContactOutputResponse: Equatable {

    public init() {}
}

struct DeleteContactOutputResponseBody: Equatable {
}

extension DeleteContactOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCustomVerificationEmailTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomVerificationEmailTemplateInput(templateName: \(String(describing: templateName)))"}
}

extension DeleteCustomVerificationEmailTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteCustomVerificationEmailTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCustomVerificationEmailTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<DeleteCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomVerificationEmailTemplateOutputError>
}

public struct DeleteCustomVerificationEmailTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCustomVerificationEmailTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<DeleteCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomVerificationEmailTemplateOutputError>
}

/// <p>Represents a request to delete an existing custom verification email template.</p>
public struct DeleteCustomVerificationEmailTemplateInput: Equatable {
    /// <p>The name of the custom verification email template that you want to delete.</p>
    public let templateName: String?

    public init (
        templateName: String? = nil
    )
    {
        self.templateName = templateName
    }
}

struct DeleteCustomVerificationEmailTemplateInputBody: Equatable {
}

extension DeleteCustomVerificationEmailTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCustomVerificationEmailTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCustomVerificationEmailTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCustomVerificationEmailTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomVerificationEmailTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomVerificationEmailTemplateOutputResponse()"}
}

extension DeleteCustomVerificationEmailTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>If the action is successful, the service sends back an HTTP 200 response with an empty
///             HTTP body.</p>
public struct DeleteCustomVerificationEmailTemplateOutputResponse: Equatable {

    public init() {}
}

struct DeleteCustomVerificationEmailTemplateOutputResponseBody: Equatable {
}

extension DeleteCustomVerificationEmailTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDedicatedIpPoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDedicatedIpPoolInput(poolName: \(String(describing: poolName)))"}
}

extension DeleteDedicatedIpPoolInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDedicatedIpPoolInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDedicatedIpPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDedicatedIpPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDedicatedIpPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDedicatedIpPoolInput>
    public typealias MOutput = OperationOutput<DeleteDedicatedIpPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDedicatedIpPoolOutputError>
}

public struct DeleteDedicatedIpPoolInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDedicatedIpPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDedicatedIpPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDedicatedIpPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDedicatedIpPoolInput>
    public typealias MOutput = OperationOutput<DeleteDedicatedIpPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDedicatedIpPoolOutputError>
}

/// <p>A request to delete a dedicated IP pool.</p>
public struct DeleteDedicatedIpPoolInput: Equatable {
    /// <p>The name of the dedicated IP pool that you want to delete.</p>
    public let poolName: String?

    public init (
        poolName: String? = nil
    )
    {
        self.poolName = poolName
    }
}

struct DeleteDedicatedIpPoolInputBody: Equatable {
}

extension DeleteDedicatedIpPoolInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDedicatedIpPoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDedicatedIpPoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDedicatedIpPoolOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDedicatedIpPoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDedicatedIpPoolOutputResponse()"}
}

extension DeleteDedicatedIpPoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct DeleteDedicatedIpPoolOutputResponse: Equatable {

    public init() {}
}

struct DeleteDedicatedIpPoolOutputResponseBody: Equatable {
}

extension DeleteDedicatedIpPoolOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteEmailIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEmailIdentityInput(emailIdentity: \(String(describing: emailIdentity)))"}
}

extension DeleteEmailIdentityInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteEmailIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEmailIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEmailIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEmailIdentityInput>
    public typealias MOutput = OperationOutput<DeleteEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEmailIdentityOutputError>
}

public struct DeleteEmailIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEmailIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEmailIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEmailIdentityInput>
    public typealias MOutput = OperationOutput<DeleteEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEmailIdentityOutputError>
}

/// <p>A request to delete an existing email identity. When you delete an identity, you lose
///             the ability to send email from that identity. You can restore your ability to send email
///             by completing the verification process for the identity again.</p>
public struct DeleteEmailIdentityInput: Equatable {
    /// <p>The identity (that is, the email address or domain) that you want to delete.</p>
    public let emailIdentity: String?

    public init (
        emailIdentity: String? = nil
    )
    {
        self.emailIdentity = emailIdentity
    }
}

struct DeleteEmailIdentityInputBody: Equatable {
}

extension DeleteEmailIdentityInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteEmailIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEmailIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEmailIdentityOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEmailIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEmailIdentityOutputResponse()"}
}

extension DeleteEmailIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct DeleteEmailIdentityOutputResponse: Equatable {

    public init() {}
}

struct DeleteEmailIdentityOutputResponseBody: Equatable {
}

extension DeleteEmailIdentityOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteEmailIdentityPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEmailIdentityPolicyInput(emailIdentity: \(String(describing: emailIdentity)), policyName: \(String(describing: policyName)))"}
}

extension DeleteEmailIdentityPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteEmailIdentityPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEmailIdentityPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEmailIdentityPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEmailIdentityPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEmailIdentityPolicyInput>
    public typealias MOutput = OperationOutput<DeleteEmailIdentityPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEmailIdentityPolicyOutputError>
}

public struct DeleteEmailIdentityPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEmailIdentityPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEmailIdentityPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEmailIdentityPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEmailIdentityPolicyInput>
    public typealias MOutput = OperationOutput<DeleteEmailIdentityPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEmailIdentityPolicyOutputError>
}

/// <p>Represents a request to delete a sending authorization policy for an identity. Sending
///             authorization is an Amazon SES feature that enables you to authorize other senders to
///             use your identities. For information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization-identity-owner-tasks-management.html">Amazon SES Developer Guide</a>.</p>
public struct DeleteEmailIdentityPolicyInput: Equatable {
    /// <p>The email identity for which you want to delete a policy.</p>
    public let emailIdentity: String?
    /// <p>The name of the policy.</p>
    ///
    ///         <p>The policy name cannot exceed 64 characters and can only include alphanumeric
    ///             characters, dashes, and underscores.</p>
    public let policyName: String?

    public init (
        emailIdentity: String? = nil,
        policyName: String? = nil
    )
    {
        self.emailIdentity = emailIdentity
        self.policyName = policyName
    }
}

struct DeleteEmailIdentityPolicyInputBody: Equatable {
}

extension DeleteEmailIdentityPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteEmailIdentityPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEmailIdentityPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEmailIdentityPolicyOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEmailIdentityPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEmailIdentityPolicyOutputResponse()"}
}

extension DeleteEmailIdentityPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct DeleteEmailIdentityPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteEmailIdentityPolicyOutputResponseBody: Equatable {
}

extension DeleteEmailIdentityPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteEmailTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEmailTemplateInput(templateName: \(String(describing: templateName)))"}
}

extension DeleteEmailTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteEmailTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEmailTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEmailTemplateInput>
    public typealias MOutput = OperationOutput<DeleteEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEmailTemplateOutputError>
}

public struct DeleteEmailTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEmailTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEmailTemplateInput>
    public typealias MOutput = OperationOutput<DeleteEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEmailTemplateOutputError>
}

/// <p>Represents a request to delete an email template. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-personalized-email-api.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct DeleteEmailTemplateInput: Equatable {
    /// <p>The name of the template to be deleted.</p>
    public let templateName: String?

    public init (
        templateName: String? = nil
    )
    {
        self.templateName = templateName
    }
}

struct DeleteEmailTemplateInputBody: Equatable {
}

extension DeleteEmailTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteEmailTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEmailTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEmailTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEmailTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEmailTemplateOutputResponse()"}
}

extension DeleteEmailTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>If the action is successful, the service sends back an HTTP 200 response with an empty
///             HTTP body.</p>
public struct DeleteEmailTemplateOutputResponse: Equatable {

    public init() {}
}

struct DeleteEmailTemplateOutputResponseBody: Equatable {
}

extension DeleteEmailTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSuppressedDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSuppressedDestinationInput(emailAddress: \(String(describing: emailAddress)))"}
}

extension DeleteSuppressedDestinationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteSuppressedDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSuppressedDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSuppressedDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSuppressedDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSuppressedDestinationInput>
    public typealias MOutput = OperationOutput<DeleteSuppressedDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSuppressedDestinationOutputError>
}

public struct DeleteSuppressedDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSuppressedDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSuppressedDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSuppressedDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSuppressedDestinationInput>
    public typealias MOutput = OperationOutput<DeleteSuppressedDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSuppressedDestinationOutputError>
}

/// <p>A request to remove an email address from the suppression list for your
///             account.</p>
public struct DeleteSuppressedDestinationInput: Equatable {
    /// <p>The suppressed email destination to remove from the account suppression list.</p>
    public let emailAddress: String?

    public init (
        emailAddress: String? = nil
    )
    {
        self.emailAddress = emailAddress
    }
}

struct DeleteSuppressedDestinationInputBody: Equatable {
}

extension DeleteSuppressedDestinationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSuppressedDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSuppressedDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSuppressedDestinationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSuppressedDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSuppressedDestinationOutputResponse()"}
}

extension DeleteSuppressedDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct DeleteSuppressedDestinationOutputResponse: Equatable {

    public init() {}
}

struct DeleteSuppressedDestinationOutputResponseBody: Equatable {
}

extension DeleteSuppressedDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

/// <p>The current status of your Deliverability dashboard subscription. If this value is
///                 <code>PENDING_EXPIRATION</code>, your subscription is scheduled to expire at the end
///             of the current calendar month.</p>
public enum DeliverabilityDashboardAccountStatus {
    case active
    case disabled
    case pendingExpiration
    case sdkUnknown(String)
}

extension DeliverabilityDashboardAccountStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeliverabilityDashboardAccountStatus] {
        return [
            .active,
            .disabled,
            .pendingExpiration,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .disabled: return "DISABLED"
        case .pendingExpiration: return "PENDING_EXPIRATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeliverabilityDashboardAccountStatus(rawValue: rawValue) ?? DeliverabilityDashboardAccountStatus.sdkUnknown(rawValue)
    }
}

extension DeliverabilityTestReport: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createDate = "CreateDate"
        case deliverabilityTestStatus = "DeliverabilityTestStatus"
        case fromEmailAddress = "FromEmailAddress"
        case reportId = "ReportId"
        case reportName = "ReportName"
        case subject = "Subject"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let deliverabilityTestStatus = deliverabilityTestStatus {
            try encodeContainer.encode(deliverabilityTestStatus.rawValue, forKey: .deliverabilityTestStatus)
        }
        if let fromEmailAddress = fromEmailAddress {
            try encodeContainer.encode(fromEmailAddress, forKey: .fromEmailAddress)
        }
        if let reportId = reportId {
            try encodeContainer.encode(reportId, forKey: .reportId)
        }
        if let reportName = reportName {
            try encodeContainer.encode(reportName, forKey: .reportName)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let reportNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportName)
        reportName = reportNameDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let fromEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromEmailAddress)
        fromEmailAddress = fromEmailAddressDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let deliverabilityTestStatusDecoded = try containerValues.decodeIfPresent(DeliverabilityTestStatus.self, forKey: .deliverabilityTestStatus)
        deliverabilityTestStatus = deliverabilityTestStatusDecoded
    }
}

extension DeliverabilityTestReport: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeliverabilityTestReport(createDate: \(String(describing: createDate)), deliverabilityTestStatus: \(String(describing: deliverabilityTestStatus)), fromEmailAddress: \(String(describing: fromEmailAddress)), reportId: \(String(describing: reportId)), reportName: \(String(describing: reportName)), subject: \(String(describing: subject)))"}
}

/// <p>An object that contains metadata related to a predictive inbox placement test.</p>
public struct DeliverabilityTestReport: Equatable {
    /// <p>The date and time when the predictive inbox placement test was created, in Unix time format.</p>
    public let createDate: Date?
    /// <p>The status of the predictive inbox placement test. If the status is <code>IN_PROGRESS</code>, then the predictive inbox placement test
    ///             is currently running. Predictive inbox placement tests are usually complete within 24 hours of creating the
    ///             test. If the status is <code>COMPLETE</code>, then the test is finished, and you can use
    ///             the <code>GetDeliverabilityTestReport</code> to view the results of the test.</p>
    public let deliverabilityTestStatus: DeliverabilityTestStatus?
    /// <p>The sender address that you specified for the predictive inbox placement test.</p>
    public let fromEmailAddress: String?
    /// <p>A unique string that identifies the predictive inbox placement test.</p>
    public let reportId: String?
    /// <p>A name that helps you identify a predictive inbox placement test report.</p>
    public let reportName: String?
    /// <p>The subject line for an email that you submitted in a predictive inbox placement test.</p>
    public let subject: String?

    public init (
        createDate: Date? = nil,
        deliverabilityTestStatus: DeliverabilityTestStatus? = nil,
        fromEmailAddress: String? = nil,
        reportId: String? = nil,
        reportName: String? = nil,
        subject: String? = nil
    )
    {
        self.createDate = createDate
        self.deliverabilityTestStatus = deliverabilityTestStatus
        self.fromEmailAddress = fromEmailAddress
        self.reportId = reportId
        self.reportName = reportName
        self.subject = subject
    }
}

/// <p>The status of a predictive inbox placement test. If the status is <code>IN_PROGRESS</code>, then the predictive inbox placement test is
///             currently running. Predictive inbox placement tests are usually complete within 24 hours of creating the test.
///             If the status is <code>COMPLETE</code>, then the test is finished, and you can use the
///                 <code>GetDeliverabilityTestReport</code> operation to view the results of the
///             test.</p>
public enum DeliverabilityTestStatus {
    case completed
    case inProgress
    case sdkUnknown(String)
}

extension DeliverabilityTestStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeliverabilityTestStatus] {
        return [
            .completed,
            .inProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .inProgress: return "IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeliverabilityTestStatus(rawValue: rawValue) ?? DeliverabilityTestStatus.sdkUnknown(rawValue)
    }
}

extension DeliveryOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sendingPoolName = "SendingPoolName"
        case tlsPolicy = "TlsPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sendingPoolName = sendingPoolName {
            try encodeContainer.encode(sendingPoolName, forKey: .sendingPoolName)
        }
        if let tlsPolicy = tlsPolicy {
            try encodeContainer.encode(tlsPolicy.rawValue, forKey: .tlsPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tlsPolicyDecoded = try containerValues.decodeIfPresent(TlsPolicy.self, forKey: .tlsPolicy)
        tlsPolicy = tlsPolicyDecoded
        let sendingPoolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sendingPoolName)
        sendingPoolName = sendingPoolNameDecoded
    }
}

extension DeliveryOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeliveryOptions(sendingPoolName: \(String(describing: sendingPoolName)), tlsPolicy: \(String(describing: tlsPolicy)))"}
}

/// <p>Used to associate a configuration set with a dedicated IP pool.</p>
public struct DeliveryOptions: Equatable {
    /// <p>The name of the dedicated IP pool that you want to associate with the configuration
    ///             set.</p>
    public let sendingPoolName: String?
    /// <p>Specifies whether messages that use the configuration set are required to use
    ///             Transport Layer Security (TLS). If the value is <code>Require</code>, messages are only
    ///             delivered if a TLS connection can be established. If the value is <code>Optional</code>,
    ///             messages can be delivered in plain text if a TLS connection can't be established.</p>
    public let tlsPolicy: TlsPolicy?

    public init (
        sendingPoolName: String? = nil,
        tlsPolicy: TlsPolicy? = nil
    )
    {
        self.sendingPoolName = sendingPoolName
        self.tlsPolicy = tlsPolicy
    }
}

extension Destination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bccAddresses = "BccAddresses"
        case ccAddresses = "CcAddresses"
        case toAddresses = "ToAddresses"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bccAddresses = bccAddresses {
            var bccAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bccAddresses)
            for emailaddresslist0 in bccAddresses {
                try bccAddressesContainer.encode(emailaddresslist0)
            }
        }
        if let ccAddresses = ccAddresses {
            var ccAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ccAddresses)
            for emailaddresslist0 in ccAddresses {
                try ccAddressesContainer.encode(emailaddresslist0)
            }
        }
        if let toAddresses = toAddresses {
            var toAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .toAddresses)
            for emailaddresslist0 in toAddresses {
                try toAddressesContainer.encode(emailaddresslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let toAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .toAddresses)
        var toAddressesDecoded0:[String]? = nil
        if let toAddressesContainer = toAddressesContainer {
            toAddressesDecoded0 = [String]()
            for string0 in toAddressesContainer {
                if let string0 = string0 {
                    toAddressesDecoded0?.append(string0)
                }
            }
        }
        toAddresses = toAddressesDecoded0
        let ccAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ccAddresses)
        var ccAddressesDecoded0:[String]? = nil
        if let ccAddressesContainer = ccAddressesContainer {
            ccAddressesDecoded0 = [String]()
            for string0 in ccAddressesContainer {
                if let string0 = string0 {
                    ccAddressesDecoded0?.append(string0)
                }
            }
        }
        ccAddresses = ccAddressesDecoded0
        let bccAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .bccAddresses)
        var bccAddressesDecoded0:[String]? = nil
        if let bccAddressesContainer = bccAddressesContainer {
            bccAddressesDecoded0 = [String]()
            for string0 in bccAddressesContainer {
                if let string0 = string0 {
                    bccAddressesDecoded0?.append(string0)
                }
            }
        }
        bccAddresses = bccAddressesDecoded0
    }
}

extension Destination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Destination(bccAddresses: \(String(describing: bccAddresses)), ccAddresses: \(String(describing: ccAddresses)), toAddresses: \(String(describing: toAddresses)))"}
}

/// <p>An object that describes the recipients for an email.</p>
public struct Destination: Equatable {
    /// <p>An array that contains the email addresses of the "BCC" (blind carbon copy) recipients
    ///             for the email.</p>
    public let bccAddresses: [String]?
    /// <p>An array that contains the email addresses of the "CC" (carbon copy) recipients for
    ///             the email.</p>
    public let ccAddresses: [String]?
    /// <p>An array that contains the email addresses of the "To" recipients for the
    ///             email.</p>
    public let toAddresses: [String]?

    public init (
        bccAddresses: [String]? = nil,
        ccAddresses: [String]? = nil,
        toAddresses: [String]? = nil
    )
    {
        self.bccAddresses = bccAddresses
        self.ccAddresses = ccAddresses
        self.toAddresses = toAddresses
    }
}

/// <p>The location where the Amazon SES API v2 finds the value of a dimension to publish to Amazon CloudWatch. If
///             you want to use the message tags that you specify using an
///                 <code>X-SES-MESSAGE-TAGS</code> header or a parameter to the <code>SendEmail</code>
///             or <code>SendRawEmail</code> API, choose <code>messageTag</code>. If you want to use
///             your own email headers, choose <code>emailHeader</code>. If you want to use link tags,
///             choose <code>linkTags</code>.</p>
public enum DimensionValueSource {
    case emailHeader
    case linkTag
    case messageTag
    case sdkUnknown(String)
}

extension DimensionValueSource : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DimensionValueSource] {
        return [
            .emailHeader,
            .linkTag,
            .messageTag,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .emailHeader: return "EMAIL_HEADER"
        case .linkTag: return "LINK_TAG"
        case .messageTag: return "MESSAGE_TAG"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DimensionValueSource(rawValue: rawValue) ?? DimensionValueSource.sdkUnknown(rawValue)
    }
}

extension DkimAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case signingAttributesOrigin = "SigningAttributesOrigin"
        case signingEnabled = "SigningEnabled"
        case status = "Status"
        case tokens = "Tokens"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signingAttributesOrigin = signingAttributesOrigin {
            try encodeContainer.encode(signingAttributesOrigin.rawValue, forKey: .signingAttributesOrigin)
        }
        if signingEnabled != false {
            try encodeContainer.encode(signingEnabled, forKey: .signingEnabled)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tokens = tokens {
            var tokensContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tokens)
            for dnstokenlist0 in tokens {
                try tokensContainer.encode(dnstokenlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .signingEnabled)
        signingEnabled = signingEnabledDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DkimStatus.self, forKey: .status)
        status = statusDecoded
        let tokensContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tokens)
        var tokensDecoded0:[String]? = nil
        if let tokensContainer = tokensContainer {
            tokensDecoded0 = [String]()
            for string0 in tokensContainer {
                if let string0 = string0 {
                    tokensDecoded0?.append(string0)
                }
            }
        }
        tokens = tokensDecoded0
        let signingAttributesOriginDecoded = try containerValues.decodeIfPresent(DkimSigningAttributesOrigin.self, forKey: .signingAttributesOrigin)
        signingAttributesOrigin = signingAttributesOriginDecoded
    }
}

extension DkimAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DkimAttributes(signingAttributesOrigin: \(String(describing: signingAttributesOrigin)), signingEnabled: \(String(describing: signingEnabled)), status: \(String(describing: status)), tokens: \(String(describing: tokens)))"}
}

/// <p>An object that contains information about the DKIM authentication status for an email
///             identity.</p>
///         <p>Amazon SES determines the authentication status by searching for specific records in the
///             DNS configuration for the domain. If you used <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html">Easy DKIM</a> to set up DKIM
///             authentication, Amazon SES tries to find three unique CNAME records in the DNS configuration
///             for your domain. If you provided a public key to perform DKIM authentication, Amazon SES
///             tries to find a TXT record that uses the selector that you specified. The value of the
///             TXT record must be a public key that's paired with the private key that you specified in
///             the process of creating the identity</p>
public struct DkimAttributes: Equatable {
    /// <p>A string that indicates how DKIM was configured for the identity. There are two
    ///             possible values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>AWS_SES</code> – Indicates that DKIM was configured for the
    ///                     identity by using <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html">Easy DKIM</a>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>EXTERNAL</code> – Indicates that DKIM was configured for the
    ///                     identity by using Bring Your Own DKIM (BYODKIM).</p>
    ///             </li>
    ///          </ul>
    public let signingAttributesOrigin: DkimSigningAttributesOrigin?
    /// <p>If the value is <code>true</code>, then the messages that you send from the identity
    ///             are signed using DKIM. If the value is <code>false</code>, then the messages that you
    ///             send from the identity aren't DKIM-signed.</p>
    public let signingEnabled: Bool
    /// <p>Describes whether or not Amazon SES has successfully located the DKIM records in the DNS
    ///             records for the domain. The status can be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>PENDING</code> – The verification process was initiated, but Amazon SES
    ///                     hasn't yet detected the DKIM records in the DNS configuration for the
    ///                     domain.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SUCCESS</code> – The verification process completed
    ///                     successfully.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>FAILED</code> – The verification process failed. This typically
    ///                     occurs when Amazon SES fails to find the DKIM records in the DNS configuration of the
    ///                     domain.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>TEMPORARY_FAILURE</code> – A temporary issue is preventing Amazon SES
    ///                     from determining the DKIM authentication status of the domain.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>NOT_STARTED</code> – The DKIM verification process hasn't been
    ///                     initiated for the domain.</p>
    ///             </li>
    ///          </ul>
    public let status: DkimStatus?
    /// <p>If you used <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html">Easy DKIM</a> to configure DKIM authentication for the domain, then this object
    ///             contains a set of unique strings that you use to create a set of CNAME records that you
    ///             add to the DNS configuration for your domain. When Amazon SES detects these records in the
    ///             DNS configuration for your domain, the DKIM authentication process is complete.</p>
    ///         <p>If you configured DKIM authentication for the domain by providing your own
    ///             public-private key pair, then this object contains the selector for the public
    ///             key.</p>
    ///         <p>Regardless of the DKIM authentication method you use, Amazon SES searches for the
    ///             appropriate records in the DNS configuration of the domain for up to 72 hours.</p>
    public let tokens: [String]?

    public init (
        signingAttributesOrigin: DkimSigningAttributesOrigin? = nil,
        signingEnabled: Bool = false,
        status: DkimStatus? = nil,
        tokens: [String]? = nil
    )
    {
        self.signingAttributesOrigin = signingAttributesOrigin
        self.signingEnabled = signingEnabled
        self.status = status
        self.tokens = tokens
    }
}

extension DkimSigningAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainSigningPrivateKey = "DomainSigningPrivateKey"
        case domainSigningSelector = "DomainSigningSelector"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainSigningPrivateKey = domainSigningPrivateKey {
            try encodeContainer.encode(domainSigningPrivateKey, forKey: .domainSigningPrivateKey)
        }
        if let domainSigningSelector = domainSigningSelector {
            try encodeContainer.encode(domainSigningSelector, forKey: .domainSigningSelector)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainSigningSelectorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainSigningSelector)
        domainSigningSelector = domainSigningSelectorDecoded
        let domainSigningPrivateKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainSigningPrivateKey)
        domainSigningPrivateKey = domainSigningPrivateKeyDecoded
    }
}

extension DkimSigningAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DkimSigningAttributes(domainSigningPrivateKey: \(String(describing: domainSigningPrivateKey)), domainSigningSelector: \(String(describing: domainSigningSelector)))"}
}

/// <p>An object that contains information about the tokens used for setting up Bring Your
///             Own DKIM (BYODKIM).</p>
public struct DkimSigningAttributes: Equatable {
    /// <p>A private key that's used to generate a DKIM signature.</p>
    ///         <p>The private key must use 1024-bit RSA encryption, and must be encoded using base64
    ///             encoding.</p>
    public let domainSigningPrivateKey: String?
    /// <p>A string that's used to identify a public key in the DNS configuration for a
    ///             domain.</p>
    public let domainSigningSelector: String?

    public init (
        domainSigningPrivateKey: String? = nil,
        domainSigningSelector: String? = nil
    )
    {
        self.domainSigningPrivateKey = domainSigningPrivateKey
        self.domainSigningSelector = domainSigningSelector
    }
}

public enum DkimSigningAttributesOrigin {
    case awsSes
    case external
    case sdkUnknown(String)
}

extension DkimSigningAttributesOrigin : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DkimSigningAttributesOrigin] {
        return [
            .awsSes,
            .external,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsSes: return "AWS_SES"
        case .external: return "EXTERNAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DkimSigningAttributesOrigin(rawValue: rawValue) ?? DkimSigningAttributesOrigin.sdkUnknown(rawValue)
    }
}

/// <p>The DKIM authentication status of the identity. The status can be one of the
///             following:</p>
///         <ul>
///             <li>
///                 <p>
///                   <code>PENDING</code> – The verification process was initiated, but Amazon SES
///                     hasn't yet detected the DKIM records in the DNS configuration for the
///                     domain.</p>
///             </li>
///             <li>
///                 <p>
///                   <code>SUCCESS</code> – The verification process completed
///                     successfully.</p>
///             </li>
///             <li>
///                 <p>
///                   <code>FAILED</code> – The verification process failed. This typically
///                     occurs when Amazon SES fails to find the DKIM records in the DNS configuration of the
///                     domain.</p>
///             </li>
///             <li>
///                 <p>
///                   <code>TEMPORARY_FAILURE</code> – A temporary issue is preventing Amazon SES
///                     from determining the DKIM authentication status of the domain.</p>
///             </li>
///             <li>
///                 <p>
///                   <code>NOT_STARTED</code> – The DKIM verification process hasn't been
///                     initiated for the domain.</p>
///             </li>
///          </ul>
public enum DkimStatus {
    case failed
    case notStarted
    case pending
    case success
    case temporaryFailure
    case sdkUnknown(String)
}

extension DkimStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DkimStatus] {
        return [
            .failed,
            .notStarted,
            .pending,
            .success,
            .temporaryFailure,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .notStarted: return "NOT_STARTED"
        case .pending: return "PENDING"
        case .success: return "SUCCESS"
        case .temporaryFailure: return "TEMPORARY_FAILURE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DkimStatus(rawValue: rawValue) ?? DkimStatus.sdkUnknown(rawValue)
    }
}

extension DomainDeliverabilityCampaign: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case campaignId = "CampaignId"
        case deleteRate = "DeleteRate"
        case esps = "Esps"
        case firstSeenDateTime = "FirstSeenDateTime"
        case fromAddress = "FromAddress"
        case imageUrl = "ImageUrl"
        case inboxCount = "InboxCount"
        case lastSeenDateTime = "LastSeenDateTime"
        case projectedVolume = "ProjectedVolume"
        case readDeleteRate = "ReadDeleteRate"
        case readRate = "ReadRate"
        case sendingIps = "SendingIps"
        case spamCount = "SpamCount"
        case subject = "Subject"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignId = campaignId {
            try encodeContainer.encode(campaignId, forKey: .campaignId)
        }
        if let deleteRate = deleteRate {
            try encodeContainer.encode(deleteRate, forKey: .deleteRate)
        }
        if let esps = esps {
            var espsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .esps)
            for esps0 in esps {
                try espsContainer.encode(esps0)
            }
        }
        if let firstSeenDateTime = firstSeenDateTime {
            try encodeContainer.encode(firstSeenDateTime.timeIntervalSince1970, forKey: .firstSeenDateTime)
        }
        if let fromAddress = fromAddress {
            try encodeContainer.encode(fromAddress, forKey: .fromAddress)
        }
        if let imageUrl = imageUrl {
            try encodeContainer.encode(imageUrl, forKey: .imageUrl)
        }
        if let inboxCount = inboxCount {
            try encodeContainer.encode(inboxCount, forKey: .inboxCount)
        }
        if let lastSeenDateTime = lastSeenDateTime {
            try encodeContainer.encode(lastSeenDateTime.timeIntervalSince1970, forKey: .lastSeenDateTime)
        }
        if let projectedVolume = projectedVolume {
            try encodeContainer.encode(projectedVolume, forKey: .projectedVolume)
        }
        if let readDeleteRate = readDeleteRate {
            try encodeContainer.encode(readDeleteRate, forKey: .readDeleteRate)
        }
        if let readRate = readRate {
            try encodeContainer.encode(readRate, forKey: .readRate)
        }
        if let sendingIps = sendingIps {
            var sendingIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sendingIps)
            for iplist0 in sendingIps {
                try sendingIpsContainer.encode(iplist0)
            }
        }
        if let spamCount = spamCount {
            try encodeContainer.encode(spamCount, forKey: .spamCount)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .campaignId)
        campaignId = campaignIdDecoded
        let imageUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageUrl)
        imageUrl = imageUrlDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let fromAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromAddress)
        fromAddress = fromAddressDecoded
        let sendingIpsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sendingIps)
        var sendingIpsDecoded0:[String]? = nil
        if let sendingIpsContainer = sendingIpsContainer {
            sendingIpsDecoded0 = [String]()
            for string0 in sendingIpsContainer {
                if let string0 = string0 {
                    sendingIpsDecoded0?.append(string0)
                }
            }
        }
        sendingIps = sendingIpsDecoded0
        let firstSeenDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .firstSeenDateTime)
        firstSeenDateTime = firstSeenDateTimeDecoded
        let lastSeenDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastSeenDateTime)
        lastSeenDateTime = lastSeenDateTimeDecoded
        let inboxCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .inboxCount)
        inboxCount = inboxCountDecoded
        let spamCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .spamCount)
        spamCount = spamCountDecoded
        let readRateDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .readRate)
        readRate = readRateDecoded
        let deleteRateDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .deleteRate)
        deleteRate = deleteRateDecoded
        let readDeleteRateDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .readDeleteRate)
        readDeleteRate = readDeleteRateDecoded
        let projectedVolumeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .projectedVolume)
        projectedVolume = projectedVolumeDecoded
        let espsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .esps)
        var espsDecoded0:[String]? = nil
        if let espsContainer = espsContainer {
            espsDecoded0 = [String]()
            for string0 in espsContainer {
                if let string0 = string0 {
                    espsDecoded0?.append(string0)
                }
            }
        }
        esps = espsDecoded0
    }
}

extension DomainDeliverabilityCampaign: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainDeliverabilityCampaign(campaignId: \(String(describing: campaignId)), deleteRate: \(String(describing: deleteRate)), esps: \(String(describing: esps)), firstSeenDateTime: \(String(describing: firstSeenDateTime)), fromAddress: \(String(describing: fromAddress)), imageUrl: \(String(describing: imageUrl)), inboxCount: \(String(describing: inboxCount)), lastSeenDateTime: \(String(describing: lastSeenDateTime)), projectedVolume: \(String(describing: projectedVolume)), readDeleteRate: \(String(describing: readDeleteRate)), readRate: \(String(describing: readRate)), sendingIps: \(String(describing: sendingIps)), spamCount: \(String(describing: spamCount)), subject: \(String(describing: subject)))"}
}

/// <p>An object that contains the deliverability data for a specific campaign. This data is
///             available for a campaign only if the campaign sent email by using a domain that the
///             Deliverability dashboard is enabled for (<code>PutDeliverabilityDashboardOption</code>
///             operation).</p>
public struct DomainDeliverabilityCampaign: Equatable {
    /// <p>The unique identifier for the campaign. The Deliverability dashboard automatically generates
    ///             and assigns this identifier to a campaign.</p>
    public let campaignId: String?
    /// <p>The percentage of email messages that were deleted by recipients, without being opened
    ///             first. Due to technical limitations, this value only includes recipients who opened the
    ///             message by using an email client that supports images.</p>
    public let deleteRate: Double?
    /// <p>The major email providers who handled the email message.</p>
    public let esps: [String]?
    /// <p>The first time, in Unix time format, when the email message was delivered to any
    ///             recipient's inbox. This value can help you determine how long it took for a campaign to
    ///             deliver an email message.</p>
    public let firstSeenDateTime: Date?
    /// <p>The verified email address that the email message was sent from.</p>
    public let fromAddress: String?
    /// <p>The URL of an image that contains a snapshot of the email message that was
    ///             sent.</p>
    public let imageUrl: String?
    /// <p>The number of email messages that were delivered to recipients’ inboxes.</p>
    public let inboxCount: Int?
    /// <p>The last time, in Unix time format, when the email message was delivered to any
    ///             recipient's inbox. This value can help you determine how long it took for a campaign to
    ///             deliver an email message.</p>
    public let lastSeenDateTime: Date?
    /// <p>The projected number of recipients that the email message was sent to.</p>
    public let projectedVolume: Int?
    /// <p>The percentage of email messages that were opened and then deleted by recipients. Due
    ///             to technical limitations, this value only includes recipients who opened the message by
    ///             using an email client that supports images.</p>
    public let readDeleteRate: Double?
    /// <p>The percentage of email messages that were opened by recipients. Due to technical
    ///             limitations, this value only includes recipients who opened the message by using an
    ///             email client that supports images.</p>
    public let readRate: Double?
    /// <p>The IP addresses that were used to send the email message.</p>
    public let sendingIps: [String]?
    /// <p>The number of email messages that were delivered to recipients' spam or junk mail
    ///             folders.</p>
    public let spamCount: Int?
    /// <p>The subject line, or title, of the email message.</p>
    public let subject: String?

    public init (
        campaignId: String? = nil,
        deleteRate: Double? = nil,
        esps: [String]? = nil,
        firstSeenDateTime: Date? = nil,
        fromAddress: String? = nil,
        imageUrl: String? = nil,
        inboxCount: Int? = nil,
        lastSeenDateTime: Date? = nil,
        projectedVolume: Int? = nil,
        readDeleteRate: Double? = nil,
        readRate: Double? = nil,
        sendingIps: [String]? = nil,
        spamCount: Int? = nil,
        subject: String? = nil
    )
    {
        self.campaignId = campaignId
        self.deleteRate = deleteRate
        self.esps = esps
        self.firstSeenDateTime = firstSeenDateTime
        self.fromAddress = fromAddress
        self.imageUrl = imageUrl
        self.inboxCount = inboxCount
        self.lastSeenDateTime = lastSeenDateTime
        self.projectedVolume = projectedVolume
        self.readDeleteRate = readDeleteRate
        self.readRate = readRate
        self.sendingIps = sendingIps
        self.spamCount = spamCount
        self.subject = subject
    }
}

extension DomainDeliverabilityTrackingOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domain = "Domain"
        case inboxPlacementTrackingOption = "InboxPlacementTrackingOption"
        case subscriptionStartDate = "SubscriptionStartDate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let inboxPlacementTrackingOption = inboxPlacementTrackingOption {
            try encodeContainer.encode(inboxPlacementTrackingOption, forKey: .inboxPlacementTrackingOption)
        }
        if let subscriptionStartDate = subscriptionStartDate {
            try encodeContainer.encode(subscriptionStartDate.timeIntervalSince1970, forKey: .subscriptionStartDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
        let subscriptionStartDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .subscriptionStartDate)
        subscriptionStartDate = subscriptionStartDateDecoded
        let inboxPlacementTrackingOptionDecoded = try containerValues.decodeIfPresent(InboxPlacementTrackingOption.self, forKey: .inboxPlacementTrackingOption)
        inboxPlacementTrackingOption = inboxPlacementTrackingOptionDecoded
    }
}

extension DomainDeliverabilityTrackingOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainDeliverabilityTrackingOption(domain: \(String(describing: domain)), inboxPlacementTrackingOption: \(String(describing: inboxPlacementTrackingOption)), subscriptionStartDate: \(String(describing: subscriptionStartDate)))"}
}

/// <p>An object that contains information about the Deliverability dashboard subscription for a
///             verified domain that you use to send email and currently has an active Deliverability dashboard
///             subscription. If a Deliverability dashboard subscription is active for a domain, you gain access
///             to reputation, inbox placement, and other metrics for the domain.</p>
public struct DomainDeliverabilityTrackingOption: Equatable {
    /// <p>A verified domain that’s associated with your AWS account and currently has an
    ///             active Deliverability dashboard subscription.</p>
    public let domain: String?
    /// <p>An object that contains information about the inbox placement data settings for the
    ///             domain.</p>
    public let inboxPlacementTrackingOption: InboxPlacementTrackingOption?
    /// <p>The date, in Unix time format, when you enabled the Deliverability dashboard for the
    ///             domain.</p>
    public let subscriptionStartDate: Date?

    public init (
        domain: String? = nil,
        inboxPlacementTrackingOption: InboxPlacementTrackingOption? = nil,
        subscriptionStartDate: Date? = nil
    )
    {
        self.domain = domain
        self.inboxPlacementTrackingOption = inboxPlacementTrackingOption
        self.subscriptionStartDate = subscriptionStartDate
    }
}

extension DomainIspPlacement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inboxPercentage = "InboxPercentage"
        case inboxRawCount = "InboxRawCount"
        case ispName = "IspName"
        case spamPercentage = "SpamPercentage"
        case spamRawCount = "SpamRawCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inboxPercentage = inboxPercentage {
            try encodeContainer.encode(inboxPercentage, forKey: .inboxPercentage)
        }
        if let inboxRawCount = inboxRawCount {
            try encodeContainer.encode(inboxRawCount, forKey: .inboxRawCount)
        }
        if let ispName = ispName {
            try encodeContainer.encode(ispName, forKey: .ispName)
        }
        if let spamPercentage = spamPercentage {
            try encodeContainer.encode(spamPercentage, forKey: .spamPercentage)
        }
        if let spamRawCount = spamRawCount {
            try encodeContainer.encode(spamRawCount, forKey: .spamRawCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ispNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ispName)
        ispName = ispNameDecoded
        let inboxRawCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .inboxRawCount)
        inboxRawCount = inboxRawCountDecoded
        let spamRawCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .spamRawCount)
        spamRawCount = spamRawCountDecoded
        let inboxPercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .inboxPercentage)
        inboxPercentage = inboxPercentageDecoded
        let spamPercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .spamPercentage)
        spamPercentage = spamPercentageDecoded
    }
}

extension DomainIspPlacement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainIspPlacement(inboxPercentage: \(String(describing: inboxPercentage)), inboxRawCount: \(String(describing: inboxRawCount)), ispName: \(String(describing: ispName)), spamPercentage: \(String(describing: spamPercentage)), spamRawCount: \(String(describing: spamRawCount)))"}
}

/// <p>An object that contains inbox placement data for email sent from one of your email
///             domains to a specific email provider.</p>
public struct DomainIspPlacement: Equatable {
    /// <p>The percentage of messages that were sent from the selected domain to the specified
    ///             email provider that arrived in recipients' inboxes.</p>
    public let inboxPercentage: Double?
    /// <p>The total number of messages that were sent from the selected domain to the specified
    ///             email provider that arrived in recipients' inboxes.</p>
    public let inboxRawCount: Int?
    /// <p>The name of the email provider that the inbox placement data applies to.</p>
    public let ispName: String?
    /// <p>The percentage of messages that were sent from the selected domain to the specified
    ///             email provider that arrived in recipients' spam or junk mail folders.</p>
    public let spamPercentage: Double?
    /// <p>The total number of messages that were sent from the selected domain to the specified
    ///             email provider that arrived in recipients' spam or junk mail folders.</p>
    public let spamRawCount: Int?

    public init (
        inboxPercentage: Double? = nil,
        inboxRawCount: Int? = nil,
        ispName: String? = nil,
        spamPercentage: Double? = nil,
        spamRawCount: Int? = nil
    )
    {
        self.inboxPercentage = inboxPercentage
        self.inboxRawCount = inboxRawCount
        self.ispName = ispName
        self.spamPercentage = spamPercentage
        self.spamRawCount = spamRawCount
    }
}

extension EmailContent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case raw = "Raw"
        case simple = "Simple"
        case template = "Template"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let raw = raw {
            try encodeContainer.encode(raw, forKey: .raw)
        }
        if let simple = simple {
            try encodeContainer.encode(simple, forKey: .simple)
        }
        if let template = template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleDecoded = try containerValues.decodeIfPresent(Message.self, forKey: .simple)
        simple = simpleDecoded
        let rawDecoded = try containerValues.decodeIfPresent(RawMessage.self, forKey: .raw)
        raw = rawDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Template.self, forKey: .template)
        template = templateDecoded
    }
}

extension EmailContent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EmailContent(raw: \(String(describing: raw)), simple: \(String(describing: simple)), template: \(String(describing: template)))"}
}

/// <p>An object that defines the entire content of the email, including the message headers
///             and the body content. You can create a simple email message, in which you specify the
///             subject and the text and HTML versions of the message body. You can also create raw
///             messages, in which you specify a complete MIME-formatted message. Raw messages can
///             include attachments and custom headers.</p>
public struct EmailContent: Equatable {
    /// <p>The raw email message. The message has to meet the following criteria:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>The message has to contain a header and a body, separated by one blank
    ///                     line.</p>
    ///             </li>
    ///             <li>
    ///                 <p>All of the required header fields must be present in the message.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Each part of a multipart MIME message must be formatted properly.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If you include attachments, they must be in a file format that the Amazon SES API v2
    ///                     supports.
    ///                     </p>
    ///             </li>
    ///             <li>
    ///                 <p>The entire message must be Base64 encoded.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If any of the MIME parts in your message contain content that is outside of
    ///                     the 7-bit ASCII character range, you should encode that content to ensure that
    ///                     recipients' email clients render the message properly.</p>
    ///             </li>
    ///             <li>
    ///                 <p>The length of any single line of text in the message can't exceed 1,000
    ///                     characters. This restriction is defined in <a href="https://tools.ietf.org/html/rfc5321">RFC 5321</a>.</p>
    ///             </li>
    ///          </ul>
    public let raw: RawMessage?
    /// <p>The simple email message. The message consists of a subject and a message body.</p>
    public let simple: Message?
    /// <p>The template to use for the email message.</p>
    public let template: Template?

    public init (
        raw: RawMessage? = nil,
        simple: Message? = nil,
        template: Template? = nil
    )
    {
        self.raw = raw
        self.simple = simple
        self.template = template
    }
}

extension EmailTemplateContent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case html = "Html"
        case subject = "Subject"
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let html = html {
            try encodeContainer.encode(html, forKey: .html)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let htmlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .html)
        html = htmlDecoded
    }
}

extension EmailTemplateContent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EmailTemplateContent(html: \(String(describing: html)), subject: \(String(describing: subject)), text: \(String(describing: text)))"}
}

/// <p>The content of the email, composed of a subject line, an HTML part, and a text-only
///             part.</p>
public struct EmailTemplateContent: Equatable {
    /// <p>The HTML body of the email.</p>
    public let html: String?
    /// <p>The subject line of the email.</p>
    public let subject: String?
    /// <p>The email body that will be visible to recipients whose email clients do not display
    ///             HTML.</p>
    public let text: String?

    public init (
        html: String? = nil,
        subject: String? = nil,
        text: String? = nil
    )
    {
        self.html = html
        self.subject = subject
        self.text = text
    }
}

extension EmailTemplateMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case templateName = "TemplateName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension EmailTemplateMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EmailTemplateMetadata(createdTimestamp: \(String(describing: createdTimestamp)), templateName: \(String(describing: templateName)))"}
}

/// <p>Contains information about an email template.</p>
public struct EmailTemplateMetadata: Equatable {
    /// <p>The time and date the template was created.</p>
    public let createdTimestamp: Date?
    /// <p>The name of the template.</p>
    public let templateName: String?

    public init (
        createdTimestamp: Date? = nil,
        templateName: String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.templateName = templateName
    }
}

extension EventDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchDestination = "CloudWatchDestination"
        case enabled = "Enabled"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case name = "Name"
        case pinpointDestination = "PinpointDestination"
        case snsDestination = "SnsDestination"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchDestination = cloudWatchDestination {
            try encodeContainer.encode(cloudWatchDestination, forKey: .cloudWatchDestination)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let kinesisFirehoseDestination = kinesisFirehoseDestination {
            try encodeContainer.encode(kinesisFirehoseDestination, forKey: .kinesisFirehoseDestination)
        }
        if let matchingEventTypes = matchingEventTypes {
            var matchingEventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingEventTypes)
            for eventtypes0 in matchingEventTypes {
                try matchingEventTypesContainer.encode(eventtypes0.rawValue)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pinpointDestination = pinpointDestination {
            try encodeContainer.encode(pinpointDestination, forKey: .pinpointDestination)
        }
        if let snsDestination = snsDestination {
            try encodeContainer.encode(snsDestination, forKey: .snsDestination)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let matchingEventTypesContainer = try containerValues.decodeIfPresent([EventType?].self, forKey: .matchingEventTypes)
        var matchingEventTypesDecoded0:[EventType]? = nil
        if let matchingEventTypesContainer = matchingEventTypesContainer {
            matchingEventTypesDecoded0 = [EventType]()
            for string0 in matchingEventTypesContainer {
                if let string0 = string0 {
                    matchingEventTypesDecoded0?.append(string0)
                }
            }
        }
        matchingEventTypes = matchingEventTypesDecoded0
        let kinesisFirehoseDestinationDecoded = try containerValues.decodeIfPresent(KinesisFirehoseDestination.self, forKey: .kinesisFirehoseDestination)
        kinesisFirehoseDestination = kinesisFirehoseDestinationDecoded
        let cloudWatchDestinationDecoded = try containerValues.decodeIfPresent(CloudWatchDestination.self, forKey: .cloudWatchDestination)
        cloudWatchDestination = cloudWatchDestinationDecoded
        let snsDestinationDecoded = try containerValues.decodeIfPresent(SnsDestination.self, forKey: .snsDestination)
        snsDestination = snsDestinationDecoded
        let pinpointDestinationDecoded = try containerValues.decodeIfPresent(PinpointDestination.self, forKey: .pinpointDestination)
        pinpointDestination = pinpointDestinationDecoded
    }
}

extension EventDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventDestination(cloudWatchDestination: \(String(describing: cloudWatchDestination)), enabled: \(String(describing: enabled)), kinesisFirehoseDestination: \(String(describing: kinesisFirehoseDestination)), matchingEventTypes: \(String(describing: matchingEventTypes)), name: \(String(describing: name)), pinpointDestination: \(String(describing: pinpointDestination)), snsDestination: \(String(describing: snsDestination)))"}
}

/// <p>In the Amazon SES API v2, <i>events</i> include message sends, deliveries, opens,
///             clicks, bounces, complaints and delivery delays. <i>Event destinations</i> are places that
///             you can send information about these events to. For example, you can send event data to
///             Amazon SNS to receive notifications when you receive bounces or complaints, or you can use
///             Amazon Kinesis Data Firehose to stream data to Amazon S3 for long-term storage.</p>
public struct EventDestination: Equatable {
    /// <p>An object that defines an Amazon CloudWatch destination for email events. You can use Amazon CloudWatch to
    ///             monitor and gain insights on your email sending metrics.</p>
    public let cloudWatchDestination: CloudWatchDestination?
    /// <p>If <code>true</code>, the event destination is enabled. When the event destination is
    ///             enabled, the specified event types are sent to the destinations in this
    ///                 <code>EventDestinationDefinition</code>.</p>
    ///         <p>If <code>false</code>, the event destination is disabled. When the event destination
    ///             is disabled, events aren't sent to the specified destinations.</p>
    public let enabled: Bool
    /// <p>An object that defines an Amazon Kinesis Data Firehose destination for email events. You can use Amazon Kinesis Data Firehose to
    ///             stream data to other services, such as Amazon S3 and Amazon Redshift.</p>
    public let kinesisFirehoseDestination: KinesisFirehoseDestination?
    /// <p>The types of events that Amazon SES sends to the specified event destinations.</p>
    public let matchingEventTypes: [EventType]?
    /// <p>A name that identifies the event destination.</p>
    public let name: String?
    /// <p>An object that defines an Amazon Pinpoint project destination for email events. You can send
    ///             email event data to a Amazon Pinpoint project to view metrics using the Transactional Messaging
    ///             dashboards that are built in to Amazon Pinpoint. For more information, see <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/analytics-transactional-messages.html">Transactional
    ///                 Messaging Charts</a> in the <i>Amazon Pinpoint User Guide</i>.</p>
    public let pinpointDestination: PinpointDestination?
    /// <p>An object that defines an Amazon SNS destination for email events. You can use Amazon SNS to
    ///             send notification when certain email events occur.</p>
    public let snsDestination: SnsDestination?

    public init (
        cloudWatchDestination: CloudWatchDestination? = nil,
        enabled: Bool = false,
        kinesisFirehoseDestination: KinesisFirehoseDestination? = nil,
        matchingEventTypes: [EventType]? = nil,
        name: String? = nil,
        pinpointDestination: PinpointDestination? = nil,
        snsDestination: SnsDestination? = nil
    )
    {
        self.cloudWatchDestination = cloudWatchDestination
        self.enabled = enabled
        self.kinesisFirehoseDestination = kinesisFirehoseDestination
        self.matchingEventTypes = matchingEventTypes
        self.name = name
        self.pinpointDestination = pinpointDestination
        self.snsDestination = snsDestination
    }
}

extension EventDestinationDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchDestination = "CloudWatchDestination"
        case enabled = "Enabled"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case pinpointDestination = "PinpointDestination"
        case snsDestination = "SnsDestination"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchDestination = cloudWatchDestination {
            try encodeContainer.encode(cloudWatchDestination, forKey: .cloudWatchDestination)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let kinesisFirehoseDestination = kinesisFirehoseDestination {
            try encodeContainer.encode(kinesisFirehoseDestination, forKey: .kinesisFirehoseDestination)
        }
        if let matchingEventTypes = matchingEventTypes {
            var matchingEventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingEventTypes)
            for eventtypes0 in matchingEventTypes {
                try matchingEventTypesContainer.encode(eventtypes0.rawValue)
            }
        }
        if let pinpointDestination = pinpointDestination {
            try encodeContainer.encode(pinpointDestination, forKey: .pinpointDestination)
        }
        if let snsDestination = snsDestination {
            try encodeContainer.encode(snsDestination, forKey: .snsDestination)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let matchingEventTypesContainer = try containerValues.decodeIfPresent([EventType?].self, forKey: .matchingEventTypes)
        var matchingEventTypesDecoded0:[EventType]? = nil
        if let matchingEventTypesContainer = matchingEventTypesContainer {
            matchingEventTypesDecoded0 = [EventType]()
            for string0 in matchingEventTypesContainer {
                if let string0 = string0 {
                    matchingEventTypesDecoded0?.append(string0)
                }
            }
        }
        matchingEventTypes = matchingEventTypesDecoded0
        let kinesisFirehoseDestinationDecoded = try containerValues.decodeIfPresent(KinesisFirehoseDestination.self, forKey: .kinesisFirehoseDestination)
        kinesisFirehoseDestination = kinesisFirehoseDestinationDecoded
        let cloudWatchDestinationDecoded = try containerValues.decodeIfPresent(CloudWatchDestination.self, forKey: .cloudWatchDestination)
        cloudWatchDestination = cloudWatchDestinationDecoded
        let snsDestinationDecoded = try containerValues.decodeIfPresent(SnsDestination.self, forKey: .snsDestination)
        snsDestination = snsDestinationDecoded
        let pinpointDestinationDecoded = try containerValues.decodeIfPresent(PinpointDestination.self, forKey: .pinpointDestination)
        pinpointDestination = pinpointDestinationDecoded
    }
}

extension EventDestinationDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventDestinationDefinition(cloudWatchDestination: \(String(describing: cloudWatchDestination)), enabled: \(String(describing: enabled)), kinesisFirehoseDestination: \(String(describing: kinesisFirehoseDestination)), matchingEventTypes: \(String(describing: matchingEventTypes)), pinpointDestination: \(String(describing: pinpointDestination)), snsDestination: \(String(describing: snsDestination)))"}
}

/// <p>An object that defines the event destination. Specifically, it defines which services
///             receive events from emails sent using the configuration set that the event destination
///             is associated with. Also defines the types of events that are sent to the event
///             destination.</p>
public struct EventDestinationDefinition: Equatable {
    /// <p>An object that defines an Amazon CloudWatch destination for email events. You can use Amazon CloudWatch to
    ///             monitor and gain insights on your email sending metrics.</p>
    public let cloudWatchDestination: CloudWatchDestination?
    /// <p>If <code>true</code>, the event destination is enabled. When the event destination is
    ///             enabled, the specified event types are sent to the destinations in this
    ///                 <code>EventDestinationDefinition</code>.</p>
    ///         <p>If <code>false</code>, the event destination is disabled. When the event destination
    ///             is disabled, events aren't sent to the specified destinations.</p>
    public let enabled: Bool
    /// <p>An object that defines an Amazon Kinesis Data Firehose destination for email events. You can use Amazon Kinesis Data Firehose to
    ///             stream data to other services, such as Amazon S3 and Amazon Redshift.</p>
    public let kinesisFirehoseDestination: KinesisFirehoseDestination?
    /// <p>An array that specifies which events the Amazon SES API v2 should send to the destinations in
    ///             this <code>EventDestinationDefinition</code>.</p>
    public let matchingEventTypes: [EventType]?
    /// <p>An object that defines an Amazon Pinpoint project destination for email events. You can send
    ///             email event data to a Amazon Pinpoint project to view metrics using the Transactional Messaging
    ///             dashboards that are built in to Amazon Pinpoint. For more information, see <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/analytics-transactional-messages.html">Transactional
    ///                 Messaging Charts</a> in the <i>Amazon Pinpoint User Guide</i>.</p>
    public let pinpointDestination: PinpointDestination?
    /// <p>An object that defines an Amazon SNS destination for email events. You can use Amazon SNS to
    ///             send notification when certain email events occur.</p>
    public let snsDestination: SnsDestination?

    public init (
        cloudWatchDestination: CloudWatchDestination? = nil,
        enabled: Bool = false,
        kinesisFirehoseDestination: KinesisFirehoseDestination? = nil,
        matchingEventTypes: [EventType]? = nil,
        pinpointDestination: PinpointDestination? = nil,
        snsDestination: SnsDestination? = nil
    )
    {
        self.cloudWatchDestination = cloudWatchDestination
        self.enabled = enabled
        self.kinesisFirehoseDestination = kinesisFirehoseDestination
        self.matchingEventTypes = matchingEventTypes
        self.pinpointDestination = pinpointDestination
        self.snsDestination = snsDestination
    }
}

/// <p>An email sending event type. For example, email sends, opens, and bounces are all
///             email events.</p>
public enum EventType {
    case bounce
    case click
    case complaint
    case delivery
    case deliveryDelay
    case `open`
    case reject
    case renderingFailure
    case send
    case subscription
    case sdkUnknown(String)
}

extension EventType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventType] {
        return [
            .bounce,
            .click,
            .complaint,
            .delivery,
            .deliveryDelay,
            .open,
            .reject,
            .renderingFailure,
            .send,
            .subscription,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bounce: return "BOUNCE"
        case .click: return "CLICK"
        case .complaint: return "COMPLAINT"
        case .delivery: return "DELIVERY"
        case .deliveryDelay: return "DELIVERY_DELAY"
        case .open: return "OPEN"
        case .reject: return "REJECT"
        case .renderingFailure: return "RENDERING_FAILURE"
        case .send: return "SEND"
        case .subscription: return "SUBSCRIPTION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
    }
}

extension FailureInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorMessage = "ErrorMessage"
        case failedRecordsS3Url = "FailedRecordsS3Url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let failedRecordsS3Url = failedRecordsS3Url {
            try encodeContainer.encode(failedRecordsS3Url, forKey: .failedRecordsS3Url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRecordsS3UrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failedRecordsS3Url)
        failedRecordsS3Url = failedRecordsS3UrlDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension FailureInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailureInfo(errorMessage: \(String(describing: errorMessage)), failedRecordsS3Url: \(String(describing: failedRecordsS3Url)))"}
}

/// <p>An object that contains the failure details about an import job.</p>
public struct FailureInfo: Equatable {
    /// <p>A message about why the import job failed.</p>
    public let errorMessage: String?
    /// <p>An Amazon S3 presigned URL that contains all the failed records and related
    ///             information.</p>
    public let failedRecordsS3Url: String?

    public init (
        errorMessage: String? = nil,
        failedRecordsS3Url: String? = nil
    )
    {
        self.errorMessage = errorMessage
        self.failedRecordsS3Url = failedRecordsS3Url
    }
}

extension GetAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountInput()"}
}

extension GetAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAccountInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountInput>
    public typealias MOutput = OperationOutput<GetAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountOutputError>
}

public struct GetAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountInput>
    public typealias MOutput = OperationOutput<GetAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountOutputError>
}

/// <p>A request to obtain information about the email-sending capabilities of your Amazon SES
///             account.</p>
public struct GetAccountInput: Equatable {

    public init() {}
}

struct GetAccountInputBody: Equatable {
}

extension GetAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccountOutputError: Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountOutputResponse(dedicatedIpAutoWarmupEnabled: \(String(describing: dedicatedIpAutoWarmupEnabled)), details: \(String(describing: details)), enforcementStatus: \(String(describing: enforcementStatus)), productionAccessEnabled: \(String(describing: productionAccessEnabled)), sendQuota: \(String(describing: sendQuota)), sendingEnabled: \(String(describing: sendingEnabled)), suppressionAttributes: \(String(describing: suppressionAttributes)))"}
}

extension GetAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dedicatedIpAutoWarmupEnabled = output.dedicatedIpAutoWarmupEnabled
            self.details = output.details
            self.enforcementStatus = output.enforcementStatus
            self.productionAccessEnabled = output.productionAccessEnabled
            self.sendQuota = output.sendQuota
            self.sendingEnabled = output.sendingEnabled
            self.suppressionAttributes = output.suppressionAttributes
        } else {
            self.dedicatedIpAutoWarmupEnabled = false
            self.details = nil
            self.enforcementStatus = nil
            self.productionAccessEnabled = false
            self.sendQuota = nil
            self.sendingEnabled = false
            self.suppressionAttributes = nil
        }
    }
}

/// <p>A list of details about the email-sending capabilities of your Amazon SES account in the
///             current AWS Region.</p>
public struct GetAccountOutputResponse: Equatable {
    /// <p>Indicates whether or not the automatic warm-up feature is enabled for dedicated IP
    ///             addresses that are associated with your account.</p>
    public let dedicatedIpAutoWarmupEnabled: Bool
    /// <p>An object that defines your account details.</p>
    public let details: AccountDetails?
    /// <p>The reputation status of your Amazon SES account. The status can be one of the
    ///             following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>HEALTHY</code> – There are no reputation-related issues that
    ///                     currently impact your account.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>PROBATION</code> – We've identified potential issues with your
    ///                     Amazon SES account. We're placing your account under review while you work on
    ///                     correcting these issues.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SHUTDOWN</code> – Your account's ability to send email is
    ///                     currently paused because of an issue with the email sent from your account. When
    ///                     you correct the issue, you can contact us and request that your account's
    ///                     ability to send email is resumed.</p>
    ///             </li>
    ///          </ul>
    public let enforcementStatus: String?
    /// <p>Indicates whether or not your account has production access in the current AWS
    ///             Region.</p>
    ///         <p>If the value is <code>false</code>, then your account is in the
    ///                 <i>sandbox</i>. When your account is in the sandbox, you can only send
    ///             email to verified identities. Additionally, the maximum number of emails you can send in
    ///             a 24-hour period (your sending quota) is 200, and the maximum number of emails you can
    ///             send per second (your maximum sending rate) is 1.</p>
    ///         <p>If the value is <code>true</code>, then your account has production access. When your
    ///             account has production access, you can send email to any address. The sending quota and
    ///             maximum sending rate for your account vary based on your specific use case.</p>
    public let productionAccessEnabled: Bool
    /// <p>An object that contains information about the per-day and per-second sending limits
    ///             for your Amazon SES account in the current AWS Region.</p>
    public let sendQuota: SendQuota?
    /// <p>Indicates whether or not email sending is enabled for your Amazon SES account in the
    ///             current AWS Region.</p>
    public let sendingEnabled: Bool
    /// <p>An object that contains information about the email address suppression preferences
    ///             for your account in the current AWS Region.</p>
    public let suppressionAttributes: SuppressionAttributes?

    public init (
        dedicatedIpAutoWarmupEnabled: Bool = false,
        details: AccountDetails? = nil,
        enforcementStatus: String? = nil,
        productionAccessEnabled: Bool = false,
        sendQuota: SendQuota? = nil,
        sendingEnabled: Bool = false,
        suppressionAttributes: SuppressionAttributes? = nil
    )
    {
        self.dedicatedIpAutoWarmupEnabled = dedicatedIpAutoWarmupEnabled
        self.details = details
        self.enforcementStatus = enforcementStatus
        self.productionAccessEnabled = productionAccessEnabled
        self.sendQuota = sendQuota
        self.sendingEnabled = sendingEnabled
        self.suppressionAttributes = suppressionAttributes
    }
}

struct GetAccountOutputResponseBody: Equatable {
    public let dedicatedIpAutoWarmupEnabled: Bool
    public let enforcementStatus: String?
    public let productionAccessEnabled: Bool
    public let sendQuota: SendQuota?
    public let sendingEnabled: Bool
    public let suppressionAttributes: SuppressionAttributes?
    public let details: AccountDetails?
}

extension GetAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dedicatedIpAutoWarmupEnabled = "DedicatedIpAutoWarmupEnabled"
        case details = "Details"
        case enforcementStatus = "EnforcementStatus"
        case productionAccessEnabled = "ProductionAccessEnabled"
        case sendQuota = "SendQuota"
        case sendingEnabled = "SendingEnabled"
        case suppressionAttributes = "SuppressionAttributes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dedicatedIpAutoWarmupEnabledDecoded = try containerValues.decode(Bool.self, forKey: .dedicatedIpAutoWarmupEnabled)
        dedicatedIpAutoWarmupEnabled = dedicatedIpAutoWarmupEnabledDecoded
        let enforcementStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .enforcementStatus)
        enforcementStatus = enforcementStatusDecoded
        let productionAccessEnabledDecoded = try containerValues.decode(Bool.self, forKey: .productionAccessEnabled)
        productionAccessEnabled = productionAccessEnabledDecoded
        let sendQuotaDecoded = try containerValues.decodeIfPresent(SendQuota.self, forKey: .sendQuota)
        sendQuota = sendQuotaDecoded
        let sendingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .sendingEnabled)
        sendingEnabled = sendingEnabledDecoded
        let suppressionAttributesDecoded = try containerValues.decodeIfPresent(SuppressionAttributes.self, forKey: .suppressionAttributes)
        suppressionAttributes = suppressionAttributesDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(AccountDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

extension GetBlacklistReportsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBlacklistReportsInput(blacklistItemNames: \(String(describing: blacklistItemNames)))"}
}

extension GetBlacklistReportsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBlacklistReportsInputHeadersMiddleware: Middleware {
    public let id: String = "GetBlacklistReportsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBlacklistReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBlacklistReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBlacklistReportsInput>
    public typealias MOutput = OperationOutput<GetBlacklistReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBlacklistReportsOutputError>
}

public struct GetBlacklistReportsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBlacklistReportsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBlacklistReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBlacklistReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let blacklistItemNames = input.operationInput.blacklistItemNames {
            blacklistItemNames.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "BlacklistItemNames".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBlacklistReportsInput>
    public typealias MOutput = OperationOutput<GetBlacklistReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBlacklistReportsOutputError>
}

/// <p>A request to retrieve a list of the blacklists that your dedicated IP addresses appear
///             on.</p>
public struct GetBlacklistReportsInput: Equatable {
    /// <p>A list of IP addresses that you want to retrieve blacklist information about. You can
    ///             only specify the dedicated IP addresses that you use to send email using Amazon SES or
    ///             Amazon Pinpoint.</p>
    public let blacklistItemNames: [String]?

    public init (
        blacklistItemNames: [String]? = nil
    )
    {
        self.blacklistItemNames = blacklistItemNames
    }
}

struct GetBlacklistReportsInputBody: Equatable {
}

extension GetBlacklistReportsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBlacklistReportsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBlacklistReportsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBlacklistReportsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBlacklistReportsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBlacklistReportsOutputResponse(blacklistReport: \(String(describing: blacklistReport)))"}
}

extension GetBlacklistReportsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBlacklistReportsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.blacklistReport = output.blacklistReport
        } else {
            self.blacklistReport = nil
        }
    }
}

/// <p>An object that contains information about blacklist events.</p>
public struct GetBlacklistReportsOutputResponse: Equatable {
    /// <p>An object that contains information about a blacklist that one of your dedicated IP
    ///             addresses appears on.</p>
    public let blacklistReport: [String:[BlacklistEntry]]?

    public init (
        blacklistReport: [String:[BlacklistEntry]]? = nil
    )
    {
        self.blacklistReport = blacklistReport
    }
}

struct GetBlacklistReportsOutputResponseBody: Equatable {
    public let blacklistReport: [String:[BlacklistEntry]]?
}

extension GetBlacklistReportsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case blacklistReport = "BlacklistReport"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blacklistReportContainer = try containerValues.decodeIfPresent([String: [BlacklistEntry?]?].self, forKey: .blacklistReport)
        var blacklistReportDecoded0: [String:[BlacklistEntry]]? = nil
        if let blacklistReportContainer = blacklistReportContainer {
            blacklistReportDecoded0 = [String:[BlacklistEntry]]()
            for (key0, blacklistentries0) in blacklistReportContainer {
                var blacklistentries0Decoded0: [BlacklistEntry]? = nil
                if let blacklistentries0 = blacklistentries0 {
                    blacklistentries0Decoded0 = [BlacklistEntry]()
                    for structure1 in blacklistentries0 {
                        if let structure1 = structure1 {
                            blacklistentries0Decoded0?.append(structure1)
                        }
                    }
                }
                blacklistReportDecoded0?[key0] = blacklistentries0Decoded0
            }
        }
        blacklistReport = blacklistReportDecoded0
    }
}

extension GetConfigurationSetEventDestinationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConfigurationSetEventDestinationsInput(configurationSetName: \(String(describing: configurationSetName)))"}
}

extension GetConfigurationSetEventDestinationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetConfigurationSetEventDestinationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetConfigurationSetEventDestinationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConfigurationSetEventDestinationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConfigurationSetEventDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConfigurationSetEventDestinationsInput>
    public typealias MOutput = OperationOutput<GetConfigurationSetEventDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConfigurationSetEventDestinationsOutputError>
}

public struct GetConfigurationSetEventDestinationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConfigurationSetEventDestinationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConfigurationSetEventDestinationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConfigurationSetEventDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConfigurationSetEventDestinationsInput>
    public typealias MOutput = OperationOutput<GetConfigurationSetEventDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConfigurationSetEventDestinationsOutputError>
}

/// <p>A request to obtain information about the event destinations for a configuration
///             set.</p>
public struct GetConfigurationSetEventDestinationsInput: Equatable {
    /// <p>The name of the configuration set that contains the event destination.</p>
    public let configurationSetName: String?

    public init (
        configurationSetName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct GetConfigurationSetEventDestinationsInputBody: Equatable {
}

extension GetConfigurationSetEventDestinationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetConfigurationSetEventDestinationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigurationSetEventDestinationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConfigurationSetEventDestinationsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigurationSetEventDestinationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConfigurationSetEventDestinationsOutputResponse(eventDestinations: \(String(describing: eventDestinations)))"}
}

extension GetConfigurationSetEventDestinationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetConfigurationSetEventDestinationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventDestinations = output.eventDestinations
        } else {
            self.eventDestinations = nil
        }
    }
}

/// <p>Information about an event destination for a configuration set.</p>
public struct GetConfigurationSetEventDestinationsOutputResponse: Equatable {
    /// <p>An array that includes all of the events destinations that have been configured for
    ///             the configuration set.</p>
    public let eventDestinations: [EventDestination]?

    public init (
        eventDestinations: [EventDestination]? = nil
    )
    {
        self.eventDestinations = eventDestinations
    }
}

struct GetConfigurationSetEventDestinationsOutputResponseBody: Equatable {
    public let eventDestinations: [EventDestination]?
}

extension GetConfigurationSetEventDestinationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventDestinations = "EventDestinations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDestinationsContainer = try containerValues.decodeIfPresent([EventDestination?].self, forKey: .eventDestinations)
        var eventDestinationsDecoded0:[EventDestination]? = nil
        if let eventDestinationsContainer = eventDestinationsContainer {
            eventDestinationsDecoded0 = [EventDestination]()
            for structure0 in eventDestinationsContainer {
                if let structure0 = structure0 {
                    eventDestinationsDecoded0?.append(structure0)
                }
            }
        }
        eventDestinations = eventDestinationsDecoded0
    }
}

extension GetConfigurationSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConfigurationSetInput(configurationSetName: \(String(describing: configurationSetName)))"}
}

extension GetConfigurationSetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetConfigurationSetInputHeadersMiddleware: Middleware {
    public let id: String = "GetConfigurationSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConfigurationSetInput>
    public typealias MOutput = OperationOutput<GetConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConfigurationSetOutputError>
}

public struct GetConfigurationSetInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConfigurationSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConfigurationSetInput>
    public typealias MOutput = OperationOutput<GetConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConfigurationSetOutputError>
}

/// <p>A request to obtain information about a configuration set.</p>
public struct GetConfigurationSetInput: Equatable {
    /// <p>The name of the configuration set that you want to obtain more information
    ///             about.</p>
    public let configurationSetName: String?

    public init (
        configurationSetName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct GetConfigurationSetInputBody: Equatable {
}

extension GetConfigurationSetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetConfigurationSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigurationSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConfigurationSetOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigurationSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConfigurationSetOutputResponse(configurationSetName: \(String(describing: configurationSetName)), deliveryOptions: \(String(describing: deliveryOptions)), reputationOptions: \(String(describing: reputationOptions)), sendingOptions: \(String(describing: sendingOptions)), suppressionOptions: \(String(describing: suppressionOptions)), tags: \(String(describing: tags)), trackingOptions: \(String(describing: trackingOptions)))"}
}

extension GetConfigurationSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetConfigurationSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationSetName = output.configurationSetName
            self.deliveryOptions = output.deliveryOptions
            self.reputationOptions = output.reputationOptions
            self.sendingOptions = output.sendingOptions
            self.suppressionOptions = output.suppressionOptions
            self.tags = output.tags
            self.trackingOptions = output.trackingOptions
        } else {
            self.configurationSetName = nil
            self.deliveryOptions = nil
            self.reputationOptions = nil
            self.sendingOptions = nil
            self.suppressionOptions = nil
            self.tags = nil
            self.trackingOptions = nil
        }
    }
}

/// <p>Information about a configuration set.</p>
public struct GetConfigurationSetOutputResponse: Equatable {
    /// <p>The name of the configuration set.</p>
    public let configurationSetName: String?
    /// <p>An object that defines the dedicated IP pool that is used to send emails that you send
    ///             using the configuration set.</p>
    public let deliveryOptions: DeliveryOptions?
    /// <p>An object that defines whether or not Amazon SES collects reputation metrics for the emails
    ///             that you send that use the configuration set.</p>
    public let reputationOptions: ReputationOptions?
    /// <p>An object that defines whether or not Amazon SES can send email that you send using the
    ///             configuration set.</p>
    public let sendingOptions: SendingOptions?
    /// <p>An object that contains information about the suppression list preferences for your
    ///             account.</p>
    public let suppressionOptions: SuppressionOptions?
    /// <p>An array of objects that define the tags (keys and values) that are associated with
    ///             the configuration set.</p>
    public let tags: [Tag]?
    /// <p>An object that defines the open and click tracking options for emails that you send
    ///             using the configuration set.</p>
    public let trackingOptions: TrackingOptions?

    public init (
        configurationSetName: String? = nil,
        deliveryOptions: DeliveryOptions? = nil,
        reputationOptions: ReputationOptions? = nil,
        sendingOptions: SendingOptions? = nil,
        suppressionOptions: SuppressionOptions? = nil,
        tags: [Tag]? = nil,
        trackingOptions: TrackingOptions? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.deliveryOptions = deliveryOptions
        self.reputationOptions = reputationOptions
        self.sendingOptions = sendingOptions
        self.suppressionOptions = suppressionOptions
        self.tags = tags
        self.trackingOptions = trackingOptions
    }
}

struct GetConfigurationSetOutputResponseBody: Equatable {
    public let configurationSetName: String?
    public let trackingOptions: TrackingOptions?
    public let deliveryOptions: DeliveryOptions?
    public let reputationOptions: ReputationOptions?
    public let sendingOptions: SendingOptions?
    public let tags: [Tag]?
    public let suppressionOptions: SuppressionOptions?
}

extension GetConfigurationSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case deliveryOptions = "DeliveryOptions"
        case reputationOptions = "ReputationOptions"
        case sendingOptions = "SendingOptions"
        case suppressionOptions = "SuppressionOptions"
        case tags = "Tags"
        case trackingOptions = "TrackingOptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let trackingOptionsDecoded = try containerValues.decodeIfPresent(TrackingOptions.self, forKey: .trackingOptions)
        trackingOptions = trackingOptionsDecoded
        let deliveryOptionsDecoded = try containerValues.decodeIfPresent(DeliveryOptions.self, forKey: .deliveryOptions)
        deliveryOptions = deliveryOptionsDecoded
        let reputationOptionsDecoded = try containerValues.decodeIfPresent(ReputationOptions.self, forKey: .reputationOptions)
        reputationOptions = reputationOptionsDecoded
        let sendingOptionsDecoded = try containerValues.decodeIfPresent(SendingOptions.self, forKey: .sendingOptions)
        sendingOptions = sendingOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let suppressionOptionsDecoded = try containerValues.decodeIfPresent(SuppressionOptions.self, forKey: .suppressionOptions)
        suppressionOptions = suppressionOptionsDecoded
    }
}

extension GetContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContactInput(contactListName: \(String(describing: contactListName)), emailAddress: \(String(describing: emailAddress)))"}
}

extension GetContactInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetContactInputHeadersMiddleware: Middleware {
    public let id: String = "GetContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactInput>
    public typealias MOutput = OperationOutput<GetContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactOutputError>
}

public struct GetContactInputQueryItemMiddleware: Middleware {
    public let id: String = "GetContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactInput>
    public typealias MOutput = OperationOutput<GetContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactOutputError>
}

public struct GetContactInput: Equatable {
    /// <p>The name of the contact list to which the contact belongs.</p>
    public let contactListName: String?
    /// <p>The contact's email addres.</p>
    public let emailAddress: String?

    public init (
        contactListName: String? = nil,
        emailAddress: String? = nil
    )
    {
        self.contactListName = contactListName
        self.emailAddress = emailAddress
    }
}

struct GetContactInputBody: Equatable {
}

extension GetContactInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetContactListInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContactListInput(contactListName: \(String(describing: contactListName)))"}
}

extension GetContactListInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetContactListInputHeadersMiddleware: Middleware {
    public let id: String = "GetContactListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactListInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactListInput>
    public typealias MOutput = OperationOutput<GetContactListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactListOutputError>
}

public struct GetContactListInputQueryItemMiddleware: Middleware {
    public let id: String = "GetContactListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactListInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactListInput>
    public typealias MOutput = OperationOutput<GetContactListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactListOutputError>
}

public struct GetContactListInput: Equatable {
    /// <p>The name of the contact list.</p>
    public let contactListName: String?

    public init (
        contactListName: String? = nil
    )
    {
        self.contactListName = contactListName
    }
}

struct GetContactListInputBody: Equatable {
}

extension GetContactListInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetContactListOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContactListOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContactListOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContactListOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContactListOutputResponse(contactListName: \(String(describing: contactListName)), createdTimestamp: \(String(describing: createdTimestamp)), description: \(String(describing: description)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), tags: \(String(describing: tags)), topics: \(String(describing: topics)))"}
}

extension GetContactListOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetContactListOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contactListName = output.contactListName
            self.createdTimestamp = output.createdTimestamp
            self.description = output.description
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.tags = output.tags
            self.topics = output.topics
        } else {
            self.contactListName = nil
            self.createdTimestamp = nil
            self.description = nil
            self.lastUpdatedTimestamp = nil
            self.tags = nil
            self.topics = nil
        }
    }
}

public struct GetContactListOutputResponse: Equatable {
    /// <p>The name of the contact list.</p>
    public let contactListName: String?
    /// <p>A timestamp noting when the contact list was created.</p>
    public let createdTimestamp: Date?
    /// <p>A description of what the contact list is about.</p>
    public let description: String?
    /// <p>A timestamp noting the last time the contact list was updated.</p>
    public let lastUpdatedTimestamp: Date?
    /// <p>The tags associated with a contact list.</p>
    public let tags: [Tag]?
    /// <p>An interest group, theme, or label within a list. A contact list can have multiple
    ///             topics.</p>
    public let topics: [Topic]?

    public init (
        contactListName: String? = nil,
        createdTimestamp: Date? = nil,
        description: String? = nil,
        lastUpdatedTimestamp: Date? = nil,
        tags: [Tag]? = nil,
        topics: [Topic]? = nil
    )
    {
        self.contactListName = contactListName
        self.createdTimestamp = createdTimestamp
        self.description = description
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.tags = tags
        self.topics = topics
    }
}

struct GetContactListOutputResponseBody: Equatable {
    public let contactListName: String?
    public let topics: [Topic]?
    public let description: String?
    public let createdTimestamp: Date?
    public let lastUpdatedTimestamp: Date?
    public let tags: [Tag]?
}

extension GetContactListOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactListName = "ContactListName"
        case createdTimestamp = "CreatedTimestamp"
        case description = "Description"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case tags = "Tags"
        case topics = "Topics"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactListNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactListName)
        contactListName = contactListNameDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Topic?].self, forKey: .topics)
        var topicsDecoded0:[Topic]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Topic]()
            for structure0 in topicsContainer {
                if let structure0 = structure0 {
                    topicsDecoded0?.append(structure0)
                }
            }
        }
        topics = topicsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContactOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContactOutputResponse(attributesData: \(String(describing: attributesData)), contactListName: \(String(describing: contactListName)), createdTimestamp: \(String(describing: createdTimestamp)), emailAddress: \(String(describing: emailAddress)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), topicDefaultPreferences: \(String(describing: topicDefaultPreferences)), topicPreferences: \(String(describing: topicPreferences)), unsubscribeAll: \(String(describing: unsubscribeAll)))"}
}

extension GetContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetContactOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributesData = output.attributesData
            self.contactListName = output.contactListName
            self.createdTimestamp = output.createdTimestamp
            self.emailAddress = output.emailAddress
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.topicDefaultPreferences = output.topicDefaultPreferences
            self.topicPreferences = output.topicPreferences
            self.unsubscribeAll = output.unsubscribeAll
        } else {
            self.attributesData = nil
            self.contactListName = nil
            self.createdTimestamp = nil
            self.emailAddress = nil
            self.lastUpdatedTimestamp = nil
            self.topicDefaultPreferences = nil
            self.topicPreferences = nil
            self.unsubscribeAll = false
        }
    }
}

public struct GetContactOutputResponse: Equatable {
    /// <p>The attribute data attached to a contact.</p>
    public let attributesData: String?
    /// <p>The name of the contact list to which the contact belongs.</p>
    public let contactListName: String?
    /// <p>A timestamp noting when the contact was created.</p>
    public let createdTimestamp: Date?
    /// <p>The contact's email addres.</p>
    public let emailAddress: String?
    /// <p>A timestamp noting the last time the contact's information was updated.</p>
    public let lastUpdatedTimestamp: Date?
    /// <p>The default topic preferences applied to the contact.</p>
    public let topicDefaultPreferences: [TopicPreference]?
    /// <p>The contact's preference for being opted-in to or opted-out of a topic.></p>
    public let topicPreferences: [TopicPreference]?
    /// <p>A boolean value status noting if the contact is unsubscribed from all contact list
    ///             topics.</p>
    public let unsubscribeAll: Bool

    public init (
        attributesData: String? = nil,
        contactListName: String? = nil,
        createdTimestamp: Date? = nil,
        emailAddress: String? = nil,
        lastUpdatedTimestamp: Date? = nil,
        topicDefaultPreferences: [TopicPreference]? = nil,
        topicPreferences: [TopicPreference]? = nil,
        unsubscribeAll: Bool = false
    )
    {
        self.attributesData = attributesData
        self.contactListName = contactListName
        self.createdTimestamp = createdTimestamp
        self.emailAddress = emailAddress
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.topicDefaultPreferences = topicDefaultPreferences
        self.topicPreferences = topicPreferences
        self.unsubscribeAll = unsubscribeAll
    }
}

struct GetContactOutputResponseBody: Equatable {
    public let contactListName: String?
    public let emailAddress: String?
    public let topicPreferences: [TopicPreference]?
    public let topicDefaultPreferences: [TopicPreference]?
    public let unsubscribeAll: Bool
    public let attributesData: String?
    public let createdTimestamp: Date?
    public let lastUpdatedTimestamp: Date?
}

extension GetContactOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributesData = "AttributesData"
        case contactListName = "ContactListName"
        case createdTimestamp = "CreatedTimestamp"
        case emailAddress = "EmailAddress"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case topicDefaultPreferences = "TopicDefaultPreferences"
        case topicPreferences = "TopicPreferences"
        case unsubscribeAll = "UnsubscribeAll"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactListNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactListName)
        contactListName = contactListNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let topicPreferencesContainer = try containerValues.decodeIfPresent([TopicPreference?].self, forKey: .topicPreferences)
        var topicPreferencesDecoded0:[TopicPreference]? = nil
        if let topicPreferencesContainer = topicPreferencesContainer {
            topicPreferencesDecoded0 = [TopicPreference]()
            for structure0 in topicPreferencesContainer {
                if let structure0 = structure0 {
                    topicPreferencesDecoded0?.append(structure0)
                }
            }
        }
        topicPreferences = topicPreferencesDecoded0
        let topicDefaultPreferencesContainer = try containerValues.decodeIfPresent([TopicPreference?].self, forKey: .topicDefaultPreferences)
        var topicDefaultPreferencesDecoded0:[TopicPreference]? = nil
        if let topicDefaultPreferencesContainer = topicDefaultPreferencesContainer {
            topicDefaultPreferencesDecoded0 = [TopicPreference]()
            for structure0 in topicDefaultPreferencesContainer {
                if let structure0 = structure0 {
                    topicDefaultPreferencesDecoded0?.append(structure0)
                }
            }
        }
        topicDefaultPreferences = topicDefaultPreferencesDecoded0
        let unsubscribeAllDecoded = try containerValues.decode(Bool.self, forKey: .unsubscribeAll)
        unsubscribeAll = unsubscribeAllDecoded
        let attributesDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributesData)
        attributesData = attributesDataDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
    }
}

extension GetCustomVerificationEmailTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCustomVerificationEmailTemplateInput(templateName: \(String(describing: templateName)))"}
}

extension GetCustomVerificationEmailTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCustomVerificationEmailTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GetCustomVerificationEmailTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<GetCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCustomVerificationEmailTemplateOutputError>
}

public struct GetCustomVerificationEmailTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCustomVerificationEmailTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<GetCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCustomVerificationEmailTemplateOutputError>
}

/// <p>Represents a request to retrieve an existing custom verification email
///             template.</p>
public struct GetCustomVerificationEmailTemplateInput: Equatable {
    /// <p>The name of the custom verification email template that you want to retrieve.</p>
    public let templateName: String?

    public init (
        templateName: String? = nil
    )
    {
        self.templateName = templateName
    }
}

struct GetCustomVerificationEmailTemplateInputBody: Equatable {
}

extension GetCustomVerificationEmailTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCustomVerificationEmailTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCustomVerificationEmailTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCustomVerificationEmailTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCustomVerificationEmailTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCustomVerificationEmailTemplateOutputResponse(failureRedirectionURL: \(String(describing: failureRedirectionURL)), fromEmailAddress: \(String(describing: fromEmailAddress)), successRedirectionURL: \(String(describing: successRedirectionURL)), templateContent: \(String(describing: templateContent)), templateName: \(String(describing: templateName)), templateSubject: \(String(describing: templateSubject)))"}
}

extension GetCustomVerificationEmailTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCustomVerificationEmailTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failureRedirectionURL = output.failureRedirectionURL
            self.fromEmailAddress = output.fromEmailAddress
            self.successRedirectionURL = output.successRedirectionURL
            self.templateContent = output.templateContent
            self.templateName = output.templateName
            self.templateSubject = output.templateSubject
        } else {
            self.failureRedirectionURL = nil
            self.fromEmailAddress = nil
            self.successRedirectionURL = nil
            self.templateContent = nil
            self.templateName = nil
            self.templateSubject = nil
        }
    }
}

/// <p>The following elements are returned by the service.</p>
public struct GetCustomVerificationEmailTemplateOutputResponse: Equatable {
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    ///             is not successfully verified.</p>
    public let failureRedirectionURL: String?
    /// <p>The email address that the custom verification email is sent from.</p>
    public let fromEmailAddress: String?
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    ///             is successfully verified.</p>
    public let successRedirectionURL: String?
    /// <p>The content of the custom verification email.</p>
    public let templateContent: String?
    /// <p>The name of the custom verification email template.</p>
    public let templateName: String?
    /// <p>The subject line of the custom verification email.</p>
    public let templateSubject: String?

    public init (
        failureRedirectionURL: String? = nil,
        fromEmailAddress: String? = nil,
        successRedirectionURL: String? = nil,
        templateContent: String? = nil,
        templateName: String? = nil,
        templateSubject: String? = nil
    )
    {
        self.failureRedirectionURL = failureRedirectionURL
        self.fromEmailAddress = fromEmailAddress
        self.successRedirectionURL = successRedirectionURL
        self.templateContent = templateContent
        self.templateName = templateName
        self.templateSubject = templateSubject
    }
}

struct GetCustomVerificationEmailTemplateOutputResponseBody: Equatable {
    public let templateName: String?
    public let fromEmailAddress: String?
    public let templateSubject: String?
    public let templateContent: String?
    public let successRedirectionURL: String?
    public let failureRedirectionURL: String?
}

extension GetCustomVerificationEmailTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failureRedirectionURL = "FailureRedirectionURL"
        case fromEmailAddress = "FromEmailAddress"
        case successRedirectionURL = "SuccessRedirectionURL"
        case templateContent = "TemplateContent"
        case templateName = "TemplateName"
        case templateSubject = "TemplateSubject"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let fromEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromEmailAddress)
        fromEmailAddress = fromEmailAddressDecoded
        let templateSubjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateSubject)
        templateSubject = templateSubjectDecoded
        let templateContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateContent)
        templateContent = templateContentDecoded
        let successRedirectionURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .successRedirectionURL)
        successRedirectionURL = successRedirectionURLDecoded
        let failureRedirectionURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureRedirectionURL)
        failureRedirectionURL = failureRedirectionURLDecoded
    }
}

extension GetDedicatedIpInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDedicatedIpInput(ip: \(String(describing: ip)))"}
}

extension GetDedicatedIpInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDedicatedIpInputHeadersMiddleware: Middleware {
    public let id: String = "GetDedicatedIpInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDedicatedIpInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDedicatedIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDedicatedIpInput>
    public typealias MOutput = OperationOutput<GetDedicatedIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDedicatedIpOutputError>
}

public struct GetDedicatedIpInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDedicatedIpInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDedicatedIpInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDedicatedIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDedicatedIpInput>
    public typealias MOutput = OperationOutput<GetDedicatedIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDedicatedIpOutputError>
}

/// <p>A request to obtain more information about a dedicated IP address.</p>
public struct GetDedicatedIpInput: Equatable {
    /// <p>The IP address that you want to obtain more information about. The value you specify
    ///             has to be a dedicated IP address that's assocaited with your AWS account.</p>
    public let ip: String?

    public init (
        ip: String? = nil
    )
    {
        self.ip = ip
    }
}

struct GetDedicatedIpInputBody: Equatable {
}

extension GetDedicatedIpInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDedicatedIpOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDedicatedIpOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDedicatedIpOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDedicatedIpOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDedicatedIpOutputResponse(dedicatedIp: \(String(describing: dedicatedIp)))"}
}

extension GetDedicatedIpOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDedicatedIpOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dedicatedIp = output.dedicatedIp
        } else {
            self.dedicatedIp = nil
        }
    }
}

/// <p>Information about a dedicated IP address.</p>
public struct GetDedicatedIpOutputResponse: Equatable {
    /// <p>An object that contains information about a dedicated IP address.</p>
    public let dedicatedIp: DedicatedIp?

    public init (
        dedicatedIp: DedicatedIp? = nil
    )
    {
        self.dedicatedIp = dedicatedIp
    }
}

struct GetDedicatedIpOutputResponseBody: Equatable {
    public let dedicatedIp: DedicatedIp?
}

extension GetDedicatedIpOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dedicatedIp = "DedicatedIp"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dedicatedIpDecoded = try containerValues.decodeIfPresent(DedicatedIp.self, forKey: .dedicatedIp)
        dedicatedIp = dedicatedIpDecoded
    }
}

extension GetDedicatedIpsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDedicatedIpsInput(nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)), poolName: \(String(describing: poolName)))"}
}

extension GetDedicatedIpsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDedicatedIpsInputHeadersMiddleware: Middleware {
    public let id: String = "GetDedicatedIpsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDedicatedIpsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDedicatedIpsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDedicatedIpsInput>
    public typealias MOutput = OperationOutput<GetDedicatedIpsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDedicatedIpsOutputError>
}

public struct GetDedicatedIpsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDedicatedIpsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDedicatedIpsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDedicatedIpsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "PageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let poolName = input.operationInput.poolName {
            let poolNameQueryItem = URLQueryItem(name: "PoolName".urlPercentEncoding(), value: String(poolName).urlPercentEncoding())
            input.builder.withQueryItem(poolNameQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDedicatedIpsInput>
    public typealias MOutput = OperationOutput<GetDedicatedIpsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDedicatedIpsOutputError>
}

/// <p>A request to obtain more information about dedicated IP pools.</p>
public struct GetDedicatedIpsInput: Equatable {
    /// <p>A token returned from a previous call to <code>GetDedicatedIps</code> to indicate the
    ///             position of the dedicated IP pool in the list of IP pools.</p>
    public let nextToken: String?
    /// <p>The number of results to show in a single call to <code>GetDedicatedIpsRequest</code>.
    ///             If the number of results is larger than the number you specified in this parameter, then
    ///             the response includes a <code>NextToken</code> element, which you can use to obtain
    ///             additional results.</p>
    public let pageSize: Int?
    /// <p>The name of the IP pool that the dedicated IP address is associated with.</p>
    public let poolName: String?

    public init (
        nextToken: String? = nil,
        pageSize: Int? = nil,
        poolName: String? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.poolName = poolName
    }
}

struct GetDedicatedIpsInputBody: Equatable {
}

extension GetDedicatedIpsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDedicatedIpsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDedicatedIpsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDedicatedIpsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDedicatedIpsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDedicatedIpsOutputResponse(dedicatedIps: \(String(describing: dedicatedIps)), nextToken: \(String(describing: nextToken)))"}
}

extension GetDedicatedIpsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDedicatedIpsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dedicatedIps = output.dedicatedIps
            self.nextToken = output.nextToken
        } else {
            self.dedicatedIps = nil
            self.nextToken = nil
        }
    }
}

/// <p>Information about the dedicated IP addresses that are associated with your AWS
///             account.</p>
public struct GetDedicatedIpsOutputResponse: Equatable {
    /// <p>A list of dedicated IP addresses that are associated with your AWS account.</p>
    public let dedicatedIps: [DedicatedIp]?
    /// <p>A token that indicates that there are additional dedicated IP addresses to list. To
    ///             view additional addresses, issue another request to <code>GetDedicatedIps</code>,
    ///             passing this token in the <code>NextToken</code> parameter.</p>
    public let nextToken: String?

    public init (
        dedicatedIps: [DedicatedIp]? = nil,
        nextToken: String? = nil
    )
    {
        self.dedicatedIps = dedicatedIps
        self.nextToken = nextToken
    }
}

struct GetDedicatedIpsOutputResponseBody: Equatable {
    public let dedicatedIps: [DedicatedIp]?
    public let nextToken: String?
}

extension GetDedicatedIpsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dedicatedIps = "DedicatedIps"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dedicatedIpsContainer = try containerValues.decodeIfPresent([DedicatedIp?].self, forKey: .dedicatedIps)
        var dedicatedIpsDecoded0:[DedicatedIp]? = nil
        if let dedicatedIpsContainer = dedicatedIpsContainer {
            dedicatedIpsDecoded0 = [DedicatedIp]()
            for structure0 in dedicatedIpsContainer {
                if let structure0 = structure0 {
                    dedicatedIpsDecoded0?.append(structure0)
                }
            }
        }
        dedicatedIps = dedicatedIpsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDeliverabilityDashboardOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeliverabilityDashboardOptionsInput()"}
}

extension GetDeliverabilityDashboardOptionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDeliverabilityDashboardOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeliverabilityDashboardOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeliverabilityDashboardOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeliverabilityDashboardOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeliverabilityDashboardOptionsInput>
    public typealias MOutput = OperationOutput<GetDeliverabilityDashboardOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeliverabilityDashboardOptionsOutputError>
}

public struct GetDeliverabilityDashboardOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeliverabilityDashboardOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeliverabilityDashboardOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeliverabilityDashboardOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeliverabilityDashboardOptionsInput>
    public typealias MOutput = OperationOutput<GetDeliverabilityDashboardOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeliverabilityDashboardOptionsOutputError>
}

/// <p>Retrieve information about the status of the Deliverability dashboard for your AWS account.
///             When the Deliverability dashboard is enabled, you gain access to reputation, deliverability, and
///             other metrics for your domains. You also gain the ability to perform predictive inbox placement tests.</p>
///
///         <p>When you use the Deliverability dashboard, you pay a monthly subscription charge, in addition
///             to any other fees that you accrue by using Amazon SES and other AWS services. For more
///             information about the features and cost of a Deliverability dashboard subscription, see <a href="http://aws.amazon.com/pinpoint/pricing/">Amazon Pinpoint Pricing</a>.</p>
public struct GetDeliverabilityDashboardOptionsInput: Equatable {

    public init() {}
}

struct GetDeliverabilityDashboardOptionsInputBody: Equatable {
}

extension GetDeliverabilityDashboardOptionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDeliverabilityDashboardOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeliverabilityDashboardOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeliverabilityDashboardOptionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeliverabilityDashboardOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeliverabilityDashboardOptionsOutputResponse(accountStatus: \(String(describing: accountStatus)), activeSubscribedDomains: \(String(describing: activeSubscribedDomains)), dashboardEnabled: \(String(describing: dashboardEnabled)), pendingExpirationSubscribedDomains: \(String(describing: pendingExpirationSubscribedDomains)), subscriptionExpiryDate: \(String(describing: subscriptionExpiryDate)))"}
}

extension GetDeliverabilityDashboardOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDeliverabilityDashboardOptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountStatus = output.accountStatus
            self.activeSubscribedDomains = output.activeSubscribedDomains
            self.dashboardEnabled = output.dashboardEnabled
            self.pendingExpirationSubscribedDomains = output.pendingExpirationSubscribedDomains
            self.subscriptionExpiryDate = output.subscriptionExpiryDate
        } else {
            self.accountStatus = nil
            self.activeSubscribedDomains = nil
            self.dashboardEnabled = false
            self.pendingExpirationSubscribedDomains = nil
            self.subscriptionExpiryDate = nil
        }
    }
}

/// <p>An object that shows the status of the Deliverability dashboard.</p>
public struct GetDeliverabilityDashboardOptionsOutputResponse: Equatable {
    /// <p>The current status of your Deliverability dashboard subscription. If this value is
    ///                 <code>PENDING_EXPIRATION</code>, your subscription is scheduled to expire at the end
    ///             of the current calendar month.</p>
    public let accountStatus: DeliverabilityDashboardAccountStatus?
    /// <p>An array of objects, one for each verified domain that you use to send email and
    ///             currently has an active Deliverability dashboard subscription that isn’t scheduled to expire at
    ///             the end of the current calendar month.</p>
    public let activeSubscribedDomains: [DomainDeliverabilityTrackingOption]?
    /// <p>Specifies whether the Deliverability dashboard is enabled. If this value is <code>true</code>,
    ///             the dashboard is enabled.</p>
    public let dashboardEnabled: Bool
    /// <p>An array of objects, one for each verified domain that you use to send email and
    ///             currently has an active Deliverability dashboard subscription that's scheduled to expire at the
    ///             end of the current calendar month.</p>
    public let pendingExpirationSubscribedDomains: [DomainDeliverabilityTrackingOption]?
    /// <p>The date, in Unix time format, when your current subscription to the Deliverability dashboard
    ///             is scheduled to expire, if your subscription is scheduled to expire at the end of the
    ///             current calendar month. This value is null if you have an active subscription that isn’t
    ///             due to expire at the end of the month.</p>
    public let subscriptionExpiryDate: Date?

    public init (
        accountStatus: DeliverabilityDashboardAccountStatus? = nil,
        activeSubscribedDomains: [DomainDeliverabilityTrackingOption]? = nil,
        dashboardEnabled: Bool = false,
        pendingExpirationSubscribedDomains: [DomainDeliverabilityTrackingOption]? = nil,
        subscriptionExpiryDate: Date? = nil
    )
    {
        self.accountStatus = accountStatus
        self.activeSubscribedDomains = activeSubscribedDomains
        self.dashboardEnabled = dashboardEnabled
        self.pendingExpirationSubscribedDomains = pendingExpirationSubscribedDomains
        self.subscriptionExpiryDate = subscriptionExpiryDate
    }
}

struct GetDeliverabilityDashboardOptionsOutputResponseBody: Equatable {
    public let dashboardEnabled: Bool
    public let subscriptionExpiryDate: Date?
    public let accountStatus: DeliverabilityDashboardAccountStatus?
    public let activeSubscribedDomains: [DomainDeliverabilityTrackingOption]?
    public let pendingExpirationSubscribedDomains: [DomainDeliverabilityTrackingOption]?
}

extension GetDeliverabilityDashboardOptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountStatus = "AccountStatus"
        case activeSubscribedDomains = "ActiveSubscribedDomains"
        case dashboardEnabled = "DashboardEnabled"
        case pendingExpirationSubscribedDomains = "PendingExpirationSubscribedDomains"
        case subscriptionExpiryDate = "SubscriptionExpiryDate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardEnabledDecoded = try containerValues.decode(Bool.self, forKey: .dashboardEnabled)
        dashboardEnabled = dashboardEnabledDecoded
        let subscriptionExpiryDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .subscriptionExpiryDate)
        subscriptionExpiryDate = subscriptionExpiryDateDecoded
        let accountStatusDecoded = try containerValues.decodeIfPresent(DeliverabilityDashboardAccountStatus.self, forKey: .accountStatus)
        accountStatus = accountStatusDecoded
        let activeSubscribedDomainsContainer = try containerValues.decodeIfPresent([DomainDeliverabilityTrackingOption?].self, forKey: .activeSubscribedDomains)
        var activeSubscribedDomainsDecoded0:[DomainDeliverabilityTrackingOption]? = nil
        if let activeSubscribedDomainsContainer = activeSubscribedDomainsContainer {
            activeSubscribedDomainsDecoded0 = [DomainDeliverabilityTrackingOption]()
            for structure0 in activeSubscribedDomainsContainer {
                if let structure0 = structure0 {
                    activeSubscribedDomainsDecoded0?.append(structure0)
                }
            }
        }
        activeSubscribedDomains = activeSubscribedDomainsDecoded0
        let pendingExpirationSubscribedDomainsContainer = try containerValues.decodeIfPresent([DomainDeliverabilityTrackingOption?].self, forKey: .pendingExpirationSubscribedDomains)
        var pendingExpirationSubscribedDomainsDecoded0:[DomainDeliverabilityTrackingOption]? = nil
        if let pendingExpirationSubscribedDomainsContainer = pendingExpirationSubscribedDomainsContainer {
            pendingExpirationSubscribedDomainsDecoded0 = [DomainDeliverabilityTrackingOption]()
            for structure0 in pendingExpirationSubscribedDomainsContainer {
                if let structure0 = structure0 {
                    pendingExpirationSubscribedDomainsDecoded0?.append(structure0)
                }
            }
        }
        pendingExpirationSubscribedDomains = pendingExpirationSubscribedDomainsDecoded0
    }
}

extension GetDeliverabilityTestReportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeliverabilityTestReportInput(reportId: \(String(describing: reportId)))"}
}

extension GetDeliverabilityTestReportInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDeliverabilityTestReportInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeliverabilityTestReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeliverabilityTestReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeliverabilityTestReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeliverabilityTestReportInput>
    public typealias MOutput = OperationOutput<GetDeliverabilityTestReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeliverabilityTestReportOutputError>
}

public struct GetDeliverabilityTestReportInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeliverabilityTestReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeliverabilityTestReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeliverabilityTestReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeliverabilityTestReportInput>
    public typealias MOutput = OperationOutput<GetDeliverabilityTestReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeliverabilityTestReportOutputError>
}

/// <p>A request to retrieve the results of a predictive inbox placement test.</p>
public struct GetDeliverabilityTestReportInput: Equatable {
    /// <p>A unique string that identifies the predictive inbox placement test.</p>
    public let reportId: String?

    public init (
        reportId: String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct GetDeliverabilityTestReportInputBody: Equatable {
}

extension GetDeliverabilityTestReportInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDeliverabilityTestReportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeliverabilityTestReportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeliverabilityTestReportOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeliverabilityTestReportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeliverabilityTestReportOutputResponse(deliverabilityTestReport: \(String(describing: deliverabilityTestReport)), ispPlacements: \(String(describing: ispPlacements)), message: \(String(describing: message)), overallPlacement: \(String(describing: overallPlacement)), tags: \(String(describing: tags)))"}
}

extension GetDeliverabilityTestReportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDeliverabilityTestReportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deliverabilityTestReport = output.deliverabilityTestReport
            self.ispPlacements = output.ispPlacements
            self.message = output.message
            self.overallPlacement = output.overallPlacement
            self.tags = output.tags
        } else {
            self.deliverabilityTestReport = nil
            self.ispPlacements = nil
            self.message = nil
            self.overallPlacement = nil
            self.tags = nil
        }
    }
}

/// <p>The results of the predictive inbox placement test.</p>
public struct GetDeliverabilityTestReportOutputResponse: Equatable {
    /// <p>An object that contains the results of the predictive inbox placement test.</p>
    public let deliverabilityTestReport: DeliverabilityTestReport?
    /// <p>An object that describes how the test email was handled by several email providers,
    ///             including Gmail, Hotmail, Yahoo, AOL, and others.</p>
    public let ispPlacements: [IspPlacement]?
    /// <p>An object that contains the message that you sent when you performed this
    ///             predictive inbox placement test.</p>
    public let message: String?
    /// <p>An object that specifies how many test messages that were sent during the predictive inbox placement test were
    ///             delivered to recipients' inboxes, how many were sent to recipients' spam folders, and
    ///             how many weren't delivered.</p>
    public let overallPlacement: PlacementStatistics?
    /// <p>An array of objects that define the tags (keys and values) that are associated with
    ///             the predictive inbox placement test.</p>
    public let tags: [Tag]?

    public init (
        deliverabilityTestReport: DeliverabilityTestReport? = nil,
        ispPlacements: [IspPlacement]? = nil,
        message: String? = nil,
        overallPlacement: PlacementStatistics? = nil,
        tags: [Tag]? = nil
    )
    {
        self.deliverabilityTestReport = deliverabilityTestReport
        self.ispPlacements = ispPlacements
        self.message = message
        self.overallPlacement = overallPlacement
        self.tags = tags
    }
}

struct GetDeliverabilityTestReportOutputResponseBody: Equatable {
    public let deliverabilityTestReport: DeliverabilityTestReport?
    public let overallPlacement: PlacementStatistics?
    public let ispPlacements: [IspPlacement]?
    public let message: String?
    public let tags: [Tag]?
}

extension GetDeliverabilityTestReportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deliverabilityTestReport = "DeliverabilityTestReport"
        case ispPlacements = "IspPlacements"
        case message = "Message"
        case overallPlacement = "OverallPlacement"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliverabilityTestReportDecoded = try containerValues.decodeIfPresent(DeliverabilityTestReport.self, forKey: .deliverabilityTestReport)
        deliverabilityTestReport = deliverabilityTestReportDecoded
        let overallPlacementDecoded = try containerValues.decodeIfPresent(PlacementStatistics.self, forKey: .overallPlacement)
        overallPlacement = overallPlacementDecoded
        let ispPlacementsContainer = try containerValues.decodeIfPresent([IspPlacement?].self, forKey: .ispPlacements)
        var ispPlacementsDecoded0:[IspPlacement]? = nil
        if let ispPlacementsContainer = ispPlacementsContainer {
            ispPlacementsDecoded0 = [IspPlacement]()
            for structure0 in ispPlacementsContainer {
                if let structure0 = structure0 {
                    ispPlacementsDecoded0?.append(structure0)
                }
            }
        }
        ispPlacements = ispPlacementsDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetDomainDeliverabilityCampaignInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainDeliverabilityCampaignInput(campaignId: \(String(describing: campaignId)))"}
}

extension GetDomainDeliverabilityCampaignInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDomainDeliverabilityCampaignInputHeadersMiddleware: Middleware {
    public let id: String = "GetDomainDeliverabilityCampaignInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainDeliverabilityCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainDeliverabilityCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainDeliverabilityCampaignInput>
    public typealias MOutput = OperationOutput<GetDomainDeliverabilityCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainDeliverabilityCampaignOutputError>
}

public struct GetDomainDeliverabilityCampaignInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDomainDeliverabilityCampaignInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainDeliverabilityCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainDeliverabilityCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainDeliverabilityCampaignInput>
    public typealias MOutput = OperationOutput<GetDomainDeliverabilityCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainDeliverabilityCampaignOutputError>
}

/// <p>Retrieve all the deliverability data for a specific campaign. This data is available
///             for a campaign only if the campaign sent email by using a domain that the
///             Deliverability dashboard is enabled for (<code>PutDeliverabilityDashboardOption</code>
///             operation).</p>
public struct GetDomainDeliverabilityCampaignInput: Equatable {
    /// <p>The unique identifier for the campaign. The Deliverability dashboard automatically generates
    ///             and assigns this identifier to a campaign.</p>
    public let campaignId: String?

    public init (
        campaignId: String? = nil
    )
    {
        self.campaignId = campaignId
    }
}

struct GetDomainDeliverabilityCampaignInputBody: Equatable {
}

extension GetDomainDeliverabilityCampaignInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDomainDeliverabilityCampaignOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainDeliverabilityCampaignOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainDeliverabilityCampaignOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainDeliverabilityCampaignOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainDeliverabilityCampaignOutputResponse(domainDeliverabilityCampaign: \(String(describing: domainDeliverabilityCampaign)))"}
}

extension GetDomainDeliverabilityCampaignOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDomainDeliverabilityCampaignOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainDeliverabilityCampaign = output.domainDeliverabilityCampaign
        } else {
            self.domainDeliverabilityCampaign = nil
        }
    }
}

/// <p>An object that contains all the deliverability data for a specific campaign. This data
///             is available for a campaign only if the campaign sent email by using a domain that the
///             Deliverability dashboard is enabled for.</p>
public struct GetDomainDeliverabilityCampaignOutputResponse: Equatable {
    /// <p>An object that contains the deliverability data for the campaign.</p>
    public let domainDeliverabilityCampaign: DomainDeliverabilityCampaign?

    public init (
        domainDeliverabilityCampaign: DomainDeliverabilityCampaign? = nil
    )
    {
        self.domainDeliverabilityCampaign = domainDeliverabilityCampaign
    }
}

struct GetDomainDeliverabilityCampaignOutputResponseBody: Equatable {
    public let domainDeliverabilityCampaign: DomainDeliverabilityCampaign?
}

extension GetDomainDeliverabilityCampaignOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainDeliverabilityCampaign = "DomainDeliverabilityCampaign"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDeliverabilityCampaignDecoded = try containerValues.decodeIfPresent(DomainDeliverabilityCampaign.self, forKey: .domainDeliverabilityCampaign)
        domainDeliverabilityCampaign = domainDeliverabilityCampaignDecoded
    }
}

extension GetDomainStatisticsReportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainStatisticsReportInput(domain: \(String(describing: domain)), endDate: \(String(describing: endDate)), startDate: \(String(describing: startDate)))"}
}

extension GetDomainStatisticsReportInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDomainStatisticsReportInputHeadersMiddleware: Middleware {
    public let id: String = "GetDomainStatisticsReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainStatisticsReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainStatisticsReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainStatisticsReportInput>
    public typealias MOutput = OperationOutput<GetDomainStatisticsReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainStatisticsReportOutputError>
}

public struct GetDomainStatisticsReportInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDomainStatisticsReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainStatisticsReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainStatisticsReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let startDate = input.operationInput.startDate {
            let startDateQueryItem = URLQueryItem(name: "StartDate".urlPercentEncoding(), value: String(startDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startDateQueryItem)
        }
        if let endDate = input.operationInput.endDate {
            let endDateQueryItem = URLQueryItem(name: "EndDate".urlPercentEncoding(), value: String(endDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endDateQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainStatisticsReportInput>
    public typealias MOutput = OperationOutput<GetDomainStatisticsReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainStatisticsReportOutputError>
}

/// <p>A request to obtain deliverability metrics for a domain.</p>
public struct GetDomainStatisticsReportInput: Equatable {
    /// <p>The domain that you want to obtain deliverability metrics for.</p>
    public let domain: String?
    /// <p>The last day (in Unix time) that you want to obtain domain deliverability metrics for.
    ///             The <code>EndDate</code> that you specify has to be less than or equal to 30 days after
    ///             the <code>StartDate</code>.</p>
    public let endDate: Date?
    /// <p>The first day (in Unix time) that you want to obtain domain deliverability metrics
    ///             for.</p>
    public let startDate: Date?

    public init (
        domain: String? = nil,
        endDate: Date? = nil,
        startDate: Date? = nil
    )
    {
        self.domain = domain
        self.endDate = endDate
        self.startDate = startDate
    }
}

struct GetDomainStatisticsReportInputBody: Equatable {
}

extension GetDomainStatisticsReportInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDomainStatisticsReportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainStatisticsReportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainStatisticsReportOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainStatisticsReportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainStatisticsReportOutputResponse(dailyVolumes: \(String(describing: dailyVolumes)), overallVolume: \(String(describing: overallVolume)))"}
}

extension GetDomainStatisticsReportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDomainStatisticsReportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dailyVolumes = output.dailyVolumes
            self.overallVolume = output.overallVolume
        } else {
            self.dailyVolumes = nil
            self.overallVolume = nil
        }
    }
}

/// <p>An object that includes statistics that are related to the domain that you
///             specified.</p>
public struct GetDomainStatisticsReportOutputResponse: Equatable {
    /// <p>An object that contains deliverability metrics for the domain that you specified. This
    ///             object contains data for each day, starting on the <code>StartDate</code> and ending on
    ///             the <code>EndDate</code>.</p>
    public let dailyVolumes: [DailyVolume]?
    /// <p>An object that contains deliverability metrics for the domain that you specified. The
    ///             data in this object is a summary of all of the data that was collected from the
    ///                 <code>StartDate</code> to the <code>EndDate</code>.</p>
    public let overallVolume: OverallVolume?

    public init (
        dailyVolumes: [DailyVolume]? = nil,
        overallVolume: OverallVolume? = nil
    )
    {
        self.dailyVolumes = dailyVolumes
        self.overallVolume = overallVolume
    }
}

struct GetDomainStatisticsReportOutputResponseBody: Equatable {
    public let overallVolume: OverallVolume?
    public let dailyVolumes: [DailyVolume]?
}

extension GetDomainStatisticsReportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dailyVolumes = "DailyVolumes"
        case overallVolume = "OverallVolume"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overallVolumeDecoded = try containerValues.decodeIfPresent(OverallVolume.self, forKey: .overallVolume)
        overallVolume = overallVolumeDecoded
        let dailyVolumesContainer = try containerValues.decodeIfPresent([DailyVolume?].self, forKey: .dailyVolumes)
        var dailyVolumesDecoded0:[DailyVolume]? = nil
        if let dailyVolumesContainer = dailyVolumesContainer {
            dailyVolumesDecoded0 = [DailyVolume]()
            for structure0 in dailyVolumesContainer {
                if let structure0 = structure0 {
                    dailyVolumesDecoded0?.append(structure0)
                }
            }
        }
        dailyVolumes = dailyVolumesDecoded0
    }
}

extension GetEmailIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEmailIdentityInput(emailIdentity: \(String(describing: emailIdentity)))"}
}

extension GetEmailIdentityInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEmailIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "GetEmailIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEmailIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEmailIdentityInput>
    public typealias MOutput = OperationOutput<GetEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEmailIdentityOutputError>
}

public struct GetEmailIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEmailIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEmailIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEmailIdentityInput>
    public typealias MOutput = OperationOutput<GetEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEmailIdentityOutputError>
}

/// <p>A request to return details about an email identity.</p>
public struct GetEmailIdentityInput: Equatable {
    /// <p>The email identity that you want to retrieve details for.</p>
    public let emailIdentity: String?

    public init (
        emailIdentity: String? = nil
    )
    {
        self.emailIdentity = emailIdentity
    }
}

struct GetEmailIdentityInputBody: Equatable {
}

extension GetEmailIdentityInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEmailIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEmailIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEmailIdentityOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEmailIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEmailIdentityOutputResponse(configurationSetName: \(String(describing: configurationSetName)), dkimAttributes: \(String(describing: dkimAttributes)), feedbackForwardingStatus: \(String(describing: feedbackForwardingStatus)), identityType: \(String(describing: identityType)), mailFromAttributes: \(String(describing: mailFromAttributes)), policies: \(String(describing: policies)), tags: \(String(describing: tags)), verifiedForSendingStatus: \(String(describing: verifiedForSendingStatus)))"}
}

extension GetEmailIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEmailIdentityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationSetName = output.configurationSetName
            self.dkimAttributes = output.dkimAttributes
            self.feedbackForwardingStatus = output.feedbackForwardingStatus
            self.identityType = output.identityType
            self.mailFromAttributes = output.mailFromAttributes
            self.policies = output.policies
            self.tags = output.tags
            self.verifiedForSendingStatus = output.verifiedForSendingStatus
        } else {
            self.configurationSetName = nil
            self.dkimAttributes = nil
            self.feedbackForwardingStatus = false
            self.identityType = nil
            self.mailFromAttributes = nil
            self.policies = nil
            self.tags = nil
            self.verifiedForSendingStatus = false
        }
    }
}

/// <p>Details about an email identity.</p>
public struct GetEmailIdentityOutputResponse: Equatable {
    /// <p>The configuration set used by default when sending from this identity.</p>
    public let configurationSetName: String?
    /// <p>An object that contains information about the DKIM attributes for the identity.</p>
    public let dkimAttributes: DkimAttributes?
    /// <p>The feedback forwarding configuration for the identity.</p>
    ///         <p>If the value is <code>true</code>, you receive email notifications when bounce or
    ///             complaint events occur. These notifications are sent to the address that you specified
    ///             in the <code>Return-Path</code> header of the original email.</p>
    ///         <p>You're required to have a method of tracking bounces and complaints. If you haven't
    ///             set up another mechanism for receiving bounce or complaint notifications (for example,
    ///             by setting up an event destination), you receive an email notification when these events
    ///             occur (even if this setting is disabled).</p>
    public let feedbackForwardingStatus: Bool
    /// <p>The email identity type.</p>
    public let identityType: IdentityType?
    /// <p>An object that contains information about the Mail-From attributes for the email
    ///             identity.</p>
    public let mailFromAttributes: MailFromAttributes?
    /// <p>A map of policy names to policies.</p>
    public let policies: [String:String]?
    /// <p>An array of objects that define the tags (keys and values) that are associated with
    ///             the email identity.</p>
    public let tags: [Tag]?
    /// <p>Specifies whether or not the identity is verified. You can only send email from
    ///             verified email addresses or domains. For more information about verifying identities,
    ///             see the <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-email-manage-verify.html">Amazon Pinpoint User Guide</a>.</p>
    public let verifiedForSendingStatus: Bool

    public init (
        configurationSetName: String? = nil,
        dkimAttributes: DkimAttributes? = nil,
        feedbackForwardingStatus: Bool = false,
        identityType: IdentityType? = nil,
        mailFromAttributes: MailFromAttributes? = nil,
        policies: [String:String]? = nil,
        tags: [Tag]? = nil,
        verifiedForSendingStatus: Bool = false
    )
    {
        self.configurationSetName = configurationSetName
        self.dkimAttributes = dkimAttributes
        self.feedbackForwardingStatus = feedbackForwardingStatus
        self.identityType = identityType
        self.mailFromAttributes = mailFromAttributes
        self.policies = policies
        self.tags = tags
        self.verifiedForSendingStatus = verifiedForSendingStatus
    }
}

struct GetEmailIdentityOutputResponseBody: Equatable {
    public let identityType: IdentityType?
    public let feedbackForwardingStatus: Bool
    public let verifiedForSendingStatus: Bool
    public let dkimAttributes: DkimAttributes?
    public let mailFromAttributes: MailFromAttributes?
    public let policies: [String:String]?
    public let tags: [Tag]?
    public let configurationSetName: String?
}

extension GetEmailIdentityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case dkimAttributes = "DkimAttributes"
        case feedbackForwardingStatus = "FeedbackForwardingStatus"
        case identityType = "IdentityType"
        case mailFromAttributes = "MailFromAttributes"
        case policies = "Policies"
        case tags = "Tags"
        case verifiedForSendingStatus = "VerifiedForSendingStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityTypeDecoded = try containerValues.decodeIfPresent(IdentityType.self, forKey: .identityType)
        identityType = identityTypeDecoded
        let feedbackForwardingStatusDecoded = try containerValues.decode(Bool.self, forKey: .feedbackForwardingStatus)
        feedbackForwardingStatus = feedbackForwardingStatusDecoded
        let verifiedForSendingStatusDecoded = try containerValues.decode(Bool.self, forKey: .verifiedForSendingStatus)
        verifiedForSendingStatus = verifiedForSendingStatusDecoded
        let dkimAttributesDecoded = try containerValues.decodeIfPresent(DkimAttributes.self, forKey: .dkimAttributes)
        dkimAttributes = dkimAttributesDecoded
        let mailFromAttributesDecoded = try containerValues.decodeIfPresent(MailFromAttributes.self, forKey: .mailFromAttributes)
        mailFromAttributes = mailFromAttributesDecoded
        let policiesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .policies)
        var policiesDecoded0: [String:String]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [String:String]()
            for (key0, policy0) in policiesContainer {
                if let policy0 = policy0 {
                    policiesDecoded0?[key0] = policy0
                }
            }
        }
        policies = policiesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
    }
}

extension GetEmailIdentityPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEmailIdentityPoliciesInput(emailIdentity: \(String(describing: emailIdentity)))"}
}

extension GetEmailIdentityPoliciesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEmailIdentityPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "GetEmailIdentityPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEmailIdentityPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEmailIdentityPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEmailIdentityPoliciesInput>
    public typealias MOutput = OperationOutput<GetEmailIdentityPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEmailIdentityPoliciesOutputError>
}

public struct GetEmailIdentityPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEmailIdentityPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEmailIdentityPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEmailIdentityPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEmailIdentityPoliciesInput>
    public typealias MOutput = OperationOutput<GetEmailIdentityPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEmailIdentityPoliciesOutputError>
}

/// <p>A request to return the policies of an email identity.</p>
public struct GetEmailIdentityPoliciesInput: Equatable {
    /// <p>The email identity that you want to retrieve policies for.</p>
    public let emailIdentity: String?

    public init (
        emailIdentity: String? = nil
    )
    {
        self.emailIdentity = emailIdentity
    }
}

struct GetEmailIdentityPoliciesInputBody: Equatable {
}

extension GetEmailIdentityPoliciesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEmailIdentityPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEmailIdentityPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEmailIdentityPoliciesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEmailIdentityPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEmailIdentityPoliciesOutputResponse(policies: \(String(describing: policies)))"}
}

extension GetEmailIdentityPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEmailIdentityPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policies = output.policies
        } else {
            self.policies = nil
        }
    }
}

/// <p>Identity policies associated with email identity.</p>
public struct GetEmailIdentityPoliciesOutputResponse: Equatable {
    /// <p>A map of policy names to policies.</p>
    public let policies: [String:String]?

    public init (
        policies: [String:String]? = nil
    )
    {
        self.policies = policies
    }
}

struct GetEmailIdentityPoliciesOutputResponseBody: Equatable {
    public let policies: [String:String]?
}

extension GetEmailIdentityPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policies = "Policies"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .policies)
        var policiesDecoded0: [String:String]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [String:String]()
            for (key0, policy0) in policiesContainer {
                if let policy0 = policy0 {
                    policiesDecoded0?[key0] = policy0
                }
            }
        }
        policies = policiesDecoded0
    }
}

extension GetEmailTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEmailTemplateInput(templateName: \(String(describing: templateName)))"}
}

extension GetEmailTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEmailTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GetEmailTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEmailTemplateInput>
    public typealias MOutput = OperationOutput<GetEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEmailTemplateOutputError>
}

public struct GetEmailTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEmailTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEmailTemplateInput>
    public typealias MOutput = OperationOutput<GetEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEmailTemplateOutputError>
}

/// <p>Represents a request to display the template object (which includes the subject line,
///             HTML part and text part) for the template you specify.</p>
public struct GetEmailTemplateInput: Equatable {
    /// <p>The name of the template you want to retrieve.</p>
    public let templateName: String?

    public init (
        templateName: String? = nil
    )
    {
        self.templateName = templateName
    }
}

struct GetEmailTemplateInputBody: Equatable {
}

extension GetEmailTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEmailTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEmailTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEmailTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEmailTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEmailTemplateOutputResponse(templateContent: \(String(describing: templateContent)), templateName: \(String(describing: templateName)))"}
}

extension GetEmailTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEmailTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.templateContent = output.templateContent
            self.templateName = output.templateName
        } else {
            self.templateContent = nil
            self.templateName = nil
        }
    }
}

/// <p>The following element is returned by the service.</p>
public struct GetEmailTemplateOutputResponse: Equatable {
    /// <p>The content of the email template, composed of a subject line, an HTML part, and a
    ///             text-only part.</p>
    public let templateContent: EmailTemplateContent?
    /// <p>The name of the template you want to retrieve.</p>
    public let templateName: String?

    public init (
        templateContent: EmailTemplateContent? = nil,
        templateName: String? = nil
    )
    {
        self.templateContent = templateContent
        self.templateName = templateName
    }
}

struct GetEmailTemplateOutputResponseBody: Equatable {
    public let templateName: String?
    public let templateContent: EmailTemplateContent?
}

extension GetEmailTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case templateContent = "TemplateContent"
        case templateName = "TemplateName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateContentDecoded = try containerValues.decodeIfPresent(EmailTemplateContent.self, forKey: .templateContent)
        templateContent = templateContentDecoded
    }
}

extension GetImportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetImportJobInput(jobId: \(String(describing: jobId)))"}
}

extension GetImportJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetImportJobInputHeadersMiddleware: Middleware {
    public let id: String = "GetImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetImportJobInput>
    public typealias MOutput = OperationOutput<GetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetImportJobOutputError>
}

public struct GetImportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "GetImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetImportJobInput>
    public typealias MOutput = OperationOutput<GetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetImportJobOutputError>
}

/// <p>Represents a request for information about an import job using the import job
///             ID.</p>
public struct GetImportJobInput: Equatable {
    /// <p>The ID of the import job.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetImportJobInputBody: Equatable {
}

extension GetImportJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetImportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetImportJobOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetImportJobOutputResponse(completedTimestamp: \(String(describing: completedTimestamp)), createdTimestamp: \(String(describing: createdTimestamp)), failedRecordsCount: \(String(describing: failedRecordsCount)), failureInfo: \(String(describing: failureInfo)), importDataSource: \(String(describing: importDataSource)), importDestination: \(String(describing: importDestination)), jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)), processedRecordsCount: \(String(describing: processedRecordsCount)))"}
}

extension GetImportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetImportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.completedTimestamp = output.completedTimestamp
            self.createdTimestamp = output.createdTimestamp
            self.failedRecordsCount = output.failedRecordsCount
            self.failureInfo = output.failureInfo
            self.importDataSource = output.importDataSource
            self.importDestination = output.importDestination
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
            self.processedRecordsCount = output.processedRecordsCount
        } else {
            self.completedTimestamp = nil
            self.createdTimestamp = nil
            self.failedRecordsCount = nil
            self.failureInfo = nil
            self.importDataSource = nil
            self.importDestination = nil
            self.jobId = nil
            self.jobStatus = nil
            self.processedRecordsCount = nil
        }
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct GetImportJobOutputResponse: Equatable {
    /// <p>The time stamp of when the import job was completed.</p>
    public let completedTimestamp: Date?
    /// <p>The time stamp of when the import job was created.</p>
    public let createdTimestamp: Date?
    /// <p>The number of records that failed processing because of invalid input or other
    ///             reasons.</p>
    public let failedRecordsCount: Int?
    /// <p>The failure details about an import job.</p>
    public let failureInfo: FailureInfo?
    /// <p>The data source of the import job.</p>
    public let importDataSource: ImportDataSource?
    /// <p>The destination of the import job.</p>
    public let importDestination: ImportDestination?
    /// <p>A string that represents the import job ID.</p>
    public let jobId: String?
    /// <p>The status of the import job.</p>
    public let jobStatus: JobStatus?
    /// <p>The current number of records processed.</p>
    public let processedRecordsCount: Int?

    public init (
        completedTimestamp: Date? = nil,
        createdTimestamp: Date? = nil,
        failedRecordsCount: Int? = nil,
        failureInfo: FailureInfo? = nil,
        importDataSource: ImportDataSource? = nil,
        importDestination: ImportDestination? = nil,
        jobId: String? = nil,
        jobStatus: JobStatus? = nil,
        processedRecordsCount: Int? = nil
    )
    {
        self.completedTimestamp = completedTimestamp
        self.createdTimestamp = createdTimestamp
        self.failedRecordsCount = failedRecordsCount
        self.failureInfo = failureInfo
        self.importDataSource = importDataSource
        self.importDestination = importDestination
        self.jobId = jobId
        self.jobStatus = jobStatus
        self.processedRecordsCount = processedRecordsCount
    }
}

struct GetImportJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let importDestination: ImportDestination?
    public let importDataSource: ImportDataSource?
    public let failureInfo: FailureInfo?
    public let jobStatus: JobStatus?
    public let createdTimestamp: Date?
    public let completedTimestamp: Date?
    public let processedRecordsCount: Int?
    public let failedRecordsCount: Int?
}

extension GetImportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case completedTimestamp = "CompletedTimestamp"
        case createdTimestamp = "CreatedTimestamp"
        case failedRecordsCount = "FailedRecordsCount"
        case failureInfo = "FailureInfo"
        case importDataSource = "ImportDataSource"
        case importDestination = "ImportDestination"
        case jobId = "JobId"
        case jobStatus = "JobStatus"
        case processedRecordsCount = "ProcessedRecordsCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let importDestinationDecoded = try containerValues.decodeIfPresent(ImportDestination.self, forKey: .importDestination)
        importDestination = importDestinationDecoded
        let importDataSourceDecoded = try containerValues.decodeIfPresent(ImportDataSource.self, forKey: .importDataSource)
        importDataSource = importDataSourceDecoded
        let failureInfoDecoded = try containerValues.decodeIfPresent(FailureInfo.self, forKey: .failureInfo)
        failureInfo = failureInfoDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let completedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedTimestamp)
        completedTimestamp = completedTimestampDecoded
        let processedRecordsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .processedRecordsCount)
        processedRecordsCount = processedRecordsCountDecoded
        let failedRecordsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .failedRecordsCount)
        failedRecordsCount = failedRecordsCountDecoded
    }
}

extension GetSuppressedDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSuppressedDestinationInput(emailAddress: \(String(describing: emailAddress)))"}
}

extension GetSuppressedDestinationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSuppressedDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "GetSuppressedDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSuppressedDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSuppressedDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSuppressedDestinationInput>
    public typealias MOutput = OperationOutput<GetSuppressedDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSuppressedDestinationOutputError>
}

public struct GetSuppressedDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSuppressedDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSuppressedDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSuppressedDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSuppressedDestinationInput>
    public typealias MOutput = OperationOutput<GetSuppressedDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSuppressedDestinationOutputError>
}

/// <p>A request to retrieve information about an email address that's on the suppression
///             list for your account.</p>
public struct GetSuppressedDestinationInput: Equatable {
    /// <p>The email address that's on the account suppression list.</p>
    public let emailAddress: String?

    public init (
        emailAddress: String? = nil
    )
    {
        self.emailAddress = emailAddress
    }
}

struct GetSuppressedDestinationInputBody: Equatable {
}

extension GetSuppressedDestinationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSuppressedDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSuppressedDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSuppressedDestinationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSuppressedDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSuppressedDestinationOutputResponse(suppressedDestination: \(String(describing: suppressedDestination)))"}
}

extension GetSuppressedDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSuppressedDestinationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.suppressedDestination = output.suppressedDestination
        } else {
            self.suppressedDestination = nil
        }
    }
}

/// <p>Information about the suppressed email address.</p>
public struct GetSuppressedDestinationOutputResponse: Equatable {
    /// <p>An object containing information about the suppressed email address.</p>
    public let suppressedDestination: SuppressedDestination?

    public init (
        suppressedDestination: SuppressedDestination? = nil
    )
    {
        self.suppressedDestination = suppressedDestination
    }
}

struct GetSuppressedDestinationOutputResponseBody: Equatable {
    public let suppressedDestination: SuppressedDestination?
}

extension GetSuppressedDestinationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case suppressedDestination = "SuppressedDestination"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suppressedDestinationDecoded = try containerValues.decodeIfPresent(SuppressedDestination.self, forKey: .suppressedDestination)
        suppressedDestination = suppressedDestinationDecoded
    }
}

extension IdentityInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityName = "IdentityName"
        case identityType = "IdentityType"
        case sendingEnabled = "SendingEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityName = identityName {
            try encodeContainer.encode(identityName, forKey: .identityName)
        }
        if let identityType = identityType {
            try encodeContainer.encode(identityType.rawValue, forKey: .identityType)
        }
        if sendingEnabled != false {
            try encodeContainer.encode(sendingEnabled, forKey: .sendingEnabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityTypeDecoded = try containerValues.decodeIfPresent(IdentityType.self, forKey: .identityType)
        identityType = identityTypeDecoded
        let identityNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityName)
        identityName = identityNameDecoded
        let sendingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .sendingEnabled)
        sendingEnabled = sendingEnabledDecoded
    }
}

extension IdentityInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdentityInfo(identityName: \(String(describing: identityName)), identityType: \(String(describing: identityType)), sendingEnabled: \(String(describing: sendingEnabled)))"}
}

/// <p>Information about an email identity.</p>
public struct IdentityInfo: Equatable {
    /// <p>The address or domain of the identity.</p>
    public let identityName: String?
    /// <p>The email identity type. The identity type can be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>EMAIL_ADDRESS</code> – The identity is an email address.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DOMAIN</code> – The identity is a domain.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>MANAGED_DOMAIN</code> – The identity is a domain that is managed
    ///                     by AWS.</p>
    ///             </li>
    ///          </ul>
    public let identityType: IdentityType?
    /// <p>Indicates whether or not you can send email from the identity.</p>
    ///         <p>An <i>identity</i> is an email address or domain that you send email
    ///             from. Before you can send email from an identity, you have to demostrate that you own
    ///             the identity, and that you authorize Amazon SES to send email from that identity.</p>
    public let sendingEnabled: Bool

    public init (
        identityName: String? = nil,
        identityType: IdentityType? = nil,
        sendingEnabled: Bool = false
    )
    {
        self.identityName = identityName
        self.identityType = identityType
        self.sendingEnabled = sendingEnabled
    }
}

/// <p>The email identity type. The identity type can be one of the following:</p>
///         <ul>
///             <li>
///                 <p>
///                   <code>EMAIL_ADDRESS</code> – The identity is an email address.</p>
///             </li>
///             <li>
///                 <p>
///                   <code>DOMAIN</code> – The identity is a domain.</p>
///             </li>
///          </ul>
public enum IdentityType {
    case domain
    case emailAddress
    case managedDomain
    case sdkUnknown(String)
}

extension IdentityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IdentityType] {
        return [
            .domain,
            .emailAddress,
            .managedDomain,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .domain: return "DOMAIN"
        case .emailAddress: return "EMAIL_ADDRESS"
        case .managedDomain: return "MANAGED_DOMAIN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IdentityType(rawValue: rawValue) ?? IdentityType.sdkUnknown(rawValue)
    }
}

extension ImportDataSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataFormat = "DataFormat"
        case s3Url = "S3Url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataFormat = dataFormat {
            try encodeContainer.encode(dataFormat.rawValue, forKey: .dataFormat)
        }
        if let s3Url = s3Url {
            try encodeContainer.encode(s3Url, forKey: .s3Url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Url)
        s3Url = s3UrlDecoded
        let dataFormatDecoded = try containerValues.decodeIfPresent(DataFormat.self, forKey: .dataFormat)
        dataFormat = dataFormatDecoded
    }
}

extension ImportDataSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportDataSource(dataFormat: \(String(describing: dataFormat)), s3Url: \(String(describing: s3Url)))"}
}

/// <p>An object that contains details about the data source of the import job.</p>
public struct ImportDataSource: Equatable {
    /// <p>The data format of the import job's data source.</p>
    public let dataFormat: DataFormat?
    /// <p>An Amazon S3 URL in the format
    ///                 s3://<i><bucket_name></i>/<i><object></i>.</p>
    public let s3Url: String?

    public init (
        dataFormat: DataFormat? = nil,
        s3Url: String? = nil
    )
    {
        self.dataFormat = dataFormat
        self.s3Url = s3Url
    }
}

extension ImportDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactListDestination = "ContactListDestination"
        case suppressionListDestination = "SuppressionListDestination"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactListDestination = contactListDestination {
            try encodeContainer.encode(contactListDestination, forKey: .contactListDestination)
        }
        if let suppressionListDestination = suppressionListDestination {
            try encodeContainer.encode(suppressionListDestination, forKey: .suppressionListDestination)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suppressionListDestinationDecoded = try containerValues.decodeIfPresent(SuppressionListDestination.self, forKey: .suppressionListDestination)
        suppressionListDestination = suppressionListDestinationDecoded
        let contactListDestinationDecoded = try containerValues.decodeIfPresent(ContactListDestination.self, forKey: .contactListDestination)
        contactListDestination = contactListDestinationDecoded
    }
}

extension ImportDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportDestination(contactListDestination: \(String(describing: contactListDestination)), suppressionListDestination: \(String(describing: suppressionListDestination)))"}
}

/// <p>An object that contains details about the resource destination the import job is going
///             to target.</p>
public struct ImportDestination: Equatable {
    /// <p>An object that contains the action of the import job towards a contact list.</p>
    public let contactListDestination: ContactListDestination?
    /// <p>An object that contains the action of the import job towards suppression list.</p>
    public let suppressionListDestination: SuppressionListDestination?

    public init (
        contactListDestination: ContactListDestination? = nil,
        suppressionListDestination: SuppressionListDestination? = nil
    )
    {
        self.contactListDestination = contactListDestination
        self.suppressionListDestination = suppressionListDestination
    }
}

/// <p>The destination of the import job, which can be used to list import jobs that have a
///             certain <code>ImportDestinationType</code>.</p>
public enum ImportDestinationType {
    case contactList
    case suppressionList
    case sdkUnknown(String)
}

extension ImportDestinationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImportDestinationType] {
        return [
            .contactList,
            .suppressionList,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .contactList: return "CONTACT_LIST"
        case .suppressionList: return "SUPPRESSION_LIST"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImportDestinationType(rawValue: rawValue) ?? ImportDestinationType.sdkUnknown(rawValue)
    }
}

extension ImportJobSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case importDestination = "ImportDestination"
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let importDestination = importDestination {
            try encodeContainer.encode(importDestination, forKey: .importDestination)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let importDestinationDecoded = try containerValues.decodeIfPresent(ImportDestination.self, forKey: .importDestination)
        importDestination = importDestinationDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension ImportJobSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportJobSummary(createdTimestamp: \(String(describing: createdTimestamp)), importDestination: \(String(describing: importDestination)), jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

/// <p>A summary of the import job.</p>
public struct ImportJobSummary: Equatable {
    /// <p>The date and time when the import job was created.</p>
    public let createdTimestamp: Date?
    /// <p>An object that contains details about the resource destination the import job is going
    ///             to target.</p>
    public let importDestination: ImportDestination?
    /// <p>A string that represents the import job ID.</p>
    public let jobId: String?
    /// <p>The status of the import job.</p>
    public let jobStatus: JobStatus?

    public init (
        createdTimestamp: Date? = nil,
        importDestination: ImportDestination? = nil,
        jobId: String? = nil,
        jobStatus: JobStatus? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.importDestination = importDestination
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

extension InboxPlacementTrackingOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case global = "Global"
        case trackedIsps = "TrackedIsps"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if global != false {
            try encodeContainer.encode(global, forKey: .global)
        }
        if let trackedIsps = trackedIsps {
            var trackedIspsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trackedIsps)
            for ispnamelist0 in trackedIsps {
                try trackedIspsContainer.encode(ispnamelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalDecoded = try containerValues.decode(Bool.self, forKey: .global)
        global = globalDecoded
        let trackedIspsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .trackedIsps)
        var trackedIspsDecoded0:[String]? = nil
        if let trackedIspsContainer = trackedIspsContainer {
            trackedIspsDecoded0 = [String]()
            for string0 in trackedIspsContainer {
                if let string0 = string0 {
                    trackedIspsDecoded0?.append(string0)
                }
            }
        }
        trackedIsps = trackedIspsDecoded0
    }
}

extension InboxPlacementTrackingOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InboxPlacementTrackingOption(global: \(String(describing: global)), trackedIsps: \(String(describing: trackedIsps)))"}
}

/// <p>An object that contains information about the inbox placement data settings for a
///             verified domain that’s associated with your AWS account. This data is available only
///             if you enabled the Deliverability dashboard for the domain.</p>
public struct InboxPlacementTrackingOption: Equatable {
    /// <p>Specifies whether inbox placement data is being tracked for the domain.</p>
    public let global: Bool
    /// <p>An array of strings, one for each major email provider that the inbox placement data
    ///             applies to.</p>
    public let trackedIsps: [String]?

    public init (
        global: Bool = false,
        trackedIsps: [String]? = nil
    )
    {
        self.global = global
        self.trackedIsps = trackedIsps
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified request includes an invalid or expired token.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IspPlacement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ispName = "IspName"
        case placementStatistics = "PlacementStatistics"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ispName = ispName {
            try encodeContainer.encode(ispName, forKey: .ispName)
        }
        if let placementStatistics = placementStatistics {
            try encodeContainer.encode(placementStatistics, forKey: .placementStatistics)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ispNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ispName)
        ispName = ispNameDecoded
        let placementStatisticsDecoded = try containerValues.decodeIfPresent(PlacementStatistics.self, forKey: .placementStatistics)
        placementStatistics = placementStatisticsDecoded
    }
}

extension IspPlacement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IspPlacement(ispName: \(String(describing: ispName)), placementStatistics: \(String(describing: placementStatistics)))"}
}

/// <p>An object that describes how email sent during the predictive inbox placement test was handled by a certain
///             email provider.</p>
public struct IspPlacement: Equatable {
    /// <p>The name of the email provider that the inbox placement data applies to.</p>
    public let ispName: String?
    /// <p>An object that contains inbox placement metrics for a specific email provider.</p>
    public let placementStatistics: PlacementStatistics?

    public init (
        ispName: String? = nil,
        placementStatistics: PlacementStatistics? = nil
    )
    {
        self.ispName = ispName
        self.placementStatistics = placementStatistics
    }
}

/// <p>The status of the import job.</p>
public enum JobStatus {
    case completed
    case created
    case failed
    case processing
    case sdkUnknown(String)
}

extension JobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobStatus] {
        return [
            .completed,
            .created,
            .failed,
            .processing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .created: return "CREATED"
        case .failed: return "FAILED"
        case .processing: return "PROCESSING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
    }
}

extension KinesisFirehoseDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deliveryStreamArn = "DeliveryStreamArn"
        case iamRoleArn = "IamRoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryStreamArn = deliveryStreamArn {
            try encodeContainer.encode(deliveryStreamArn, forKey: .deliveryStreamArn)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let deliveryStreamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deliveryStreamArn)
        deliveryStreamArn = deliveryStreamArnDecoded
    }
}

extension KinesisFirehoseDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisFirehoseDestination(deliveryStreamArn: \(String(describing: deliveryStreamArn)), iamRoleArn: \(String(describing: iamRoleArn)))"}
}

/// <p>An object that defines an Amazon Kinesis Data Firehose destination for email events. You can use Amazon Kinesis Data Firehose to
///             stream data to other services, such as Amazon S3 and Amazon Redshift.</p>
public struct KinesisFirehoseDestination: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon Kinesis Data Firehose stream that the Amazon SES API v2 sends email
    ///             events to.</p>
    public let deliveryStreamArn: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role that the Amazon SES API v2 uses to send email
    ///             events to the Amazon Kinesis Data Firehose stream.</p>
    public let iamRoleArn: String?

    public init (
        deliveryStreamArn: String? = nil,
        iamRoleArn: String? = nil
    )
    {
        self.deliveryStreamArn = deliveryStreamArn
        self.iamRoleArn = iamRoleArn
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There are too many instances of the specified resource type.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListConfigurationSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationSetsInput(nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)))"}
}

extension ListConfigurationSetsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListConfigurationSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListConfigurationSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationSetsInput>
    public typealias MOutput = OperationOutput<ListConfigurationSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationSetsOutputError>
}

public struct ListConfigurationSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListConfigurationSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "PageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationSetsInput>
    public typealias MOutput = OperationOutput<ListConfigurationSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationSetsOutputError>
}

/// <p>A request to obtain a list of configuration sets for your Amazon SES account in the current
///             AWS Region.</p>
public struct ListConfigurationSetsInput: Equatable {
    /// <p>A token returned from a previous call to <code>ListConfigurationSets</code> to
    ///             indicate the position in the list of configuration sets.</p>
    public let nextToken: String?
    /// <p>The number of results to show in a single call to <code>ListConfigurationSets</code>.
    ///             If the number of results is larger than the number you specified in this parameter, then
    ///             the response includes a <code>NextToken</code> element, which you can use to obtain
    ///             additional results.</p>
    public let pageSize: Int?

    public init (
        nextToken: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListConfigurationSetsInputBody: Equatable {
}

extension ListConfigurationSetsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListConfigurationSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationSetsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationSetsOutputResponse(configurationSets: \(String(describing: configurationSets)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConfigurationSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListConfigurationSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationSets = output.configurationSets
            self.nextToken = output.nextToken
        } else {
            self.configurationSets = nil
            self.nextToken = nil
        }
    }
}

/// <p>A list of configuration sets in your Amazon SES account in the current AWS Region.</p>
public struct ListConfigurationSetsOutputResponse: Equatable {
    /// <p>An array that contains all of the configuration sets in your Amazon SES account in the
    ///             current AWS Region.</p>
    public let configurationSets: [String]?
    /// <p>A token that indicates that there are additional configuration sets to list. To view
    ///             additional configuration sets, issue another request to
    ///                 <code>ListConfigurationSets</code>, and pass this token in the
    ///                 <code>NextToken</code> parameter.</p>
    public let nextToken: String?

    public init (
        configurationSets: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.configurationSets = configurationSets
        self.nextToken = nextToken
    }
}

struct ListConfigurationSetsOutputResponseBody: Equatable {
    public let configurationSets: [String]?
    public let nextToken: String?
}

extension ListConfigurationSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSets = "ConfigurationSets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .configurationSets)
        var configurationSetsDecoded0:[String]? = nil
        if let configurationSetsContainer = configurationSetsContainer {
            configurationSetsDecoded0 = [String]()
            for string0 in configurationSetsContainer {
                if let string0 = string0 {
                    configurationSetsDecoded0?.append(string0)
                }
            }
        }
        configurationSets = configurationSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListContactListsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListContactListsInput(nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)))"}
}

extension ListContactListsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListContactListsInputHeadersMiddleware: Middleware {
    public let id: String = "ListContactListsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContactListsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContactListsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContactListsInput>
    public typealias MOutput = OperationOutput<ListContactListsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContactListsOutputError>
}

public struct ListContactListsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListContactListsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContactListsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContactListsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "PageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContactListsInput>
    public typealias MOutput = OperationOutput<ListContactListsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContactListsOutputError>
}

public struct ListContactListsInput: Equatable {
    /// <p>A string token indicating that there might be additional contact lists available to be
    ///             listed. Use the token provided in the Response to use in the subsequent call to
    ///             ListContactLists with the same parameters to retrieve the next page of contact
    ///             lists.</p>
    public let nextToken: String?
    /// <p>Maximum number of contact lists to return at once. Use this parameter to paginate
    ///             results. If additional contact lists exist beyond the specified limit, the
    ///                 <code>NextToken</code> element is sent in the response. Use the
    ///                 <code>NextToken</code> value in subsequent requests to retrieve additional
    ///             lists.</p>
    public let pageSize: Int?

    public init (
        nextToken: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListContactListsInputBody: Equatable {
}

extension ListContactListsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListContactListsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContactListsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListContactListsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContactListsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListContactListsOutputResponse(contactLists: \(String(describing: contactLists)), nextToken: \(String(describing: nextToken)))"}
}

extension ListContactListsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListContactListsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contactLists = output.contactLists
            self.nextToken = output.nextToken
        } else {
            self.contactLists = nil
            self.nextToken = nil
        }
    }
}

public struct ListContactListsOutputResponse: Equatable {
    /// <p>The available contact lists.</p>
    public let contactLists: [ContactList]?
    /// <p>A string token indicating that there might be additional contact lists available to be
    ///             listed. Copy this token to a subsequent call to <code>ListContactLists</code> with the
    ///             same parameters to retrieve the next page of contact lists.</p>
    public let nextToken: String?

    public init (
        contactLists: [ContactList]? = nil,
        nextToken: String? = nil
    )
    {
        self.contactLists = contactLists
        self.nextToken = nextToken
    }
}

struct ListContactListsOutputResponseBody: Equatable {
    public let contactLists: [ContactList]?
    public let nextToken: String?
}

extension ListContactListsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactLists = "ContactLists"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactListsContainer = try containerValues.decodeIfPresent([ContactList?].self, forKey: .contactLists)
        var contactListsDecoded0:[ContactList]? = nil
        if let contactListsContainer = contactListsContainer {
            contactListsDecoded0 = [ContactList]()
            for structure0 in contactListsContainer {
                if let structure0 = structure0 {
                    contactListsDecoded0?.append(structure0)
                }
            }
        }
        contactLists = contactListsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListContactsFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filteredStatus = "FilteredStatus"
        case topicFilter = "TopicFilter"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filteredStatus = filteredStatus {
            try encodeContainer.encode(filteredStatus.rawValue, forKey: .filteredStatus)
        }
        if let topicFilter = topicFilter {
            try encodeContainer.encode(topicFilter, forKey: .topicFilter)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filteredStatusDecoded = try containerValues.decodeIfPresent(SubscriptionStatus.self, forKey: .filteredStatus)
        filteredStatus = filteredStatusDecoded
        let topicFilterDecoded = try containerValues.decodeIfPresent(TopicFilter.self, forKey: .topicFilter)
        topicFilter = topicFilterDecoded
    }
}

extension ListContactsFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListContactsFilter(filteredStatus: \(String(describing: filteredStatus)), topicFilter: \(String(describing: topicFilter)))"}
}

/// <p>A filter that can be applied to a list of contacts.</p>
public struct ListContactsFilter: Equatable {
    /// <p>The status by which you are filtering: <code>OPT_IN</code> or
    ///             <code>OPT_OUT</code>.</p>
    public let filteredStatus: SubscriptionStatus?
    /// <p>Used for filtering by a specific topic preference.</p>
    public let topicFilter: TopicFilter?

    public init (
        filteredStatus: SubscriptionStatus? = nil,
        topicFilter: TopicFilter? = nil
    )
    {
        self.filteredStatus = filteredStatus
        self.topicFilter = topicFilter
    }
}

public struct ListContactsInputBodyMiddleware: Middleware {
    public let id: String = "ListContactsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContactsInput>
    public typealias MOutput = OperationOutput<ListContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContactsOutputError>
}

extension ListContactsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListContactsInput(contactListName: \(String(describing: contactListName)), filter: \(String(describing: filter)), nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)))"}
}

extension ListContactsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }
}

public struct ListContactsInputHeadersMiddleware: Middleware {
    public let id: String = "ListContactsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContactsInput>
    public typealias MOutput = OperationOutput<ListContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContactsOutputError>
}

public struct ListContactsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListContactsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "PageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContactsInput>
    public typealias MOutput = OperationOutput<ListContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContactsOutputError>
}

public struct ListContactsInput: Equatable {
    /// <p>The name of the contact list.</p>
    public let contactListName: String?
    /// <p>A filter that can be applied to a list of contacts.</p>
    public let filter: ListContactsFilter?
    /// <p>A string token indicating that there might be additional contacts available to be
    ///             listed. Use the token provided in the Response to use in the subsequent call to
    ///             ListContacts with the same parameters to retrieve the next page of contacts.</p>
    public let nextToken: String?
    /// <p>The number of contacts that may be returned at once, which is dependent on if there
    ///             are more or less contacts than the value of the PageSize. Use this parameter to
    ///             paginate results. If additional contacts exist beyond the specified limit, the
    ///                 <code>NextToken</code> element is sent in the response. Use the
    ///                 <code>NextToken</code> value in subsequent requests to retrieve additional
    ///             contacts.</p>
    public let pageSize: Int?

    public init (
        contactListName: String? = nil,
        filter: ListContactsFilter? = nil,
        nextToken: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.contactListName = contactListName
        self.filter = filter
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListContactsInputBody: Equatable {
    public let filter: ListContactsFilter?
}

extension ListContactsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ListContactsFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListContactsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContactsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListContactsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContactsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListContactsOutputResponse(contacts: \(String(describing: contacts)), nextToken: \(String(describing: nextToken)))"}
}

extension ListContactsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListContactsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contacts = output.contacts
            self.nextToken = output.nextToken
        } else {
            self.contacts = nil
            self.nextToken = nil
        }
    }
}

public struct ListContactsOutputResponse: Equatable {
    /// <p>The contacts present in a specific contact list.</p>
    public let contacts: [Contact]?
    /// <p>A string token indicating that there might be additional contacts available to be
    ///             listed. Copy this token to a subsequent call to <code>ListContacts</code> with the same
    ///             parameters to retrieve the next page of contacts.</p>
    public let nextToken: String?

    public init (
        contacts: [Contact]? = nil,
        nextToken: String? = nil
    )
    {
        self.contacts = contacts
        self.nextToken = nextToken
    }
}

struct ListContactsOutputResponseBody: Equatable {
    public let contacts: [Contact]?
    public let nextToken: String?
}

extension ListContactsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contacts = "Contacts"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactsContainer = try containerValues.decodeIfPresent([Contact?].self, forKey: .contacts)
        var contactsDecoded0:[Contact]? = nil
        if let contactsContainer = contactsContainer {
            contactsDecoded0 = [Contact]()
            for structure0 in contactsContainer {
                if let structure0 = structure0 {
                    contactsDecoded0?.append(structure0)
                }
            }
        }
        contacts = contactsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomVerificationEmailTemplatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCustomVerificationEmailTemplatesInput(nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)))"}
}

extension ListCustomVerificationEmailTemplatesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListCustomVerificationEmailTemplatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListCustomVerificationEmailTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomVerificationEmailTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomVerificationEmailTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomVerificationEmailTemplatesInput>
    public typealias MOutput = OperationOutput<ListCustomVerificationEmailTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomVerificationEmailTemplatesOutputError>
}

public struct ListCustomVerificationEmailTemplatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCustomVerificationEmailTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomVerificationEmailTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomVerificationEmailTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "PageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomVerificationEmailTemplatesInput>
    public typealias MOutput = OperationOutput<ListCustomVerificationEmailTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomVerificationEmailTemplatesOutputError>
}

/// <p>Represents a request to list the existing custom verification email templates for your
///             account.</p>
public struct ListCustomVerificationEmailTemplatesInput: Equatable {
    /// <p>A token returned from a previous call to
    ///                 <code>ListCustomVerificationEmailTemplates</code> to indicate the position in the
    ///             list of custom verification email templates.</p>
    public let nextToken: String?
    /// <p>The number of results to show in a single call to
    ///                 <code>ListCustomVerificationEmailTemplates</code>. If the number of results is
    ///             larger than the number you specified in this parameter, then the response includes a
    ///                 <code>NextToken</code> element, which you can use to obtain additional
    ///             results.</p>
    ///         <p>The value you specify has to be at least 1, and can be no more than 50.</p>
    public let pageSize: Int?

    public init (
        nextToken: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListCustomVerificationEmailTemplatesInputBody: Equatable {
}

extension ListCustomVerificationEmailTemplatesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListCustomVerificationEmailTemplatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomVerificationEmailTemplatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCustomVerificationEmailTemplatesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomVerificationEmailTemplatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCustomVerificationEmailTemplatesOutputResponse(customVerificationEmailTemplates: \(String(describing: customVerificationEmailTemplates)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCustomVerificationEmailTemplatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCustomVerificationEmailTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customVerificationEmailTemplates = output.customVerificationEmailTemplates
            self.nextToken = output.nextToken
        } else {
            self.customVerificationEmailTemplates = nil
            self.nextToken = nil
        }
    }
}

/// <p>The following elements are returned by the service.</p>
public struct ListCustomVerificationEmailTemplatesOutputResponse: Equatable {
    /// <p>A list of the custom verification email templates that exist in your account.</p>
    public let customVerificationEmailTemplates: [CustomVerificationEmailTemplateMetadata]?
    /// <p>A token indicating that there are additional custom verification email templates
    ///             available to be listed. Pass this token to a subsequent call to
    ///                 <code>ListCustomVerificationEmailTemplates</code> to retrieve the next 50 custom
    ///             verification email templates.</p>
    public let nextToken: String?

    public init (
        customVerificationEmailTemplates: [CustomVerificationEmailTemplateMetadata]? = nil,
        nextToken: String? = nil
    )
    {
        self.customVerificationEmailTemplates = customVerificationEmailTemplates
        self.nextToken = nextToken
    }
}

struct ListCustomVerificationEmailTemplatesOutputResponseBody: Equatable {
    public let customVerificationEmailTemplates: [CustomVerificationEmailTemplateMetadata]?
    public let nextToken: String?
}

extension ListCustomVerificationEmailTemplatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customVerificationEmailTemplates = "CustomVerificationEmailTemplates"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customVerificationEmailTemplatesContainer = try containerValues.decodeIfPresent([CustomVerificationEmailTemplateMetadata?].self, forKey: .customVerificationEmailTemplates)
        var customVerificationEmailTemplatesDecoded0:[CustomVerificationEmailTemplateMetadata]? = nil
        if let customVerificationEmailTemplatesContainer = customVerificationEmailTemplatesContainer {
            customVerificationEmailTemplatesDecoded0 = [CustomVerificationEmailTemplateMetadata]()
            for structure0 in customVerificationEmailTemplatesContainer {
                if let structure0 = structure0 {
                    customVerificationEmailTemplatesDecoded0?.append(structure0)
                }
            }
        }
        customVerificationEmailTemplates = customVerificationEmailTemplatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDedicatedIpPoolsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDedicatedIpPoolsInput(nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)))"}
}

extension ListDedicatedIpPoolsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDedicatedIpPoolsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDedicatedIpPoolsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDedicatedIpPoolsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDedicatedIpPoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDedicatedIpPoolsInput>
    public typealias MOutput = OperationOutput<ListDedicatedIpPoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDedicatedIpPoolsOutputError>
}

public struct ListDedicatedIpPoolsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDedicatedIpPoolsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDedicatedIpPoolsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDedicatedIpPoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "PageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDedicatedIpPoolsInput>
    public typealias MOutput = OperationOutput<ListDedicatedIpPoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDedicatedIpPoolsOutputError>
}

/// <p>A request to obtain a list of dedicated IP pools.</p>
public struct ListDedicatedIpPoolsInput: Equatable {
    /// <p>A token returned from a previous call to <code>ListDedicatedIpPools</code> to indicate
    ///             the position in the list of dedicated IP pools.</p>
    public let nextToken: String?
    /// <p>The number of results to show in a single call to <code>ListDedicatedIpPools</code>.
    ///             If the number of results is larger than the number you specified in this parameter, then
    ///             the response includes a <code>NextToken</code> element, which you can use to obtain
    ///             additional results.</p>
    public let pageSize: Int?

    public init (
        nextToken: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListDedicatedIpPoolsInputBody: Equatable {
}

extension ListDedicatedIpPoolsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDedicatedIpPoolsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDedicatedIpPoolsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDedicatedIpPoolsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDedicatedIpPoolsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDedicatedIpPoolsOutputResponse(dedicatedIpPools: \(String(describing: dedicatedIpPools)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDedicatedIpPoolsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDedicatedIpPoolsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dedicatedIpPools = output.dedicatedIpPools
            self.nextToken = output.nextToken
        } else {
            self.dedicatedIpPools = nil
            self.nextToken = nil
        }
    }
}

/// <p>A list of dedicated IP pools.</p>
public struct ListDedicatedIpPoolsOutputResponse: Equatable {
    /// <p>A list of all of the dedicated IP pools that are associated with your AWS account in
    ///             the current Region.</p>
    public let dedicatedIpPools: [String]?
    /// <p>A token that indicates that there are additional IP pools to list. To view additional
    ///             IP pools, issue another request to <code>ListDedicatedIpPools</code>, passing this token
    ///             in the <code>NextToken</code> parameter.</p>
    public let nextToken: String?

    public init (
        dedicatedIpPools: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.dedicatedIpPools = dedicatedIpPools
        self.nextToken = nextToken
    }
}

struct ListDedicatedIpPoolsOutputResponseBody: Equatable {
    public let dedicatedIpPools: [String]?
    public let nextToken: String?
}

extension ListDedicatedIpPoolsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dedicatedIpPools = "DedicatedIpPools"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dedicatedIpPoolsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dedicatedIpPools)
        var dedicatedIpPoolsDecoded0:[String]? = nil
        if let dedicatedIpPoolsContainer = dedicatedIpPoolsContainer {
            dedicatedIpPoolsDecoded0 = [String]()
            for string0 in dedicatedIpPoolsContainer {
                if let string0 = string0 {
                    dedicatedIpPoolsDecoded0?.append(string0)
                }
            }
        }
        dedicatedIpPools = dedicatedIpPoolsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeliverabilityTestReportsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeliverabilityTestReportsInput(nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)))"}
}

extension ListDeliverabilityTestReportsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDeliverabilityTestReportsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDeliverabilityTestReportsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeliverabilityTestReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeliverabilityTestReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeliverabilityTestReportsInput>
    public typealias MOutput = OperationOutput<ListDeliverabilityTestReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeliverabilityTestReportsOutputError>
}

public struct ListDeliverabilityTestReportsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDeliverabilityTestReportsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeliverabilityTestReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeliverabilityTestReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "PageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeliverabilityTestReportsInput>
    public typealias MOutput = OperationOutput<ListDeliverabilityTestReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeliverabilityTestReportsOutputError>
}

/// <p>A request to list all of the predictive inbox placement tests that you've performed.</p>
public struct ListDeliverabilityTestReportsInput: Equatable {
    /// <p>A token returned from a previous call to <code>ListDeliverabilityTestReports</code> to
    ///             indicate the position in the list of predictive inbox placement tests.</p>
    public let nextToken: String?
    /// <p>The number of results to show in a single call to
    ///                 <code>ListDeliverabilityTestReports</code>. If the number of results is larger than
    ///             the number you specified in this parameter, then the response includes a
    ///                 <code>NextToken</code> element, which you can use to obtain additional
    ///             results.</p>
    ///         <p>The value you specify has to be at least 0, and can be no more than 1000.</p>
    public let pageSize: Int?

    public init (
        nextToken: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListDeliverabilityTestReportsInputBody: Equatable {
}

extension ListDeliverabilityTestReportsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDeliverabilityTestReportsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeliverabilityTestReportsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeliverabilityTestReportsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeliverabilityTestReportsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeliverabilityTestReportsOutputResponse(deliverabilityTestReports: \(String(describing: deliverabilityTestReports)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDeliverabilityTestReportsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDeliverabilityTestReportsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deliverabilityTestReports = output.deliverabilityTestReports
            self.nextToken = output.nextToken
        } else {
            self.deliverabilityTestReports = nil
            self.nextToken = nil
        }
    }
}

/// <p>A list of the predictive inbox placement test reports that are available for your account, regardless of
///             whether or not those tests are complete.</p>
public struct ListDeliverabilityTestReportsOutputResponse: Equatable {
    /// <p>An object that contains a lists of predictive inbox placement tests that you've performed.</p>
    public let deliverabilityTestReports: [DeliverabilityTestReport]?
    /// <p>A token that indicates that there are additional predictive inbox placement tests to list. To view additional
    ///             predictive inbox placement tests, issue another request to <code>ListDeliverabilityTestReports</code>, and pass
    ///             this token in the <code>NextToken</code> parameter.</p>
    public let nextToken: String?

    public init (
        deliverabilityTestReports: [DeliverabilityTestReport]? = nil,
        nextToken: String? = nil
    )
    {
        self.deliverabilityTestReports = deliverabilityTestReports
        self.nextToken = nextToken
    }
}

struct ListDeliverabilityTestReportsOutputResponseBody: Equatable {
    public let deliverabilityTestReports: [DeliverabilityTestReport]?
    public let nextToken: String?
}

extension ListDeliverabilityTestReportsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deliverabilityTestReports = "DeliverabilityTestReports"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliverabilityTestReportsContainer = try containerValues.decodeIfPresent([DeliverabilityTestReport?].self, forKey: .deliverabilityTestReports)
        var deliverabilityTestReportsDecoded0:[DeliverabilityTestReport]? = nil
        if let deliverabilityTestReportsContainer = deliverabilityTestReportsContainer {
            deliverabilityTestReportsDecoded0 = [DeliverabilityTestReport]()
            for structure0 in deliverabilityTestReportsContainer {
                if let structure0 = structure0 {
                    deliverabilityTestReportsDecoded0?.append(structure0)
                }
            }
        }
        deliverabilityTestReports = deliverabilityTestReportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDomainDeliverabilityCampaignsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDomainDeliverabilityCampaignsInput(endDate: \(String(describing: endDate)), nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)), startDate: \(String(describing: startDate)), subscribedDomain: \(String(describing: subscribedDomain)))"}
}

extension ListDomainDeliverabilityCampaignsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDomainDeliverabilityCampaignsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDomainDeliverabilityCampaignsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainDeliverabilityCampaignsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainDeliverabilityCampaignsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainDeliverabilityCampaignsInput>
    public typealias MOutput = OperationOutput<ListDomainDeliverabilityCampaignsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainDeliverabilityCampaignsOutputError>
}

public struct ListDomainDeliverabilityCampaignsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDomainDeliverabilityCampaignsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainDeliverabilityCampaignsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainDeliverabilityCampaignsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let startDate = input.operationInput.startDate {
            let startDateQueryItem = URLQueryItem(name: "StartDate".urlPercentEncoding(), value: String(startDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startDateQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "PageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let endDate = input.operationInput.endDate {
            let endDateQueryItem = URLQueryItem(name: "EndDate".urlPercentEncoding(), value: String(endDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endDateQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainDeliverabilityCampaignsInput>
    public typealias MOutput = OperationOutput<ListDomainDeliverabilityCampaignsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainDeliverabilityCampaignsOutputError>
}

/// <p>Retrieve deliverability data for all the campaigns that used a specific domain to send
///             email during a specified time range. This data is available for a domain only if you
///             enabled the Deliverability dashboard.</p>
public struct ListDomainDeliverabilityCampaignsInput: Equatable {
    /// <p>The last day, in Unix time format, that you want to obtain deliverability data for.
    ///             This value has to be less than or equal to 30 days after the value of the
    ///                 <code>StartDate</code> parameter.</p>
    public let endDate: Date?
    /// <p>A token that’s returned from a previous call to the
    ///                 <code>ListDomainDeliverabilityCampaigns</code> operation. This token indicates the
    ///             position of a campaign in the list of campaigns.</p>
    public let nextToken: String?
    /// <p>The maximum number of results to include in response to a single call to the
    ///                 <code>ListDomainDeliverabilityCampaigns</code> operation. If the number of results
    ///             is larger than the number that you specify in this parameter, the response includes a
    ///                 <code>NextToken</code> element, which you can use to obtain additional
    ///             results.</p>
    public let pageSize: Int?
    /// <p>The first day, in Unix time format, that you want to obtain deliverability data
    ///             for.</p>
    public let startDate: Date?
    /// <p>The domain to obtain deliverability data for.</p>
    public let subscribedDomain: String?

    public init (
        endDate: Date? = nil,
        nextToken: String? = nil,
        pageSize: Int? = nil,
        startDate: Date? = nil,
        subscribedDomain: String? = nil
    )
    {
        self.endDate = endDate
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.startDate = startDate
        self.subscribedDomain = subscribedDomain
    }
}

struct ListDomainDeliverabilityCampaignsInputBody: Equatable {
}

extension ListDomainDeliverabilityCampaignsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDomainDeliverabilityCampaignsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainDeliverabilityCampaignsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDomainDeliverabilityCampaignsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainDeliverabilityCampaignsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDomainDeliverabilityCampaignsOutputResponse(domainDeliverabilityCampaigns: \(String(describing: domainDeliverabilityCampaigns)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDomainDeliverabilityCampaignsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDomainDeliverabilityCampaignsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainDeliverabilityCampaigns = output.domainDeliverabilityCampaigns
            self.nextToken = output.nextToken
        } else {
            self.domainDeliverabilityCampaigns = nil
            self.nextToken = nil
        }
    }
}

/// <p>An array of objects that provide deliverability data for all the campaigns that used a
///             specific domain to send email during a specified time range. This data is available for
///             a domain only if you enabled the Deliverability dashboard for the domain.</p>
public struct ListDomainDeliverabilityCampaignsOutputResponse: Equatable {
    /// <p>An array of responses, one for each campaign that used the domain to send email during
    ///             the specified time range.</p>
    public let domainDeliverabilityCampaigns: [DomainDeliverabilityCampaign]?
    /// <p>A token that’s returned from a previous call to the
    ///                 <code>ListDomainDeliverabilityCampaigns</code> operation. This token indicates the
    ///             position of the campaign in the list of campaigns.</p>
    public let nextToken: String?

    public init (
        domainDeliverabilityCampaigns: [DomainDeliverabilityCampaign]? = nil,
        nextToken: String? = nil
    )
    {
        self.domainDeliverabilityCampaigns = domainDeliverabilityCampaigns
        self.nextToken = nextToken
    }
}

struct ListDomainDeliverabilityCampaignsOutputResponseBody: Equatable {
    public let domainDeliverabilityCampaigns: [DomainDeliverabilityCampaign]?
    public let nextToken: String?
}

extension ListDomainDeliverabilityCampaignsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainDeliverabilityCampaigns = "DomainDeliverabilityCampaigns"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDeliverabilityCampaignsContainer = try containerValues.decodeIfPresent([DomainDeliverabilityCampaign?].self, forKey: .domainDeliverabilityCampaigns)
        var domainDeliverabilityCampaignsDecoded0:[DomainDeliverabilityCampaign]? = nil
        if let domainDeliverabilityCampaignsContainer = domainDeliverabilityCampaignsContainer {
            domainDeliverabilityCampaignsDecoded0 = [DomainDeliverabilityCampaign]()
            for structure0 in domainDeliverabilityCampaignsContainer {
                if let structure0 = structure0 {
                    domainDeliverabilityCampaignsDecoded0?.append(structure0)
                }
            }
        }
        domainDeliverabilityCampaigns = domainDeliverabilityCampaignsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEmailIdentitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEmailIdentitiesInput(nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)))"}
}

extension ListEmailIdentitiesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListEmailIdentitiesInputHeadersMiddleware: Middleware {
    public let id: String = "ListEmailIdentitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEmailIdentitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEmailIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEmailIdentitiesInput>
    public typealias MOutput = OperationOutput<ListEmailIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEmailIdentitiesOutputError>
}

public struct ListEmailIdentitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEmailIdentitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEmailIdentitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEmailIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "PageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEmailIdentitiesInput>
    public typealias MOutput = OperationOutput<ListEmailIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEmailIdentitiesOutputError>
}

/// <p>A request to list all of the email identities associated with your AWS account. This
///             list includes identities that you've already verified, identities that are unverified,
///             and identities that were verified in the past, but are no longer verified.</p>
public struct ListEmailIdentitiesInput: Equatable {
    /// <p>A token returned from a previous call to <code>ListEmailIdentities</code> to indicate
    ///             the position in the list of identities.</p>
    public let nextToken: String?
    /// <p>The number of results to show in a single call to <code>ListEmailIdentities</code>. If
    ///             the number of results is larger than the number you specified in this parameter, then
    ///             the response includes a <code>NextToken</code> element, which you can use to obtain
    ///             additional results.</p>
    ///         <p>The value you specify has to be at least 0, and can be no more than 1000.</p>
    public let pageSize: Int?

    public init (
        nextToken: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListEmailIdentitiesInputBody: Equatable {
}

extension ListEmailIdentitiesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListEmailIdentitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEmailIdentitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEmailIdentitiesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEmailIdentitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEmailIdentitiesOutputResponse(emailIdentities: \(String(describing: emailIdentities)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEmailIdentitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEmailIdentitiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.emailIdentities = output.emailIdentities
            self.nextToken = output.nextToken
        } else {
            self.emailIdentities = nil
            self.nextToken = nil
        }
    }
}

/// <p>A list of all of the identities that you've attempted to verify, regardless of whether
///             or not those identities were successfully verified.</p>
public struct ListEmailIdentitiesOutputResponse: Equatable {
    /// <p>An array that includes all of the email identities associated with your AWS
    ///             account.</p>
    public let emailIdentities: [IdentityInfo]?
    /// <p>A token that indicates that there are additional configuration sets to list. To view
    ///             additional configuration sets, issue another request to
    ///             <code>ListEmailIdentities</code>, and pass this token in the <code>NextToken</code>
    ///             parameter.</p>
    public let nextToken: String?

    public init (
        emailIdentities: [IdentityInfo]? = nil,
        nextToken: String? = nil
    )
    {
        self.emailIdentities = emailIdentities
        self.nextToken = nextToken
    }
}

struct ListEmailIdentitiesOutputResponseBody: Equatable {
    public let emailIdentities: [IdentityInfo]?
    public let nextToken: String?
}

extension ListEmailIdentitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case emailIdentities = "EmailIdentities"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailIdentitiesContainer = try containerValues.decodeIfPresent([IdentityInfo?].self, forKey: .emailIdentities)
        var emailIdentitiesDecoded0:[IdentityInfo]? = nil
        if let emailIdentitiesContainer = emailIdentitiesContainer {
            emailIdentitiesDecoded0 = [IdentityInfo]()
            for structure0 in emailIdentitiesContainer {
                if let structure0 = structure0 {
                    emailIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        emailIdentities = emailIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEmailTemplatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEmailTemplatesInput(nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)))"}
}

extension ListEmailTemplatesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListEmailTemplatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListEmailTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEmailTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEmailTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEmailTemplatesInput>
    public typealias MOutput = OperationOutput<ListEmailTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEmailTemplatesOutputError>
}

public struct ListEmailTemplatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEmailTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEmailTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEmailTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "PageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEmailTemplatesInput>
    public typealias MOutput = OperationOutput<ListEmailTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEmailTemplatesOutputError>
}

/// <p>Represents a request to list the email templates present in your Amazon SES account in the
///             current AWS Region. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-personalized-email-api.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct ListEmailTemplatesInput: Equatable {
    /// <p>A token returned from a previous call to <code>ListEmailTemplates</code> to indicate
    ///             the position in the list of email templates.</p>
    public let nextToken: String?
    /// <p>The number of results to show in a single call to <code>ListEmailTemplates</code>. If the number of
    ///             results is larger than the number you specified in this parameter, then the response
    ///             includes a <code>NextToken</code> element, which you can use to obtain additional results.</p>
    ///         <p>The value you specify has to be at least 1, and can be no more than 10.</p>
    public let pageSize: Int?

    public init (
        nextToken: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListEmailTemplatesInputBody: Equatable {
}

extension ListEmailTemplatesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListEmailTemplatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEmailTemplatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEmailTemplatesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEmailTemplatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEmailTemplatesOutputResponse(nextToken: \(String(describing: nextToken)), templatesMetadata: \(String(describing: templatesMetadata)))"}
}

extension ListEmailTemplatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEmailTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.templatesMetadata = output.templatesMetadata
        } else {
            self.nextToken = nil
            self.templatesMetadata = nil
        }
    }
}

/// <p>The following elements are returned by the service.</p>
public struct ListEmailTemplatesOutputResponse: Equatable {
    /// <p>A token indicating that there are additional email templates available to be listed.
    ///             Pass this token to a subsequent <code>ListEmailTemplates</code> call to retrieve the
    ///             next 10 email templates.</p>
    public let nextToken: String?
    /// <p>An array the contains the name and creation time stamp for each template in your Amazon SES
    ///             account.</p>
    public let templatesMetadata: [EmailTemplateMetadata]?

    public init (
        nextToken: String? = nil,
        templatesMetadata: [EmailTemplateMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.templatesMetadata = templatesMetadata
    }
}

struct ListEmailTemplatesOutputResponseBody: Equatable {
    public let templatesMetadata: [EmailTemplateMetadata]?
    public let nextToken: String?
}

extension ListEmailTemplatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case templatesMetadata = "TemplatesMetadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templatesMetadataContainer = try containerValues.decodeIfPresent([EmailTemplateMetadata?].self, forKey: .templatesMetadata)
        var templatesMetadataDecoded0:[EmailTemplateMetadata]? = nil
        if let templatesMetadataContainer = templatesMetadataContainer {
            templatesMetadataDecoded0 = [EmailTemplateMetadata]()
            for structure0 in templatesMetadataContainer {
                if let structure0 = structure0 {
                    templatesMetadataDecoded0?.append(structure0)
                }
            }
        }
        templatesMetadata = templatesMetadataDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListImportJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListImportJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImportJobsInput>
    public typealias MOutput = OperationOutput<ListImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImportJobsOutputError>
}

extension ListImportJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImportJobsInput(importDestinationType: \(String(describing: importDestinationType)), nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)))"}
}

extension ListImportJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case importDestinationType = "ImportDestinationType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let importDestinationType = importDestinationType {
            try encodeContainer.encode(importDestinationType.rawValue, forKey: .importDestinationType)
        }
    }
}

public struct ListImportJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListImportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImportJobsInput>
    public typealias MOutput = OperationOutput<ListImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImportJobsOutputError>
}

public struct ListImportJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListImportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "PageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImportJobsInput>
    public typealias MOutput = OperationOutput<ListImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImportJobsOutputError>
}

/// <p>Represents a request to list all of the import jobs for a data destination within the
///             specified maximum number of import jobs.</p>
public struct ListImportJobsInput: Equatable {
    /// <p>The destination of the import job, which can be used to list import jobs that have a
    ///             certain <code>ImportDestinationType</code>.</p>
    public let importDestinationType: ImportDestinationType?
    /// <p>A string token indicating that there might be additional import jobs available to be
    ///             listed. Copy this token to a subsequent call to <code>ListImportJobs</code> with the
    ///             same parameters to retrieve the next page of import jobs.</p>
    public let nextToken: String?
    /// <p>Maximum number of import jobs to return at once. Use this parameter to paginate
    ///             results. If additional import jobs exist beyond the specified limit, the
    ///                 <code>NextToken</code> element is sent in the response. Use the
    ///                 <code>NextToken</code> value in subsequent requests to retrieve additional
    ///             addresses.</p>
    public let pageSize: Int?

    public init (
        importDestinationType: ImportDestinationType? = nil,
        nextToken: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.importDestinationType = importDestinationType
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListImportJobsInputBody: Equatable {
    public let importDestinationType: ImportDestinationType?
}

extension ListImportJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case importDestinationType = "ImportDestinationType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importDestinationTypeDecoded = try containerValues.decodeIfPresent(ImportDestinationType.self, forKey: .importDestinationType)
        importDestinationType = importDestinationTypeDecoded
    }
}

extension ListImportJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImportJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListImportJobsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImportJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImportJobsOutputResponse(importJobs: \(String(describing: importJobs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListImportJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListImportJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.importJobs = output.importJobs
            self.nextToken = output.nextToken
        } else {
            self.importJobs = nil
            self.nextToken = nil
        }
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct ListImportJobsOutputResponse: Equatable {
    /// <p>A list of the import job summaries.</p>
    public let importJobs: [ImportJobSummary]?
    /// <p>A string token indicating that there might be additional import jobs available to be
    ///             listed. Copy this token to a subsequent call to <code>ListImportJobs</code> with the
    ///             same parameters to retrieve the next page of import jobs.</p>
    public let nextToken: String?

    public init (
        importJobs: [ImportJobSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.importJobs = importJobs
        self.nextToken = nextToken
    }
}

struct ListImportJobsOutputResponseBody: Equatable {
    public let importJobs: [ImportJobSummary]?
    public let nextToken: String?
}

extension ListImportJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case importJobs = "ImportJobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importJobsContainer = try containerValues.decodeIfPresent([ImportJobSummary?].self, forKey: .importJobs)
        var importJobsDecoded0:[ImportJobSummary]? = nil
        if let importJobsContainer = importJobsContainer {
            importJobsDecoded0 = [ImportJobSummary]()
            for structure0 in importJobsContainer {
                if let structure0 = structure0 {
                    importJobsDecoded0?.append(structure0)
                }
            }
        }
        importJobs = importJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListManagementOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactListName = "ContactListName"
        case topicName = "TopicName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactListName = contactListName {
            try encodeContainer.encode(contactListName, forKey: .contactListName)
        }
        if let topicName = topicName {
            try encodeContainer.encode(topicName, forKey: .topicName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactListNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactListName)
        contactListName = contactListNameDecoded
        let topicNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicName)
        topicName = topicNameDecoded
    }
}

extension ListManagementOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListManagementOptions(contactListName: \(String(describing: contactListName)), topicName: \(String(describing: topicName)))"}
}

/// <p>An object used to specify a list or topic to which an email belongs, which will be
///             used when a contact chooses to unsubscribe.</p>
public struct ListManagementOptions: Equatable {
    /// <p>The name of the contact list.</p>
    public let contactListName: String?
    /// <p>The name of the topic.</p>
    public let topicName: String?

    public init (
        contactListName: String? = nil,
        topicName: String? = nil
    )
    {
        self.contactListName = contactListName
        self.topicName = topicName
    }
}

extension ListSuppressedDestinationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSuppressedDestinationsInput(endDate: \(String(describing: endDate)), nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)), reasons: \(String(describing: reasons)), startDate: \(String(describing: startDate)))"}
}

extension ListSuppressedDestinationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListSuppressedDestinationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSuppressedDestinationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSuppressedDestinationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSuppressedDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSuppressedDestinationsInput>
    public typealias MOutput = OperationOutput<ListSuppressedDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSuppressedDestinationsOutputError>
}

public struct ListSuppressedDestinationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSuppressedDestinationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSuppressedDestinationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSuppressedDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let startDate = input.operationInput.startDate {
            let startDateQueryItem = URLQueryItem(name: "StartDate".urlPercentEncoding(), value: String(startDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startDateQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "PageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let reasons = input.operationInput.reasons {
            reasons.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "Reason".urlPercentEncoding(), value: String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let endDate = input.operationInput.endDate {
            let endDateQueryItem = URLQueryItem(name: "EndDate".urlPercentEncoding(), value: String(endDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endDateQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSuppressedDestinationsInput>
    public typealias MOutput = OperationOutput<ListSuppressedDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSuppressedDestinationsOutputError>
}

/// <p>A request to obtain a list of email destinations that are on the suppression list for
///             your account.</p>
public struct ListSuppressedDestinationsInput: Equatable {
    /// <p>Used to filter the list of suppressed email destinations so that it only includes
    ///             addresses that were added to the list before a specific date. The date that you specify
    ///             should be in Unix time format.</p>
    public let endDate: Date?
    /// <p>A token returned from a previous call to <code>ListSuppressedDestinations</code> to
    ///             indicate the position in the list of suppressed email addresses.</p>
    public let nextToken: String?
    /// <p>The number of results to show in a single call to
    ///                 <code>ListSuppressedDestinations</code>. If the number of results is larger than the
    ///             number you specified in this parameter, then the response includes a
    ///                 <code>NextToken</code> element, which you can use to obtain additional
    ///             results.</p>
    public let pageSize: Int?
    /// <p>The factors that caused the email address to be added to .</p>
    public let reasons: [SuppressionListReason]?
    /// <p>Used to filter the list of suppressed email destinations so that it only includes
    ///             addresses that were added to the list after a specific date. The date that you specify
    ///             should be in Unix time format.</p>
    public let startDate: Date?

    public init (
        endDate: Date? = nil,
        nextToken: String? = nil,
        pageSize: Int? = nil,
        reasons: [SuppressionListReason]? = nil,
        startDate: Date? = nil
    )
    {
        self.endDate = endDate
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.reasons = reasons
        self.startDate = startDate
    }
}

struct ListSuppressedDestinationsInputBody: Equatable {
}

extension ListSuppressedDestinationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListSuppressedDestinationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSuppressedDestinationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSuppressedDestinationsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case invalidNextTokenException(InvalidNextTokenException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSuppressedDestinationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSuppressedDestinationsOutputResponse(nextToken: \(String(describing: nextToken)), suppressedDestinationSummaries: \(String(describing: suppressedDestinationSummaries)))"}
}

extension ListSuppressedDestinationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSuppressedDestinationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.suppressedDestinationSummaries = output.suppressedDestinationSummaries
        } else {
            self.nextToken = nil
            self.suppressedDestinationSummaries = nil
        }
    }
}

/// <p>A list of suppressed email addresses.</p>
public struct ListSuppressedDestinationsOutputResponse: Equatable {
    /// <p>A token that indicates that there are additional email addresses on the suppression
    ///             list for your account. To view additional suppressed addresses, issue another request to
    ///                 <code>ListSuppressedDestinations</code>, and pass this token in the
    ///                 <code>NextToken</code> parameter.</p>
    public let nextToken: String?
    /// <p>A list of summaries, each containing a summary for a suppressed email
    ///             destination.</p>
    public let suppressedDestinationSummaries: [SuppressedDestinationSummary]?

    public init (
        nextToken: String? = nil,
        suppressedDestinationSummaries: [SuppressedDestinationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.suppressedDestinationSummaries = suppressedDestinationSummaries
    }
}

struct ListSuppressedDestinationsOutputResponseBody: Equatable {
    public let suppressedDestinationSummaries: [SuppressedDestinationSummary]?
    public let nextToken: String?
}

extension ListSuppressedDestinationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case suppressedDestinationSummaries = "SuppressedDestinationSummaries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suppressedDestinationSummariesContainer = try containerValues.decodeIfPresent([SuppressedDestinationSummary?].self, forKey: .suppressedDestinationSummaries)
        var suppressedDestinationSummariesDecoded0:[SuppressedDestinationSummary]? = nil
        if let suppressedDestinationSummariesContainer = suppressedDestinationSummariesContainer {
            suppressedDestinationSummariesDecoded0 = [SuppressedDestinationSummary]()
            for structure0 in suppressedDestinationSummariesContainer {
                if let structure0 = structure0 {
                    suppressedDestinationSummariesDecoded0?.append(structure0)
                }
            }
        }
        suppressedDestinationSummaries = suppressedDestinationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "ResourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to retrieve tag
    ///             information for.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>An array that lists all the tags that are associated with the resource. Each tag
    ///             consists of a required tag key (<code>Key</code>) and an associated tag value
    ///                 (<code>Value</code>)</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MailFromAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case behaviorOnMxFailure = "BehaviorOnMxFailure"
        case mailFromDomain = "MailFromDomain"
        case mailFromDomainStatus = "MailFromDomainStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let behaviorOnMxFailure = behaviorOnMxFailure {
            try encodeContainer.encode(behaviorOnMxFailure.rawValue, forKey: .behaviorOnMxFailure)
        }
        if let mailFromDomain = mailFromDomain {
            try encodeContainer.encode(mailFromDomain, forKey: .mailFromDomain)
        }
        if let mailFromDomainStatus = mailFromDomainStatus {
            try encodeContainer.encode(mailFromDomainStatus.rawValue, forKey: .mailFromDomainStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mailFromDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mailFromDomain)
        mailFromDomain = mailFromDomainDecoded
        let mailFromDomainStatusDecoded = try containerValues.decodeIfPresent(MailFromDomainStatus.self, forKey: .mailFromDomainStatus)
        mailFromDomainStatus = mailFromDomainStatusDecoded
        let behaviorOnMxFailureDecoded = try containerValues.decodeIfPresent(BehaviorOnMxFailure.self, forKey: .behaviorOnMxFailure)
        behaviorOnMxFailure = behaviorOnMxFailureDecoded
    }
}

extension MailFromAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MailFromAttributes(behaviorOnMxFailure: \(String(describing: behaviorOnMxFailure)), mailFromDomain: \(String(describing: mailFromDomain)), mailFromDomainStatus: \(String(describing: mailFromDomainStatus)))"}
}

/// <p>A list of attributes that are associated with a MAIL FROM domain.</p>
public struct MailFromAttributes: Equatable {
    /// <p>The action that you want to take if the required MX record can't be found when you
    ///             send an email. When you set this value to <code>UseDefaultValue</code>, the mail is sent
    ///             using <i>amazonses.com</i> as the MAIL FROM domain. When you set this
    ///             value to <code>RejectMessage</code>, the Amazon SES API v2 returns a
    ///                 <code>MailFromDomainNotVerified</code> error, and doesn't attempt to deliver the
    ///             email.</p>
    ///         <p>These behaviors are taken when the custom MAIL FROM domain configuration is in the
    ///                 <code>Pending</code>, <code>Failed</code>, and <code>TemporaryFailure</code>
    ///             states.</p>
    public let behaviorOnMxFailure: BehaviorOnMxFailure?
    /// <p>The name of a domain that an email identity uses as a custom MAIL FROM domain.</p>
    public let mailFromDomain: String?
    /// <p>The status of the MAIL FROM domain. This status can have the following values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>PENDING</code> – Amazon SES hasn't started searching for the MX record
    ///                     yet.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SUCCESS</code> – Amazon SES detected the required MX record for the
    ///                     MAIL FROM domain.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>FAILED</code> – Amazon SES can't find the required MX record, or the
    ///                     record no longer exists.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>TEMPORARY_FAILURE</code> – A temporary issue occurred, which
    ///                     prevented Amazon SES from determining the status of the MAIL FROM domain.</p>
    ///             </li>
    ///          </ul>
    public let mailFromDomainStatus: MailFromDomainStatus?

    public init (
        behaviorOnMxFailure: BehaviorOnMxFailure? = nil,
        mailFromDomain: String? = nil,
        mailFromDomainStatus: MailFromDomainStatus? = nil
    )
    {
        self.behaviorOnMxFailure = behaviorOnMxFailure
        self.mailFromDomain = mailFromDomain
        self.mailFromDomainStatus = mailFromDomainStatus
    }
}

extension MailFromDomainNotVerifiedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MailFromDomainNotVerifiedException(message: \(String(describing: message)))"}
}

extension MailFromDomainNotVerifiedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MailFromDomainNotVerifiedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The message can't be sent because the sending domain isn't verified.</p>
public struct MailFromDomainNotVerifiedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MailFromDomainNotVerifiedExceptionBody: Equatable {
    public let message: String?
}

extension MailFromDomainNotVerifiedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

/// <p>The status of the MAIL FROM domain. This status can have the following values:</p>
///         <ul>
///             <li>
///                 <p>
///                   <code>PENDING</code> – Amazon SES hasn't started searching for the MX record
///                     yet.</p>
///             </li>
///             <li>
///                 <p>
///                   <code>SUCCESS</code> – Amazon SES detected the required MX record for the
///                     MAIL FROM domain.</p>
///             </li>
///             <li>
///                 <p>
///                   <code>FAILED</code> – Amazon SES can't find the required MX record, or the
///                     record no longer exists.</p>
///             </li>
///             <li>
///                 <p>
///                   <code>TEMPORARY_FAILURE</code> – A temporary issue occurred, which
///                     prevented Amazon SES from determining the status of the MAIL FROM domain.</p>
///             </li>
///          </ul>
public enum MailFromDomainStatus {
    case failed
    case pending
    case success
    case temporaryFailure
    case sdkUnknown(String)
}

extension MailFromDomainStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MailFromDomainStatus] {
        return [
            .failed,
            .pending,
            .success,
            .temporaryFailure,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case .success: return "SUCCESS"
        case .temporaryFailure: return "TEMPORARY_FAILURE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MailFromDomainStatus(rawValue: rawValue) ?? MailFromDomainStatus.sdkUnknown(rawValue)
    }
}

public enum MailType {
    case marketing
    case transactional
    case sdkUnknown(String)
}

extension MailType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MailType] {
        return [
            .marketing,
            .transactional,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .marketing: return "MARKETING"
        case .transactional: return "TRANSACTIONAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MailType(rawValue: rawValue) ?? MailType.sdkUnknown(rawValue)
    }
}

extension Message: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case subject = "Subject"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectDecoded = try containerValues.decodeIfPresent(Content.self, forKey: .subject)
        subject = subjectDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(Body.self, forKey: .body)
        body = bodyDecoded
    }
}

extension Message: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Message(body: \(String(describing: body)), subject: \(String(describing: subject)))"}
}

/// <p>Represents the email message that you're sending. The <code>Message</code> object
///             consists of a subject line and a message body.</p>
public struct Message: Equatable {
    /// <p>The body of the message. You can specify an HTML version of the message, a text-only
    ///             version of the message, or both.</p>
    public let body: Body?
    /// <p>The subject line of the email. The subject line can only contain 7-bit ASCII
    ///             characters. However, you can specify non-ASCII characters in the subject line by using
    ///             encoded-word syntax, as described in <a href="https://tools.ietf.org/html/rfc2047">RFC 2047</a>.</p>
    public let subject: Content?

    public init (
        body: Body? = nil,
        subject: Content? = nil
    )
    {
        self.body = body
        self.subject = subject
    }
}

extension MessageRejected: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MessageRejected(message: \(String(describing: message)))"}
}

extension MessageRejected: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MessageRejectedBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The message can't be sent because it contains invalid content.</p>
public struct MessageRejected: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MessageRejectedBody: Equatable {
    public let message: String?
}

extension MessageRejectedBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MessageTag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MessageTag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MessageTag(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Contains the name and value of a tag that you apply to an email. You can use message
///             tags when you publish email sending events.
///             </p>
public struct MessageTag: Equatable {
    /// <p>The name of the message tag. The message tag name has to meet the following
    ///             criteria:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>It can only contain ASCII letters (a–z, A–Z), numbers (0–9),
    ///                     underscores (_), or dashes (-).</p>
    ///             </li>
    ///             <li>
    ///                 <p>It can contain no more than 256 characters.</p>
    ///             </li>
    ///          </ul>
    public let name: String?
    /// <p>The value of the message tag. The message tag value has to meet the following
    ///             criteria:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>It can only contain ASCII letters (a–z, A–Z), numbers (0–9),
    ///                     underscores (_), or dashes (-).</p>
    ///             </li>
    ///             <li>
    ///                 <p>It can contain no more than 256 characters.</p>
    ///             </li>
    ///          </ul>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource you attempted to access doesn't exist.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OverallVolume: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainIspPlacements = "DomainIspPlacements"
        case readRatePercent = "ReadRatePercent"
        case volumeStatistics = "VolumeStatistics"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainIspPlacements = domainIspPlacements {
            var domainIspPlacementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainIspPlacements)
            for domainispplacements0 in domainIspPlacements {
                try domainIspPlacementsContainer.encode(domainispplacements0)
            }
        }
        if let readRatePercent = readRatePercent {
            try encodeContainer.encode(readRatePercent, forKey: .readRatePercent)
        }
        if let volumeStatistics = volumeStatistics {
            try encodeContainer.encode(volumeStatistics, forKey: .volumeStatistics)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeStatisticsDecoded = try containerValues.decodeIfPresent(VolumeStatistics.self, forKey: .volumeStatistics)
        volumeStatistics = volumeStatisticsDecoded
        let readRatePercentDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .readRatePercent)
        readRatePercent = readRatePercentDecoded
        let domainIspPlacementsContainer = try containerValues.decodeIfPresent([DomainIspPlacement?].self, forKey: .domainIspPlacements)
        var domainIspPlacementsDecoded0:[DomainIspPlacement]? = nil
        if let domainIspPlacementsContainer = domainIspPlacementsContainer {
            domainIspPlacementsDecoded0 = [DomainIspPlacement]()
            for structure0 in domainIspPlacementsContainer {
                if let structure0 = structure0 {
                    domainIspPlacementsDecoded0?.append(structure0)
                }
            }
        }
        domainIspPlacements = domainIspPlacementsDecoded0
    }
}

extension OverallVolume: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OverallVolume(domainIspPlacements: \(String(describing: domainIspPlacements)), readRatePercent: \(String(describing: readRatePercent)), volumeStatistics: \(String(describing: volumeStatistics)))"}
}

/// <p>An object that contains information about email that was sent from the selected
///             domain.</p>
public struct OverallVolume: Equatable {
    /// <p>An object that contains inbox and junk mail placement metrics for individual email
    ///             providers.</p>
    public let domainIspPlacements: [DomainIspPlacement]?
    /// <p>The percentage of emails that were sent from the domain that were read by their
    ///             recipients.</p>
    public let readRatePercent: Double?
    /// <p>An object that contains information about the numbers of messages that arrived in
    ///             recipients' inboxes and junk mail folders.</p>
    public let volumeStatistics: VolumeStatistics?

    public init (
        domainIspPlacements: [DomainIspPlacement]? = nil,
        readRatePercent: Double? = nil,
        volumeStatistics: VolumeStatistics? = nil
    )
    {
        self.domainIspPlacements = domainIspPlacements
        self.readRatePercent = readRatePercent
        self.volumeStatistics = volumeStatistics
    }
}

extension PinpointDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationArn = "ApplicationArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

extension PinpointDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PinpointDestination(applicationArn: \(String(describing: applicationArn)))"}
}

/// <p>An object that defines an Amazon Pinpoint project destination for email events. You can send
///             email event data to a Amazon Pinpoint project to view metrics using the Transactional Messaging
///             dashboards that are built in to Amazon Pinpoint. For more information, see <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/analytics-transactional-messages.html">Transactional
///                 Messaging Charts</a> in the <i>Amazon Pinpoint User Guide</i>.</p>
public struct PinpointDestination: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon Pinpoint project that you want to send email
    ///             events to.</p>
    public let applicationArn: String?

    public init (
        applicationArn: String? = nil
    )
    {
        self.applicationArn = applicationArn
    }
}

extension PlacementStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dkimPercentage = "DkimPercentage"
        case inboxPercentage = "InboxPercentage"
        case missingPercentage = "MissingPercentage"
        case spamPercentage = "SpamPercentage"
        case spfPercentage = "SpfPercentage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dkimPercentage = dkimPercentage {
            try encodeContainer.encode(dkimPercentage, forKey: .dkimPercentage)
        }
        if let inboxPercentage = inboxPercentage {
            try encodeContainer.encode(inboxPercentage, forKey: .inboxPercentage)
        }
        if let missingPercentage = missingPercentage {
            try encodeContainer.encode(missingPercentage, forKey: .missingPercentage)
        }
        if let spamPercentage = spamPercentage {
            try encodeContainer.encode(spamPercentage, forKey: .spamPercentage)
        }
        if let spfPercentage = spfPercentage {
            try encodeContainer.encode(spfPercentage, forKey: .spfPercentage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inboxPercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .inboxPercentage)
        inboxPercentage = inboxPercentageDecoded
        let spamPercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .spamPercentage)
        spamPercentage = spamPercentageDecoded
        let missingPercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .missingPercentage)
        missingPercentage = missingPercentageDecoded
        let spfPercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .spfPercentage)
        spfPercentage = spfPercentageDecoded
        let dkimPercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .dkimPercentage)
        dkimPercentage = dkimPercentageDecoded
    }
}

extension PlacementStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlacementStatistics(dkimPercentage: \(String(describing: dkimPercentage)), inboxPercentage: \(String(describing: inboxPercentage)), missingPercentage: \(String(describing: missingPercentage)), spamPercentage: \(String(describing: spamPercentage)), spfPercentage: \(String(describing: spfPercentage)))"}
}

/// <p>An object that contains inbox placement data for an email provider.</p>
public struct PlacementStatistics: Equatable {
    /// <p>The percentage of emails that were authenticated by using DomainKeys Identified Mail
    ///             (DKIM) during the predictive inbox placement test.</p>
    public let dkimPercentage: Double?
    /// <p>The percentage of emails that arrived in recipients' inboxes during the predictive inbox placement test.</p>
    public let inboxPercentage: Double?
    /// <p>The percentage of emails that didn't arrive in recipients' inboxes at all during the
    ///             predictive inbox placement test.</p>
    public let missingPercentage: Double?
    /// <p>The percentage of emails that arrived in recipients' spam or junk mail folders during
    ///             the predictive inbox placement test.</p>
    public let spamPercentage: Double?
    /// <p>The percentage of emails that were authenticated by using Sender Policy Framework
    ///             (SPF) during the predictive inbox placement test.</p>
    public let spfPercentage: Double?

    public init (
        dkimPercentage: Double? = nil,
        inboxPercentage: Double? = nil,
        missingPercentage: Double? = nil,
        spamPercentage: Double? = nil,
        spfPercentage: Double? = nil
    )
    {
        self.dkimPercentage = dkimPercentage
        self.inboxPercentage = inboxPercentage
        self.missingPercentage = missingPercentage
        self.spamPercentage = spamPercentage
        self.spfPercentage = spfPercentage
    }
}

public struct PutAccountDedicatedIpWarmupAttributesInputBodyMiddleware: Middleware {
    public let id: String = "PutAccountDedicatedIpWarmupAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountDedicatedIpWarmupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountDedicatedIpWarmupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountDedicatedIpWarmupAttributesInput>
    public typealias MOutput = OperationOutput<PutAccountDedicatedIpWarmupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountDedicatedIpWarmupAttributesOutputError>
}

extension PutAccountDedicatedIpWarmupAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccountDedicatedIpWarmupAttributesInput(autoWarmupEnabled: \(String(describing: autoWarmupEnabled)))"}
}

extension PutAccountDedicatedIpWarmupAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoWarmupEnabled = "AutoWarmupEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoWarmupEnabled != false {
            try encodeContainer.encode(autoWarmupEnabled, forKey: .autoWarmupEnabled)
        }
    }
}

public struct PutAccountDedicatedIpWarmupAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "PutAccountDedicatedIpWarmupAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountDedicatedIpWarmupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountDedicatedIpWarmupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountDedicatedIpWarmupAttributesInput>
    public typealias MOutput = OperationOutput<PutAccountDedicatedIpWarmupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountDedicatedIpWarmupAttributesOutputError>
}

public struct PutAccountDedicatedIpWarmupAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "PutAccountDedicatedIpWarmupAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountDedicatedIpWarmupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountDedicatedIpWarmupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountDedicatedIpWarmupAttributesInput>
    public typealias MOutput = OperationOutput<PutAccountDedicatedIpWarmupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountDedicatedIpWarmupAttributesOutputError>
}

/// <p>A request to enable or disable the automatic IP address warm-up feature.</p>
public struct PutAccountDedicatedIpWarmupAttributesInput: Equatable {
    /// <p>Enables or disables the automatic warm-up feature for dedicated IP addresses that are
    ///             associated with your Amazon SES account in the current AWS Region. Set to <code>true</code>
    ///             to enable the automatic warm-up feature, or set to <code>false</code> to disable
    ///             it.</p>
    public let autoWarmupEnabled: Bool

    public init (
        autoWarmupEnabled: Bool = false
    )
    {
        self.autoWarmupEnabled = autoWarmupEnabled
    }
}

struct PutAccountDedicatedIpWarmupAttributesInputBody: Equatable {
    public let autoWarmupEnabled: Bool
}

extension PutAccountDedicatedIpWarmupAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoWarmupEnabled = "AutoWarmupEnabled"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoWarmupEnabledDecoded = try containerValues.decode(Bool.self, forKey: .autoWarmupEnabled)
        autoWarmupEnabled = autoWarmupEnabledDecoded
    }
}

extension PutAccountDedicatedIpWarmupAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAccountDedicatedIpWarmupAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAccountDedicatedIpWarmupAttributesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAccountDedicatedIpWarmupAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccountDedicatedIpWarmupAttributesOutputResponse()"}
}

extension PutAccountDedicatedIpWarmupAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutAccountDedicatedIpWarmupAttributesOutputResponse: Equatable {

    public init() {}
}

struct PutAccountDedicatedIpWarmupAttributesOutputResponseBody: Equatable {
}

extension PutAccountDedicatedIpWarmupAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutAccountDetailsInputBodyMiddleware: Middleware {
    public let id: String = "PutAccountDetailsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountDetailsInput>
    public typealias MOutput = OperationOutput<PutAccountDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountDetailsOutputError>
}

extension PutAccountDetailsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccountDetailsInput(additionalContactEmailAddresses: \(String(describing: additionalContactEmailAddresses)), contactLanguage: \(String(describing: contactLanguage)), mailType: \(String(describing: mailType)), productionAccessEnabled: \(String(describing: productionAccessEnabled)), useCaseDescription: \(String(describing: useCaseDescription)), websiteURL: \(String(describing: websiteURL)))"}
}

extension PutAccountDetailsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalContactEmailAddresses = "AdditionalContactEmailAddresses"
        case contactLanguage = "ContactLanguage"
        case mailType = "MailType"
        case productionAccessEnabled = "ProductionAccessEnabled"
        case useCaseDescription = "UseCaseDescription"
        case websiteURL = "WebsiteURL"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalContactEmailAddresses = additionalContactEmailAddresses {
            var additionalContactEmailAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalContactEmailAddresses)
            for additionalcontactemailaddresses0 in additionalContactEmailAddresses {
                try additionalContactEmailAddressesContainer.encode(additionalcontactemailaddresses0)
            }
        }
        if let contactLanguage = contactLanguage {
            try encodeContainer.encode(contactLanguage.rawValue, forKey: .contactLanguage)
        }
        if let mailType = mailType {
            try encodeContainer.encode(mailType.rawValue, forKey: .mailType)
        }
        if let productionAccessEnabled = productionAccessEnabled {
            try encodeContainer.encode(productionAccessEnabled, forKey: .productionAccessEnabled)
        }
        if let useCaseDescription = useCaseDescription {
            try encodeContainer.encode(useCaseDescription, forKey: .useCaseDescription)
        }
        if let websiteURL = websiteURL {
            try encodeContainer.encode(websiteURL, forKey: .websiteURL)
        }
    }
}

public struct PutAccountDetailsInputHeadersMiddleware: Middleware {
    public let id: String = "PutAccountDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountDetailsInput>
    public typealias MOutput = OperationOutput<PutAccountDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountDetailsOutputError>
}

public struct PutAccountDetailsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutAccountDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountDetailsInput>
    public typealias MOutput = OperationOutput<PutAccountDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountDetailsOutputError>
}

/// <p>A request to submit new account details.</p>
public struct PutAccountDetailsInput: Equatable {
    /// <p>Additional email addresses that you would like to be notified regarding Amazon SES
    ///             matters.</p>
    public let additionalContactEmailAddresses: [String]?
    /// <p>The language you would prefer to be contacted with.</p>
    public let contactLanguage: ContactLanguage?
    /// <p>The type of email your account will send.</p>
    public let mailType: MailType?
    /// <p>Indicates whether or not your account should have production access in the current
    ///             AWS Region.</p>
    ///         <p>If the value is <code>false</code>, then your account is in the
    ///                 <i>sandbox</i>. When your account is in the sandbox, you can only send
    ///             email to verified identities. Additionally, the maximum number of emails you can send in
    ///             a 24-hour period (your sending quota) is 200, and the maximum number of emails you can
    ///             send per second (your maximum sending rate) is 1.</p>
    ///         <p>If the value is <code>true</code>, then your account has production access. When your
    ///             account has production access, you can send email to any address. The sending quota and
    ///             maximum sending rate for your account vary based on your specific use case.</p>
    public let productionAccessEnabled: Bool?
    /// <p>A description of the types of email that you plan to send.</p>
    public let useCaseDescription: String?
    /// <p>The URL of your website. This information helps us better understand the type of
    ///             content that you plan to send.</p>
    public let websiteURL: String?

    public init (
        additionalContactEmailAddresses: [String]? = nil,
        contactLanguage: ContactLanguage? = nil,
        mailType: MailType? = nil,
        productionAccessEnabled: Bool? = nil,
        useCaseDescription: String? = nil,
        websiteURL: String? = nil
    )
    {
        self.additionalContactEmailAddresses = additionalContactEmailAddresses
        self.contactLanguage = contactLanguage
        self.mailType = mailType
        self.productionAccessEnabled = productionAccessEnabled
        self.useCaseDescription = useCaseDescription
        self.websiteURL = websiteURL
    }
}

struct PutAccountDetailsInputBody: Equatable {
    public let mailType: MailType?
    public let websiteURL: String?
    public let contactLanguage: ContactLanguage?
    public let useCaseDescription: String?
    public let additionalContactEmailAddresses: [String]?
    public let productionAccessEnabled: Bool?
}

extension PutAccountDetailsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case additionalContactEmailAddresses = "AdditionalContactEmailAddresses"
        case contactLanguage = "ContactLanguage"
        case mailType = "MailType"
        case productionAccessEnabled = "ProductionAccessEnabled"
        case useCaseDescription = "UseCaseDescription"
        case websiteURL = "WebsiteURL"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mailTypeDecoded = try containerValues.decodeIfPresent(MailType.self, forKey: .mailType)
        mailType = mailTypeDecoded
        let websiteURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .websiteURL)
        websiteURL = websiteURLDecoded
        let contactLanguageDecoded = try containerValues.decodeIfPresent(ContactLanguage.self, forKey: .contactLanguage)
        contactLanguage = contactLanguageDecoded
        let useCaseDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .useCaseDescription)
        useCaseDescription = useCaseDescriptionDecoded
        let additionalContactEmailAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .additionalContactEmailAddresses)
        var additionalContactEmailAddressesDecoded0:[String]? = nil
        if let additionalContactEmailAddressesContainer = additionalContactEmailAddressesContainer {
            additionalContactEmailAddressesDecoded0 = [String]()
            for string0 in additionalContactEmailAddressesContainer {
                if let string0 = string0 {
                    additionalContactEmailAddressesDecoded0?.append(string0)
                }
            }
        }
        additionalContactEmailAddresses = additionalContactEmailAddressesDecoded0
        let productionAccessEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .productionAccessEnabled)
        productionAccessEnabled = productionAccessEnabledDecoded
    }
}

extension PutAccountDetailsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAccountDetailsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAccountDetailsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAccountDetailsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccountDetailsOutputResponse()"}
}

extension PutAccountDetailsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutAccountDetailsOutputResponse: Equatable {

    public init() {}
}

struct PutAccountDetailsOutputResponseBody: Equatable {
}

extension PutAccountDetailsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutAccountSendingAttributesInputBodyMiddleware: Middleware {
    public let id: String = "PutAccountSendingAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountSendingAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountSendingAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountSendingAttributesInput>
    public typealias MOutput = OperationOutput<PutAccountSendingAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountSendingAttributesOutputError>
}

extension PutAccountSendingAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccountSendingAttributesInput(sendingEnabled: \(String(describing: sendingEnabled)))"}
}

extension PutAccountSendingAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sendingEnabled = "SendingEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if sendingEnabled != false {
            try encodeContainer.encode(sendingEnabled, forKey: .sendingEnabled)
        }
    }
}

public struct PutAccountSendingAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "PutAccountSendingAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountSendingAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountSendingAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountSendingAttributesInput>
    public typealias MOutput = OperationOutput<PutAccountSendingAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountSendingAttributesOutputError>
}

public struct PutAccountSendingAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "PutAccountSendingAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountSendingAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountSendingAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountSendingAttributesInput>
    public typealias MOutput = OperationOutput<PutAccountSendingAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountSendingAttributesOutputError>
}

/// <p>A request to change the ability of your account to send email.</p>
public struct PutAccountSendingAttributesInput: Equatable {
    /// <p>Enables or disables your account's ability to send email. Set to <code>true</code> to
    ///             enable email sending, or set to <code>false</code> to disable email sending.</p>
    ///         <note>
    ///             <p>If AWS paused your account's ability to send email, you can't use this operation
    ///                 to resume your account's ability to send email.</p>
    ///         </note>
    public let sendingEnabled: Bool

    public init (
        sendingEnabled: Bool = false
    )
    {
        self.sendingEnabled = sendingEnabled
    }
}

struct PutAccountSendingAttributesInputBody: Equatable {
    public let sendingEnabled: Bool
}

extension PutAccountSendingAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sendingEnabled = "SendingEnabled"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sendingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .sendingEnabled)
        sendingEnabled = sendingEnabledDecoded
    }
}

extension PutAccountSendingAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAccountSendingAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAccountSendingAttributesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAccountSendingAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccountSendingAttributesOutputResponse()"}
}

extension PutAccountSendingAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutAccountSendingAttributesOutputResponse: Equatable {

    public init() {}
}

struct PutAccountSendingAttributesOutputResponseBody: Equatable {
}

extension PutAccountSendingAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutAccountSuppressionAttributesInputBodyMiddleware: Middleware {
    public let id: String = "PutAccountSuppressionAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountSuppressionAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountSuppressionAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountSuppressionAttributesInput>
    public typealias MOutput = OperationOutput<PutAccountSuppressionAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountSuppressionAttributesOutputError>
}

extension PutAccountSuppressionAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccountSuppressionAttributesInput(suppressedReasons: \(String(describing: suppressedReasons)))"}
}

extension PutAccountSuppressionAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case suppressedReasons = "SuppressedReasons"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let suppressedReasons = suppressedReasons {
            var suppressedReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .suppressedReasons)
            for suppressionlistreasons0 in suppressedReasons {
                try suppressedReasonsContainer.encode(suppressionlistreasons0.rawValue)
            }
        }
    }
}

public struct PutAccountSuppressionAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "PutAccountSuppressionAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountSuppressionAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountSuppressionAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountSuppressionAttributesInput>
    public typealias MOutput = OperationOutput<PutAccountSuppressionAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountSuppressionAttributesOutputError>
}

public struct PutAccountSuppressionAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "PutAccountSuppressionAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountSuppressionAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountSuppressionAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountSuppressionAttributesInput>
    public typealias MOutput = OperationOutput<PutAccountSuppressionAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountSuppressionAttributesOutputError>
}

/// <p>A request to change your account's suppression preferences.</p>
public struct PutAccountSuppressionAttributesInput: Equatable {
    /// <p>A list that contains the reasons that email addresses will be automatically added to
    ///             the suppression list for your account. This list can contain any or all of the
    ///             following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>COMPLAINT</code> – Amazon SES adds an email address to the suppression
    ///                     list for your account when a message sent to that address results in a
    ///                     complaint.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>BOUNCE</code> – Amazon SES adds an email address to the suppression
    ///                     list for your account when a message sent to that address results in a hard
    ///                     bounce.</p>
    ///             </li>
    ///          </ul>
    public let suppressedReasons: [SuppressionListReason]?

    public init (
        suppressedReasons: [SuppressionListReason]? = nil
    )
    {
        self.suppressedReasons = suppressedReasons
    }
}

struct PutAccountSuppressionAttributesInputBody: Equatable {
    public let suppressedReasons: [SuppressionListReason]?
}

extension PutAccountSuppressionAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case suppressedReasons = "SuppressedReasons"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suppressedReasonsContainer = try containerValues.decodeIfPresent([SuppressionListReason?].self, forKey: .suppressedReasons)
        var suppressedReasonsDecoded0:[SuppressionListReason]? = nil
        if let suppressedReasonsContainer = suppressedReasonsContainer {
            suppressedReasonsDecoded0 = [SuppressionListReason]()
            for string0 in suppressedReasonsContainer {
                if let string0 = string0 {
                    suppressedReasonsDecoded0?.append(string0)
                }
            }
        }
        suppressedReasons = suppressedReasonsDecoded0
    }
}

extension PutAccountSuppressionAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAccountSuppressionAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAccountSuppressionAttributesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAccountSuppressionAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccountSuppressionAttributesOutputResponse()"}
}

extension PutAccountSuppressionAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutAccountSuppressionAttributesOutputResponse: Equatable {

    public init() {}
}

struct PutAccountSuppressionAttributesOutputResponseBody: Equatable {
}

extension PutAccountSuppressionAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutConfigurationSetDeliveryOptionsInputBodyMiddleware: Middleware {
    public let id: String = "PutConfigurationSetDeliveryOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetDeliveryOptionsOutputError>
}

extension PutConfigurationSetDeliveryOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationSetDeliveryOptionsInput(configurationSetName: \(String(describing: configurationSetName)), sendingPoolName: \(String(describing: sendingPoolName)), tlsPolicy: \(String(describing: tlsPolicy)))"}
}

extension PutConfigurationSetDeliveryOptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sendingPoolName = "SendingPoolName"
        case tlsPolicy = "TlsPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sendingPoolName = sendingPoolName {
            try encodeContainer.encode(sendingPoolName, forKey: .sendingPoolName)
        }
        if let tlsPolicy = tlsPolicy {
            try encodeContainer.encode(tlsPolicy.rawValue, forKey: .tlsPolicy)
        }
    }
}

public struct PutConfigurationSetDeliveryOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "PutConfigurationSetDeliveryOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetDeliveryOptionsOutputError>
}

public struct PutConfigurationSetDeliveryOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutConfigurationSetDeliveryOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetDeliveryOptionsOutputError>
}

/// <p>A request to associate a configuration set with a dedicated IP pool.</p>
public struct PutConfigurationSetDeliveryOptionsInput: Equatable {
    /// <p>The name of the configuration set that you want to associate with a dedicated IP
    ///             pool.</p>
    public let configurationSetName: String?
    /// <p>The name of the dedicated IP pool that you want to associate with the configuration
    ///             set.</p>
    public let sendingPoolName: String?
    /// <p>Specifies whether messages that use the configuration set are required to use
    ///             Transport Layer Security (TLS). If the value is <code>Require</code>, messages are only
    ///             delivered if a TLS connection can be established. If the value is <code>Optional</code>,
    ///             messages can be delivered in plain text if a TLS connection can't be established.</p>
    public let tlsPolicy: TlsPolicy?

    public init (
        configurationSetName: String? = nil,
        sendingPoolName: String? = nil,
        tlsPolicy: TlsPolicy? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.sendingPoolName = sendingPoolName
        self.tlsPolicy = tlsPolicy
    }
}

struct PutConfigurationSetDeliveryOptionsInputBody: Equatable {
    public let tlsPolicy: TlsPolicy?
    public let sendingPoolName: String?
}

extension PutConfigurationSetDeliveryOptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sendingPoolName = "SendingPoolName"
        case tlsPolicy = "TlsPolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tlsPolicyDecoded = try containerValues.decodeIfPresent(TlsPolicy.self, forKey: .tlsPolicy)
        tlsPolicy = tlsPolicyDecoded
        let sendingPoolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sendingPoolName)
        sendingPoolName = sendingPoolNameDecoded
    }
}

extension PutConfigurationSetDeliveryOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConfigurationSetDeliveryOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutConfigurationSetDeliveryOptionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConfigurationSetDeliveryOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationSetDeliveryOptionsOutputResponse()"}
}

extension PutConfigurationSetDeliveryOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutConfigurationSetDeliveryOptionsOutputResponse: Equatable {

    public init() {}
}

struct PutConfigurationSetDeliveryOptionsOutputResponseBody: Equatable {
}

extension PutConfigurationSetDeliveryOptionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutConfigurationSetReputationOptionsInputBodyMiddleware: Middleware {
    public let id: String = "PutConfigurationSetReputationOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetReputationOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetReputationOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetReputationOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetReputationOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetReputationOptionsOutputError>
}

extension PutConfigurationSetReputationOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationSetReputationOptionsInput(configurationSetName: \(String(describing: configurationSetName)), reputationMetricsEnabled: \(String(describing: reputationMetricsEnabled)))"}
}

extension PutConfigurationSetReputationOptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reputationMetricsEnabled = "ReputationMetricsEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if reputationMetricsEnabled != false {
            try encodeContainer.encode(reputationMetricsEnabled, forKey: .reputationMetricsEnabled)
        }
    }
}

public struct PutConfigurationSetReputationOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "PutConfigurationSetReputationOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetReputationOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetReputationOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetReputationOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetReputationOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetReputationOptionsOutputError>
}

public struct PutConfigurationSetReputationOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutConfigurationSetReputationOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetReputationOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetReputationOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetReputationOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetReputationOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetReputationOptionsOutputError>
}

/// <p>A request to enable or disable tracking of reputation metrics for a configuration
///             set.</p>
public struct PutConfigurationSetReputationOptionsInput: Equatable {
    /// <p>The name of the configuration set that you want to enable or disable reputation metric
    ///             tracking for.</p>
    public let configurationSetName: String?
    /// <p>If <code>true</code>, tracking of reputation metrics is enabled for the configuration
    ///             set. If <code>false</code>, tracking of reputation metrics is disabled for the
    ///             configuration set.</p>
    public let reputationMetricsEnabled: Bool

    public init (
        configurationSetName: String? = nil,
        reputationMetricsEnabled: Bool = false
    )
    {
        self.configurationSetName = configurationSetName
        self.reputationMetricsEnabled = reputationMetricsEnabled
    }
}

struct PutConfigurationSetReputationOptionsInputBody: Equatable {
    public let reputationMetricsEnabled: Bool
}

extension PutConfigurationSetReputationOptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reputationMetricsEnabled = "ReputationMetricsEnabled"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reputationMetricsEnabledDecoded = try containerValues.decode(Bool.self, forKey: .reputationMetricsEnabled)
        reputationMetricsEnabled = reputationMetricsEnabledDecoded
    }
}

extension PutConfigurationSetReputationOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConfigurationSetReputationOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutConfigurationSetReputationOptionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConfigurationSetReputationOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationSetReputationOptionsOutputResponse()"}
}

extension PutConfigurationSetReputationOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutConfigurationSetReputationOptionsOutputResponse: Equatable {

    public init() {}
}

struct PutConfigurationSetReputationOptionsOutputResponseBody: Equatable {
}

extension PutConfigurationSetReputationOptionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutConfigurationSetSendingOptionsInputBodyMiddleware: Middleware {
    public let id: String = "PutConfigurationSetSendingOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetSendingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetSendingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetSendingOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetSendingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetSendingOptionsOutputError>
}

extension PutConfigurationSetSendingOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationSetSendingOptionsInput(configurationSetName: \(String(describing: configurationSetName)), sendingEnabled: \(String(describing: sendingEnabled)))"}
}

extension PutConfigurationSetSendingOptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sendingEnabled = "SendingEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if sendingEnabled != false {
            try encodeContainer.encode(sendingEnabled, forKey: .sendingEnabled)
        }
    }
}

public struct PutConfigurationSetSendingOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "PutConfigurationSetSendingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetSendingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetSendingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetSendingOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetSendingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetSendingOptionsOutputError>
}

public struct PutConfigurationSetSendingOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutConfigurationSetSendingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetSendingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetSendingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetSendingOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetSendingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetSendingOptionsOutputError>
}

/// <p>A request to enable or disable the ability of Amazon SES to send emails that use a specific
///             configuration set.</p>
public struct PutConfigurationSetSendingOptionsInput: Equatable {
    /// <p>The name of the configuration set that you want to enable or disable email sending
    ///             for.</p>
    public let configurationSetName: String?
    /// <p>If <code>true</code>, email sending is enabled for the configuration set. If
    ///                 <code>false</code>, email sending is disabled for the configuration set.</p>
    public let sendingEnabled: Bool

    public init (
        configurationSetName: String? = nil,
        sendingEnabled: Bool = false
    )
    {
        self.configurationSetName = configurationSetName
        self.sendingEnabled = sendingEnabled
    }
}

struct PutConfigurationSetSendingOptionsInputBody: Equatable {
    public let sendingEnabled: Bool
}

extension PutConfigurationSetSendingOptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sendingEnabled = "SendingEnabled"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sendingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .sendingEnabled)
        sendingEnabled = sendingEnabledDecoded
    }
}

extension PutConfigurationSetSendingOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConfigurationSetSendingOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutConfigurationSetSendingOptionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConfigurationSetSendingOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationSetSendingOptionsOutputResponse()"}
}

extension PutConfigurationSetSendingOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutConfigurationSetSendingOptionsOutputResponse: Equatable {

    public init() {}
}

struct PutConfigurationSetSendingOptionsOutputResponseBody: Equatable {
}

extension PutConfigurationSetSendingOptionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutConfigurationSetSuppressionOptionsInputBodyMiddleware: Middleware {
    public let id: String = "PutConfigurationSetSuppressionOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetSuppressionOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetSuppressionOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetSuppressionOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetSuppressionOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetSuppressionOptionsOutputError>
}

extension PutConfigurationSetSuppressionOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationSetSuppressionOptionsInput(configurationSetName: \(String(describing: configurationSetName)), suppressedReasons: \(String(describing: suppressedReasons)))"}
}

extension PutConfigurationSetSuppressionOptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case suppressedReasons = "SuppressedReasons"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let suppressedReasons = suppressedReasons {
            var suppressedReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .suppressedReasons)
            for suppressionlistreasons0 in suppressedReasons {
                try suppressedReasonsContainer.encode(suppressionlistreasons0.rawValue)
            }
        }
    }
}

public struct PutConfigurationSetSuppressionOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "PutConfigurationSetSuppressionOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetSuppressionOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetSuppressionOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetSuppressionOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetSuppressionOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetSuppressionOptionsOutputError>
}

public struct PutConfigurationSetSuppressionOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutConfigurationSetSuppressionOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetSuppressionOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetSuppressionOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetSuppressionOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetSuppressionOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetSuppressionOptionsOutputError>
}

/// <p>A request to change the account suppression list preferences for a specific
///             configuration set.</p>
public struct PutConfigurationSetSuppressionOptionsInput: Equatable {
    /// <p>The name of the configuration set that you want to change the suppression list
    ///             preferences for.</p>
    public let configurationSetName: String?
    /// <p>A list that contains the reasons that email addresses are automatically added to the
    ///             suppression list for your account. This list can contain any or all of the
    ///             following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>COMPLAINT</code> – Amazon SES adds an email address to the suppression
    ///                     list for your account when a message sent to that address results in a
    ///                     complaint.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>BOUNCE</code> – Amazon SES adds an email address to the suppression
    ///                     list for your account when a message sent to that address results in a
    ///                     hard bounce.</p>
    ///             </li>
    ///          </ul>
    public let suppressedReasons: [SuppressionListReason]?

    public init (
        configurationSetName: String? = nil,
        suppressedReasons: [SuppressionListReason]? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.suppressedReasons = suppressedReasons
    }
}

struct PutConfigurationSetSuppressionOptionsInputBody: Equatable {
    public let suppressedReasons: [SuppressionListReason]?
}

extension PutConfigurationSetSuppressionOptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case suppressedReasons = "SuppressedReasons"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suppressedReasonsContainer = try containerValues.decodeIfPresent([SuppressionListReason?].self, forKey: .suppressedReasons)
        var suppressedReasonsDecoded0:[SuppressionListReason]? = nil
        if let suppressedReasonsContainer = suppressedReasonsContainer {
            suppressedReasonsDecoded0 = [SuppressionListReason]()
            for string0 in suppressedReasonsContainer {
                if let string0 = string0 {
                    suppressedReasonsDecoded0?.append(string0)
                }
            }
        }
        suppressedReasons = suppressedReasonsDecoded0
    }
}

extension PutConfigurationSetSuppressionOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConfigurationSetSuppressionOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutConfigurationSetSuppressionOptionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConfigurationSetSuppressionOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationSetSuppressionOptionsOutputResponse()"}
}

extension PutConfigurationSetSuppressionOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutConfigurationSetSuppressionOptionsOutputResponse: Equatable {

    public init() {}
}

struct PutConfigurationSetSuppressionOptionsOutputResponseBody: Equatable {
}

extension PutConfigurationSetSuppressionOptionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutConfigurationSetTrackingOptionsInputBodyMiddleware: Middleware {
    public let id: String = "PutConfigurationSetTrackingOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetTrackingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetTrackingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetTrackingOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetTrackingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetTrackingOptionsOutputError>
}

extension PutConfigurationSetTrackingOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationSetTrackingOptionsInput(configurationSetName: \(String(describing: configurationSetName)), customRedirectDomain: \(String(describing: customRedirectDomain)))"}
}

extension PutConfigurationSetTrackingOptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customRedirectDomain = "CustomRedirectDomain"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customRedirectDomain = customRedirectDomain {
            try encodeContainer.encode(customRedirectDomain, forKey: .customRedirectDomain)
        }
    }
}

public struct PutConfigurationSetTrackingOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "PutConfigurationSetTrackingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetTrackingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetTrackingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetTrackingOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetTrackingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetTrackingOptionsOutputError>
}

public struct PutConfigurationSetTrackingOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutConfigurationSetTrackingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetTrackingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetTrackingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetTrackingOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetTrackingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetTrackingOptionsOutputError>
}

/// <p>A request to add a custom domain for tracking open and click events to a configuration
///             set.</p>
public struct PutConfigurationSetTrackingOptionsInput: Equatable {
    /// <p>The name of the configuration set that you want to add a custom tracking domain
    ///             to.</p>
    public let configurationSetName: String?
    /// <p>The domain that you want to use to track open and click events.</p>
    public let customRedirectDomain: String?

    public init (
        configurationSetName: String? = nil,
        customRedirectDomain: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.customRedirectDomain = customRedirectDomain
    }
}

struct PutConfigurationSetTrackingOptionsInputBody: Equatable {
    public let customRedirectDomain: String?
}

extension PutConfigurationSetTrackingOptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customRedirectDomain = "CustomRedirectDomain"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customRedirectDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customRedirectDomain)
        customRedirectDomain = customRedirectDomainDecoded
    }
}

extension PutConfigurationSetTrackingOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConfigurationSetTrackingOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutConfigurationSetTrackingOptionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConfigurationSetTrackingOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationSetTrackingOptionsOutputResponse()"}
}

extension PutConfigurationSetTrackingOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutConfigurationSetTrackingOptionsOutputResponse: Equatable {

    public init() {}
}

struct PutConfigurationSetTrackingOptionsOutputResponseBody: Equatable {
}

extension PutConfigurationSetTrackingOptionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutDedicatedIpInPoolInputBodyMiddleware: Middleware {
    public let id: String = "PutDedicatedIpInPoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDedicatedIpInPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDedicatedIpInPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDedicatedIpInPoolInput>
    public typealias MOutput = OperationOutput<PutDedicatedIpInPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDedicatedIpInPoolOutputError>
}

extension PutDedicatedIpInPoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDedicatedIpInPoolInput(destinationPoolName: \(String(describing: destinationPoolName)), ip: \(String(describing: ip)))"}
}

extension PutDedicatedIpInPoolInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationPoolName = "DestinationPoolName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationPoolName = destinationPoolName {
            try encodeContainer.encode(destinationPoolName, forKey: .destinationPoolName)
        }
    }
}

public struct PutDedicatedIpInPoolInputHeadersMiddleware: Middleware {
    public let id: String = "PutDedicatedIpInPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDedicatedIpInPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDedicatedIpInPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDedicatedIpInPoolInput>
    public typealias MOutput = OperationOutput<PutDedicatedIpInPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDedicatedIpInPoolOutputError>
}

public struct PutDedicatedIpInPoolInputQueryItemMiddleware: Middleware {
    public let id: String = "PutDedicatedIpInPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDedicatedIpInPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDedicatedIpInPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDedicatedIpInPoolInput>
    public typealias MOutput = OperationOutput<PutDedicatedIpInPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDedicatedIpInPoolOutputError>
}

/// <p>A request to move a dedicated IP address to a dedicated IP pool.</p>
public struct PutDedicatedIpInPoolInput: Equatable {
    /// <p>The name of the IP pool that you want to add the dedicated IP address to. You have to
    ///             specify an IP pool that already exists.</p>
    public let destinationPoolName: String?
    /// <p>The IP address that you want to move to the dedicated IP pool. The value you specify
    ///             has to be a dedicated IP address that's associated with your AWS account.</p>
    public let ip: String?

    public init (
        destinationPoolName: String? = nil,
        ip: String? = nil
    )
    {
        self.destinationPoolName = destinationPoolName
        self.ip = ip
    }
}

struct PutDedicatedIpInPoolInputBody: Equatable {
    public let destinationPoolName: String?
}

extension PutDedicatedIpInPoolInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationPoolName = "DestinationPoolName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPoolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationPoolName)
        destinationPoolName = destinationPoolNameDecoded
    }
}

extension PutDedicatedIpInPoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDedicatedIpInPoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDedicatedIpInPoolOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDedicatedIpInPoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDedicatedIpInPoolOutputResponse()"}
}

extension PutDedicatedIpInPoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutDedicatedIpInPoolOutputResponse: Equatable {

    public init() {}
}

struct PutDedicatedIpInPoolOutputResponseBody: Equatable {
}

extension PutDedicatedIpInPoolOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutDedicatedIpWarmupAttributesInputBodyMiddleware: Middleware {
    public let id: String = "PutDedicatedIpWarmupAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDedicatedIpWarmupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDedicatedIpWarmupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDedicatedIpWarmupAttributesInput>
    public typealias MOutput = OperationOutput<PutDedicatedIpWarmupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDedicatedIpWarmupAttributesOutputError>
}

extension PutDedicatedIpWarmupAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDedicatedIpWarmupAttributesInput(ip: \(String(describing: ip)), warmupPercentage: \(String(describing: warmupPercentage)))"}
}

extension PutDedicatedIpWarmupAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case warmupPercentage = "WarmupPercentage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let warmupPercentage = warmupPercentage {
            try encodeContainer.encode(warmupPercentage, forKey: .warmupPercentage)
        }
    }
}

public struct PutDedicatedIpWarmupAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "PutDedicatedIpWarmupAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDedicatedIpWarmupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDedicatedIpWarmupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDedicatedIpWarmupAttributesInput>
    public typealias MOutput = OperationOutput<PutDedicatedIpWarmupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDedicatedIpWarmupAttributesOutputError>
}

public struct PutDedicatedIpWarmupAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "PutDedicatedIpWarmupAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDedicatedIpWarmupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDedicatedIpWarmupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDedicatedIpWarmupAttributesInput>
    public typealias MOutput = OperationOutput<PutDedicatedIpWarmupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDedicatedIpWarmupAttributesOutputError>
}

/// <p>A request to change the warm-up attributes for a dedicated IP address. This operation
///             is useful when you want to resume the warm-up process for an existing IP address.</p>
public struct PutDedicatedIpWarmupAttributesInput: Equatable {
    /// <p>The dedicated IP address that you want to update the warm-up attributes for.</p>
    public let ip: String?
    /// <p>The warm-up percentage that you want to associate with the dedicated IP
    ///             address.</p>
    public let warmupPercentage: Int?

    public init (
        ip: String? = nil,
        warmupPercentage: Int? = nil
    )
    {
        self.ip = ip
        self.warmupPercentage = warmupPercentage
    }
}

struct PutDedicatedIpWarmupAttributesInputBody: Equatable {
    public let warmupPercentage: Int?
}

extension PutDedicatedIpWarmupAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case warmupPercentage = "WarmupPercentage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let warmupPercentageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .warmupPercentage)
        warmupPercentage = warmupPercentageDecoded
    }
}

extension PutDedicatedIpWarmupAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDedicatedIpWarmupAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDedicatedIpWarmupAttributesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDedicatedIpWarmupAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDedicatedIpWarmupAttributesOutputResponse()"}
}

extension PutDedicatedIpWarmupAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutDedicatedIpWarmupAttributesOutputResponse: Equatable {

    public init() {}
}

struct PutDedicatedIpWarmupAttributesOutputResponseBody: Equatable {
}

extension PutDedicatedIpWarmupAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutDeliverabilityDashboardOptionInputBodyMiddleware: Middleware {
    public let id: String = "PutDeliverabilityDashboardOptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDeliverabilityDashboardOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDeliverabilityDashboardOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDeliverabilityDashboardOptionInput>
    public typealias MOutput = OperationOutput<PutDeliverabilityDashboardOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDeliverabilityDashboardOptionOutputError>
}

extension PutDeliverabilityDashboardOptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDeliverabilityDashboardOptionInput(dashboardEnabled: \(String(describing: dashboardEnabled)), subscribedDomains: \(String(describing: subscribedDomains)))"}
}

extension PutDeliverabilityDashboardOptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dashboardEnabled = "DashboardEnabled"
        case subscribedDomains = "SubscribedDomains"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dashboardEnabled != false {
            try encodeContainer.encode(dashboardEnabled, forKey: .dashboardEnabled)
        }
        if let subscribedDomains = subscribedDomains {
            var subscribedDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribedDomains)
            for domaindeliverabilitytrackingoptions0 in subscribedDomains {
                try subscribedDomainsContainer.encode(domaindeliverabilitytrackingoptions0)
            }
        }
    }
}

public struct PutDeliverabilityDashboardOptionInputHeadersMiddleware: Middleware {
    public let id: String = "PutDeliverabilityDashboardOptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDeliverabilityDashboardOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDeliverabilityDashboardOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDeliverabilityDashboardOptionInput>
    public typealias MOutput = OperationOutput<PutDeliverabilityDashboardOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDeliverabilityDashboardOptionOutputError>
}

public struct PutDeliverabilityDashboardOptionInputQueryItemMiddleware: Middleware {
    public let id: String = "PutDeliverabilityDashboardOptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDeliverabilityDashboardOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDeliverabilityDashboardOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDeliverabilityDashboardOptionInput>
    public typealias MOutput = OperationOutput<PutDeliverabilityDashboardOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDeliverabilityDashboardOptionOutputError>
}

/// <p>Enable or disable the Deliverability dashboard. When you enable the Deliverability dashboard, you gain
///             access to reputation, deliverability, and other metrics for the domains that you use to
///             send email using Amazon SES API v2. You also gain the ability to perform predictive inbox placement tests.</p>
///         <p>When you use the Deliverability dashboard, you pay a monthly subscription charge, in addition
///             to any other fees that you accrue by using Amazon SES and other AWS services. For more
///             information about the features and cost of a Deliverability dashboard subscription, see <a href="http://aws.amazon.com/pinpoint/pricing/">Amazon Pinpoint Pricing</a>.</p>
public struct PutDeliverabilityDashboardOptionInput: Equatable {
    /// <p>Specifies whether to enable the Deliverability dashboard. To enable the dashboard, set this
    ///             value to <code>true</code>.</p>
    public let dashboardEnabled: Bool
    /// <p>An array of objects, one for each verified domain that you use to send email and
    ///             enabled the Deliverability dashboard for.</p>
    public let subscribedDomains: [DomainDeliverabilityTrackingOption]?

    public init (
        dashboardEnabled: Bool = false,
        subscribedDomains: [DomainDeliverabilityTrackingOption]? = nil
    )
    {
        self.dashboardEnabled = dashboardEnabled
        self.subscribedDomains = subscribedDomains
    }
}

struct PutDeliverabilityDashboardOptionInputBody: Equatable {
    public let dashboardEnabled: Bool
    public let subscribedDomains: [DomainDeliverabilityTrackingOption]?
}

extension PutDeliverabilityDashboardOptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dashboardEnabled = "DashboardEnabled"
        case subscribedDomains = "SubscribedDomains"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardEnabledDecoded = try containerValues.decode(Bool.self, forKey: .dashboardEnabled)
        dashboardEnabled = dashboardEnabledDecoded
        let subscribedDomainsContainer = try containerValues.decodeIfPresent([DomainDeliverabilityTrackingOption?].self, forKey: .subscribedDomains)
        var subscribedDomainsDecoded0:[DomainDeliverabilityTrackingOption]? = nil
        if let subscribedDomainsContainer = subscribedDomainsContainer {
            subscribedDomainsDecoded0 = [DomainDeliverabilityTrackingOption]()
            for structure0 in subscribedDomainsContainer {
                if let structure0 = structure0 {
                    subscribedDomainsDecoded0?.append(structure0)
                }
            }
        }
        subscribedDomains = subscribedDomainsDecoded0
    }
}

extension PutDeliverabilityDashboardOptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDeliverabilityDashboardOptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDeliverabilityDashboardOptionOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDeliverabilityDashboardOptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDeliverabilityDashboardOptionOutputResponse()"}
}

extension PutDeliverabilityDashboardOptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>A response that indicates whether the Deliverability dashboard is enabled.</p>
public struct PutDeliverabilityDashboardOptionOutputResponse: Equatable {

    public init() {}
}

struct PutDeliverabilityDashboardOptionOutputResponseBody: Equatable {
}

extension PutDeliverabilityDashboardOptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutEmailIdentityConfigurationSetAttributesInputBodyMiddleware: Middleware {
    public let id: String = "PutEmailIdentityConfigurationSetAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityConfigurationSetAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityConfigurationSetAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityConfigurationSetAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityConfigurationSetAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityConfigurationSetAttributesOutputError>
}

extension PutEmailIdentityConfigurationSetAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEmailIdentityConfigurationSetAttributesInput(configurationSetName: \(String(describing: configurationSetName)), emailIdentity: \(String(describing: emailIdentity)))"}
}

extension PutEmailIdentityConfigurationSetAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
    }
}

public struct PutEmailIdentityConfigurationSetAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "PutEmailIdentityConfigurationSetAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityConfigurationSetAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityConfigurationSetAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityConfigurationSetAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityConfigurationSetAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityConfigurationSetAttributesOutputError>
}

public struct PutEmailIdentityConfigurationSetAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "PutEmailIdentityConfigurationSetAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityConfigurationSetAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityConfigurationSetAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityConfigurationSetAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityConfigurationSetAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityConfigurationSetAttributesOutputError>
}

/// <p>A request to associate a configuration set with an email identity.</p>
public struct PutEmailIdentityConfigurationSetAttributesInput: Equatable {
    /// <p>The configuration set that you want to associate with an email identity.</p>
    public let configurationSetName: String?
    /// <p>The email address or domain that you want to associate with a configuration set.</p>
    public let emailIdentity: String?

    public init (
        configurationSetName: String? = nil,
        emailIdentity: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.emailIdentity = emailIdentity
    }
}

struct PutEmailIdentityConfigurationSetAttributesInputBody: Equatable {
    public let configurationSetName: String?
}

extension PutEmailIdentityConfigurationSetAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
    }
}

extension PutEmailIdentityConfigurationSetAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEmailIdentityConfigurationSetAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEmailIdentityConfigurationSetAttributesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEmailIdentityConfigurationSetAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEmailIdentityConfigurationSetAttributesOutputResponse()"}
}

extension PutEmailIdentityConfigurationSetAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>If the action is successful, the service sends back an HTTP 200 response with an empty HTTP body.</p>
public struct PutEmailIdentityConfigurationSetAttributesOutputResponse: Equatable {

    public init() {}
}

struct PutEmailIdentityConfigurationSetAttributesOutputResponseBody: Equatable {
}

extension PutEmailIdentityConfigurationSetAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutEmailIdentityDkimAttributesInputBodyMiddleware: Middleware {
    public let id: String = "PutEmailIdentityDkimAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityDkimAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityDkimAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityDkimAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityDkimAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityDkimAttributesOutputError>
}

extension PutEmailIdentityDkimAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEmailIdentityDkimAttributesInput(emailIdentity: \(String(describing: emailIdentity)), signingEnabled: \(String(describing: signingEnabled)))"}
}

extension PutEmailIdentityDkimAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case signingEnabled = "SigningEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if signingEnabled != false {
            try encodeContainer.encode(signingEnabled, forKey: .signingEnabled)
        }
    }
}

public struct PutEmailIdentityDkimAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "PutEmailIdentityDkimAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityDkimAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityDkimAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityDkimAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityDkimAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityDkimAttributesOutputError>
}

public struct PutEmailIdentityDkimAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "PutEmailIdentityDkimAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityDkimAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityDkimAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityDkimAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityDkimAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityDkimAttributesOutputError>
}

/// <p>A request to enable or disable DKIM signing of email that you send from an email
///             identity.</p>
public struct PutEmailIdentityDkimAttributesInput: Equatable {
    /// <p>The email identity that you want to change the DKIM settings for.</p>
    public let emailIdentity: String?
    /// <p>Sets the DKIM signing configuration for the identity.</p>
    ///         <p>When you set this value <code>true</code>, then the messages that are sent from the
    ///             identity are signed using DKIM. If you set this value to <code>false</code>, your
    ///             messages are sent without DKIM signing.</p>
    public let signingEnabled: Bool

    public init (
        emailIdentity: String? = nil,
        signingEnabled: Bool = false
    )
    {
        self.emailIdentity = emailIdentity
        self.signingEnabled = signingEnabled
    }
}

struct PutEmailIdentityDkimAttributesInputBody: Equatable {
    public let signingEnabled: Bool
}

extension PutEmailIdentityDkimAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case signingEnabled = "SigningEnabled"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .signingEnabled)
        signingEnabled = signingEnabledDecoded
    }
}

extension PutEmailIdentityDkimAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEmailIdentityDkimAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEmailIdentityDkimAttributesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEmailIdentityDkimAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEmailIdentityDkimAttributesOutputResponse()"}
}

extension PutEmailIdentityDkimAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutEmailIdentityDkimAttributesOutputResponse: Equatable {

    public init() {}
}

struct PutEmailIdentityDkimAttributesOutputResponseBody: Equatable {
}

extension PutEmailIdentityDkimAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutEmailIdentityDkimSigningAttributesInputBodyMiddleware: Middleware {
    public let id: String = "PutEmailIdentityDkimSigningAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityDkimSigningAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityDkimSigningAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityDkimSigningAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityDkimSigningAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityDkimSigningAttributesOutputError>
}

extension PutEmailIdentityDkimSigningAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEmailIdentityDkimSigningAttributesInput(emailIdentity: \(String(describing: emailIdentity)), signingAttributes: \(String(describing: signingAttributes)), signingAttributesOrigin: \(String(describing: signingAttributesOrigin)))"}
}

extension PutEmailIdentityDkimSigningAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case signingAttributes = "SigningAttributes"
        case signingAttributesOrigin = "SigningAttributesOrigin"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signingAttributes = signingAttributes {
            try encodeContainer.encode(signingAttributes, forKey: .signingAttributes)
        }
        if let signingAttributesOrigin = signingAttributesOrigin {
            try encodeContainer.encode(signingAttributesOrigin.rawValue, forKey: .signingAttributesOrigin)
        }
    }
}

public struct PutEmailIdentityDkimSigningAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "PutEmailIdentityDkimSigningAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityDkimSigningAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityDkimSigningAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityDkimSigningAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityDkimSigningAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityDkimSigningAttributesOutputError>
}

public struct PutEmailIdentityDkimSigningAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "PutEmailIdentityDkimSigningAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityDkimSigningAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityDkimSigningAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityDkimSigningAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityDkimSigningAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityDkimSigningAttributesOutputError>
}

/// <p>A request to change the DKIM attributes for an email identity.</p>
public struct PutEmailIdentityDkimSigningAttributesInput: Equatable {
    /// <p>The email identity that you want to configure DKIM for.</p>
    public let emailIdentity: String?
    /// <p>An object that contains information about the private key and selector that you want
    ///             to use to configure DKIM for the identity. This object is only required if you want to
    ///             configure Bring Your Own DKIM (BYODKIM) for the identity.</p>
    public let signingAttributes: DkimSigningAttributes?
    /// <p>The method that you want to use to configure DKIM for the identity. There are two
    ///             possible values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>AWS_SES</code> – Configure DKIM for the identity by using <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html">Easy
    ///                         DKIM</a>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>EXTERNAL</code> – Configure DKIM for the identity by using Bring
    ///                     Your Own DKIM (BYODKIM).</p>
    ///             </li>
    ///          </ul>
    public let signingAttributesOrigin: DkimSigningAttributesOrigin?

    public init (
        emailIdentity: String? = nil,
        signingAttributes: DkimSigningAttributes? = nil,
        signingAttributesOrigin: DkimSigningAttributesOrigin? = nil
    )
    {
        self.emailIdentity = emailIdentity
        self.signingAttributes = signingAttributes
        self.signingAttributesOrigin = signingAttributesOrigin
    }
}

struct PutEmailIdentityDkimSigningAttributesInputBody: Equatable {
    public let signingAttributesOrigin: DkimSigningAttributesOrigin?
    public let signingAttributes: DkimSigningAttributes?
}

extension PutEmailIdentityDkimSigningAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case signingAttributes = "SigningAttributes"
        case signingAttributesOrigin = "SigningAttributesOrigin"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingAttributesOriginDecoded = try containerValues.decodeIfPresent(DkimSigningAttributesOrigin.self, forKey: .signingAttributesOrigin)
        signingAttributesOrigin = signingAttributesOriginDecoded
        let signingAttributesDecoded = try containerValues.decodeIfPresent(DkimSigningAttributes.self, forKey: .signingAttributes)
        signingAttributes = signingAttributesDecoded
    }
}

extension PutEmailIdentityDkimSigningAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEmailIdentityDkimSigningAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEmailIdentityDkimSigningAttributesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEmailIdentityDkimSigningAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEmailIdentityDkimSigningAttributesOutputResponse(dkimStatus: \(String(describing: dkimStatus)), dkimTokens: \(String(describing: dkimTokens)))"}
}

extension PutEmailIdentityDkimSigningAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutEmailIdentityDkimSigningAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dkimStatus = output.dkimStatus
            self.dkimTokens = output.dkimTokens
        } else {
            self.dkimStatus = nil
            self.dkimTokens = nil
        }
    }
}

/// <p>If the action is successful, the service sends back an HTTP 200 response.</p>
///         <p>The following data is returned in JSON format by the service.</p>
public struct PutEmailIdentityDkimSigningAttributesOutputResponse: Equatable {
    /// <p>The DKIM authentication status of the identity. Amazon SES determines the authentication
    ///             status by searching for specific records in the DNS configuration for your domain. If
    ///             you used <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html">Easy
    ///                 DKIM</a> to set up DKIM authentication, Amazon SES tries to find three unique CNAME
    ///             records in the DNS configuration for your domain.</p>
    ///         <p>If you provided a public key to perform DKIM authentication, Amazon SES tries to find a TXT
    ///             record that uses the selector that you specified. The value of the TXT record must be a
    ///             public key that's paired with the private key that you specified in the process of
    ///             creating the identity.</p>
    ///         <p>The status can be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>PENDING</code> – The verification process was initiated, but Amazon SES
    ///                     hasn't yet detected the DKIM records in the DNS configuration for the
    ///                     domain.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SUCCESS</code> – The verification process completed
    ///                     successfully.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>FAILED</code> – The verification process failed. This typically
    ///                     occurs when Amazon SES fails to find the DKIM records in the DNS configuration of the
    ///                     domain.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>TEMPORARY_FAILURE</code> – A temporary issue is preventing Amazon SES
    ///                     from determining the DKIM authentication status of the domain.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>NOT_STARTED</code> – The DKIM verification process hasn't been
    ///                     initiated for the domain.</p>
    ///             </li>
    ///          </ul>
    public let dkimStatus: DkimStatus?
    /// <p>If you used <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html">Easy DKIM</a> to configure DKIM authentication for the domain, then this object
    ///             contains a set of unique strings that you use to create a set of CNAME records that you
    ///             add to the DNS configuration for your domain. When Amazon SES detects these records in the
    ///             DNS configuration for your domain, the DKIM authentication process is complete.</p>
    ///         <p>If you configured DKIM authentication for the domain by providing your own
    ///             public-private key pair, then this object contains the selector that's associated with
    ///             your public key.</p>
    ///         <p>Regardless of the DKIM authentication method you use, Amazon SES searches for the
    ///             appropriate records in the DNS configuration of the domain for up to 72 hours.</p>
    public let dkimTokens: [String]?

    public init (
        dkimStatus: DkimStatus? = nil,
        dkimTokens: [String]? = nil
    )
    {
        self.dkimStatus = dkimStatus
        self.dkimTokens = dkimTokens
    }
}

struct PutEmailIdentityDkimSigningAttributesOutputResponseBody: Equatable {
    public let dkimStatus: DkimStatus?
    public let dkimTokens: [String]?
}

extension PutEmailIdentityDkimSigningAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dkimStatus = "DkimStatus"
        case dkimTokens = "DkimTokens"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dkimStatusDecoded = try containerValues.decodeIfPresent(DkimStatus.self, forKey: .dkimStatus)
        dkimStatus = dkimStatusDecoded
        let dkimTokensContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dkimTokens)
        var dkimTokensDecoded0:[String]? = nil
        if let dkimTokensContainer = dkimTokensContainer {
            dkimTokensDecoded0 = [String]()
            for string0 in dkimTokensContainer {
                if let string0 = string0 {
                    dkimTokensDecoded0?.append(string0)
                }
            }
        }
        dkimTokens = dkimTokensDecoded0
    }
}

public struct PutEmailIdentityFeedbackAttributesInputBodyMiddleware: Middleware {
    public let id: String = "PutEmailIdentityFeedbackAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityFeedbackAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityFeedbackAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityFeedbackAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityFeedbackAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityFeedbackAttributesOutputError>
}

extension PutEmailIdentityFeedbackAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEmailIdentityFeedbackAttributesInput(emailForwardingEnabled: \(String(describing: emailForwardingEnabled)), emailIdentity: \(String(describing: emailIdentity)))"}
}

extension PutEmailIdentityFeedbackAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emailForwardingEnabled = "EmailForwardingEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if emailForwardingEnabled != false {
            try encodeContainer.encode(emailForwardingEnabled, forKey: .emailForwardingEnabled)
        }
    }
}

public struct PutEmailIdentityFeedbackAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "PutEmailIdentityFeedbackAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityFeedbackAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityFeedbackAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityFeedbackAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityFeedbackAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityFeedbackAttributesOutputError>
}

public struct PutEmailIdentityFeedbackAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "PutEmailIdentityFeedbackAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityFeedbackAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityFeedbackAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityFeedbackAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityFeedbackAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityFeedbackAttributesOutputError>
}

/// <p>A request to set the attributes that control how bounce and complaint events are
///             processed.</p>
public struct PutEmailIdentityFeedbackAttributesInput: Equatable {
    /// <p>Sets the feedback forwarding configuration for the identity.</p>
    ///         <p>If the value is <code>true</code>, you receive email notifications when bounce or
    ///             complaint events occur. These notifications are sent to the address that you specified
    ///             in the <code>Return-Path</code> header of the original email.</p>
    ///         <p>You're required to have a method of tracking bounces and complaints. If you haven't
    ///             set up another mechanism for receiving bounce or complaint notifications (for example,
    ///             by setting up an event destination), you receive an email notification when these events
    ///             occur (even if this setting is disabled).</p>
    public let emailForwardingEnabled: Bool
    /// <p>The email identity that you want to configure bounce and complaint feedback forwarding
    ///             for.</p>
    public let emailIdentity: String?

    public init (
        emailForwardingEnabled: Bool = false,
        emailIdentity: String? = nil
    )
    {
        self.emailForwardingEnabled = emailForwardingEnabled
        self.emailIdentity = emailIdentity
    }
}

struct PutEmailIdentityFeedbackAttributesInputBody: Equatable {
    public let emailForwardingEnabled: Bool
}

extension PutEmailIdentityFeedbackAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case emailForwardingEnabled = "EmailForwardingEnabled"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailForwardingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .emailForwardingEnabled)
        emailForwardingEnabled = emailForwardingEnabledDecoded
    }
}

extension PutEmailIdentityFeedbackAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEmailIdentityFeedbackAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEmailIdentityFeedbackAttributesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEmailIdentityFeedbackAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEmailIdentityFeedbackAttributesOutputResponse()"}
}

extension PutEmailIdentityFeedbackAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutEmailIdentityFeedbackAttributesOutputResponse: Equatable {

    public init() {}
}

struct PutEmailIdentityFeedbackAttributesOutputResponseBody: Equatable {
}

extension PutEmailIdentityFeedbackAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutEmailIdentityMailFromAttributesInputBodyMiddleware: Middleware {
    public let id: String = "PutEmailIdentityMailFromAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityMailFromAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityMailFromAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityMailFromAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityMailFromAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityMailFromAttributesOutputError>
}

extension PutEmailIdentityMailFromAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEmailIdentityMailFromAttributesInput(behaviorOnMxFailure: \(String(describing: behaviorOnMxFailure)), emailIdentity: \(String(describing: emailIdentity)), mailFromDomain: \(String(describing: mailFromDomain)))"}
}

extension PutEmailIdentityMailFromAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case behaviorOnMxFailure = "BehaviorOnMxFailure"
        case mailFromDomain = "MailFromDomain"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let behaviorOnMxFailure = behaviorOnMxFailure {
            try encodeContainer.encode(behaviorOnMxFailure.rawValue, forKey: .behaviorOnMxFailure)
        }
        if let mailFromDomain = mailFromDomain {
            try encodeContainer.encode(mailFromDomain, forKey: .mailFromDomain)
        }
    }
}

public struct PutEmailIdentityMailFromAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "PutEmailIdentityMailFromAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityMailFromAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityMailFromAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityMailFromAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityMailFromAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityMailFromAttributesOutputError>
}

public struct PutEmailIdentityMailFromAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "PutEmailIdentityMailFromAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityMailFromAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityMailFromAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityMailFromAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityMailFromAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityMailFromAttributesOutputError>
}

/// <p>A request to configure the custom MAIL FROM domain for a verified identity.</p>
public struct PutEmailIdentityMailFromAttributesInput: Equatable {
    /// <p>The action that you want to take if the required MX record isn't found when you send
    ///             an email. When you set this value to <code>UseDefaultValue</code>, the mail is sent
    ///             using <i>amazonses.com</i> as the MAIL FROM domain. When you set this
    ///             value to <code>RejectMessage</code>, the Amazon SES API v2 returns a
    ///                 <code>MailFromDomainNotVerified</code> error, and doesn't attempt to deliver the
    ///             email.</p>
    ///         <p>These behaviors are taken when the custom MAIL FROM domain configuration is in the
    ///                 <code>Pending</code>, <code>Failed</code>, and <code>TemporaryFailure</code>
    ///             states.</p>
    public let behaviorOnMxFailure: BehaviorOnMxFailure?
    /// <p>The verified email identity that you want to set up the custom MAIL FROM domain
    ///             for.</p>
    public let emailIdentity: String?
    /// <p> The custom MAIL FROM domain that you want the verified identity to use. The MAIL FROM
    ///             domain must meet the following criteria:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>It has to be a subdomain of the verified identity.</p>
    ///             </li>
    ///             <li>
    ///                 <p>It can't be used to receive email.</p>
    ///             </li>
    ///             <li>
    ///                 <p>It can't be used in a "From" address if the MAIL FROM domain is a destination
    ///                     for feedback forwarding emails.</p>
    ///             </li>
    ///          </ul>
    public let mailFromDomain: String?

    public init (
        behaviorOnMxFailure: BehaviorOnMxFailure? = nil,
        emailIdentity: String? = nil,
        mailFromDomain: String? = nil
    )
    {
        self.behaviorOnMxFailure = behaviorOnMxFailure
        self.emailIdentity = emailIdentity
        self.mailFromDomain = mailFromDomain
    }
}

struct PutEmailIdentityMailFromAttributesInputBody: Equatable {
    public let mailFromDomain: String?
    public let behaviorOnMxFailure: BehaviorOnMxFailure?
}

extension PutEmailIdentityMailFromAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case behaviorOnMxFailure = "BehaviorOnMxFailure"
        case mailFromDomain = "MailFromDomain"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mailFromDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mailFromDomain)
        mailFromDomain = mailFromDomainDecoded
        let behaviorOnMxFailureDecoded = try containerValues.decodeIfPresent(BehaviorOnMxFailure.self, forKey: .behaviorOnMxFailure)
        behaviorOnMxFailure = behaviorOnMxFailureDecoded
    }
}

extension PutEmailIdentityMailFromAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEmailIdentityMailFromAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEmailIdentityMailFromAttributesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEmailIdentityMailFromAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEmailIdentityMailFromAttributesOutputResponse()"}
}

extension PutEmailIdentityMailFromAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutEmailIdentityMailFromAttributesOutputResponse: Equatable {

    public init() {}
}

struct PutEmailIdentityMailFromAttributesOutputResponseBody: Equatable {
}

extension PutEmailIdentityMailFromAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutSuppressedDestinationInputBodyMiddleware: Middleware {
    public let id: String = "PutSuppressedDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSuppressedDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSuppressedDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSuppressedDestinationInput>
    public typealias MOutput = OperationOutput<PutSuppressedDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSuppressedDestinationOutputError>
}

extension PutSuppressedDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutSuppressedDestinationInput(emailAddress: \(String(describing: emailAddress)), reason: \(String(describing: reason)))"}
}

extension PutSuppressedDestinationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emailAddress = "EmailAddress"
        case reason = "Reason"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let reason = reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
    }
}

public struct PutSuppressedDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "PutSuppressedDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSuppressedDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSuppressedDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSuppressedDestinationInput>
    public typealias MOutput = OperationOutput<PutSuppressedDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSuppressedDestinationOutputError>
}

public struct PutSuppressedDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutSuppressedDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSuppressedDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSuppressedDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSuppressedDestinationInput>
    public typealias MOutput = OperationOutput<PutSuppressedDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSuppressedDestinationOutputError>
}

/// <p>A request to add an email destination to the suppression list for your account.</p>
public struct PutSuppressedDestinationInput: Equatable {
    /// <p>The email address that should be added to the suppression list for your
    ///             account.</p>
    public let emailAddress: String?
    /// <p>The factors that should cause the email address to be added to the suppression list
    ///             for your account.</p>
    public let reason: SuppressionListReason?

    public init (
        emailAddress: String? = nil,
        reason: SuppressionListReason? = nil
    )
    {
        self.emailAddress = emailAddress
        self.reason = reason
    }
}

struct PutSuppressedDestinationInputBody: Equatable {
    public let emailAddress: String?
    public let reason: SuppressionListReason?
}

extension PutSuppressedDestinationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case emailAddress = "EmailAddress"
        case reason = "Reason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(SuppressionListReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension PutSuppressedDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSuppressedDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutSuppressedDestinationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSuppressedDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutSuppressedDestinationOutputResponse()"}
}

extension PutSuppressedDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutSuppressedDestinationOutputResponse: Equatable {

    public init() {}
}

struct PutSuppressedDestinationOutputResponseBody: Equatable {
}

extension PutSuppressedDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RawMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case data = "Data"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .data)
        data = dataDecoded
    }
}

extension RawMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RawMessage(data: \(String(describing: data)))"}
}

/// <p>Represents the raw content of an email message.</p>
public struct RawMessage: Equatable {
    /// <p>The raw email message. The message has to meet the following criteria:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>The message has to contain a header and a body, separated by one blank
    ///                     line.</p>
    ///             </li>
    ///             <li>
    ///                 <p>All of the required header fields must be present in the message.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Each part of a multipart MIME message must be formatted properly.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Attachments must be in a file format that the Amazon SES supports.</p>
    ///             </li>
    ///             <li>
    ///                 <p>The entire message must be Base64 encoded.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If any of the MIME parts in your message contain content that is outside of
    ///                     the 7-bit ASCII character range, you should encode that content to ensure that
    ///                     recipients' email clients render the message properly.</p>
    ///             </li>
    ///             <li>
    ///                 <p>The length of any single line of text in the message can't exceed 1,000
    ///                     characters. This restriction is defined in <a href="https://tools.ietf.org/html/rfc5321">RFC 5321</a>.</p>
    ///             </li>
    ///          </ul>
    public let data: Data?

    public init (
        data: Data? = nil
    )
    {
        self.data = data
    }
}

extension ReplacementEmailContent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replacementTemplate = "ReplacementTemplate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replacementTemplate = replacementTemplate {
            try encodeContainer.encode(replacementTemplate, forKey: .replacementTemplate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replacementTemplateDecoded = try containerValues.decodeIfPresent(ReplacementTemplate.self, forKey: .replacementTemplate)
        replacementTemplate = replacementTemplateDecoded
    }
}

extension ReplacementEmailContent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplacementEmailContent(replacementTemplate: \(String(describing: replacementTemplate)))"}
}

/// <p>The <code>ReplaceEmailContent</code> object to be used for a specific
///                 <code>BulkEmailEntry</code>. The <code>ReplacementTemplate</code> can be specified
///             within this object.</p>
public struct ReplacementEmailContent: Equatable {
    /// <p>The <code>ReplacementTemplate</code> associated with
    ///                 <code>ReplacementEmailContent</code>.</p>
    public let replacementTemplate: ReplacementTemplate?

    public init (
        replacementTemplate: ReplacementTemplate? = nil
    )
    {
        self.replacementTemplate = replacementTemplate
    }
}

extension ReplacementTemplate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replacementTemplateData = "ReplacementTemplateData"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replacementTemplateData = replacementTemplateData {
            try encodeContainer.encode(replacementTemplateData, forKey: .replacementTemplateData)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replacementTemplateDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replacementTemplateData)
        replacementTemplateData = replacementTemplateDataDecoded
    }
}

extension ReplacementTemplate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplacementTemplate(replacementTemplateData: \(String(describing: replacementTemplateData)))"}
}

/// <p>An object which contains <code>ReplacementTemplateData</code> to be used for a
///             specific <code>BulkEmailEntry</code>.</p>
public struct ReplacementTemplate: Equatable {
    /// <p>A list of replacement values to apply to the template. This parameter is a JSON
    ///             object, typically consisting of key-value pairs in which the keys correspond to
    ///             replacement tags in the email template.</p>
    public let replacementTemplateData: String?

    public init (
        replacementTemplateData: String? = nil
    )
    {
        self.replacementTemplateData = replacementTemplateData
    }
}

extension ReputationOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastFreshStart = "LastFreshStart"
        case reputationMetricsEnabled = "ReputationMetricsEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastFreshStart = lastFreshStart {
            try encodeContainer.encode(lastFreshStart.timeIntervalSince1970, forKey: .lastFreshStart)
        }
        if reputationMetricsEnabled != false {
            try encodeContainer.encode(reputationMetricsEnabled, forKey: .reputationMetricsEnabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reputationMetricsEnabledDecoded = try containerValues.decode(Bool.self, forKey: .reputationMetricsEnabled)
        reputationMetricsEnabled = reputationMetricsEnabledDecoded
        let lastFreshStartDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastFreshStart)
        lastFreshStart = lastFreshStartDecoded
    }
}

extension ReputationOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReputationOptions(lastFreshStart: \(String(describing: lastFreshStart)), reputationMetricsEnabled: \(String(describing: reputationMetricsEnabled)))"}
}

/// <p>Enable or disable collection of reputation metrics for emails that you send using this
///             configuration set in the current AWS Region. </p>
public struct ReputationOptions: Equatable {
    /// <p>The date and time (in Unix time) when the reputation metrics were last given a fresh
    ///             start. When your account is given a fresh start, your reputation metrics are calculated
    ///             starting from the date of the fresh start.</p>
    public let lastFreshStart: Date?
    /// <p>If <code>true</code>, tracking of reputation metrics is enabled for the configuration
    ///             set. If <code>false</code>, tracking of reputation metrics is disabled for the
    ///             configuration set.</p>
    public let reputationMetricsEnabled: Bool

    public init (
        lastFreshStart: Date? = nil,
        reputationMetricsEnabled: Bool = false
    )
    {
        self.lastFreshStart = lastFreshStart
        self.reputationMetricsEnabled = reputationMetricsEnabled
    }
}

extension ReviewDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case caseId = "CaseId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseId = caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ReviewStatus.self, forKey: .status)
        status = statusDecoded
        let caseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .caseId)
        caseId = caseIdDecoded
    }
}

extension ReviewDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReviewDetails(caseId: \(String(describing: caseId)), status: \(String(describing: status)))"}
}

/// <p>An object that contains information about your account details review.</p>
public struct ReviewDetails: Equatable {
    /// <p>The associated support center case ID (if any).</p>
    public let caseId: String?
    /// <p>The status of the latest review of your account. The status can be one of the
    ///             following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>PENDING</code> – We have received your appeal and are in the
    ///                     process of reviewing it.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>GRANTED</code> – Your appeal has been reviewed and your production
    ///                     access has been granted.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DENIED</code> – Your appeal has been reviewed and your production
    ///                     access has been denied.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>FAILED</code> – An internal error occurred and we didn't receive
    ///                     your appeal. You can submit your appeal again.</p>
    ///             </li>
    ///          </ul>
    public let status: ReviewStatus?

    public init (
        caseId: String? = nil,
        status: ReviewStatus? = nil
    )
    {
        self.caseId = caseId
        self.status = status
    }
}

public enum ReviewStatus {
    case denied
    case failed
    case granted
    case pending
    case sdkUnknown(String)
}

extension ReviewStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReviewStatus] {
        return [
            .denied,
            .failed,
            .granted,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .denied: return "DENIED"
        case .failed: return "FAILED"
        case .granted: return "GRANTED"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReviewStatus(rawValue: rawValue) ?? ReviewStatus.sdkUnknown(rawValue)
    }
}

public struct SendBulkEmailInputBodyMiddleware: Middleware {
    public let id: String = "SendBulkEmailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendBulkEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendBulkEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendBulkEmailInput>
    public typealias MOutput = OperationOutput<SendBulkEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendBulkEmailOutputError>
}

extension SendBulkEmailInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendBulkEmailInput(bulkEmailEntries: \(String(describing: bulkEmailEntries)), configurationSetName: \(String(describing: configurationSetName)), defaultContent: \(String(describing: defaultContent)), defaultEmailTags: \(String(describing: defaultEmailTags)), feedbackForwardingEmailAddress: \(String(describing: feedbackForwardingEmailAddress)), feedbackForwardingEmailAddressIdentityArn: \(String(describing: feedbackForwardingEmailAddressIdentityArn)), fromEmailAddress: \(String(describing: fromEmailAddress)), fromEmailAddressIdentityArn: \(String(describing: fromEmailAddressIdentityArn)), replyToAddresses: \(String(describing: replyToAddresses)))"}
}

extension SendBulkEmailInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bulkEmailEntries = "BulkEmailEntries"
        case configurationSetName = "ConfigurationSetName"
        case defaultContent = "DefaultContent"
        case defaultEmailTags = "DefaultEmailTags"
        case feedbackForwardingEmailAddress = "FeedbackForwardingEmailAddress"
        case feedbackForwardingEmailAddressIdentityArn = "FeedbackForwardingEmailAddressIdentityArn"
        case fromEmailAddress = "FromEmailAddress"
        case fromEmailAddressIdentityArn = "FromEmailAddressIdentityArn"
        case replyToAddresses = "ReplyToAddresses"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bulkEmailEntries = bulkEmailEntries {
            var bulkEmailEntriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bulkEmailEntries)
            for bulkemailentrylist0 in bulkEmailEntries {
                try bulkEmailEntriesContainer.encode(bulkemailentrylist0)
            }
        }
        if let configurationSetName = configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let defaultContent = defaultContent {
            try encodeContainer.encode(defaultContent, forKey: .defaultContent)
        }
        if let defaultEmailTags = defaultEmailTags {
            var defaultEmailTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultEmailTags)
            for messagetaglist0 in defaultEmailTags {
                try defaultEmailTagsContainer.encode(messagetaglist0)
            }
        }
        if let feedbackForwardingEmailAddress = feedbackForwardingEmailAddress {
            try encodeContainer.encode(feedbackForwardingEmailAddress, forKey: .feedbackForwardingEmailAddress)
        }
        if let feedbackForwardingEmailAddressIdentityArn = feedbackForwardingEmailAddressIdentityArn {
            try encodeContainer.encode(feedbackForwardingEmailAddressIdentityArn, forKey: .feedbackForwardingEmailAddressIdentityArn)
        }
        if let fromEmailAddress = fromEmailAddress {
            try encodeContainer.encode(fromEmailAddress, forKey: .fromEmailAddress)
        }
        if let fromEmailAddressIdentityArn = fromEmailAddressIdentityArn {
            try encodeContainer.encode(fromEmailAddressIdentityArn, forKey: .fromEmailAddressIdentityArn)
        }
        if let replyToAddresses = replyToAddresses {
            var replyToAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replyToAddresses)
            for emailaddresslist0 in replyToAddresses {
                try replyToAddressesContainer.encode(emailaddresslist0)
            }
        }
    }
}

public struct SendBulkEmailInputHeadersMiddleware: Middleware {
    public let id: String = "SendBulkEmailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendBulkEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendBulkEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendBulkEmailInput>
    public typealias MOutput = OperationOutput<SendBulkEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendBulkEmailOutputError>
}

public struct SendBulkEmailInputQueryItemMiddleware: Middleware {
    public let id: String = "SendBulkEmailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendBulkEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendBulkEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendBulkEmailInput>
    public typealias MOutput = OperationOutput<SendBulkEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendBulkEmailOutputError>
}

/// <p>Represents a request to send email messages to multiple destinations using Amazon SES. For
///             more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-personalized-email-api.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct SendBulkEmailInput: Equatable {
    /// <p>The list of bulk email entry objects.</p>
    public let bulkEmailEntries: [BulkEmailEntry]?
    /// <p>The name of the configuration set that you want to use when sending the email.</p>
    public let configurationSetName: String?
    /// <p>An object that contains the body of the message. You can specify a template
    ///             message.</p>
    public let defaultContent: BulkEmailContent?
    /// <p>A list of tags, in the form of name/value pairs, to apply to an email that you send
    ///             using the <code>SendEmail</code> operation. Tags correspond to characteristics of the
    ///             email that you define, so that you can publish email sending events.</p>
    public let defaultEmailTags: [MessageTag]?
    /// <p>The address that you want bounce and complaint notifications to be sent to.</p>
    public let feedbackForwardingEmailAddress: String?
    /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
    ///             that is associated with the sending authorization policy that permits you to use the
    ///             email address specified in the <code>FeedbackForwardingEmailAddress</code>
    ///             parameter.</p>
    ///         <p>For example, if the owner of example.com (which has ARN
    ///             arn:aws:ses:us-east-1:123456789012:identity/example.com) attaches a policy to it that
    ///             authorizes you to use feedback@example.com, then you would specify the
    ///                 <code>FeedbackForwardingEmailAddressIdentityArn</code> to be
    ///             arn:aws:ses:us-east-1:123456789012:identity/example.com, and the
    ///                 <code>FeedbackForwardingEmailAddress</code> to be feedback@example.com.</p>
    ///         <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    public let feedbackForwardingEmailAddressIdentityArn: String?
    /// <p>The email address that you want to use as the "From" address for the email. The
    ///             address that you specify has to be verified.</p>
    public let fromEmailAddress: String?
    /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
    ///             that is associated with the sending authorization policy that permits you to use the
    ///             email address specified in the <code>FromEmailAddress</code> parameter.</p>
    ///         <p>For example, if the owner of example.com (which has ARN
    ///             arn:aws:ses:us-east-1:123456789012:identity/example.com) attaches a policy to it that
    ///             authorizes you to use sender@example.com, then you would specify the
    ///                 <code>FromEmailAddressIdentityArn</code> to be
    ///             arn:aws:ses:us-east-1:123456789012:identity/example.com, and the
    ///                 <code>FromEmailAddress</code> to be sender@example.com.</p>
    ///         <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    public let fromEmailAddressIdentityArn: String?
    /// <p>The "Reply-to" email addresses for the message. When the recipient replies to the
    ///             message, each Reply-to address receives the reply.</p>
    public let replyToAddresses: [String]?

    public init (
        bulkEmailEntries: [BulkEmailEntry]? = nil,
        configurationSetName: String? = nil,
        defaultContent: BulkEmailContent? = nil,
        defaultEmailTags: [MessageTag]? = nil,
        feedbackForwardingEmailAddress: String? = nil,
        feedbackForwardingEmailAddressIdentityArn: String? = nil,
        fromEmailAddress: String? = nil,
        fromEmailAddressIdentityArn: String? = nil,
        replyToAddresses: [String]? = nil
    )
    {
        self.bulkEmailEntries = bulkEmailEntries
        self.configurationSetName = configurationSetName
        self.defaultContent = defaultContent
        self.defaultEmailTags = defaultEmailTags
        self.feedbackForwardingEmailAddress = feedbackForwardingEmailAddress
        self.feedbackForwardingEmailAddressIdentityArn = feedbackForwardingEmailAddressIdentityArn
        self.fromEmailAddress = fromEmailAddress
        self.fromEmailAddressIdentityArn = fromEmailAddressIdentityArn
        self.replyToAddresses = replyToAddresses
    }
}

struct SendBulkEmailInputBody: Equatable {
    public let fromEmailAddress: String?
    public let fromEmailAddressIdentityArn: String?
    public let replyToAddresses: [String]?
    public let feedbackForwardingEmailAddress: String?
    public let feedbackForwardingEmailAddressIdentityArn: String?
    public let defaultEmailTags: [MessageTag]?
    public let defaultContent: BulkEmailContent?
    public let bulkEmailEntries: [BulkEmailEntry]?
    public let configurationSetName: String?
}

extension SendBulkEmailInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bulkEmailEntries = "BulkEmailEntries"
        case configurationSetName = "ConfigurationSetName"
        case defaultContent = "DefaultContent"
        case defaultEmailTags = "DefaultEmailTags"
        case feedbackForwardingEmailAddress = "FeedbackForwardingEmailAddress"
        case feedbackForwardingEmailAddressIdentityArn = "FeedbackForwardingEmailAddressIdentityArn"
        case fromEmailAddress = "FromEmailAddress"
        case fromEmailAddressIdentityArn = "FromEmailAddressIdentityArn"
        case replyToAddresses = "ReplyToAddresses"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromEmailAddress)
        fromEmailAddress = fromEmailAddressDecoded
        let fromEmailAddressIdentityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromEmailAddressIdentityArn)
        fromEmailAddressIdentityArn = fromEmailAddressIdentityArnDecoded
        let replyToAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .replyToAddresses)
        var replyToAddressesDecoded0:[String]? = nil
        if let replyToAddressesContainer = replyToAddressesContainer {
            replyToAddressesDecoded0 = [String]()
            for string0 in replyToAddressesContainer {
                if let string0 = string0 {
                    replyToAddressesDecoded0?.append(string0)
                }
            }
        }
        replyToAddresses = replyToAddressesDecoded0
        let feedbackForwardingEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .feedbackForwardingEmailAddress)
        feedbackForwardingEmailAddress = feedbackForwardingEmailAddressDecoded
        let feedbackForwardingEmailAddressIdentityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .feedbackForwardingEmailAddressIdentityArn)
        feedbackForwardingEmailAddressIdentityArn = feedbackForwardingEmailAddressIdentityArnDecoded
        let defaultEmailTagsContainer = try containerValues.decodeIfPresent([MessageTag?].self, forKey: .defaultEmailTags)
        var defaultEmailTagsDecoded0:[MessageTag]? = nil
        if let defaultEmailTagsContainer = defaultEmailTagsContainer {
            defaultEmailTagsDecoded0 = [MessageTag]()
            for structure0 in defaultEmailTagsContainer {
                if let structure0 = structure0 {
                    defaultEmailTagsDecoded0?.append(structure0)
                }
            }
        }
        defaultEmailTags = defaultEmailTagsDecoded0
        let defaultContentDecoded = try containerValues.decodeIfPresent(BulkEmailContent.self, forKey: .defaultContent)
        defaultContent = defaultContentDecoded
        let bulkEmailEntriesContainer = try containerValues.decodeIfPresent([BulkEmailEntry?].self, forKey: .bulkEmailEntries)
        var bulkEmailEntriesDecoded0:[BulkEmailEntry]? = nil
        if let bulkEmailEntriesContainer = bulkEmailEntriesContainer {
            bulkEmailEntriesDecoded0 = [BulkEmailEntry]()
            for structure0 in bulkEmailEntriesContainer {
                if let structure0 = structure0 {
                    bulkEmailEntriesDecoded0?.append(structure0)
                }
            }
        }
        bulkEmailEntries = bulkEmailEntriesDecoded0
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
    }
}

extension SendBulkEmailOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendBulkEmailOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccountSuspendedException" : self = .accountSuspendedException(try AccountSuspendedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailFromDomainNotVerifiedException" : self = .mailFromDomainNotVerifiedException(try MailFromDomainNotVerifiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MessageRejected" : self = .messageRejected(try MessageRejected(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SendingPausedException" : self = .sendingPausedException(try SendingPausedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendBulkEmailOutputError: Equatable {
    case accountSuspendedException(AccountSuspendedException)
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case mailFromDomainNotVerifiedException(MailFromDomainNotVerifiedException)
    case messageRejected(MessageRejected)
    case notFoundException(NotFoundException)
    case sendingPausedException(SendingPausedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendBulkEmailOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendBulkEmailOutputResponse(bulkEmailEntryResults: \(String(describing: bulkEmailEntryResults)))"}
}

extension SendBulkEmailOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendBulkEmailOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bulkEmailEntryResults = output.bulkEmailEntryResults
        } else {
            self.bulkEmailEntryResults = nil
        }
    }
}

/// <p>The following data is returned in JSON format by the service.</p>
public struct SendBulkEmailOutputResponse: Equatable {
    /// <p>A list of <code>BulkMailEntry</code> objects.</p>
    public let bulkEmailEntryResults: [BulkEmailEntryResult]?

    public init (
        bulkEmailEntryResults: [BulkEmailEntryResult]? = nil
    )
    {
        self.bulkEmailEntryResults = bulkEmailEntryResults
    }
}

struct SendBulkEmailOutputResponseBody: Equatable {
    public let bulkEmailEntryResults: [BulkEmailEntryResult]?
}

extension SendBulkEmailOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bulkEmailEntryResults = "BulkEmailEntryResults"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bulkEmailEntryResultsContainer = try containerValues.decodeIfPresent([BulkEmailEntryResult?].self, forKey: .bulkEmailEntryResults)
        var bulkEmailEntryResultsDecoded0:[BulkEmailEntryResult]? = nil
        if let bulkEmailEntryResultsContainer = bulkEmailEntryResultsContainer {
            bulkEmailEntryResultsDecoded0 = [BulkEmailEntryResult]()
            for structure0 in bulkEmailEntryResultsContainer {
                if let structure0 = structure0 {
                    bulkEmailEntryResultsDecoded0?.append(structure0)
                }
            }
        }
        bulkEmailEntryResults = bulkEmailEntryResultsDecoded0
    }
}

public struct SendCustomVerificationEmailInputBodyMiddleware: Middleware {
    public let id: String = "SendCustomVerificationEmailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendCustomVerificationEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendCustomVerificationEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendCustomVerificationEmailInput>
    public typealias MOutput = OperationOutput<SendCustomVerificationEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendCustomVerificationEmailOutputError>
}

extension SendCustomVerificationEmailInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendCustomVerificationEmailInput(configurationSetName: \(String(describing: configurationSetName)), emailAddress: \(String(describing: emailAddress)), templateName: \(String(describing: templateName)))"}
}

extension SendCustomVerificationEmailInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case emailAddress = "EmailAddress"
        case templateName = "TemplateName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

public struct SendCustomVerificationEmailInputHeadersMiddleware: Middleware {
    public let id: String = "SendCustomVerificationEmailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendCustomVerificationEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendCustomVerificationEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendCustomVerificationEmailInput>
    public typealias MOutput = OperationOutput<SendCustomVerificationEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendCustomVerificationEmailOutputError>
}

public struct SendCustomVerificationEmailInputQueryItemMiddleware: Middleware {
    public let id: String = "SendCustomVerificationEmailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendCustomVerificationEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendCustomVerificationEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendCustomVerificationEmailInput>
    public typealias MOutput = OperationOutput<SendCustomVerificationEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendCustomVerificationEmailOutputError>
}

/// <p>Represents a request to send a custom verification email to a specified
///             recipient.</p>
public struct SendCustomVerificationEmailInput: Equatable {
    /// <p>Name of a configuration set to use when sending the verification email.</p>
    public let configurationSetName: String?
    /// <p>The email address to verify.</p>
    public let emailAddress: String?
    /// <p>The name of the custom verification email template to use when sending the
    ///             verification email.</p>
    public let templateName: String?

    public init (
        configurationSetName: String? = nil,
        emailAddress: String? = nil,
        templateName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.emailAddress = emailAddress
        self.templateName = templateName
    }
}

struct SendCustomVerificationEmailInputBody: Equatable {
    public let emailAddress: String?
    public let templateName: String?
    public let configurationSetName: String?
}

extension SendCustomVerificationEmailInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case emailAddress = "EmailAddress"
        case templateName = "TemplateName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
    }
}

extension SendCustomVerificationEmailOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendCustomVerificationEmailOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailFromDomainNotVerifiedException" : self = .mailFromDomainNotVerifiedException(try MailFromDomainNotVerifiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MessageRejected" : self = .messageRejected(try MessageRejected(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SendingPausedException" : self = .sendingPausedException(try SendingPausedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendCustomVerificationEmailOutputError: Equatable {
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case mailFromDomainNotVerifiedException(MailFromDomainNotVerifiedException)
    case messageRejected(MessageRejected)
    case notFoundException(NotFoundException)
    case sendingPausedException(SendingPausedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendCustomVerificationEmailOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendCustomVerificationEmailOutputResponse(messageId: \(String(describing: messageId)))"}
}

extension SendCustomVerificationEmailOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendCustomVerificationEmailOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

/// <p>The following element is returned by the service.</p>
public struct SendCustomVerificationEmailOutputResponse: Equatable {
    /// <p>The unique message identifier returned from the
    ///                 <code>SendCustomVerificationEmail</code> operation.</p>
    public let messageId: String?

    public init (
        messageId: String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendCustomVerificationEmailOutputResponseBody: Equatable {
    public let messageId: String?
}

extension SendCustomVerificationEmailOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageId = "MessageId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

public struct SendEmailInputBodyMiddleware: Middleware {
    public let id: String = "SendEmailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendEmailInput>
    public typealias MOutput = OperationOutput<SendEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendEmailOutputError>
}

extension SendEmailInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendEmailInput(configurationSetName: \(String(describing: configurationSetName)), content: \(String(describing: content)), destination: \(String(describing: destination)), emailTags: \(String(describing: emailTags)), feedbackForwardingEmailAddress: \(String(describing: feedbackForwardingEmailAddress)), feedbackForwardingEmailAddressIdentityArn: \(String(describing: feedbackForwardingEmailAddressIdentityArn)), fromEmailAddress: \(String(describing: fromEmailAddress)), fromEmailAddressIdentityArn: \(String(describing: fromEmailAddressIdentityArn)), listManagementOptions: \(String(describing: listManagementOptions)), replyToAddresses: \(String(describing: replyToAddresses)))"}
}

extension SendEmailInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case content = "Content"
        case destination = "Destination"
        case emailTags = "EmailTags"
        case feedbackForwardingEmailAddress = "FeedbackForwardingEmailAddress"
        case feedbackForwardingEmailAddressIdentityArn = "FeedbackForwardingEmailAddressIdentityArn"
        case fromEmailAddress = "FromEmailAddress"
        case fromEmailAddressIdentityArn = "FromEmailAddressIdentityArn"
        case listManagementOptions = "ListManagementOptions"
        case replyToAddresses = "ReplyToAddresses"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let emailTags = emailTags {
            var emailTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .emailTags)
            for messagetaglist0 in emailTags {
                try emailTagsContainer.encode(messagetaglist0)
            }
        }
        if let feedbackForwardingEmailAddress = feedbackForwardingEmailAddress {
            try encodeContainer.encode(feedbackForwardingEmailAddress, forKey: .feedbackForwardingEmailAddress)
        }
        if let feedbackForwardingEmailAddressIdentityArn = feedbackForwardingEmailAddressIdentityArn {
            try encodeContainer.encode(feedbackForwardingEmailAddressIdentityArn, forKey: .feedbackForwardingEmailAddressIdentityArn)
        }
        if let fromEmailAddress = fromEmailAddress {
            try encodeContainer.encode(fromEmailAddress, forKey: .fromEmailAddress)
        }
        if let fromEmailAddressIdentityArn = fromEmailAddressIdentityArn {
            try encodeContainer.encode(fromEmailAddressIdentityArn, forKey: .fromEmailAddressIdentityArn)
        }
        if let listManagementOptions = listManagementOptions {
            try encodeContainer.encode(listManagementOptions, forKey: .listManagementOptions)
        }
        if let replyToAddresses = replyToAddresses {
            var replyToAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replyToAddresses)
            for emailaddresslist0 in replyToAddresses {
                try replyToAddressesContainer.encode(emailaddresslist0)
            }
        }
    }
}

public struct SendEmailInputHeadersMiddleware: Middleware {
    public let id: String = "SendEmailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendEmailInput>
    public typealias MOutput = OperationOutput<SendEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendEmailOutputError>
}

public struct SendEmailInputQueryItemMiddleware: Middleware {
    public let id: String = "SendEmailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendEmailInput>
    public typealias MOutput = OperationOutput<SendEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendEmailOutputError>
}

/// <p>Represents a request to send a single formatted email using Amazon SES. For more
///             information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-formatted.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct SendEmailInput: Equatable {
    /// <p>The name of the configuration set that you want to use when sending the email.</p>
    public let configurationSetName: String?
    /// <p>An object that contains the body of the message. You can send either a Simple message
    ///             Raw message or a template Message.</p>
    public let content: EmailContent?
    /// <p>An object that contains the recipients of the email message.</p>
    public let destination: Destination?
    /// <p>A list of tags, in the form of name/value pairs, to apply to an email that you send
    ///             using the <code>SendEmail</code> operation. Tags correspond to characteristics of the
    ///             email that you define, so that you can publish email sending events. </p>
    public let emailTags: [MessageTag]?
    /// <p>The address that you want bounce and complaint notifications to be sent to.</p>
    public let feedbackForwardingEmailAddress: String?
    /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
    ///             that is associated with the sending authorization policy that permits you to use the
    ///             email address specified in the <code>FeedbackForwardingEmailAddress</code>
    ///             parameter.</p>
    ///         <p>For example, if the owner of example.com (which has ARN
    ///             arn:aws:ses:us-east-1:123456789012:identity/example.com) attaches a policy to it that
    ///             authorizes you to use feedback@example.com, then you would specify the
    ///                 <code>FeedbackForwardingEmailAddressIdentityArn</code> to be
    ///             arn:aws:ses:us-east-1:123456789012:identity/example.com, and the
    ///                 <code>FeedbackForwardingEmailAddress</code> to be feedback@example.com.</p>
    ///         <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    public let feedbackForwardingEmailAddressIdentityArn: String?
    /// <p>The email address that you want to use as the "From" address for the email. The
    ///             address that you specify has to be verified.
    ///             </p>
    public let fromEmailAddress: String?
    /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
    ///             that is associated with the sending authorization policy that permits you to use the
    ///             email address specified in the <code>FromEmailAddress</code> parameter.</p>
    ///         <p>For example, if the owner of example.com (which has ARN
    ///             arn:aws:ses:us-east-1:123456789012:identity/example.com) attaches a policy to it that
    ///             authorizes you to use sender@example.com, then you would specify the
    ///                 <code>FromEmailAddressIdentityArn</code> to be
    ///             arn:aws:ses:us-east-1:123456789012:identity/example.com, and the
    ///                 <code>FromEmailAddress</code> to be sender@example.com.</p>
    ///         <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    ///         <p>For Raw emails, the <code>FromEmailAddressIdentityArn</code> value overrides the
    ///             X-SES-SOURCE-ARN and X-SES-FROM-ARN headers specified in raw email message
    ///             content.</p>
    public let fromEmailAddressIdentityArn: String?
    /// <p>An object used to specify a list or topic to which an email belongs, which will be
    ///             used when a contact chooses to unsubscribe.</p>
    public let listManagementOptions: ListManagementOptions?
    /// <p>The "Reply-to" email addresses for the message. When the recipient replies to the
    ///             message, each Reply-to address receives the reply.</p>
    public let replyToAddresses: [String]?

    public init (
        configurationSetName: String? = nil,
        content: EmailContent? = nil,
        destination: Destination? = nil,
        emailTags: [MessageTag]? = nil,
        feedbackForwardingEmailAddress: String? = nil,
        feedbackForwardingEmailAddressIdentityArn: String? = nil,
        fromEmailAddress: String? = nil,
        fromEmailAddressIdentityArn: String? = nil,
        listManagementOptions: ListManagementOptions? = nil,
        replyToAddresses: [String]? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.content = content
        self.destination = destination
        self.emailTags = emailTags
        self.feedbackForwardingEmailAddress = feedbackForwardingEmailAddress
        self.feedbackForwardingEmailAddressIdentityArn = feedbackForwardingEmailAddressIdentityArn
        self.fromEmailAddress = fromEmailAddress
        self.fromEmailAddressIdentityArn = fromEmailAddressIdentityArn
        self.listManagementOptions = listManagementOptions
        self.replyToAddresses = replyToAddresses
    }
}

struct SendEmailInputBody: Equatable {
    public let fromEmailAddress: String?
    public let fromEmailAddressIdentityArn: String?
    public let destination: Destination?
    public let replyToAddresses: [String]?
    public let feedbackForwardingEmailAddress: String?
    public let feedbackForwardingEmailAddressIdentityArn: String?
    public let content: EmailContent?
    public let emailTags: [MessageTag]?
    public let configurationSetName: String?
    public let listManagementOptions: ListManagementOptions?
}

extension SendEmailInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case content = "Content"
        case destination = "Destination"
        case emailTags = "EmailTags"
        case feedbackForwardingEmailAddress = "FeedbackForwardingEmailAddress"
        case feedbackForwardingEmailAddressIdentityArn = "FeedbackForwardingEmailAddressIdentityArn"
        case fromEmailAddress = "FromEmailAddress"
        case fromEmailAddressIdentityArn = "FromEmailAddressIdentityArn"
        case listManagementOptions = "ListManagementOptions"
        case replyToAddresses = "ReplyToAddresses"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromEmailAddress)
        fromEmailAddress = fromEmailAddressDecoded
        let fromEmailAddressIdentityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromEmailAddressIdentityArn)
        fromEmailAddressIdentityArn = fromEmailAddressIdentityArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Destination.self, forKey: .destination)
        destination = destinationDecoded
        let replyToAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .replyToAddresses)
        var replyToAddressesDecoded0:[String]? = nil
        if let replyToAddressesContainer = replyToAddressesContainer {
            replyToAddressesDecoded0 = [String]()
            for string0 in replyToAddressesContainer {
                if let string0 = string0 {
                    replyToAddressesDecoded0?.append(string0)
                }
            }
        }
        replyToAddresses = replyToAddressesDecoded0
        let feedbackForwardingEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .feedbackForwardingEmailAddress)
        feedbackForwardingEmailAddress = feedbackForwardingEmailAddressDecoded
        let feedbackForwardingEmailAddressIdentityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .feedbackForwardingEmailAddressIdentityArn)
        feedbackForwardingEmailAddressIdentityArn = feedbackForwardingEmailAddressIdentityArnDecoded
        let contentDecoded = try containerValues.decodeIfPresent(EmailContent.self, forKey: .content)
        content = contentDecoded
        let emailTagsContainer = try containerValues.decodeIfPresent([MessageTag?].self, forKey: .emailTags)
        var emailTagsDecoded0:[MessageTag]? = nil
        if let emailTagsContainer = emailTagsContainer {
            emailTagsDecoded0 = [MessageTag]()
            for structure0 in emailTagsContainer {
                if let structure0 = structure0 {
                    emailTagsDecoded0?.append(structure0)
                }
            }
        }
        emailTags = emailTagsDecoded0
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let listManagementOptionsDecoded = try containerValues.decodeIfPresent(ListManagementOptions.self, forKey: .listManagementOptions)
        listManagementOptions = listManagementOptionsDecoded
    }
}

extension SendEmailOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendEmailOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccountSuspendedException" : self = .accountSuspendedException(try AccountSuspendedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailFromDomainNotVerifiedException" : self = .mailFromDomainNotVerifiedException(try MailFromDomainNotVerifiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MessageRejected" : self = .messageRejected(try MessageRejected(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SendingPausedException" : self = .sendingPausedException(try SendingPausedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendEmailOutputError: Equatable {
    case accountSuspendedException(AccountSuspendedException)
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case mailFromDomainNotVerifiedException(MailFromDomainNotVerifiedException)
    case messageRejected(MessageRejected)
    case notFoundException(NotFoundException)
    case sendingPausedException(SendingPausedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendEmailOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendEmailOutputResponse(messageId: \(String(describing: messageId)))"}
}

extension SendEmailOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendEmailOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

/// <p>A unique message ID that you receive when an email is accepted for sending.</p>
public struct SendEmailOutputResponse: Equatable {
    /// <p>A unique identifier for the message that is generated when the message is
    ///             accepted.</p>
    ///         <note>
    ///             <p>It's possible for Amazon SES to accept a message without sending it. This can happen
    ///                 when the message that you're trying to send has an attachment contains a virus, or
    ///                 when you send a templated email that contains invalid personalization content, for
    ///                 example.</p>
    ///         </note>
    public let messageId: String?

    public init (
        messageId: String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendEmailOutputResponseBody: Equatable {
    public let messageId: String?
}

extension SendEmailOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageId = "MessageId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension SendQuota: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case max24HourSend = "Max24HourSend"
        case maxSendRate = "MaxSendRate"
        case sentLast24Hours = "SentLast24Hours"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if max24HourSend != 0.0 {
            try encodeContainer.encode(max24HourSend, forKey: .max24HourSend)
        }
        if maxSendRate != 0.0 {
            try encodeContainer.encode(maxSendRate, forKey: .maxSendRate)
        }
        if sentLast24Hours != 0.0 {
            try encodeContainer.encode(sentLast24Hours, forKey: .sentLast24Hours)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let max24HourSendDecoded = try containerValues.decode(Double.self, forKey: .max24HourSend)
        max24HourSend = max24HourSendDecoded
        let maxSendRateDecoded = try containerValues.decode(Double.self, forKey: .maxSendRate)
        maxSendRate = maxSendRateDecoded
        let sentLast24HoursDecoded = try containerValues.decode(Double.self, forKey: .sentLast24Hours)
        sentLast24Hours = sentLast24HoursDecoded
    }
}

extension SendQuota: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendQuota(max24HourSend: \(String(describing: max24HourSend)), maxSendRate: \(String(describing: maxSendRate)), sentLast24Hours: \(String(describing: sentLast24Hours)))"}
}

/// <p>An object that contains information about the per-day and per-second sending limits
///             for your Amazon SES account in the current AWS Region.</p>
public struct SendQuota: Equatable {
    /// <p>The maximum number of emails that you can send in the current AWS Region over a
    ///             24-hour period. This value is also called your <i>sending
    ///             quota</i>.</p>
    public let max24HourSend: Double
    /// <p>The maximum number of emails that you can send per second in the current AWS Region.
    ///             This value is also called your <i>maximum sending rate</i> or your
    ///                 <i>maximum TPS (transactions per second) rate</i>.</p>
    public let maxSendRate: Double
    /// <p>The number of emails sent from your Amazon SES account in the current AWS Region over the
    ///             past 24 hours.</p>
    public let sentLast24Hours: Double

    public init (
        max24HourSend: Double = 0.0,
        maxSendRate: Double = 0.0,
        sentLast24Hours: Double = 0.0
    )
    {
        self.max24HourSend = max24HourSend
        self.maxSendRate = maxSendRate
        self.sentLast24Hours = sentLast24Hours
    }
}

extension SendingOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sendingEnabled = "SendingEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if sendingEnabled != false {
            try encodeContainer.encode(sendingEnabled, forKey: .sendingEnabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sendingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .sendingEnabled)
        sendingEnabled = sendingEnabledDecoded
    }
}

extension SendingOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendingOptions(sendingEnabled: \(String(describing: sendingEnabled)))"}
}

/// <p>Used to enable or disable email sending for messages that use this configuration set
///             in the current AWS Region.</p>
public struct SendingOptions: Equatable {
    /// <p>If <code>true</code>, email sending is enabled for the configuration set. If
    ///                 <code>false</code>, email sending is disabled for the configuration set.</p>
    public let sendingEnabled: Bool

    public init (
        sendingEnabled: Bool = false
    )
    {
        self.sendingEnabled = sendingEnabled
    }
}

extension SendingPausedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendingPausedException(message: \(String(describing: message)))"}
}

extension SendingPausedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendingPausedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The message can't be sent because the account's ability to send email is currently
///             paused.</p>
public struct SendingPausedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SendingPausedExceptionBody: Equatable {
    public let message: String?
}

extension SendingPausedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnsDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicArn = topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension SnsDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnsDestination(topicArn: \(String(describing: topicArn)))"}
}

/// <p>An object that defines an Amazon SNS destination for email events. You can use Amazon SNS to
///             send notification when certain email events occur.</p>
public struct SnsDestination: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic that you want to publish email
    ///             events to. For more information about Amazon SNS topics, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html">Amazon SNS Developer
    ///                 Guide</a>.</p>
    public let topicArn: String?

    public init (
        topicArn: String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

public enum SubscriptionStatus {
    case optIn
    case optOut
    case sdkUnknown(String)
}

extension SubscriptionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SubscriptionStatus] {
        return [
            .optIn,
            .optOut,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .optIn: return "OPT_IN"
        case .optOut: return "OPT_OUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SubscriptionStatus(rawValue: rawValue) ?? SubscriptionStatus.sdkUnknown(rawValue)
    }
}

extension SuppressedDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case emailAddress = "EmailAddress"
        case lastUpdateTime = "LastUpdateTime"
        case reason = "Reason"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let reason = reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(SuppressionListReason.self, forKey: .reason)
        reason = reasonDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let attributesDecoded = try containerValues.decodeIfPresent(SuppressedDestinationAttributes.self, forKey: .attributes)
        attributes = attributesDecoded
    }
}

extension SuppressedDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SuppressedDestination(attributes: \(String(describing: attributes)), emailAddress: \(String(describing: emailAddress)), lastUpdateTime: \(String(describing: lastUpdateTime)), reason: \(String(describing: reason)))"}
}

/// <p>An object that contains information about an email address that is on the suppression
///             list for your account.</p>
public struct SuppressedDestination: Equatable {
    /// <p>An optional value that can contain additional information about the reasons that the
    ///             address was added to the suppression list for your account.</p>
    public let attributes: SuppressedDestinationAttributes?
    /// <p>The email address that is on the suppression list for your account.</p>
    public let emailAddress: String?
    /// <p>The date and time when the suppressed destination was last updated, shown in Unix time
    ///             format.</p>
    public let lastUpdateTime: Date?
    /// <p>The reason that the address was added to the suppression list for your account.</p>
    public let reason: SuppressionListReason?

    public init (
        attributes: SuppressedDestinationAttributes? = nil,
        emailAddress: String? = nil,
        lastUpdateTime: Date? = nil,
        reason: SuppressionListReason? = nil
    )
    {
        self.attributes = attributes
        self.emailAddress = emailAddress
        self.lastUpdateTime = lastUpdateTime
        self.reason = reason
    }
}

extension SuppressedDestinationAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case feedbackId = "FeedbackId"
        case messageId = "MessageId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let feedbackId = feedbackId {
            try encodeContainer.encode(feedbackId, forKey: .feedbackId)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let feedbackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .feedbackId)
        feedbackId = feedbackIdDecoded
    }
}

extension SuppressedDestinationAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SuppressedDestinationAttributes(feedbackId: \(String(describing: feedbackId)), messageId: \(String(describing: messageId)))"}
}

/// <p>An object that contains additional attributes that are related an email address that
///             is on the suppression list for your account.</p>
public struct SuppressedDestinationAttributes: Equatable {
    /// <p>A unique identifier that's generated when an email address is added to the suppression
    ///             list for your account.</p>
    public let feedbackId: String?
    /// <p>The unique identifier of the email message that caused the email address to be added
    ///             to the suppression list for your account.</p>
    public let messageId: String?

    public init (
        feedbackId: String? = nil,
        messageId: String? = nil
    )
    {
        self.feedbackId = feedbackId
        self.messageId = messageId
    }
}

extension SuppressedDestinationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emailAddress = "EmailAddress"
        case lastUpdateTime = "LastUpdateTime"
        case reason = "Reason"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let reason = reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(SuppressionListReason.self, forKey: .reason)
        reason = reasonDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension SuppressedDestinationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SuppressedDestinationSummary(emailAddress: \(String(describing: emailAddress)), lastUpdateTime: \(String(describing: lastUpdateTime)), reason: \(String(describing: reason)))"}
}

/// <p>A summary that describes the suppressed email address.</p>
public struct SuppressedDestinationSummary: Equatable {
    /// <p>The email address that's on the suppression list for your account.</p>
    public let emailAddress: String?
    /// <p>The date and time when the suppressed destination was last updated, shown in Unix time
    ///             format.</p>
    public let lastUpdateTime: Date?
    /// <p>The reason that the address was added to the suppression list for your account.</p>
    public let reason: SuppressionListReason?

    public init (
        emailAddress: String? = nil,
        lastUpdateTime: Date? = nil,
        reason: SuppressionListReason? = nil
    )
    {
        self.emailAddress = emailAddress
        self.lastUpdateTime = lastUpdateTime
        self.reason = reason
    }
}

extension SuppressionAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case suppressedReasons = "SuppressedReasons"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let suppressedReasons = suppressedReasons {
            var suppressedReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .suppressedReasons)
            for suppressionlistreasons0 in suppressedReasons {
                try suppressedReasonsContainer.encode(suppressionlistreasons0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suppressedReasonsContainer = try containerValues.decodeIfPresent([SuppressionListReason?].self, forKey: .suppressedReasons)
        var suppressedReasonsDecoded0:[SuppressionListReason]? = nil
        if let suppressedReasonsContainer = suppressedReasonsContainer {
            suppressedReasonsDecoded0 = [SuppressionListReason]()
            for string0 in suppressedReasonsContainer {
                if let string0 = string0 {
                    suppressedReasonsDecoded0?.append(string0)
                }
            }
        }
        suppressedReasons = suppressedReasonsDecoded0
    }
}

extension SuppressionAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SuppressionAttributes(suppressedReasons: \(String(describing: suppressedReasons)))"}
}

/// <p>An object that contains information about the email address suppression preferences
///             for your account in the current AWS Region.</p>
public struct SuppressionAttributes: Equatable {
    /// <p>A list that contains the reasons that email addresses will be automatically added to
    ///             the suppression list for your account. This list can contain any or all of the
    ///             following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>COMPLAINT</code> – Amazon SES adds an email address to the suppression
    ///                     list for your account when a message sent to that address results in a
    ///                     complaint.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>BOUNCE</code> – Amazon SES adds an email address to the suppression
    ///                     list for your account when a message sent to that address results in a hard
    ///                     bounce.</p>
    ///             </li>
    ///          </ul>
    public let suppressedReasons: [SuppressionListReason]?

    public init (
        suppressedReasons: [SuppressionListReason]? = nil
    )
    {
        self.suppressedReasons = suppressedReasons
    }
}

extension SuppressionListDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case suppressionListImportAction = "SuppressionListImportAction"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let suppressionListImportAction = suppressionListImportAction {
            try encodeContainer.encode(suppressionListImportAction.rawValue, forKey: .suppressionListImportAction)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suppressionListImportActionDecoded = try containerValues.decodeIfPresent(SuppressionListImportAction.self, forKey: .suppressionListImportAction)
        suppressionListImportAction = suppressionListImportActionDecoded
    }
}

extension SuppressionListDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SuppressionListDestination(suppressionListImportAction: \(String(describing: suppressionListImportAction)))"}
}

/// <p>An object that contains details about the action of suppression list.</p>
public struct SuppressionListDestination: Equatable {
    /// <p>The type of action that you want to perform on the address. Acceptable values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>PUT: add the addresses to the suppression list. If the record already exists,
    ///                     it will override it with the new value.</p>
    ///             </li>
    ///             <li>
    ///                 <p>DELETE: remove the addresses from the suppression list.</p>
    ///             </li>
    ///          </ul>
    public let suppressionListImportAction: SuppressionListImportAction?

    public init (
        suppressionListImportAction: SuppressionListImportAction? = nil
    )
    {
        self.suppressionListImportAction = suppressionListImportAction
    }
}

/// <p>The type of action that you want to perform on the address. Acceptable values:</p>
///         <ul>
///             <li>
///                 <p>PUT: add the addresses to the suppression list.</p>
///             </li>
///             <li>
///                 <p>DELETE: remove the address from the suppression list.</p>
///             </li>
///          </ul>
public enum SuppressionListImportAction {
    case delete
    case put
    case sdkUnknown(String)
}

extension SuppressionListImportAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SuppressionListImportAction] {
        return [
            .delete,
            .put,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .delete: return "DELETE"
        case .put: return "PUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SuppressionListImportAction(rawValue: rawValue) ?? SuppressionListImportAction.sdkUnknown(rawValue)
    }
}

/// <p>The reason that the address was added to the suppression list for your account. The
///             value can be one of the following:</p>
///         <ul>
///             <li>
///                 <p>
///                   <code>COMPLAINT</code> – Amazon SES added an email address to the suppression
///                     list for your account because a message sent to that address results in a
///                     complaint.</p>
///             </li>
///             <li>
///                 <p>
///                   <code>BOUNCE</code> – Amazon SES added an email address to the suppression
///                     list for your account because a message sent to that address results in a hard
///                     bounce.</p>
///             </li>
///          </ul>
public enum SuppressionListReason {
    case bounce
    case complaint
    case sdkUnknown(String)
}

extension SuppressionListReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SuppressionListReason] {
        return [
            .bounce,
            .complaint,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bounce: return "BOUNCE"
        case .complaint: return "COMPLAINT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SuppressionListReason(rawValue: rawValue) ?? SuppressionListReason.sdkUnknown(rawValue)
    }
}

extension SuppressionOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case suppressedReasons = "SuppressedReasons"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let suppressedReasons = suppressedReasons {
            var suppressedReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .suppressedReasons)
            for suppressionlistreasons0 in suppressedReasons {
                try suppressedReasonsContainer.encode(suppressionlistreasons0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suppressedReasonsContainer = try containerValues.decodeIfPresent([SuppressionListReason?].self, forKey: .suppressedReasons)
        var suppressedReasonsDecoded0:[SuppressionListReason]? = nil
        if let suppressedReasonsContainer = suppressedReasonsContainer {
            suppressedReasonsDecoded0 = [SuppressionListReason]()
            for string0 in suppressedReasonsContainer {
                if let string0 = string0 {
                    suppressedReasonsDecoded0?.append(string0)
                }
            }
        }
        suppressedReasons = suppressedReasonsDecoded0
    }
}

extension SuppressionOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SuppressionOptions(suppressedReasons: \(String(describing: suppressedReasons)))"}
}

/// <p>An object that contains information about the suppression list preferences for your
///             account.</p>
public struct SuppressionOptions: Equatable {
    /// <p>A list that contains the reasons that email addresses are automatically added to the
    ///             suppression list for your account. This list can contain any or all of the
    ///             following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>COMPLAINT</code> – Amazon SES adds an email address to the suppression
    ///                     list for your account when a message sent to that address results in a
    ///                     complaint.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>BOUNCE</code> – Amazon SES adds an email address to the suppression
    ///                     list for your account when a message sent to that address results in a hard
    ///                     bounce.</p>
    ///             </li>
    ///          </ul>
    public let suppressedReasons: [SuppressionListReason]?

    public init (
        suppressedReasons: [SuppressionListReason]? = nil
    )
    {
        self.suppressedReasons = suppressedReasons
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>An object that defines the tags that are associated with a resource.
///                 A <i>tag</i> is a label that you optionally define and associate with
///             a resource. Tags can help you categorize and manage resources in different ways, such as
///             by purpose, owner, environment, or other criteria. A resource can have as many as 50
///             tags.</p>
///         <p>Each tag consists of a required <i>tag key</i> and an
///                 associated <i>tag value</i>, both of which you define. A tag key is a
///             general label that acts as a category for a more specific tag value. A tag value acts as
///             a descriptor within a tag key. A tag key can contain as many as 128 characters. A tag
///             value can contain as many as 256 characters. The characters can be Unicode letters,
///             digits, white space, or one of the following symbols: _ . : / = + -. The following
///             additional restrictions apply to tags:</p>
///         <ul>
///             <li>
///                 <p>Tag keys and values are case sensitive.</p>
///             </li>
///             <li>
///                 <p>For each associated resource, each tag key must be unique and it can have only
///                     one value.</p>
///             </li>
///             <li>
///                 <p>The <code>aws:</code> prefix is reserved for use by AWS; you can’t use it in
///                     any tag keys or values that you define. In addition, you can't edit or remove
///                     tag keys or values that use this prefix. Tags that use this prefix don’t count
///                     against the limit of 50 tags per resource.</p>
///             </li>
///             <li>
///                 <p>You can associate tags with public or shared resources, but the tags are
///                     available only for your AWS account, not any other accounts that share the
///                     resource. In addition, the tags are available only for resources that are
///                     located in the specified AWS Region for your AWS account.</p>
///             </li>
///          </ul>
public struct Tag: Equatable {
    /// <p>One part of a key-value pair that defines a tag. The maximum length of a tag key is
    ///             128 characters. The minimum length is 1 character.</p>
    public let key: String?
    /// <p>The optional part of a key-value pair that defines a tag. The maximum length of a tag
    ///             value is 256 characters. The minimum length is 0 characters. If you don't want a
    ///             resource to have a specific tag value, don't specify a value for this parameter. If you
    ///             don't specify a value, Amazon SES sets the value to an empty string.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to add one or more tags
    ///             to.</p>
    public let resourceArn: String?
    /// <p>A list of the tags that you want to add to the resource. A tag consists of a required
    ///             tag key (<code>Key</code>) and an associated tag value (<code>Value</code>). The maximum
    ///             length of a tag key is 128 characters. The maximum length of a tag value is 256
    ///             characters.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Template: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case templateArn = "TemplateArn"
        case templateData = "TemplateData"
        case templateName = "TemplateName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateArn = templateArn {
            try encodeContainer.encode(templateArn, forKey: .templateArn)
        }
        if let templateData = templateData {
            try encodeContainer.encode(templateData, forKey: .templateData)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let templateDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateData)
        templateData = templateDataDecoded
    }
}

extension Template: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Template(templateArn: \(String(describing: templateArn)), templateData: \(String(describing: templateData)), templateName: \(String(describing: templateName)))"}
}

/// <p>An object that defines the email template to use for an email message, and the values
///             to use for any message variables in that template. An <i>email
///                 template</i> is a type of message template that contains content that you
///             want to define, save, and reuse in email messages that you send.</p>
public struct Template: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the template.</p>
    public let templateArn: String?
    /// <p>An object that defines the values to use for message variables in the template. This
    ///             object is a set of key-value pairs. Each key defines a message variable in the template.
    ///             The corresponding value defines the value to use for that variable.</p>
    public let templateData: String?
    /// <p>The name of the template. You will refer to this name when you send email using the
    ///                 <code>SendTemplatedEmail</code> or <code>SendBulkTemplatedEmail</code> operations.
    ///         </p>
    public let templateName: String?

    public init (
        templateArn: String? = nil,
        templateData: String? = nil,
        templateName: String? = nil
    )
    {
        self.templateArn = templateArn
        self.templateData = templateData
        self.templateName = templateName
    }
}

public struct TestRenderEmailTemplateInputBodyMiddleware: Middleware {
    public let id: String = "TestRenderEmailTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestRenderEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<TestRenderEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestRenderEmailTemplateInput>
    public typealias MOutput = OperationOutput<TestRenderEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestRenderEmailTemplateOutputError>
}

extension TestRenderEmailTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestRenderEmailTemplateInput(templateData: \(String(describing: templateData)), templateName: \(String(describing: templateName)))"}
}

extension TestRenderEmailTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case templateData = "TemplateData"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateData = templateData {
            try encodeContainer.encode(templateData, forKey: .templateData)
        }
    }
}

public struct TestRenderEmailTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "TestRenderEmailTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestRenderEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<TestRenderEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestRenderEmailTemplateInput>
    public typealias MOutput = OperationOutput<TestRenderEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestRenderEmailTemplateOutputError>
}

public struct TestRenderEmailTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "TestRenderEmailTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestRenderEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<TestRenderEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestRenderEmailTemplateInput>
    public typealias MOutput = OperationOutput<TestRenderEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestRenderEmailTemplateOutputError>
}

/// <p>>Represents a request to create a preview of the MIME content of an email when
///             provided with a template and a set of replacement data.</p>
public struct TestRenderEmailTemplateInput: Equatable {
    /// <p>A list of replacement values to apply to the template. This parameter is a JSON
    ///             object, typically consisting of key-value pairs in which the keys correspond to
    ///             replacement tags in the email template.</p>
    public let templateData: String?
    /// <p>The name of the template that you want to render.</p>
    public let templateName: String?

    public init (
        templateData: String? = nil,
        templateName: String? = nil
    )
    {
        self.templateData = templateData
        self.templateName = templateName
    }
}

struct TestRenderEmailTemplateInputBody: Equatable {
    public let templateData: String?
}

extension TestRenderEmailTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case templateData = "TemplateData"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateData)
        templateData = templateDataDecoded
    }
}

extension TestRenderEmailTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestRenderEmailTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestRenderEmailTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestRenderEmailTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestRenderEmailTemplateOutputResponse(renderedTemplate: \(String(describing: renderedTemplate)))"}
}

extension TestRenderEmailTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TestRenderEmailTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.renderedTemplate = output.renderedTemplate
        } else {
            self.renderedTemplate = nil
        }
    }
}

/// <p>The following element is returned by the service.</p>
public struct TestRenderEmailTemplateOutputResponse: Equatable {
    /// <p>The complete MIME message rendered by applying the data in the
    ///                 <code>TemplateData</code> parameter to the template specified in the TemplateName
    ///             parameter.</p>
    public let renderedTemplate: String?

    public init (
        renderedTemplate: String? = nil
    )
    {
        self.renderedTemplate = renderedTemplate
    }
}

struct TestRenderEmailTemplateOutputResponseBody: Equatable {
    public let renderedTemplate: String?
}

extension TestRenderEmailTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case renderedTemplate = "RenderedTemplate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let renderedTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .renderedTemplate)
        renderedTemplate = renderedTemplateDecoded
    }
}

/// <p>Specifies whether messages that use the configuration set are required to use
///             Transport Layer Security (TLS). If the value is <code>Require</code>, messages are only
///             delivered if a TLS connection can be established. If the value is <code>Optional</code>,
///             messages can be delivered in plain text if a TLS connection can't be established.</p>
public enum TlsPolicy {
    case `optional`
    case require
    case sdkUnknown(String)
}

extension TlsPolicy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TlsPolicy] {
        return [
            .optional,
            .require,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .optional: return "OPTIONAL"
        case .require: return "REQUIRE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TlsPolicy(rawValue: rawValue) ?? TlsPolicy.sdkUnknown(rawValue)
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Too many requests have been made to the operation.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Topic: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultSubscriptionStatus = "DefaultSubscriptionStatus"
        case description = "Description"
        case displayName = "DisplayName"
        case topicName = "TopicName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultSubscriptionStatus = defaultSubscriptionStatus {
            try encodeContainer.encode(defaultSubscriptionStatus.rawValue, forKey: .defaultSubscriptionStatus)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let topicName = topicName {
            try encodeContainer.encode(topicName, forKey: .topicName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicName)
        topicName = topicNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let defaultSubscriptionStatusDecoded = try containerValues.decodeIfPresent(SubscriptionStatus.self, forKey: .defaultSubscriptionStatus)
        defaultSubscriptionStatus = defaultSubscriptionStatusDecoded
    }
}

extension Topic: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Topic(defaultSubscriptionStatus: \(String(describing: defaultSubscriptionStatus)), description: \(String(describing: description)), displayName: \(String(describing: displayName)), topicName: \(String(describing: topicName)))"}
}

/// <p>An interest group, theme, or label within a list. Lists can have multiple
///             topics.</p>
public struct Topic: Equatable {
    /// <p>The default subscription status to be applied to a contact if the contact has not
    ///             noted their preference for subscribing to a topic.</p>
    public let defaultSubscriptionStatus: SubscriptionStatus?
    /// <p>A description of what the topic is about, which the contact will see.</p>
    public let description: String?
    /// <p>The name of the topic the contact will see.</p>
    public let displayName: String?
    /// <p>The name of the topic.</p>
    public let topicName: String?

    public init (
        defaultSubscriptionStatus: SubscriptionStatus? = nil,
        description: String? = nil,
        displayName: String? = nil,
        topicName: String? = nil
    )
    {
        self.defaultSubscriptionStatus = defaultSubscriptionStatus
        self.description = description
        self.displayName = displayName
        self.topicName = topicName
    }
}

extension TopicFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case topicName = "TopicName"
        case useDefaultIfPreferenceUnavailable = "UseDefaultIfPreferenceUnavailable"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicName = topicName {
            try encodeContainer.encode(topicName, forKey: .topicName)
        }
        if useDefaultIfPreferenceUnavailable != false {
            try encodeContainer.encode(useDefaultIfPreferenceUnavailable, forKey: .useDefaultIfPreferenceUnavailable)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicName)
        topicName = topicNameDecoded
        let useDefaultIfPreferenceUnavailableDecoded = try containerValues.decode(Bool.self, forKey: .useDefaultIfPreferenceUnavailable)
        useDefaultIfPreferenceUnavailable = useDefaultIfPreferenceUnavailableDecoded
    }
}

extension TopicFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TopicFilter(topicName: \(String(describing: topicName)), useDefaultIfPreferenceUnavailable: \(String(describing: useDefaultIfPreferenceUnavailable)))"}
}

/// <p>Used for filtering by a specific topic preference.</p>
public struct TopicFilter: Equatable {
    /// <p>The name of a topic on which you wish to apply the filter.</p>
    public let topicName: String?
    /// <p>Notes that the default subscription status should be applied to a contact because the
    ///             contact has not noted their preference for subscribing to a topic.</p>
    public let useDefaultIfPreferenceUnavailable: Bool

    public init (
        topicName: String? = nil,
        useDefaultIfPreferenceUnavailable: Bool = false
    )
    {
        self.topicName = topicName
        self.useDefaultIfPreferenceUnavailable = useDefaultIfPreferenceUnavailable
    }
}

extension TopicPreference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case subscriptionStatus = "SubscriptionStatus"
        case topicName = "TopicName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subscriptionStatus = subscriptionStatus {
            try encodeContainer.encode(subscriptionStatus.rawValue, forKey: .subscriptionStatus)
        }
        if let topicName = topicName {
            try encodeContainer.encode(topicName, forKey: .topicName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicName)
        topicName = topicNameDecoded
        let subscriptionStatusDecoded = try containerValues.decodeIfPresent(SubscriptionStatus.self, forKey: .subscriptionStatus)
        subscriptionStatus = subscriptionStatusDecoded
    }
}

extension TopicPreference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TopicPreference(subscriptionStatus: \(String(describing: subscriptionStatus)), topicName: \(String(describing: topicName)))"}
}

/// <p>The contact's preference for being opted-in to or opted-out of a topic.</p>
public struct TopicPreference: Equatable {
    /// <p>The contact's subscription status to a topic which is either <code>OPT_IN</code> or
    ///                 <code>OPT_OUT</code>.</p>
    public let subscriptionStatus: SubscriptionStatus?
    /// <p>The name of the topic.</p>
    public let topicName: String?

    public init (
        subscriptionStatus: SubscriptionStatus? = nil,
        topicName: String? = nil
    )
    {
        self.subscriptionStatus = subscriptionStatus
        self.topicName = topicName
    }
}

extension TrackingOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customRedirectDomain = "CustomRedirectDomain"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customRedirectDomain = customRedirectDomain {
            try encodeContainer.encode(customRedirectDomain, forKey: .customRedirectDomain)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customRedirectDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customRedirectDomain)
        customRedirectDomain = customRedirectDomainDecoded
    }
}

extension TrackingOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrackingOptions(customRedirectDomain: \(String(describing: customRedirectDomain)))"}
}

/// <p>An object that defines the tracking options for a configuration set. When you use the
///             Amazon SES API v2 to send an email, it contains an invisible image that's used to track when
///             recipients open your email. If your email contains links, those links are changed
///             slightly in order to track when recipients click them.</p>
///         <p>These images and links include references to a domain operated by AWS. You can
///             optionally configure the Amazon SES to use a domain that you operate for these images and
///             links.</p>
public struct TrackingOptions: Equatable {
    /// <p>The domain that you want to use for tracking open and click events.</p>
    public let customRedirectDomain: String?

    public init (
        customRedirectDomain: String? = nil
    )
    {
        self.customRedirectDomain = customRedirectDomain
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "ResourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "TagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to remove one or more
    ///             tags from.</p>
    public let resourceArn: String?
    /// <p>The tags (tag keys) that you want to remove from the resource. When you specify a tag
    ///             key, the action removes both that key and its associated tag value.</p>
    ///         <p>To remove more than one tag from the resource, append the <code>TagKeys</code>
    ///             parameter and argument for each additional tag to remove, separated by an ampersand. For
    ///             example:
    ///                 <code>/v2/email/tags?ResourceArn=ResourceArn&TagKeys=Key1&TagKeys=Key2</code>
    ///         </p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateConfigurationSetEventDestinationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetEventDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetEventDestinationOutputError>
}

extension UpdateConfigurationSetEventDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationSetEventDestinationInput(configurationSetName: \(String(describing: configurationSetName)), eventDestination: \(String(describing: eventDestination)), eventDestinationName: \(String(describing: eventDestinationName)))"}
}

extension UpdateConfigurationSetEventDestinationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventDestination = "EventDestination"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDestination = eventDestination {
            try encodeContainer.encode(eventDestination, forKey: .eventDestination)
        }
    }
}

public struct UpdateConfigurationSetEventDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetEventDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetEventDestinationOutputError>
}

public struct UpdateConfigurationSetEventDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetEventDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetEventDestinationOutputError>
}

/// <p>A request to change the settings for an event destination for a configuration
///             set.</p>
public struct UpdateConfigurationSetEventDestinationInput: Equatable {
    /// <p>The name of the configuration set that contains the event destination that you want to
    ///             modify.</p>
    public let configurationSetName: String?
    /// <p>An object that defines the event destination.</p>
    public let eventDestination: EventDestinationDefinition?
    /// <p>The name of the event destination that you want to modify.</p>
    public let eventDestinationName: String?

    public init (
        configurationSetName: String? = nil,
        eventDestination: EventDestinationDefinition? = nil,
        eventDestinationName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
        self.eventDestinationName = eventDestinationName
    }
}

struct UpdateConfigurationSetEventDestinationInputBody: Equatable {
    public let eventDestination: EventDestinationDefinition?
}

extension UpdateConfigurationSetEventDestinationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventDestination = "EventDestination"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDestinationDecoded = try containerValues.decodeIfPresent(EventDestinationDefinition.self, forKey: .eventDestination)
        eventDestination = eventDestinationDecoded
    }
}

extension UpdateConfigurationSetEventDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConfigurationSetEventDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigurationSetEventDestinationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigurationSetEventDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationSetEventDestinationOutputResponse()"}
}

extension UpdateConfigurationSetEventDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct UpdateConfigurationSetEventDestinationOutputResponse: Equatable {

    public init() {}
}

struct UpdateConfigurationSetEventDestinationOutputResponseBody: Equatable {
}

extension UpdateConfigurationSetEventDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateContactInputBodyMiddleware: Middleware {
    public let id: String = "UpdateContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactInput>
    public typealias MOutput = OperationOutput<UpdateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactOutputError>
}

extension UpdateContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateContactInput(attributesData: \(String(describing: attributesData)), contactListName: \(String(describing: contactListName)), emailAddress: \(String(describing: emailAddress)), topicPreferences: \(String(describing: topicPreferences)), unsubscribeAll: \(String(describing: unsubscribeAll)))"}
}

extension UpdateContactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributesData = "AttributesData"
        case topicPreferences = "TopicPreferences"
        case unsubscribeAll = "UnsubscribeAll"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributesData = attributesData {
            try encodeContainer.encode(attributesData, forKey: .attributesData)
        }
        if let topicPreferences = topicPreferences {
            var topicPreferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topicPreferences)
            for topicpreferencelist0 in topicPreferences {
                try topicPreferencesContainer.encode(topicpreferencelist0)
            }
        }
        if unsubscribeAll != false {
            try encodeContainer.encode(unsubscribeAll, forKey: .unsubscribeAll)
        }
    }
}

public struct UpdateContactInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactInput>
    public typealias MOutput = OperationOutput<UpdateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactOutputError>
}

public struct UpdateContactInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactInput>
    public typealias MOutput = OperationOutput<UpdateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactOutputError>
}

public struct UpdateContactInput: Equatable {
    /// <p>The attribute data attached to a contact.</p>
    public let attributesData: String?
    /// <p>The name of the contact list.</p>
    public let contactListName: String?
    /// <p>The contact's email addres.</p>
    public let emailAddress: String?
    /// <p>The contact's preference for being opted-in to or opted-out of a topic.</p>
    public let topicPreferences: [TopicPreference]?
    /// <p>A boolean value status noting if the contact is unsubscribed from all contact list
    ///             topics.</p>
    public let unsubscribeAll: Bool

    public init (
        attributesData: String? = nil,
        contactListName: String? = nil,
        emailAddress: String? = nil,
        topicPreferences: [TopicPreference]? = nil,
        unsubscribeAll: Bool = false
    )
    {
        self.attributesData = attributesData
        self.contactListName = contactListName
        self.emailAddress = emailAddress
        self.topicPreferences = topicPreferences
        self.unsubscribeAll = unsubscribeAll
    }
}

struct UpdateContactInputBody: Equatable {
    public let topicPreferences: [TopicPreference]?
    public let unsubscribeAll: Bool
    public let attributesData: String?
}

extension UpdateContactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributesData = "AttributesData"
        case topicPreferences = "TopicPreferences"
        case unsubscribeAll = "UnsubscribeAll"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicPreferencesContainer = try containerValues.decodeIfPresent([TopicPreference?].self, forKey: .topicPreferences)
        var topicPreferencesDecoded0:[TopicPreference]? = nil
        if let topicPreferencesContainer = topicPreferencesContainer {
            topicPreferencesDecoded0 = [TopicPreference]()
            for structure0 in topicPreferencesContainer {
                if let structure0 = structure0 {
                    topicPreferencesDecoded0?.append(structure0)
                }
            }
        }
        topicPreferences = topicPreferencesDecoded0
        let unsubscribeAllDecoded = try containerValues.decode(Bool.self, forKey: .unsubscribeAll)
        unsubscribeAll = unsubscribeAllDecoded
        let attributesDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributesData)
        attributesData = attributesDataDecoded
    }
}

public struct UpdateContactListInputBodyMiddleware: Middleware {
    public let id: String = "UpdateContactListInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactListInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactListInput>
    public typealias MOutput = OperationOutput<UpdateContactListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactListOutputError>
}

extension UpdateContactListInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateContactListInput(contactListName: \(String(describing: contactListName)), description: \(String(describing: description)), topics: \(String(describing: topics)))"}
}

extension UpdateContactListInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case topics = "Topics"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let topics = topics {
            var topicsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topics)
            for topics0 in topics {
                try topicsContainer.encode(topics0)
            }
        }
    }
}

public struct UpdateContactListInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateContactListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactListInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactListInput>
    public typealias MOutput = OperationOutput<UpdateContactListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactListOutputError>
}

public struct UpdateContactListInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateContactListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactListInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactListInput>
    public typealias MOutput = OperationOutput<UpdateContactListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactListOutputError>
}

public struct UpdateContactListInput: Equatable {
    /// <p>The name of the contact list.</p>
    public let contactListName: String?
    /// <p>A description of what the contact list is about.</p>
    public let description: String?
    /// <p>An interest group, theme, or label within a list. A contact list can have multiple
    ///             topics.</p>
    public let topics: [Topic]?

    public init (
        contactListName: String? = nil,
        description: String? = nil,
        topics: [Topic]? = nil
    )
    {
        self.contactListName = contactListName
        self.description = description
        self.topics = topics
    }
}

struct UpdateContactListInputBody: Equatable {
    public let topics: [Topic]?
    public let description: String?
}

extension UpdateContactListInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case topics = "Topics"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicsContainer = try containerValues.decodeIfPresent([Topic?].self, forKey: .topics)
        var topicsDecoded0:[Topic]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Topic]()
            for structure0 in topicsContainer {
                if let structure0 = structure0 {
                    topicsDecoded0?.append(structure0)
                }
            }
        }
        topics = topicsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateContactListOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactListOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactListOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactListOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateContactListOutputResponse()"}
}

extension UpdateContactListOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactListOutputResponse: Equatable {

    public init() {}
}

struct UpdateContactListOutputResponseBody: Equatable {
}

extension UpdateContactListOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UpdateContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateContactOutputResponse()"}
}

extension UpdateContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactOutputResponse: Equatable {

    public init() {}
}

struct UpdateContactOutputResponseBody: Equatable {
}

extension UpdateContactOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateCustomVerificationEmailTemplateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCustomVerificationEmailTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<UpdateCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomVerificationEmailTemplateOutputError>
}

extension UpdateCustomVerificationEmailTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCustomVerificationEmailTemplateInput(failureRedirectionURL: \(String(describing: failureRedirectionURL)), fromEmailAddress: \(String(describing: fromEmailAddress)), successRedirectionURL: \(String(describing: successRedirectionURL)), templateContent: \(String(describing: templateContent)), templateName: \(String(describing: templateName)), templateSubject: \(String(describing: templateSubject)))"}
}

extension UpdateCustomVerificationEmailTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failureRedirectionURL = "FailureRedirectionURL"
        case fromEmailAddress = "FromEmailAddress"
        case successRedirectionURL = "SuccessRedirectionURL"
        case templateContent = "TemplateContent"
        case templateSubject = "TemplateSubject"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureRedirectionURL = failureRedirectionURL {
            try encodeContainer.encode(failureRedirectionURL, forKey: .failureRedirectionURL)
        }
        if let fromEmailAddress = fromEmailAddress {
            try encodeContainer.encode(fromEmailAddress, forKey: .fromEmailAddress)
        }
        if let successRedirectionURL = successRedirectionURL {
            try encodeContainer.encode(successRedirectionURL, forKey: .successRedirectionURL)
        }
        if let templateContent = templateContent {
            try encodeContainer.encode(templateContent, forKey: .templateContent)
        }
        if let templateSubject = templateSubject {
            try encodeContainer.encode(templateSubject, forKey: .templateSubject)
        }
    }
}

public struct UpdateCustomVerificationEmailTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCustomVerificationEmailTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<UpdateCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomVerificationEmailTemplateOutputError>
}

public struct UpdateCustomVerificationEmailTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCustomVerificationEmailTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<UpdateCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomVerificationEmailTemplateOutputError>
}

/// <p>Represents a request to update an existing custom verification email template.</p>
public struct UpdateCustomVerificationEmailTemplateInput: Equatable {
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    ///             is not successfully verified.</p>
    public let failureRedirectionURL: String?
    /// <p>The email address that the custom verification email is sent from.</p>
    public let fromEmailAddress: String?
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    ///             is successfully verified.</p>
    public let successRedirectionURL: String?
    /// <p>The content of the custom verification email. The total size of the email must be less
    ///             than 10 MB. The message body may contain HTML, with some limitations. For more
    ///             information, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-verify-address-custom.html#custom-verification-emails-faq">Custom Verification Email Frequently Asked Questions</a> in the <i>Amazon SES
    ///                 Developer Guide</i>.</p>
    public let templateContent: String?
    /// <p>The name of the custom verification email template that you want to update.</p>
    public let templateName: String?
    /// <p>The subject line of the custom verification email.</p>
    public let templateSubject: String?

    public init (
        failureRedirectionURL: String? = nil,
        fromEmailAddress: String? = nil,
        successRedirectionURL: String? = nil,
        templateContent: String? = nil,
        templateName: String? = nil,
        templateSubject: String? = nil
    )
    {
        self.failureRedirectionURL = failureRedirectionURL
        self.fromEmailAddress = fromEmailAddress
        self.successRedirectionURL = successRedirectionURL
        self.templateContent = templateContent
        self.templateName = templateName
        self.templateSubject = templateSubject
    }
}

struct UpdateCustomVerificationEmailTemplateInputBody: Equatable {
    public let fromEmailAddress: String?
    public let templateSubject: String?
    public let templateContent: String?
    public let successRedirectionURL: String?
    public let failureRedirectionURL: String?
}

extension UpdateCustomVerificationEmailTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failureRedirectionURL = "FailureRedirectionURL"
        case fromEmailAddress = "FromEmailAddress"
        case successRedirectionURL = "SuccessRedirectionURL"
        case templateContent = "TemplateContent"
        case templateSubject = "TemplateSubject"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromEmailAddress)
        fromEmailAddress = fromEmailAddressDecoded
        let templateSubjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateSubject)
        templateSubject = templateSubjectDecoded
        let templateContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateContent)
        templateContent = templateContentDecoded
        let successRedirectionURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .successRedirectionURL)
        successRedirectionURL = successRedirectionURLDecoded
        let failureRedirectionURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureRedirectionURL)
        failureRedirectionURL = failureRedirectionURLDecoded
    }
}

extension UpdateCustomVerificationEmailTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCustomVerificationEmailTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCustomVerificationEmailTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCustomVerificationEmailTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCustomVerificationEmailTemplateOutputResponse()"}
}

extension UpdateCustomVerificationEmailTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>If the action is successful, the service sends back an HTTP 200 response with an empty
///             HTTP body.</p>
public struct UpdateCustomVerificationEmailTemplateOutputResponse: Equatable {

    public init() {}
}

struct UpdateCustomVerificationEmailTemplateOutputResponseBody: Equatable {
}

extension UpdateCustomVerificationEmailTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateEmailIdentityPolicyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateEmailIdentityPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEmailIdentityPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEmailIdentityPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEmailIdentityPolicyInput>
    public typealias MOutput = OperationOutput<UpdateEmailIdentityPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEmailIdentityPolicyOutputError>
}

extension UpdateEmailIdentityPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEmailIdentityPolicyInput(emailIdentity: \(String(describing: emailIdentity)), policy: \(String(describing: policy)), policyName: \(String(describing: policyName)))"}
}

extension UpdateEmailIdentityPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct UpdateEmailIdentityPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateEmailIdentityPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEmailIdentityPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEmailIdentityPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEmailIdentityPolicyInput>
    public typealias MOutput = OperationOutput<UpdateEmailIdentityPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEmailIdentityPolicyOutputError>
}

public struct UpdateEmailIdentityPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateEmailIdentityPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEmailIdentityPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEmailIdentityPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEmailIdentityPolicyInput>
    public typealias MOutput = OperationOutput<UpdateEmailIdentityPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEmailIdentityPolicyOutputError>
}

/// <p>Represents a request to update a sending authorization policy for an identity. Sending
///             authorization is an Amazon SES feature that enables you to authorize other senders to use
///             your identities. For information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization-identity-owner-tasks-management.html">Amazon SES Developer Guide</a>.</p>
public struct UpdateEmailIdentityPolicyInput: Equatable {
    /// <p>The email identity for which you want to update policy.</p>
    public let emailIdentity: String?
    /// <p>The text of the policy in JSON format. The policy cannot exceed 4 KB.</p>
    ///         <p> For information about the syntax of sending authorization policies, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization-policies.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    public let policy: String?
    /// <p>The name of the policy.</p>
    ///
    ///         <p>The policy name cannot exceed 64 characters and can only include alphanumeric
    ///             characters, dashes, and underscores.</p>
    public let policyName: String?

    public init (
        emailIdentity: String? = nil,
        policy: String? = nil,
        policyName: String? = nil
    )
    {
        self.emailIdentity = emailIdentity
        self.policy = policy
        self.policyName = policyName
    }
}

struct UpdateEmailIdentityPolicyInputBody: Equatable {
    public let policy: String?
}

extension UpdateEmailIdentityPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension UpdateEmailIdentityPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEmailIdentityPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEmailIdentityPolicyOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEmailIdentityPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEmailIdentityPolicyOutputResponse()"}
}

extension UpdateEmailIdentityPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct UpdateEmailIdentityPolicyOutputResponse: Equatable {

    public init() {}
}

struct UpdateEmailIdentityPolicyOutputResponseBody: Equatable {
}

extension UpdateEmailIdentityPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateEmailTemplateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateEmailTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEmailTemplateInput>
    public typealias MOutput = OperationOutput<UpdateEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEmailTemplateOutputError>
}

extension UpdateEmailTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEmailTemplateInput(templateContent: \(String(describing: templateContent)), templateName: \(String(describing: templateName)))"}
}

extension UpdateEmailTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case templateContent = "TemplateContent"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateContent = templateContent {
            try encodeContainer.encode(templateContent, forKey: .templateContent)
        }
    }
}

public struct UpdateEmailTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateEmailTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEmailTemplateInput>
    public typealias MOutput = OperationOutput<UpdateEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEmailTemplateOutputError>
}

public struct UpdateEmailTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateEmailTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEmailTemplateInput>
    public typealias MOutput = OperationOutput<UpdateEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEmailTemplateOutputError>
}

/// <p>Represents a request to update an email template. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-personalized-email-api.html">Amazon SES
///                 Developer Guide</a>.</p>
public struct UpdateEmailTemplateInput: Equatable {
    /// <p>The content of the email template, composed of a subject line, an HTML part, and a
    ///             text-only part.</p>
    public let templateContent: EmailTemplateContent?
    /// <p>The name of the template you want to update.</p>
    public let templateName: String?

    public init (
        templateContent: EmailTemplateContent? = nil,
        templateName: String? = nil
    )
    {
        self.templateContent = templateContent
        self.templateName = templateName
    }
}

struct UpdateEmailTemplateInputBody: Equatable {
    public let templateContent: EmailTemplateContent?
}

extension UpdateEmailTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case templateContent = "TemplateContent"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateContentDecoded = try containerValues.decodeIfPresent(EmailTemplateContent.self, forKey: .templateContent)
        templateContent = templateContentDecoded
    }
}

extension UpdateEmailTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEmailTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEmailTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEmailTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEmailTemplateOutputResponse()"}
}

extension UpdateEmailTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>If the action is successful, the service sends back an HTTP 200 response with an empty
///             HTTP body.</p>
public struct UpdateEmailTemplateOutputResponse: Equatable {

    public init() {}
}

struct UpdateEmailTemplateOutputResponseBody: Equatable {
}

extension UpdateEmailTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension VolumeStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inboxRawCount = "InboxRawCount"
        case projectedInbox = "ProjectedInbox"
        case projectedSpam = "ProjectedSpam"
        case spamRawCount = "SpamRawCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inboxRawCount = inboxRawCount {
            try encodeContainer.encode(inboxRawCount, forKey: .inboxRawCount)
        }
        if let projectedInbox = projectedInbox {
            try encodeContainer.encode(projectedInbox, forKey: .projectedInbox)
        }
        if let projectedSpam = projectedSpam {
            try encodeContainer.encode(projectedSpam, forKey: .projectedSpam)
        }
        if let spamRawCount = spamRawCount {
            try encodeContainer.encode(spamRawCount, forKey: .spamRawCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inboxRawCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .inboxRawCount)
        inboxRawCount = inboxRawCountDecoded
        let spamRawCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .spamRawCount)
        spamRawCount = spamRawCountDecoded
        let projectedInboxDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .projectedInbox)
        projectedInbox = projectedInboxDecoded
        let projectedSpamDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .projectedSpam)
        projectedSpam = projectedSpamDecoded
    }
}

extension VolumeStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VolumeStatistics(inboxRawCount: \(String(describing: inboxRawCount)), projectedInbox: \(String(describing: projectedInbox)), projectedSpam: \(String(describing: projectedSpam)), spamRawCount: \(String(describing: spamRawCount)))"}
}

/// <p>An object that contains information about the amount of email that was delivered to
///             recipients.</p>
public struct VolumeStatistics: Equatable {
    /// <p>The total number of emails that arrived in recipients' inboxes.</p>
    public let inboxRawCount: Int?
    /// <p>An estimate of the percentage of emails sent from the current domain that will arrive
    ///             in recipients' inboxes.</p>
    public let projectedInbox: Int?
    /// <p>An estimate of the percentage of emails sent from the current domain that will arrive
    ///             in recipients' spam or junk mail folders.</p>
    public let projectedSpam: Int?
    /// <p>The total number of emails that arrived in recipients' spam or junk mail
    ///             folders.</p>
    public let spamRawCount: Int?

    public init (
        inboxRawCount: Int? = nil,
        projectedInbox: Int? = nil,
        projectedSpam: Int? = nil,
        spamRawCount: Int? = nil
    )
    {
        self.inboxRawCount = inboxRawCount
        self.projectedInbox = projectedInbox
        self.projectedSpam = projectedSpam
        self.spamRawCount = spamRawCount
    }
}

/// <p>The warmup status of a dedicated IP.</p>
public enum WarmupStatus {
    case done
    case inProgress
    case sdkUnknown(String)
}

extension WarmupStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WarmupStatus] {
        return [
            .done,
            .inProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .done: return "DONE"
        case .inProgress: return "IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WarmupStatus(rawValue: rawValue) ?? WarmupStatus.sdkUnknown(rawValue)
    }
}
