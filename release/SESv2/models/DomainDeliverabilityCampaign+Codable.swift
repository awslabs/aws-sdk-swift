// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension DomainDeliverabilityCampaign: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case campaignId = "CampaignId"
        case deleteRate = "DeleteRate"
        case esps = "Esps"
        case firstSeenDateTime = "FirstSeenDateTime"
        case fromAddress = "FromAddress"
        case imageUrl = "ImageUrl"
        case inboxCount = "InboxCount"
        case lastSeenDateTime = "LastSeenDateTime"
        case projectedVolume = "ProjectedVolume"
        case readDeleteRate = "ReadDeleteRate"
        case readRate = "ReadRate"
        case sendingIps = "SendingIps"
        case spamCount = "SpamCount"
        case subject = "Subject"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignId = campaignId {
            try encodeContainer.encode(campaignId, forKey: .campaignId)
        }
        if let deleteRate = deleteRate {
            try encodeContainer.encode(deleteRate, forKey: .deleteRate)
        }
        if let esps = esps {
            var espsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .esps)
            for esps0 in esps {
                try espsContainer.encode(esps0)
            }
        }
        if let firstSeenDateTime = firstSeenDateTime {
            try encodeContainer.encode(firstSeenDateTime.timeIntervalSince1970, forKey: .firstSeenDateTime)
        }
        if let fromAddress = fromAddress {
            try encodeContainer.encode(fromAddress, forKey: .fromAddress)
        }
        if let imageUrl = imageUrl {
            try encodeContainer.encode(imageUrl, forKey: .imageUrl)
        }
        if let inboxCount = inboxCount {
            try encodeContainer.encode(inboxCount, forKey: .inboxCount)
        }
        if let lastSeenDateTime = lastSeenDateTime {
            try encodeContainer.encode(lastSeenDateTime.timeIntervalSince1970, forKey: .lastSeenDateTime)
        }
        if let projectedVolume = projectedVolume {
            try encodeContainer.encode(projectedVolume, forKey: .projectedVolume)
        }
        if let readDeleteRate = readDeleteRate {
            try encodeContainer.encode(readDeleteRate, forKey: .readDeleteRate)
        }
        if let readRate = readRate {
            try encodeContainer.encode(readRate, forKey: .readRate)
        }
        if let sendingIps = sendingIps {
            var sendingIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sendingIps)
            for iplist0 in sendingIps {
                try sendingIpsContainer.encode(iplist0)
            }
        }
        if let spamCount = spamCount {
            try encodeContainer.encode(spamCount, forKey: .spamCount)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .campaignId)
        campaignId = campaignIdDecoded
        let imageUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageUrl)
        imageUrl = imageUrlDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let fromAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromAddress)
        fromAddress = fromAddressDecoded
        let sendingIpsContainer = try containerValues.decodeIfPresent([String].self, forKey: .sendingIps)
        var sendingIpsDecoded0:[String]? = nil
        if let sendingIpsContainer = sendingIpsContainer {
            sendingIpsDecoded0 = [String]()
            for string0 in sendingIpsContainer {
                sendingIpsDecoded0?.append(string0)
            }
        }
        sendingIps = sendingIpsDecoded0
        let firstSeenDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .firstSeenDateTime)
        firstSeenDateTime = firstSeenDateTimeDecoded
        let lastSeenDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastSeenDateTime)
        lastSeenDateTime = lastSeenDateTimeDecoded
        let inboxCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .inboxCount)
        inboxCount = inboxCountDecoded
        let spamCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .spamCount)
        spamCount = spamCountDecoded
        let readRateDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .readRate)
        readRate = readRateDecoded
        let deleteRateDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .deleteRate)
        deleteRate = deleteRateDecoded
        let readDeleteRateDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .readDeleteRate)
        readDeleteRate = readDeleteRateDecoded
        let projectedVolumeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .projectedVolume)
        projectedVolume = projectedVolumeDecoded
        let espsContainer = try containerValues.decodeIfPresent([String].self, forKey: .esps)
        var espsDecoded0:[String]? = nil
        if let espsContainer = espsContainer {
            espsDecoded0 = [String]()
            for string0 in espsContainer {
                espsDecoded0?.append(string0)
            }
        }
        esps = espsDecoded0
    }
}
