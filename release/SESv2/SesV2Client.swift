// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class SesV2Client {
    let client: SdkHttpClient
    let config: SesV2ClientConfiguration
    let serviceName = "SESv2"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: SesV2ClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class SesV2ClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> SesV2ClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try SesV2ClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension SesV2Client: SesV2ClientProtocol {
    /// <p>Create a configuration set. <i>Configuration sets</i> are groups of
    ///             rules that you can apply to the emails that you send. You apply a configuration set to
    ///             an email by specifying the name of the configuration set when you call the Amazon SES API v2. When
    ///             you apply a configuration set to an email, all of the rules in that configuration set
    ///             are applied to the email. </p>
    public func createConfigurationSet(input: CreateConfigurationSetInput, completion: @escaping (SdkResult<CreateConfigurationSetOutputResponse, CreateConfigurationSetOutputError>) -> Void)
    {
        let urlPath = "/v2/email/configuration-sets"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createConfigurationSet")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateConfigurationSetInput, CreateConfigurationSetOutputResponse, CreateConfigurationSetOutputError>(id: "createConfigurationSet")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateConfigurationSetInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateConfigurationSetInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateConfigurationSetInput, CreateConfigurationSetOutputResponse, CreateConfigurationSetOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateConfigurationSetInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Create an event destination. <i>Events</i> include message sends,
    ///             deliveries, opens, clicks, bounces, and complaints. <i>Event
    ///                 destinations</i> are places that you can send information about these events
    ///             to. For example, you can send event data to Amazon SNS to receive notifications when you
    ///             receive bounces or complaints, or you can use Amazon Kinesis Data Firehose to stream data to Amazon S3 for long-term
    ///             storage.</p>
    ///         <p>A single configuration set can include more than one event destination.</p>
    public func createConfigurationSetEventDestination(input: CreateConfigurationSetEventDestinationInput, completion: @escaping (SdkResult<CreateConfigurationSetEventDestinationOutputResponse, CreateConfigurationSetEventDestinationOutputError>) -> Void)
    {
        guard let configurationSetName = input.configurationSetName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component configurationSetName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/configuration-sets/\(configurationSetName)/event-destinations"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createConfigurationSetEventDestination")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateConfigurationSetEventDestinationInput, CreateConfigurationSetEventDestinationOutputResponse, CreateConfigurationSetEventDestinationOutputError>(id: "createConfigurationSetEventDestination")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateConfigurationSetEventDestinationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateConfigurationSetEventDestinationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateConfigurationSetEventDestinationInput, CreateConfigurationSetEventDestinationOutputResponse, CreateConfigurationSetEventDestinationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateConfigurationSetEventDestinationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a contact, which is an end-user who is receiving the email, and adds them to a
    ///             contact list.</p>
    public func createContact(input: CreateContactInput, completion: @escaping (SdkResult<CreateContactOutputResponse, CreateContactOutputError>) -> Void)
    {
        guard let contactListName = input.contactListName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component contactListName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/contact-lists/\(contactListName)/contacts"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createContact")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateContactInput, CreateContactOutputResponse, CreateContactOutputError>(id: "createContact")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateContactInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateContactInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateContactInput, CreateContactOutputResponse, CreateContactOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateContactInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a contact list.</p>
    public func createContactList(input: CreateContactListInput, completion: @escaping (SdkResult<CreateContactListOutputResponse, CreateContactListOutputError>) -> Void)
    {
        let urlPath = "/v2/email/contact-lists"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createContactList")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateContactListInput, CreateContactListOutputResponse, CreateContactListOutputError>(id: "createContactList")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateContactListInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateContactListInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateContactListInput, CreateContactListOutputResponse, CreateContactListOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateContactListInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new custom verification email template.</p>
    ///         <p>For more information about custom verification email templates, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-verify-address-custom.html">Using Custom Verification Email Templates</a> in the <i>Amazon SES Developer
    ///                 Guide</i>.</p>
    ///         <p>You can execute this operation no more than once per second.</p>
    public func createCustomVerificationEmailTemplate(input: CreateCustomVerificationEmailTemplateInput, completion: @escaping (SdkResult<CreateCustomVerificationEmailTemplateOutputResponse, CreateCustomVerificationEmailTemplateOutputError>) -> Void)
    {
        let urlPath = "/v2/email/custom-verification-email-templates"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createCustomVerificationEmailTemplate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateCustomVerificationEmailTemplateInput, CreateCustomVerificationEmailTemplateOutputResponse, CreateCustomVerificationEmailTemplateOutputError>(id: "createCustomVerificationEmailTemplate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateCustomVerificationEmailTemplateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateCustomVerificationEmailTemplateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateCustomVerificationEmailTemplateInput, CreateCustomVerificationEmailTemplateOutputResponse, CreateCustomVerificationEmailTemplateOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateCustomVerificationEmailTemplateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Create a new pool of dedicated IP addresses. A pool can include one or more dedicated
    ///             IP addresses that are associated with your AWS account. You can associate a pool with
    ///             a configuration set. When you send an email that uses that configuration set, the
    ///             message is sent from one of the addresses in the associated pool.</p>
    public func createDedicatedIpPool(input: CreateDedicatedIpPoolInput, completion: @escaping (SdkResult<CreateDedicatedIpPoolOutputResponse, CreateDedicatedIpPoolOutputError>) -> Void)
    {
        let urlPath = "/v2/email/dedicated-ip-pools"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createDedicatedIpPool")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateDedicatedIpPoolInput, CreateDedicatedIpPoolOutputResponse, CreateDedicatedIpPoolOutputError>(id: "createDedicatedIpPool")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateDedicatedIpPoolInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateDedicatedIpPoolInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateDedicatedIpPoolInput, CreateDedicatedIpPoolOutputResponse, CreateDedicatedIpPoolOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateDedicatedIpPoolInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Create a new predictive inbox placement test. Predictive inbox placement tests can help you predict how your messages will be handled
    ///             by various email providers around the world. When you perform a predictive inbox placement test, you provide a
    ///             sample message that contains the content that you plan to send to your customers. Amazon SES
    ///             then sends that message to special email addresses spread across several major email
    ///             providers. After about 24 hours, the test is complete, and you can use the
    ///                 <code>GetDeliverabilityTestReport</code> operation to view the results of the
    ///             test.</p>
    public func createDeliverabilityTestReport(input: CreateDeliverabilityTestReportInput, completion: @escaping (SdkResult<CreateDeliverabilityTestReportOutputResponse, CreateDeliverabilityTestReportOutputError>) -> Void)
    {
        let urlPath = "/v2/email/deliverability-dashboard/test"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createDeliverabilityTestReport")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateDeliverabilityTestReportInput, CreateDeliverabilityTestReportOutputResponse, CreateDeliverabilityTestReportOutputError>(id: "createDeliverabilityTestReport")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateDeliverabilityTestReportInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateDeliverabilityTestReportInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateDeliverabilityTestReportInput, CreateDeliverabilityTestReportOutputResponse, CreateDeliverabilityTestReportOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateDeliverabilityTestReportInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Starts the process of verifying an email identity. An <i>identity</i> is
    ///             an email address or domain that you use when you send email. Before you can use an
    ///             identity to send email, you first have to verify it. By verifying an identity, you
    ///             demonstrate that you're the owner of the identity, and that you've given Amazon SES API v2
    ///             permission to send email from the identity.</p>
    ///         <p>When you verify an email address, Amazon SES sends an email to the address. Your email
    ///             address is verified as soon as you follow the link in the verification email.
    ///
    ///         </p>
    ///         <p>When you verify a domain without specifying the <code>DkimSigningAttributes</code>
    ///             object, this operation provides a set of DKIM tokens. You can convert these tokens into
    ///             CNAME records, which you then add to the DNS configuration for your domain. Your domain
    ///             is verified when Amazon SES detects these records in the DNS configuration for your domain.
    ///             This verification method is known as <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html">Easy DKIM</a>.</p>
    ///         <p>Alternatively, you can perform the verification process by providing your own
    ///             public-private key pair. This verification method is known as Bring Your Own DKIM
    ///             (BYODKIM). To use BYODKIM, your call to the <code>CreateEmailIdentity</code> operation
    ///             has to include the <code>DkimSigningAttributes</code> object. When you specify this
    ///             object, you provide a selector (a component of the DNS record name that identifies the
    ///             public key that you want to use for DKIM authentication) and a private key.</p>
    ///         <p>When you verify a domain, this operation provides a set of DKIM tokens, which you can
    ///             convert into CNAME tokens. You add these CNAME tokens to the DNS configuration for your
    ///             domain. Your domain is verified when Amazon SES detects these records in the DNS
    ///             configuration for your domain. For some DNS providers, it can take 72 hours or more to
    ///             complete the domain verification process.</p>
    ///         <p>Additionally, you can associate an existing configuration set with the email identity that you're verifying.</p>
    public func createEmailIdentity(input: CreateEmailIdentityInput, completion: @escaping (SdkResult<CreateEmailIdentityOutputResponse, CreateEmailIdentityOutputError>) -> Void)
    {
        let urlPath = "/v2/email/identities"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createEmailIdentity")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateEmailIdentityInput, CreateEmailIdentityOutputResponse, CreateEmailIdentityOutputError>(id: "createEmailIdentity")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateEmailIdentityInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateEmailIdentityInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateEmailIdentityInput, CreateEmailIdentityOutputResponse, CreateEmailIdentityOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateEmailIdentityInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates the specified sending authorization policy for the given identity (an email
    ///         address or a domain).</p>
    ///         <note>
    ///             <p>This API is for the identity owner only. If you have not verified the identity,
    ///                 this API will return an error.</p>
    ///         </note>
    ///         <p>Sending authorization is a feature that enables an identity owner to authorize other
    ///             senders to use its identities. For information about using sending authorization, see
    ///             the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    ///
    ///         <p>You can execute this operation no more than once per second.</p>
    public func createEmailIdentityPolicy(input: CreateEmailIdentityPolicyInput, completion: @escaping (SdkResult<CreateEmailIdentityPolicyOutputResponse, CreateEmailIdentityPolicyOutputError>) -> Void)
    {
        guard let emailIdentity = input.emailIdentity else {
            completion(.failure(.client(ClientError.serializationFailed("uri component emailIdentity unexpectedly nil"))))
            return
        }
        guard let policyName = input.policyName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component policyName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/identities/\(emailIdentity)/policies/\(policyName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createEmailIdentityPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateEmailIdentityPolicyInput, CreateEmailIdentityPolicyOutputResponse, CreateEmailIdentityPolicyOutputError>(id: "createEmailIdentityPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateEmailIdentityPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateEmailIdentityPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateEmailIdentityPolicyInput, CreateEmailIdentityPolicyOutputResponse, CreateEmailIdentityPolicyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateEmailIdentityPolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an email template. Email templates enable you to send personalized email to
    ///             one or more destinations in a single API operation. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-personalized-email-api.html">Amazon SES
    ///                 Developer Guide</a>.</p>
    ///         <p>You can execute this operation no more than once per second.</p>
    public func createEmailTemplate(input: CreateEmailTemplateInput, completion: @escaping (SdkResult<CreateEmailTemplateOutputResponse, CreateEmailTemplateOutputError>) -> Void)
    {
        let urlPath = "/v2/email/templates"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createEmailTemplate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateEmailTemplateInput, CreateEmailTemplateOutputResponse, CreateEmailTemplateOutputError>(id: "createEmailTemplate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateEmailTemplateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateEmailTemplateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateEmailTemplateInput, CreateEmailTemplateOutputResponse, CreateEmailTemplateOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateEmailTemplateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an import job for a data destination.</p>
    public func createImportJob(input: CreateImportJobInput, completion: @escaping (SdkResult<CreateImportJobOutputResponse, CreateImportJobOutputError>) -> Void)
    {
        let urlPath = "/v2/email/import-jobs"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createImportJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateImportJobInput, CreateImportJobOutputResponse, CreateImportJobOutputError>(id: "createImportJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateImportJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateImportJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateImportJobInput, CreateImportJobOutputResponse, CreateImportJobOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateImportJobInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Delete an existing configuration set.</p>
    ///         <p>
    ///             <i>Configuration sets</i> are groups of rules that you can apply to the
    ///             emails you send. You apply a configuration set to an email by including a reference to
    ///             the configuration set in the headers of the email. When you apply a configuration set to
    ///             an email, all of the rules in that configuration set are applied to the email.</p>
    public func deleteConfigurationSet(input: DeleteConfigurationSetInput, completion: @escaping (SdkResult<DeleteConfigurationSetOutputResponse, DeleteConfigurationSetOutputError>) -> Void)
    {
        guard let configurationSetName = input.configurationSetName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component configurationSetName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/configuration-sets/\(configurationSetName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteConfigurationSet")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteConfigurationSetInput, DeleteConfigurationSetOutputResponse, DeleteConfigurationSetOutputError>(id: "deleteConfigurationSet")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteConfigurationSetInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteConfigurationSetInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteConfigurationSetInput, DeleteConfigurationSetOutputResponse, DeleteConfigurationSetOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Delete an event destination.</p>
    ///         <p>
    ///             <i>Events</i> include message sends, deliveries, opens, clicks, bounces,
    ///             and complaints. <i>Event destinations</i> are places that you can send
    ///             information about these events to. For example, you can send event data to Amazon SNS to
    ///             receive notifications when you receive bounces or complaints, or you can use Amazon Kinesis Data Firehose to
    ///             stream data to Amazon S3 for long-term storage.</p>
    public func deleteConfigurationSetEventDestination(input: DeleteConfigurationSetEventDestinationInput, completion: @escaping (SdkResult<DeleteConfigurationSetEventDestinationOutputResponse, DeleteConfigurationSetEventDestinationOutputError>) -> Void)
    {
        guard let configurationSetName = input.configurationSetName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component configurationSetName unexpectedly nil"))))
            return
        }
        guard let eventDestinationName = input.eventDestinationName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component eventDestinationName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/configuration-sets/\(configurationSetName)/event-destinations/\(eventDestinationName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteConfigurationSetEventDestination")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteConfigurationSetEventDestinationInput, DeleteConfigurationSetEventDestinationOutputResponse, DeleteConfigurationSetEventDestinationOutputError>(id: "deleteConfigurationSetEventDestination")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteConfigurationSetEventDestinationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteConfigurationSetEventDestinationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteConfigurationSetEventDestinationInput, DeleteConfigurationSetEventDestinationOutputResponse, DeleteConfigurationSetEventDestinationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes a contact from a contact list.</p>
    public func deleteContact(input: DeleteContactInput, completion: @escaping (SdkResult<DeleteContactOutputResponse, DeleteContactOutputError>) -> Void)
    {
        guard let contactListName = input.contactListName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component contactListName unexpectedly nil"))))
            return
        }
        guard let emailAddress = input.emailAddress else {
            completion(.failure(.client(ClientError.serializationFailed("uri component emailAddress unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/contact-lists/\(contactListName)/contacts/\(emailAddress)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteContact")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteContactInput, DeleteContactOutputResponse, DeleteContactOutputError>(id: "deleteContact")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteContactInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteContactInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteContactInput, DeleteContactOutputResponse, DeleteContactOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a contact list and all of the contacts on that list.</p>
    public func deleteContactList(input: DeleteContactListInput, completion: @escaping (SdkResult<DeleteContactListOutputResponse, DeleteContactListOutputError>) -> Void)
    {
        guard let contactListName = input.contactListName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component contactListName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/contact-lists/\(contactListName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteContactList")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteContactListInput, DeleteContactListOutputResponse, DeleteContactListOutputError>(id: "deleteContactList")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteContactListInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteContactListInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteContactListInput, DeleteContactListOutputResponse, DeleteContactListOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an existing custom verification email template.</p>
    ///         <p>For more information about custom verification email templates, see <a href="https://docs.aws.amazon.com/es/latest/DeveloperGuide/send-email-verify-address-custom.html">Using Custom Verification Email Templates</a> in the <i>Amazon SES Developer
    ///                 Guide</i>.</p>
    ///         <p>You can execute this operation no more than once per second.</p>
    public func deleteCustomVerificationEmailTemplate(input: DeleteCustomVerificationEmailTemplateInput, completion: @escaping (SdkResult<DeleteCustomVerificationEmailTemplateOutputResponse, DeleteCustomVerificationEmailTemplateOutputError>) -> Void)
    {
        guard let templateName = input.templateName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component templateName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/custom-verification-email-templates/\(templateName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteCustomVerificationEmailTemplate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteCustomVerificationEmailTemplateInput, DeleteCustomVerificationEmailTemplateOutputResponse, DeleteCustomVerificationEmailTemplateOutputError>(id: "deleteCustomVerificationEmailTemplate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteCustomVerificationEmailTemplateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteCustomVerificationEmailTemplateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteCustomVerificationEmailTemplateInput, DeleteCustomVerificationEmailTemplateOutputResponse, DeleteCustomVerificationEmailTemplateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Delete a dedicated IP pool.</p>
    public func deleteDedicatedIpPool(input: DeleteDedicatedIpPoolInput, completion: @escaping (SdkResult<DeleteDedicatedIpPoolOutputResponse, DeleteDedicatedIpPoolOutputError>) -> Void)
    {
        guard let poolName = input.poolName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component poolName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/dedicated-ip-pools/\(poolName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteDedicatedIpPool")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteDedicatedIpPoolInput, DeleteDedicatedIpPoolOutputResponse, DeleteDedicatedIpPoolOutputError>(id: "deleteDedicatedIpPool")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteDedicatedIpPoolInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteDedicatedIpPoolInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteDedicatedIpPoolInput, DeleteDedicatedIpPoolOutputResponse, DeleteDedicatedIpPoolOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an email identity. An identity can be either an email address or a domain
    ///             name.</p>
    public func deleteEmailIdentity(input: DeleteEmailIdentityInput, completion: @escaping (SdkResult<DeleteEmailIdentityOutputResponse, DeleteEmailIdentityOutputError>) -> Void)
    {
        guard let emailIdentity = input.emailIdentity else {
            completion(.failure(.client(ClientError.serializationFailed("uri component emailIdentity unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/identities/\(emailIdentity)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteEmailIdentity")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteEmailIdentityInput, DeleteEmailIdentityOutputResponse, DeleteEmailIdentityOutputError>(id: "deleteEmailIdentity")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteEmailIdentityInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteEmailIdentityInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteEmailIdentityInput, DeleteEmailIdentityOutputResponse, DeleteEmailIdentityOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified sending authorization policy for the given identity (an email
    ///             address or a domain). This API returns successfully even if a policy with the specified
    ///             name does not exist.</p>
    ///         <note>
    ///             <p>This API is for the identity owner only. If you have not verified the identity,
    ///                 this API will return an error.</p>
    ///         </note>
    ///         <p>Sending authorization is a feature that enables an identity owner to authorize other
    ///             senders to use its identities. For information about using sending authorization, see
    ///             the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    ///
    ///         <p>You can execute this operation no more than once per second.</p>
    public func deleteEmailIdentityPolicy(input: DeleteEmailIdentityPolicyInput, completion: @escaping (SdkResult<DeleteEmailIdentityPolicyOutputResponse, DeleteEmailIdentityPolicyOutputError>) -> Void)
    {
        guard let emailIdentity = input.emailIdentity else {
            completion(.failure(.client(ClientError.serializationFailed("uri component emailIdentity unexpectedly nil"))))
            return
        }
        guard let policyName = input.policyName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component policyName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/identities/\(emailIdentity)/policies/\(policyName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteEmailIdentityPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteEmailIdentityPolicyInput, DeleteEmailIdentityPolicyOutputResponse, DeleteEmailIdentityPolicyOutputError>(id: "deleteEmailIdentityPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteEmailIdentityPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteEmailIdentityPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteEmailIdentityPolicyInput, DeleteEmailIdentityPolicyOutputResponse, DeleteEmailIdentityPolicyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an email template.</p>
    ///
    ///         <p>You can execute this operation no more than once per second.</p>
    public func deleteEmailTemplate(input: DeleteEmailTemplateInput, completion: @escaping (SdkResult<DeleteEmailTemplateOutputResponse, DeleteEmailTemplateOutputError>) -> Void)
    {
        guard let templateName = input.templateName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component templateName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/templates/\(templateName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteEmailTemplate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteEmailTemplateInput, DeleteEmailTemplateOutputResponse, DeleteEmailTemplateOutputError>(id: "deleteEmailTemplate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteEmailTemplateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteEmailTemplateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteEmailTemplateInput, DeleteEmailTemplateOutputResponse, DeleteEmailTemplateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes an email address from the suppression list for your account.</p>
    public func deleteSuppressedDestination(input: DeleteSuppressedDestinationInput, completion: @escaping (SdkResult<DeleteSuppressedDestinationOutputResponse, DeleteSuppressedDestinationOutputError>) -> Void)
    {
        guard let emailAddress = input.emailAddress else {
            completion(.failure(.client(ClientError.serializationFailed("uri component emailAddress unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/suppression/addresses/\(emailAddress)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteSuppressedDestination")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteSuppressedDestinationInput, DeleteSuppressedDestinationOutputResponse, DeleteSuppressedDestinationOutputError>(id: "deleteSuppressedDestination")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteSuppressedDestinationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteSuppressedDestinationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteSuppressedDestinationInput, DeleteSuppressedDestinationOutputResponse, DeleteSuppressedDestinationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Obtain information about the email-sending status and capabilities of your Amazon SES
    ///             account in the current AWS Region.</p>
    public func getAccount(input: GetAccountInput, completion: @escaping (SdkResult<GetAccountOutputResponse, GetAccountOutputError>) -> Void)
    {
        let urlPath = "/v2/email/account"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getAccount")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetAccountInput, GetAccountOutputResponse, GetAccountOutputError>(id: "getAccount")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetAccountInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetAccountInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetAccountInput, GetAccountOutputResponse, GetAccountOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieve a list of the blacklists that your dedicated IP addresses appear on.</p>
    public func getBlacklistReports(input: GetBlacklistReportsInput, completion: @escaping (SdkResult<GetBlacklistReportsOutputResponse, GetBlacklistReportsOutputError>) -> Void)
    {
        let urlPath = "/v2/email/deliverability-dashboard/blacklist-report"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getBlacklistReports")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetBlacklistReportsInput, GetBlacklistReportsOutputResponse, GetBlacklistReportsOutputError>(id: "getBlacklistReports")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetBlacklistReportsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetBlacklistReportsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetBlacklistReportsInput, GetBlacklistReportsOutputResponse, GetBlacklistReportsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get information about an existing configuration set, including the dedicated IP pool
    ///             that it's associated with, whether or not it's enabled for sending email, and
    ///             more.</p>
    ///         <p>
    ///             <i>Configuration sets</i> are groups of rules that you can apply to the
    ///             emails you send. You apply a configuration set to an email by including a reference to
    ///             the configuration set in the headers of the email. When you apply a configuration set to
    ///             an email, all of the rules in that configuration set are applied to the email.</p>
    public func getConfigurationSet(input: GetConfigurationSetInput, completion: @escaping (SdkResult<GetConfigurationSetOutputResponse, GetConfigurationSetOutputError>) -> Void)
    {
        guard let configurationSetName = input.configurationSetName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component configurationSetName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/configuration-sets/\(configurationSetName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getConfigurationSet")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetConfigurationSetInput, GetConfigurationSetOutputResponse, GetConfigurationSetOutputError>(id: "getConfigurationSet")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetConfigurationSetInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetConfigurationSetInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetConfigurationSetInput, GetConfigurationSetOutputResponse, GetConfigurationSetOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieve a list of event destinations that are associated with a configuration
    ///             set.</p>
    ///         <p>
    ///             <i>Events</i> include message sends, deliveries, opens, clicks, bounces,
    ///             and complaints. <i>Event destinations</i> are places that you can send
    ///             information about these events to. For example, you can send event data to Amazon SNS to
    ///             receive notifications when you receive bounces or complaints, or you can use Amazon Kinesis Data Firehose to
    ///             stream data to Amazon S3 for long-term storage.</p>
    public func getConfigurationSetEventDestinations(input: GetConfigurationSetEventDestinationsInput, completion: @escaping (SdkResult<GetConfigurationSetEventDestinationsOutputResponse, GetConfigurationSetEventDestinationsOutputError>) -> Void)
    {
        guard let configurationSetName = input.configurationSetName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component configurationSetName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/configuration-sets/\(configurationSetName)/event-destinations"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getConfigurationSetEventDestinations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetConfigurationSetEventDestinationsInput, GetConfigurationSetEventDestinationsOutputResponse, GetConfigurationSetEventDestinationsOutputError>(id: "getConfigurationSetEventDestinations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetConfigurationSetEventDestinationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetConfigurationSetEventDestinationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetConfigurationSetEventDestinationsInput, GetConfigurationSetEventDestinationsOutputResponse, GetConfigurationSetEventDestinationsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a contact from a contact list.</p>
    public func getContact(input: GetContactInput, completion: @escaping (SdkResult<GetContactOutputResponse, GetContactOutputError>) -> Void)
    {
        guard let contactListName = input.contactListName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component contactListName unexpectedly nil"))))
            return
        }
        guard let emailAddress = input.emailAddress else {
            completion(.failure(.client(ClientError.serializationFailed("uri component emailAddress unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/contact-lists/\(contactListName)/contacts/\(emailAddress)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getContact")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetContactInput, GetContactOutputResponse, GetContactOutputError>(id: "getContact")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetContactInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetContactInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetContactInput, GetContactOutputResponse, GetContactOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns contact list metadata. It does not return any information about the contacts
    ///             present in the list.</p>
    public func getContactList(input: GetContactListInput, completion: @escaping (SdkResult<GetContactListOutputResponse, GetContactListOutputError>) -> Void)
    {
        guard let contactListName = input.contactListName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component contactListName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/contact-lists/\(contactListName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getContactList")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetContactListInput, GetContactListOutputResponse, GetContactListOutputError>(id: "getContactList")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetContactListInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetContactListInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetContactListInput, GetContactListOutputResponse, GetContactListOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the custom email verification template for the template name you
    ///             specify.</p>
    ///         <p>For more information about custom verification email templates, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-verify-address-custom.html">Using Custom Verification Email Templates</a> in the <i>Amazon SES Developer
    ///                 Guide</i>.</p>
    ///         <p>You can execute this operation no more than once per second.</p>
    public func getCustomVerificationEmailTemplate(input: GetCustomVerificationEmailTemplateInput, completion: @escaping (SdkResult<GetCustomVerificationEmailTemplateOutputResponse, GetCustomVerificationEmailTemplateOutputError>) -> Void)
    {
        guard let templateName = input.templateName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component templateName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/custom-verification-email-templates/\(templateName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getCustomVerificationEmailTemplate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetCustomVerificationEmailTemplateInput, GetCustomVerificationEmailTemplateOutputResponse, GetCustomVerificationEmailTemplateOutputError>(id: "getCustomVerificationEmailTemplate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetCustomVerificationEmailTemplateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetCustomVerificationEmailTemplateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetCustomVerificationEmailTemplateInput, GetCustomVerificationEmailTemplateOutputResponse, GetCustomVerificationEmailTemplateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get information about a dedicated IP address, including the name of the dedicated IP
    ///             pool that it's associated with, as well information about the automatic warm-up process
    ///             for the address.</p>
    public func getDedicatedIp(input: GetDedicatedIpInput, completion: @escaping (SdkResult<GetDedicatedIpOutputResponse, GetDedicatedIpOutputError>) -> Void)
    {
        guard let ip = input.ip else {
            completion(.failure(.client(ClientError.serializationFailed("uri component ip unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/dedicated-ips/\(ip)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDedicatedIp")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDedicatedIpInput, GetDedicatedIpOutputResponse, GetDedicatedIpOutputError>(id: "getDedicatedIp")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDedicatedIpInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDedicatedIpInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetDedicatedIpInput, GetDedicatedIpOutputResponse, GetDedicatedIpOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List the dedicated IP addresses that are associated with your AWS
    ///             account.</p>
    public func getDedicatedIps(input: GetDedicatedIpsInput, completion: @escaping (SdkResult<GetDedicatedIpsOutputResponse, GetDedicatedIpsOutputError>) -> Void)
    {
        let urlPath = "/v2/email/dedicated-ips"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDedicatedIps")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDedicatedIpsInput, GetDedicatedIpsOutputResponse, GetDedicatedIpsOutputError>(id: "getDedicatedIps")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDedicatedIpsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDedicatedIpsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetDedicatedIpsInput, GetDedicatedIpsOutputResponse, GetDedicatedIpsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieve information about the status of the Deliverability dashboard for your account. When
    ///             the Deliverability dashboard is enabled, you gain access to reputation, deliverability, and other
    ///             metrics for the domains that you use to send email. You also gain the ability to perform
    ///             predictive inbox placement tests.</p>
    ///
    ///         <p>When you use the Deliverability dashboard, you pay a monthly subscription charge, in addition
    ///             to any other fees that you accrue by using Amazon SES and other AWS services. For more
    ///             information about the features and cost of a Deliverability dashboard subscription, see <a href="http://aws.amazon.com/ses/pricing/">Amazon SES Pricing</a>.</p>
    public func getDeliverabilityDashboardOptions(input: GetDeliverabilityDashboardOptionsInput, completion: @escaping (SdkResult<GetDeliverabilityDashboardOptionsOutputResponse, GetDeliverabilityDashboardOptionsOutputError>) -> Void)
    {
        let urlPath = "/v2/email/deliverability-dashboard"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDeliverabilityDashboardOptions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDeliverabilityDashboardOptionsInput, GetDeliverabilityDashboardOptionsOutputResponse, GetDeliverabilityDashboardOptionsOutputError>(id: "getDeliverabilityDashboardOptions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDeliverabilityDashboardOptionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDeliverabilityDashboardOptionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetDeliverabilityDashboardOptionsInput, GetDeliverabilityDashboardOptionsOutputResponse, GetDeliverabilityDashboardOptionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieve the results of a predictive inbox placement test.</p>
    public func getDeliverabilityTestReport(input: GetDeliverabilityTestReportInput, completion: @escaping (SdkResult<GetDeliverabilityTestReportOutputResponse, GetDeliverabilityTestReportOutputError>) -> Void)
    {
        guard let reportId = input.reportId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component reportId unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/deliverability-dashboard/test-reports/\(reportId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDeliverabilityTestReport")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDeliverabilityTestReportInput, GetDeliverabilityTestReportOutputResponse, GetDeliverabilityTestReportOutputError>(id: "getDeliverabilityTestReport")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDeliverabilityTestReportInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDeliverabilityTestReportInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetDeliverabilityTestReportInput, GetDeliverabilityTestReportOutputResponse, GetDeliverabilityTestReportOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieve all the deliverability data for a specific campaign. This data is available
    ///             for a campaign only if the campaign sent email by using a domain that the
    ///             Deliverability dashboard is enabled for.</p>
    public func getDomainDeliverabilityCampaign(input: GetDomainDeliverabilityCampaignInput, completion: @escaping (SdkResult<GetDomainDeliverabilityCampaignOutputResponse, GetDomainDeliverabilityCampaignOutputError>) -> Void)
    {
        guard let campaignId = input.campaignId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component campaignId unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/deliverability-dashboard/campaigns/\(campaignId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDomainDeliverabilityCampaign")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDomainDeliverabilityCampaignInput, GetDomainDeliverabilityCampaignOutputResponse, GetDomainDeliverabilityCampaignOutputError>(id: "getDomainDeliverabilityCampaign")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDomainDeliverabilityCampaignInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDomainDeliverabilityCampaignInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetDomainDeliverabilityCampaignInput, GetDomainDeliverabilityCampaignOutputResponse, GetDomainDeliverabilityCampaignOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieve inbox placement and engagement rates for the domains that you use to send
    ///             email.</p>
    public func getDomainStatisticsReport(input: GetDomainStatisticsReportInput, completion: @escaping (SdkResult<GetDomainStatisticsReportOutputResponse, GetDomainStatisticsReportOutputError>) -> Void)
    {
        guard let domain = input.domain else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domain unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/deliverability-dashboard/statistics-report/\(domain)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDomainStatisticsReport")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDomainStatisticsReportInput, GetDomainStatisticsReportOutputResponse, GetDomainStatisticsReportOutputError>(id: "getDomainStatisticsReport")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDomainStatisticsReportInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDomainStatisticsReportInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetDomainStatisticsReportInput, GetDomainStatisticsReportOutputResponse, GetDomainStatisticsReportOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides information about a specific identity, including the identity's verification
    ///             status, sending authorization policies, its DKIM authentication status, and its custom
    ///             Mail-From settings.</p>
    public func getEmailIdentity(input: GetEmailIdentityInput, completion: @escaping (SdkResult<GetEmailIdentityOutputResponse, GetEmailIdentityOutputError>) -> Void)
    {
        guard let emailIdentity = input.emailIdentity else {
            completion(.failure(.client(ClientError.serializationFailed("uri component emailIdentity unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/identities/\(emailIdentity)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getEmailIdentity")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetEmailIdentityInput, GetEmailIdentityOutputResponse, GetEmailIdentityOutputError>(id: "getEmailIdentity")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetEmailIdentityInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetEmailIdentityInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetEmailIdentityInput, GetEmailIdentityOutputResponse, GetEmailIdentityOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the requested sending authorization policies for the given identity (an email
    ///             address or a domain). The policies are returned as a map of policy names to policy
    ///             contents. You can retrieve a maximum of 20 policies at a time.</p>
    ///         <note>
    ///             <p>This API is for the identity owner only. If you have not verified the identity,
    ///                 this API will return an error.</p>
    ///         </note>
    ///         <p>Sending authorization is a feature that enables an identity owner to authorize other
    ///             senders to use its identities. For information about using sending authorization, see
    ///             the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    ///         <p>You can execute this operation no more than once per second.</p>
    public func getEmailIdentityPolicies(input: GetEmailIdentityPoliciesInput, completion: @escaping (SdkResult<GetEmailIdentityPoliciesOutputResponse, GetEmailIdentityPoliciesOutputError>) -> Void)
    {
        guard let emailIdentity = input.emailIdentity else {
            completion(.failure(.client(ClientError.serializationFailed("uri component emailIdentity unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/identities/\(emailIdentity)/policies"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getEmailIdentityPolicies")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetEmailIdentityPoliciesInput, GetEmailIdentityPoliciesOutputResponse, GetEmailIdentityPoliciesOutputError>(id: "getEmailIdentityPolicies")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetEmailIdentityPoliciesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetEmailIdentityPoliciesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetEmailIdentityPoliciesInput, GetEmailIdentityPoliciesOutputResponse, GetEmailIdentityPoliciesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Displays the template object (which includes the subject line, HTML part and text
    ///             part) for the template you specify.</p>
    ///
    ///         <p>You can execute this operation no more than once per second.</p>
    public func getEmailTemplate(input: GetEmailTemplateInput, completion: @escaping (SdkResult<GetEmailTemplateOutputResponse, GetEmailTemplateOutputError>) -> Void)
    {
        guard let templateName = input.templateName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component templateName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/templates/\(templateName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getEmailTemplate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetEmailTemplateInput, GetEmailTemplateOutputResponse, GetEmailTemplateOutputError>(id: "getEmailTemplate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetEmailTemplateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetEmailTemplateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetEmailTemplateInput, GetEmailTemplateOutputResponse, GetEmailTemplateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides information about an import job.</p>
    public func getImportJob(input: GetImportJobInput, completion: @escaping (SdkResult<GetImportJobOutputResponse, GetImportJobOutputError>) -> Void)
    {
        guard let jobId = input.jobId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component jobId unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/import-jobs/\(jobId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getImportJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetImportJobInput, GetImportJobOutputResponse, GetImportJobOutputError>(id: "getImportJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetImportJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetImportJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetImportJobInput, GetImportJobOutputResponse, GetImportJobOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves information about a specific email address that's on the suppression list
    ///             for your account.</p>
    public func getSuppressedDestination(input: GetSuppressedDestinationInput, completion: @escaping (SdkResult<GetSuppressedDestinationOutputResponse, GetSuppressedDestinationOutputError>) -> Void)
    {
        guard let emailAddress = input.emailAddress else {
            completion(.failure(.client(ClientError.serializationFailed("uri component emailAddress unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/suppression/addresses/\(emailAddress)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getSuppressedDestination")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetSuppressedDestinationInput, GetSuppressedDestinationOutputResponse, GetSuppressedDestinationOutputError>(id: "getSuppressedDestination")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetSuppressedDestinationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetSuppressedDestinationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetSuppressedDestinationInput, GetSuppressedDestinationOutputResponse, GetSuppressedDestinationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List all of the configuration sets associated with your account in the current
    ///             region.</p>
    ///         <p>
    ///             <i>Configuration sets</i> are groups of rules that you can apply to the
    ///             emails you send. You apply a configuration set to an email by including a reference to
    ///             the configuration set in the headers of the email. When you apply a configuration set to
    ///             an email, all of the rules in that configuration set are applied to the email.</p>
    public func listConfigurationSets(input: ListConfigurationSetsInput, completion: @escaping (SdkResult<ListConfigurationSetsOutputResponse, ListConfigurationSetsOutputError>) -> Void)
    {
        let urlPath = "/v2/email/configuration-sets"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listConfigurationSets")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListConfigurationSetsInput, ListConfigurationSetsOutputResponse, ListConfigurationSetsOutputError>(id: "listConfigurationSets")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListConfigurationSetsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListConfigurationSetsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListConfigurationSetsInput, ListConfigurationSetsOutputResponse, ListConfigurationSetsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists all of the contact lists available.</p>
    public func listContactLists(input: ListContactListsInput, completion: @escaping (SdkResult<ListContactListsOutputResponse, ListContactListsOutputError>) -> Void)
    {
        let urlPath = "/v2/email/contact-lists"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listContactLists")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListContactListsInput, ListContactListsOutputResponse, ListContactListsOutputError>(id: "listContactLists")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListContactListsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListContactListsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListContactListsInput, ListContactListsOutputResponse, ListContactListsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the contacts present in a specific contact list.</p>
    public func listContacts(input: ListContactsInput, completion: @escaping (SdkResult<ListContactsOutputResponse, ListContactsOutputError>) -> Void)
    {
        guard let contactListName = input.contactListName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component contactListName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/contact-lists/\(contactListName)/contacts"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listContacts")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListContactsInput, ListContactsOutputResponse, ListContactsOutputError>(id: "listContacts")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListContactsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListContactsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListContactsInput, ListContactsOutputResponse, ListContactsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListContactsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the existing custom verification email templates for your account in the current
    ///             AWS Region.</p>
    ///         <p>For more information about custom verification email templates, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-verify-address-custom.html">Using Custom Verification Email Templates</a> in the <i>Amazon SES Developer
    ///                 Guide</i>.</p>
    ///         <p>You can execute this operation no more than once per second.</p>
    public func listCustomVerificationEmailTemplates(input: ListCustomVerificationEmailTemplatesInput, completion: @escaping (SdkResult<ListCustomVerificationEmailTemplatesOutputResponse, ListCustomVerificationEmailTemplatesOutputError>) -> Void)
    {
        let urlPath = "/v2/email/custom-verification-email-templates"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listCustomVerificationEmailTemplates")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListCustomVerificationEmailTemplatesInput, ListCustomVerificationEmailTemplatesOutputResponse, ListCustomVerificationEmailTemplatesOutputError>(id: "listCustomVerificationEmailTemplates")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListCustomVerificationEmailTemplatesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListCustomVerificationEmailTemplatesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListCustomVerificationEmailTemplatesInput, ListCustomVerificationEmailTemplatesOutputResponse, ListCustomVerificationEmailTemplatesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List all of the dedicated IP pools that exist in your AWS account in the current
    ///             Region.</p>
    public func listDedicatedIpPools(input: ListDedicatedIpPoolsInput, completion: @escaping (SdkResult<ListDedicatedIpPoolsOutputResponse, ListDedicatedIpPoolsOutputError>) -> Void)
    {
        let urlPath = "/v2/email/dedicated-ip-pools"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDedicatedIpPools")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDedicatedIpPoolsInput, ListDedicatedIpPoolsOutputResponse, ListDedicatedIpPoolsOutputError>(id: "listDedicatedIpPools")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDedicatedIpPoolsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDedicatedIpPoolsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDedicatedIpPoolsInput, ListDedicatedIpPoolsOutputResponse, ListDedicatedIpPoolsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Show a list of the predictive inbox placement tests that you've performed, regardless of their statuses. For
    ///             predictive inbox placement tests that are complete, you can use the <code>GetDeliverabilityTestReport</code>
    ///             operation to view the results.</p>
    public func listDeliverabilityTestReports(input: ListDeliverabilityTestReportsInput, completion: @escaping (SdkResult<ListDeliverabilityTestReportsOutputResponse, ListDeliverabilityTestReportsOutputError>) -> Void)
    {
        let urlPath = "/v2/email/deliverability-dashboard/test-reports"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDeliverabilityTestReports")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDeliverabilityTestReportsInput, ListDeliverabilityTestReportsOutputResponse, ListDeliverabilityTestReportsOutputError>(id: "listDeliverabilityTestReports")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDeliverabilityTestReportsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDeliverabilityTestReportsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDeliverabilityTestReportsInput, ListDeliverabilityTestReportsOutputResponse, ListDeliverabilityTestReportsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieve deliverability data for all the campaigns that used a specific domain to send
    ///             email during a specified time range. This data is available for a domain only if you
    ///             enabled the Deliverability dashboard for the domain.</p>
    public func listDomainDeliverabilityCampaigns(input: ListDomainDeliverabilityCampaignsInput, completion: @escaping (SdkResult<ListDomainDeliverabilityCampaignsOutputResponse, ListDomainDeliverabilityCampaignsOutputError>) -> Void)
    {
        guard let subscribedDomain = input.subscribedDomain else {
            completion(.failure(.client(ClientError.serializationFailed("uri component subscribedDomain unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/deliverability-dashboard/domains/\(subscribedDomain)/campaigns"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDomainDeliverabilityCampaigns")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDomainDeliverabilityCampaignsInput, ListDomainDeliverabilityCampaignsOutputResponse, ListDomainDeliverabilityCampaignsOutputError>(id: "listDomainDeliverabilityCampaigns")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDomainDeliverabilityCampaignsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDomainDeliverabilityCampaignsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDomainDeliverabilityCampaignsInput, ListDomainDeliverabilityCampaignsOutputResponse, ListDomainDeliverabilityCampaignsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of all of the email identities that are associated with your AWS
    ///             account. An identity can be either an email address or a domain. This operation returns
    ///             identities that are verified as well as those that aren't. This operation returns
    ///             identities that are associated with Amazon SES and Amazon Pinpoint.</p>
    public func listEmailIdentities(input: ListEmailIdentitiesInput, completion: @escaping (SdkResult<ListEmailIdentitiesOutputResponse, ListEmailIdentitiesOutputError>) -> Void)
    {
        let urlPath = "/v2/email/identities"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listEmailIdentities")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListEmailIdentitiesInput, ListEmailIdentitiesOutputResponse, ListEmailIdentitiesOutputError>(id: "listEmailIdentities")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListEmailIdentitiesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListEmailIdentitiesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListEmailIdentitiesInput, ListEmailIdentitiesOutputResponse, ListEmailIdentitiesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the email templates present in your Amazon SES account in the current AWS
    ///             Region.</p>
    ///
    ///         <p>You can execute this operation no more than once per second.</p>
    public func listEmailTemplates(input: ListEmailTemplatesInput, completion: @escaping (SdkResult<ListEmailTemplatesOutputResponse, ListEmailTemplatesOutputError>) -> Void)
    {
        let urlPath = "/v2/email/templates"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listEmailTemplates")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListEmailTemplatesInput, ListEmailTemplatesOutputResponse, ListEmailTemplatesOutputError>(id: "listEmailTemplates")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListEmailTemplatesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListEmailTemplatesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListEmailTemplatesInput, ListEmailTemplatesOutputResponse, ListEmailTemplatesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists all of the import jobs.</p>
    public func listImportJobs(input: ListImportJobsInput, completion: @escaping (SdkResult<ListImportJobsOutputResponse, ListImportJobsOutputError>) -> Void)
    {
        let urlPath = "/v2/email/import-jobs"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listImportJobs")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListImportJobsInput, ListImportJobsOutputResponse, ListImportJobsOutputError>(id: "listImportJobs")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListImportJobsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListImportJobsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListImportJobsInput, ListImportJobsOutputResponse, ListImportJobsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListImportJobsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a list of email addresses that are on the suppression list for your
    ///             account.</p>
    public func listSuppressedDestinations(input: ListSuppressedDestinationsInput, completion: @escaping (SdkResult<ListSuppressedDestinationsOutputResponse, ListSuppressedDestinationsOutputError>) -> Void)
    {
        let urlPath = "/v2/email/suppression/addresses"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listSuppressedDestinations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListSuppressedDestinationsInput, ListSuppressedDestinationsOutputResponse, ListSuppressedDestinationsOutputError>(id: "listSuppressedDestinations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListSuppressedDestinationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListSuppressedDestinationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListSuppressedDestinationsInput, ListSuppressedDestinationsOutputResponse, ListSuppressedDestinationsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieve a list of the tags (keys and values) that are associated with a specified
    ///             resource. A <i>tag</i> is a label that you optionally define and associate
    ///             with a resource. Each tag consists of a required <i>tag key</i> and an
    ///             optional associated <i>tag value</i>. A tag key is a general label that
    ///             acts as a category for more specific tag values. A tag value acts as a descriptor within
    ///             a tag key.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>) -> Void)
    {
        let urlPath = "/v2/email/tags"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Enable or disable the automatic warm-up feature for dedicated IP addresses.</p>
    public func putAccountDedicatedIpWarmupAttributes(input: PutAccountDedicatedIpWarmupAttributesInput, completion: @escaping (SdkResult<PutAccountDedicatedIpWarmupAttributesOutputResponse, PutAccountDedicatedIpWarmupAttributesOutputError>) -> Void)
    {
        let urlPath = "/v2/email/account/dedicated-ips/warmup"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putAccountDedicatedIpWarmupAttributes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutAccountDedicatedIpWarmupAttributesInput, PutAccountDedicatedIpWarmupAttributesOutputResponse, PutAccountDedicatedIpWarmupAttributesOutputError>(id: "putAccountDedicatedIpWarmupAttributes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutAccountDedicatedIpWarmupAttributesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutAccountDedicatedIpWarmupAttributesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutAccountDedicatedIpWarmupAttributesInput, PutAccountDedicatedIpWarmupAttributesOutputResponse, PutAccountDedicatedIpWarmupAttributesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutAccountDedicatedIpWarmupAttributesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Update your Amazon SES account details.</p>
    public func putAccountDetails(input: PutAccountDetailsInput, completion: @escaping (SdkResult<PutAccountDetailsOutputResponse, PutAccountDetailsOutputError>) -> Void)
    {
        let urlPath = "/v2/email/account/details"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putAccountDetails")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutAccountDetailsInput, PutAccountDetailsOutputResponse, PutAccountDetailsOutputError>(id: "putAccountDetails")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutAccountDetailsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutAccountDetailsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutAccountDetailsInput, PutAccountDetailsOutputResponse, PutAccountDetailsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutAccountDetailsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Enable or disable the ability of your account to send email.</p>
    public func putAccountSendingAttributes(input: PutAccountSendingAttributesInput, completion: @escaping (SdkResult<PutAccountSendingAttributesOutputResponse, PutAccountSendingAttributesOutputError>) -> Void)
    {
        let urlPath = "/v2/email/account/sending"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putAccountSendingAttributes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutAccountSendingAttributesInput, PutAccountSendingAttributesOutputResponse, PutAccountSendingAttributesOutputError>(id: "putAccountSendingAttributes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutAccountSendingAttributesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutAccountSendingAttributesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutAccountSendingAttributesInput, PutAccountSendingAttributesOutputResponse, PutAccountSendingAttributesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutAccountSendingAttributesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Change the settings for the account-level suppression list.</p>
    public func putAccountSuppressionAttributes(input: PutAccountSuppressionAttributesInput, completion: @escaping (SdkResult<PutAccountSuppressionAttributesOutputResponse, PutAccountSuppressionAttributesOutputError>) -> Void)
    {
        let urlPath = "/v2/email/account/suppression"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putAccountSuppressionAttributes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutAccountSuppressionAttributesInput, PutAccountSuppressionAttributesOutputResponse, PutAccountSuppressionAttributesOutputError>(id: "putAccountSuppressionAttributes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutAccountSuppressionAttributesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutAccountSuppressionAttributesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutAccountSuppressionAttributesInput, PutAccountSuppressionAttributesOutputResponse, PutAccountSuppressionAttributesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutAccountSuppressionAttributesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Associate a configuration set with a dedicated IP pool. You can use dedicated IP pools
    ///             to create groups of dedicated IP addresses for sending specific types of email.</p>
    public func putConfigurationSetDeliveryOptions(input: PutConfigurationSetDeliveryOptionsInput, completion: @escaping (SdkResult<PutConfigurationSetDeliveryOptionsOutputResponse, PutConfigurationSetDeliveryOptionsOutputError>) -> Void)
    {
        guard let configurationSetName = input.configurationSetName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component configurationSetName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/configuration-sets/\(configurationSetName)/delivery-options"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putConfigurationSetDeliveryOptions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutConfigurationSetDeliveryOptionsInput, PutConfigurationSetDeliveryOptionsOutputResponse, PutConfigurationSetDeliveryOptionsOutputError>(id: "putConfigurationSetDeliveryOptions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationSetDeliveryOptionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationSetDeliveryOptionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutConfigurationSetDeliveryOptionsInput, PutConfigurationSetDeliveryOptionsOutputResponse, PutConfigurationSetDeliveryOptionsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationSetDeliveryOptionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Enable or disable collection of reputation metrics for emails that you send using a
    ///             particular configuration set in a specific AWS Region.</p>
    public func putConfigurationSetReputationOptions(input: PutConfigurationSetReputationOptionsInput, completion: @escaping (SdkResult<PutConfigurationSetReputationOptionsOutputResponse, PutConfigurationSetReputationOptionsOutputError>) -> Void)
    {
        guard let configurationSetName = input.configurationSetName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component configurationSetName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/configuration-sets/\(configurationSetName)/reputation-options"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putConfigurationSetReputationOptions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutConfigurationSetReputationOptionsInput, PutConfigurationSetReputationOptionsOutputResponse, PutConfigurationSetReputationOptionsOutputError>(id: "putConfigurationSetReputationOptions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationSetReputationOptionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationSetReputationOptionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutConfigurationSetReputationOptionsInput, PutConfigurationSetReputationOptionsOutputResponse, PutConfigurationSetReputationOptionsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationSetReputationOptionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Enable or disable email sending for messages that use a particular configuration set
    ///             in a specific AWS Region.</p>
    public func putConfigurationSetSendingOptions(input: PutConfigurationSetSendingOptionsInput, completion: @escaping (SdkResult<PutConfigurationSetSendingOptionsOutputResponse, PutConfigurationSetSendingOptionsOutputError>) -> Void)
    {
        guard let configurationSetName = input.configurationSetName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component configurationSetName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/configuration-sets/\(configurationSetName)/sending"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putConfigurationSetSendingOptions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutConfigurationSetSendingOptionsInput, PutConfigurationSetSendingOptionsOutputResponse, PutConfigurationSetSendingOptionsOutputError>(id: "putConfigurationSetSendingOptions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationSetSendingOptionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationSetSendingOptionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutConfigurationSetSendingOptionsInput, PutConfigurationSetSendingOptionsOutputResponse, PutConfigurationSetSendingOptionsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationSetSendingOptionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Specify the account suppression list preferences for a configuration set.</p>
    public func putConfigurationSetSuppressionOptions(input: PutConfigurationSetSuppressionOptionsInput, completion: @escaping (SdkResult<PutConfigurationSetSuppressionOptionsOutputResponse, PutConfigurationSetSuppressionOptionsOutputError>) -> Void)
    {
        guard let configurationSetName = input.configurationSetName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component configurationSetName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/configuration-sets/\(configurationSetName)/suppression-options"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putConfigurationSetSuppressionOptions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutConfigurationSetSuppressionOptionsInput, PutConfigurationSetSuppressionOptionsOutputResponse, PutConfigurationSetSuppressionOptionsOutputError>(id: "putConfigurationSetSuppressionOptions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationSetSuppressionOptionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationSetSuppressionOptionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutConfigurationSetSuppressionOptionsInput, PutConfigurationSetSuppressionOptionsOutputResponse, PutConfigurationSetSuppressionOptionsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationSetSuppressionOptionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Specify a custom domain to use for open and click tracking elements in email that you
    ///             send.</p>
    public func putConfigurationSetTrackingOptions(input: PutConfigurationSetTrackingOptionsInput, completion: @escaping (SdkResult<PutConfigurationSetTrackingOptionsOutputResponse, PutConfigurationSetTrackingOptionsOutputError>) -> Void)
    {
        guard let configurationSetName = input.configurationSetName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component configurationSetName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/configuration-sets/\(configurationSetName)/tracking-options"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putConfigurationSetTrackingOptions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutConfigurationSetTrackingOptionsInput, PutConfigurationSetTrackingOptionsOutputResponse, PutConfigurationSetTrackingOptionsOutputError>(id: "putConfigurationSetTrackingOptions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationSetTrackingOptionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationSetTrackingOptionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutConfigurationSetTrackingOptionsInput, PutConfigurationSetTrackingOptionsOutputResponse, PutConfigurationSetTrackingOptionsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationSetTrackingOptionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Move a dedicated IP address to an existing dedicated IP pool.</p>
    ///         <note>
    ///             <p>The dedicated IP address that you specify must already exist, and must be
    ///                 associated with your AWS account.
    ///
    ///             </p>
    ///             <p>The dedicated IP pool you specify must already exist. You can create a new pool by
    ///                 using the <code>CreateDedicatedIpPool</code> operation.</p>
    ///
    ///         </note>
    public func putDedicatedIpInPool(input: PutDedicatedIpInPoolInput, completion: @escaping (SdkResult<PutDedicatedIpInPoolOutputResponse, PutDedicatedIpInPoolOutputError>) -> Void)
    {
        guard let ip = input.ip else {
            completion(.failure(.client(ClientError.serializationFailed("uri component ip unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/dedicated-ips/\(ip)/pool"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putDedicatedIpInPool")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutDedicatedIpInPoolInput, PutDedicatedIpInPoolOutputResponse, PutDedicatedIpInPoolOutputError>(id: "putDedicatedIpInPool")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutDedicatedIpInPoolInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutDedicatedIpInPoolInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutDedicatedIpInPoolInput, PutDedicatedIpInPoolOutputResponse, PutDedicatedIpInPoolOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutDedicatedIpInPoolInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p></p>
    public func putDedicatedIpWarmupAttributes(input: PutDedicatedIpWarmupAttributesInput, completion: @escaping (SdkResult<PutDedicatedIpWarmupAttributesOutputResponse, PutDedicatedIpWarmupAttributesOutputError>) -> Void)
    {
        guard let ip = input.ip else {
            completion(.failure(.client(ClientError.serializationFailed("uri component ip unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/dedicated-ips/\(ip)/warmup"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putDedicatedIpWarmupAttributes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutDedicatedIpWarmupAttributesInput, PutDedicatedIpWarmupAttributesOutputResponse, PutDedicatedIpWarmupAttributesOutputError>(id: "putDedicatedIpWarmupAttributes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutDedicatedIpWarmupAttributesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutDedicatedIpWarmupAttributesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutDedicatedIpWarmupAttributesInput, PutDedicatedIpWarmupAttributesOutputResponse, PutDedicatedIpWarmupAttributesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutDedicatedIpWarmupAttributesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Enable or disable the Deliverability dashboard. When you enable the Deliverability dashboard, you gain
    ///             access to reputation, deliverability, and other metrics for the domains that you use to
    ///             send email. You also gain the ability to perform predictive inbox placement tests.</p>
    ///
    ///         <p>When you use the Deliverability dashboard, you pay a monthly subscription charge, in addition
    ///             to any other fees that you accrue by using Amazon SES and other AWS services. For more
    ///             information about the features and cost of a Deliverability dashboard subscription, see <a href="http://aws.amazon.com/ses/pricing/">Amazon SES Pricing</a>.</p>
    public func putDeliverabilityDashboardOption(input: PutDeliverabilityDashboardOptionInput, completion: @escaping (SdkResult<PutDeliverabilityDashboardOptionOutputResponse, PutDeliverabilityDashboardOptionOutputError>) -> Void)
    {
        let urlPath = "/v2/email/deliverability-dashboard"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putDeliverabilityDashboardOption")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutDeliverabilityDashboardOptionInput, PutDeliverabilityDashboardOptionOutputResponse, PutDeliverabilityDashboardOptionOutputError>(id: "putDeliverabilityDashboardOption")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutDeliverabilityDashboardOptionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutDeliverabilityDashboardOptionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutDeliverabilityDashboardOptionInput, PutDeliverabilityDashboardOptionOutputResponse, PutDeliverabilityDashboardOptionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutDeliverabilityDashboardOptionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Used to associate a configuration set with an email identity.</p>
    public func putEmailIdentityConfigurationSetAttributes(input: PutEmailIdentityConfigurationSetAttributesInput, completion: @escaping (SdkResult<PutEmailIdentityConfigurationSetAttributesOutputResponse, PutEmailIdentityConfigurationSetAttributesOutputError>) -> Void)
    {
        guard let emailIdentity = input.emailIdentity else {
            completion(.failure(.client(ClientError.serializationFailed("uri component emailIdentity unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/identities/\(emailIdentity)/configuration-set"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putEmailIdentityConfigurationSetAttributes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutEmailIdentityConfigurationSetAttributesInput, PutEmailIdentityConfigurationSetAttributesOutputResponse, PutEmailIdentityConfigurationSetAttributesOutputError>(id: "putEmailIdentityConfigurationSetAttributes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutEmailIdentityConfigurationSetAttributesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutEmailIdentityConfigurationSetAttributesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutEmailIdentityConfigurationSetAttributesInput, PutEmailIdentityConfigurationSetAttributesOutputResponse, PutEmailIdentityConfigurationSetAttributesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutEmailIdentityConfigurationSetAttributesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Used to enable or disable DKIM authentication for an email identity.</p>
    public func putEmailIdentityDkimAttributes(input: PutEmailIdentityDkimAttributesInput, completion: @escaping (SdkResult<PutEmailIdentityDkimAttributesOutputResponse, PutEmailIdentityDkimAttributesOutputError>) -> Void)
    {
        guard let emailIdentity = input.emailIdentity else {
            completion(.failure(.client(ClientError.serializationFailed("uri component emailIdentity unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/identities/\(emailIdentity)/dkim"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putEmailIdentityDkimAttributes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutEmailIdentityDkimAttributesInput, PutEmailIdentityDkimAttributesOutputResponse, PutEmailIdentityDkimAttributesOutputError>(id: "putEmailIdentityDkimAttributes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutEmailIdentityDkimAttributesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutEmailIdentityDkimAttributesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutEmailIdentityDkimAttributesInput, PutEmailIdentityDkimAttributesOutputResponse, PutEmailIdentityDkimAttributesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutEmailIdentityDkimAttributesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Used to configure or change the DKIM authentication settings for an email domain
    ///             identity. You can use this operation to do any of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Update the signing attributes for an identity that uses Bring Your Own DKIM
    ///                     (BYODKIM).</p>
    ///             </li>
    ///             <li>
    ///                 <p>Change from using no DKIM authentication to using Easy DKIM.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Change from using no DKIM authentication to using BYODKIM.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Change from using Easy DKIM to using BYODKIM.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Change from using BYODKIM to using Easy DKIM.</p>
    ///             </li>
    ///          </ul>
    public func putEmailIdentityDkimSigningAttributes(input: PutEmailIdentityDkimSigningAttributesInput, completion: @escaping (SdkResult<PutEmailIdentityDkimSigningAttributesOutputResponse, PutEmailIdentityDkimSigningAttributesOutputError>) -> Void)
    {
        guard let emailIdentity = input.emailIdentity else {
            completion(.failure(.client(ClientError.serializationFailed("uri component emailIdentity unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/email/identities/\(emailIdentity)/dkim/signing"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putEmailIdentityDkimSigningAttributes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutEmailIdentityDkimSigningAttributesInput, PutEmailIdentityDkimSigningAttributesOutputResponse, PutEmailIdentityDkimSigningAttributesOutputError>(id: "putEmailIdentityDkimSigningAttributes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutEmailIdentityDkimSigningAttributesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutEmailIdentityDkimSigningAttributesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutEmailIdentityDkimSigningAttributesInput, PutEmailIdentityDkimSigningAttributesOutputResponse, PutEmailIdentityDkimSigningAttributesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutEmailIdentityDkimSigningAttributesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Used to enable or disable feedback forwarding for an identity. This setting determines
    ///             what happens when an identity is used to send an email that results in a bounce or
    ///             complaint event.</p>
    ///         <p>If the value is <code>true</code>, you receive email notifications when bounce or
    ///             complaint events occur. These notifications are sent to the address that you specified
    ///             in the <code>Return-Path</code> header of the original email.</p>
    ///         <p>You're required to have a method of tracking bounces and complaints. If you haven't
    ///             set up another mechanism for receiving bounce or complaint notifications (for example,
    ///             by setting up an event destination), you receive an email notification when these events
    ///             occur (even if this setting is disabled).</p>
    public func putEmailIdentityFeedbackAttributes(input: PutEmailIdentityFeedbackAttributesInput, completion: @escaping (SdkResult<PutEmailIdentityFeedbackAttributesOutputResponse, PutEmailIdentityFeedbackAttributesOutputError>) -> Void)
    {
        guard let emailIdentity = input.emailIdentity else {
            completion(.failure(.client(ClientError.serializationFailed("uri component emailIdentity unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/identities/\(emailIdentity)/feedback"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putEmailIdentityFeedbackAttributes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutEmailIdentityFeedbackAttributesInput, PutEmailIdentityFeedbackAttributesOutputResponse, PutEmailIdentityFeedbackAttributesOutputError>(id: "putEmailIdentityFeedbackAttributes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutEmailIdentityFeedbackAttributesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutEmailIdentityFeedbackAttributesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutEmailIdentityFeedbackAttributesInput, PutEmailIdentityFeedbackAttributesOutputResponse, PutEmailIdentityFeedbackAttributesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutEmailIdentityFeedbackAttributesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Used to enable or disable the custom Mail-From domain configuration for an email
    ///             identity.</p>
    public func putEmailIdentityMailFromAttributes(input: PutEmailIdentityMailFromAttributesInput, completion: @escaping (SdkResult<PutEmailIdentityMailFromAttributesOutputResponse, PutEmailIdentityMailFromAttributesOutputError>) -> Void)
    {
        guard let emailIdentity = input.emailIdentity else {
            completion(.failure(.client(ClientError.serializationFailed("uri component emailIdentity unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/identities/\(emailIdentity)/mail-from"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putEmailIdentityMailFromAttributes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutEmailIdentityMailFromAttributesInput, PutEmailIdentityMailFromAttributesOutputResponse, PutEmailIdentityMailFromAttributesOutputError>(id: "putEmailIdentityMailFromAttributes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutEmailIdentityMailFromAttributesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutEmailIdentityMailFromAttributesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutEmailIdentityMailFromAttributesInput, PutEmailIdentityMailFromAttributesOutputResponse, PutEmailIdentityMailFromAttributesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutEmailIdentityMailFromAttributesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds an email address to the suppression list for your account.</p>
    public func putSuppressedDestination(input: PutSuppressedDestinationInput, completion: @escaping (SdkResult<PutSuppressedDestinationOutputResponse, PutSuppressedDestinationOutputError>) -> Void)
    {
        let urlPath = "/v2/email/suppression/addresses"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putSuppressedDestination")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutSuppressedDestinationInput, PutSuppressedDestinationOutputResponse, PutSuppressedDestinationOutputError>(id: "putSuppressedDestination")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutSuppressedDestinationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutSuppressedDestinationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutSuppressedDestinationInput, PutSuppressedDestinationOutputResponse, PutSuppressedDestinationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutSuppressedDestinationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Composes an email message to multiple destinations.</p>
    public func sendBulkEmail(input: SendBulkEmailInput, completion: @escaping (SdkResult<SendBulkEmailOutputResponse, SendBulkEmailOutputError>) -> Void)
    {
        let urlPath = "/v2/email/outbound-bulk-emails"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "sendBulkEmail")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<SendBulkEmailInput, SendBulkEmailOutputResponse, SendBulkEmailOutputError>(id: "sendBulkEmail")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: SendBulkEmailInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: SendBulkEmailInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<SendBulkEmailInput, SendBulkEmailOutputResponse, SendBulkEmailOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: SendBulkEmailInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds an email address to the list of identities for your Amazon SES account in the current
    ///             AWS Region and attempts to verify it. As a result of executing this operation, a
    ///             customized verification email is sent to the specified address.</p>
    ///         <p>To use this operation, you must first create a custom verification email template. For
    ///             more information about creating and using custom verification email templates, see
    ///                 <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-verify-address-custom.html">Using Custom Verification Email Templates</a> in the <i>Amazon SES Developer
    ///                 Guide</i>.</p>
    ///         <p>You can execute this operation no more than once per second.</p>
    public func sendCustomVerificationEmail(input: SendCustomVerificationEmailInput, completion: @escaping (SdkResult<SendCustomVerificationEmailOutputResponse, SendCustomVerificationEmailOutputError>) -> Void)
    {
        let urlPath = "/v2/email/outbound-custom-verification-emails"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "sendCustomVerificationEmail")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<SendCustomVerificationEmailInput, SendCustomVerificationEmailOutputResponse, SendCustomVerificationEmailOutputError>(id: "sendCustomVerificationEmail")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: SendCustomVerificationEmailInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: SendCustomVerificationEmailInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<SendCustomVerificationEmailInput, SendCustomVerificationEmailOutputResponse, SendCustomVerificationEmailOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: SendCustomVerificationEmailInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Sends an email message. You can use the Amazon SES API v2 to send two types of
    ///             messages:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <b>Simple</b> – A standard email message. When
    ///                     you create this type of message, you specify the sender, the recipient, and the
    ///                     message body, and Amazon SES assembles the message for you.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>Raw</b> – A raw, MIME-formatted email
    ///                     message. When you send this type of email, you have to specify all of the
    ///                     message headers, as well as the message body. You can use this message type to
    ///                     send messages that contain attachments. The message that you specify has to be a
    ///                     valid MIME message.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>Templated</b> – A message that contains
    ///                     personalization tags. When you send this type of email, Amazon SES API v2 automatically
    ///                     replaces the tags with values that you specify.</p>
    ///             </li>
    ///          </ul>
    public func sendEmail(input: SendEmailInput, completion: @escaping (SdkResult<SendEmailOutputResponse, SendEmailOutputError>) -> Void)
    {
        let urlPath = "/v2/email/outbound-emails"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "sendEmail")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<SendEmailInput, SendEmailOutputResponse, SendEmailOutputError>(id: "sendEmail")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: SendEmailInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: SendEmailInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<SendEmailInput, SendEmailOutputResponse, SendEmailOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: SendEmailInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Add one or more tags (keys and values) to a specified resource. A
    ///                 <i>tag</i> is a label that you optionally define and associate with a
    ///             resource. Tags can help you categorize and manage resources in different ways, such as
    ///             by purpose, owner, environment, or other criteria. A resource can have as many as 50
    ///             tags.</p>
    ///         <p>Each tag consists of a required <i>tag key</i> and an
    ///                 associated <i>tag value</i>, both of which you define. A tag key is a
    ///             general label that acts as a category for more specific tag values. A tag value acts as
    ///             a descriptor within a tag key.</p>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutputResponse, TagResourceOutputError>) -> Void)
    {
        let urlPath = "/v2/email/tags"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a preview of the MIME content of an email when provided with a template and a
    ///             set of replacement data.</p>
    ///
    ///         <p>You can execute this operation no more than once per second.</p>
    public func testRenderEmailTemplate(input: TestRenderEmailTemplateInput, completion: @escaping (SdkResult<TestRenderEmailTemplateOutputResponse, TestRenderEmailTemplateOutputError>) -> Void)
    {
        guard let templateName = input.templateName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component templateName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/templates/\(templateName)/render"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "testRenderEmailTemplate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TestRenderEmailTemplateInput, TestRenderEmailTemplateOutputResponse, TestRenderEmailTemplateOutputError>(id: "testRenderEmailTemplate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TestRenderEmailTemplateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TestRenderEmailTemplateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TestRenderEmailTemplateInput, TestRenderEmailTemplateOutputResponse, TestRenderEmailTemplateOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TestRenderEmailTemplateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Remove one or more tags (keys and values) from a specified resource.</p>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutputResponse, UntagResourceOutputError>) -> Void)
    {
        let urlPath = "/v2/email/tags"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Update the configuration of an event destination for a configuration set.</p>
    ///         <p>
    ///             <i>Events</i> include message sends, deliveries, opens, clicks, bounces,
    ///             and complaints. <i>Event destinations</i> are places that you can send
    ///             information about these events to. For example, you can send event data to Amazon SNS to
    ///             receive notifications when you receive bounces or complaints, or you can use Amazon Kinesis Data Firehose to
    ///             stream data to Amazon S3 for long-term storage.</p>
    public func updateConfigurationSetEventDestination(input: UpdateConfigurationSetEventDestinationInput, completion: @escaping (SdkResult<UpdateConfigurationSetEventDestinationOutputResponse, UpdateConfigurationSetEventDestinationOutputError>) -> Void)
    {
        guard let configurationSetName = input.configurationSetName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component configurationSetName unexpectedly nil"))))
            return
        }
        guard let eventDestinationName = input.eventDestinationName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component eventDestinationName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/configuration-sets/\(configurationSetName)/event-destinations/\(eventDestinationName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateConfigurationSetEventDestination")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateConfigurationSetEventDestinationInput, UpdateConfigurationSetEventDestinationOutputResponse, UpdateConfigurationSetEventDestinationOutputError>(id: "updateConfigurationSetEventDestination")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateConfigurationSetEventDestinationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateConfigurationSetEventDestinationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateConfigurationSetEventDestinationInput, UpdateConfigurationSetEventDestinationOutputResponse, UpdateConfigurationSetEventDestinationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateConfigurationSetEventDestinationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a contact's preferences for a list. It is not necessary to specify all
    ///             existing topic preferences in the TopicPreferences object, just the ones that need
    ///             updating.</p>
    public func updateContact(input: UpdateContactInput, completion: @escaping (SdkResult<UpdateContactOutputResponse, UpdateContactOutputError>) -> Void)
    {
        guard let contactListName = input.contactListName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component contactListName unexpectedly nil"))))
            return
        }
        guard let emailAddress = input.emailAddress else {
            completion(.failure(.client(ClientError.serializationFailed("uri component emailAddress unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/contact-lists/\(contactListName)/contacts/\(emailAddress)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateContact")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateContactInput, UpdateContactOutputResponse, UpdateContactOutputError>(id: "updateContact")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateContactInput, UpdateContactOutputResponse, UpdateContactOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates contact list metadata. This operation does a complete replacement.</p>
    public func updateContactList(input: UpdateContactListInput, completion: @escaping (SdkResult<UpdateContactListOutputResponse, UpdateContactListOutputError>) -> Void)
    {
        guard let contactListName = input.contactListName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component contactListName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/contact-lists/\(contactListName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateContactList")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateContactListInput, UpdateContactListOutputResponse, UpdateContactListOutputError>(id: "updateContactList")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactListInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactListInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateContactListInput, UpdateContactListOutputResponse, UpdateContactListOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactListInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates an existing custom verification email template.</p>
    ///         <p>For more information about custom verification email templates, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-verify-address-custom.html">Using Custom Verification Email Templates</a> in the <i>Amazon SES Developer
    ///                 Guide</i>.</p>
    ///         <p>You can execute this operation no more than once per second.</p>
    public func updateCustomVerificationEmailTemplate(input: UpdateCustomVerificationEmailTemplateInput, completion: @escaping (SdkResult<UpdateCustomVerificationEmailTemplateOutputResponse, UpdateCustomVerificationEmailTemplateOutputError>) -> Void)
    {
        guard let templateName = input.templateName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component templateName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/custom-verification-email-templates/\(templateName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateCustomVerificationEmailTemplate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateCustomVerificationEmailTemplateInput, UpdateCustomVerificationEmailTemplateOutputResponse, UpdateCustomVerificationEmailTemplateOutputError>(id: "updateCustomVerificationEmailTemplate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateCustomVerificationEmailTemplateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateCustomVerificationEmailTemplateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateCustomVerificationEmailTemplateInput, UpdateCustomVerificationEmailTemplateOutputResponse, UpdateCustomVerificationEmailTemplateOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateCustomVerificationEmailTemplateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the specified sending authorization policy for the given identity (an email
    ///             address or a domain). This API returns successfully even if a policy with the specified
    ///             name does not exist.</p>
    ///         <note>
    ///             <p>This API is for the identity owner only. If you have not verified the identity,
    ///                 this API will return an error.</p>
    ///         </note>
    ///         <p>Sending authorization is a feature that enables an identity owner to authorize other
    ///             senders to use its identities. For information about using sending authorization, see
    ///             the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    ///
    ///         <p>You can execute this operation no more than once per second.</p>
    public func updateEmailIdentityPolicy(input: UpdateEmailIdentityPolicyInput, completion: @escaping (SdkResult<UpdateEmailIdentityPolicyOutputResponse, UpdateEmailIdentityPolicyOutputError>) -> Void)
    {
        guard let emailIdentity = input.emailIdentity else {
            completion(.failure(.client(ClientError.serializationFailed("uri component emailIdentity unexpectedly nil"))))
            return
        }
        guard let policyName = input.policyName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component policyName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/identities/\(emailIdentity)/policies/\(policyName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateEmailIdentityPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateEmailIdentityPolicyInput, UpdateEmailIdentityPolicyOutputResponse, UpdateEmailIdentityPolicyOutputError>(id: "updateEmailIdentityPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateEmailIdentityPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateEmailIdentityPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateEmailIdentityPolicyInput, UpdateEmailIdentityPolicyOutputResponse, UpdateEmailIdentityPolicyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateEmailIdentityPolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates an email template. Email templates enable you to send personalized email to
    ///             one or more destinations in a single API operation. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-personalized-email-api.html">Amazon SES
    ///                 Developer Guide</a>.</p>
    ///         <p>You can execute this operation no more than once per second.</p>
    public func updateEmailTemplate(input: UpdateEmailTemplateInput, completion: @escaping (SdkResult<UpdateEmailTemplateOutputResponse, UpdateEmailTemplateOutputError>) -> Void)
    {
        guard let templateName = input.templateName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component templateName unexpectedly nil"))))
            return
        }
        let urlPath = "/v2/email/templates/\(templateName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateEmailTemplate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "email.\(config.region).amazonaws.com")
                      .withSigningName(value: "ses")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateEmailTemplateInput, UpdateEmailTemplateOutputResponse, UpdateEmailTemplateOutputError>(id: "updateEmailTemplate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateEmailTemplateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateEmailTemplateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateEmailTemplateInput, UpdateEmailTemplateOutputResponse, UpdateEmailTemplateOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateEmailTemplateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
