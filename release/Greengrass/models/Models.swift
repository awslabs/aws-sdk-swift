// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AssociateRoleToGroupInputBodyMiddleware: Middleware {
    public let id: String = "AssociateRoleToGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateRoleToGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateRoleToGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateRoleToGroupInput>
    public typealias MOutput = OperationOutput<AssociateRoleToGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateRoleToGroupOutputError>
}

extension AssociateRoleToGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateRoleToGroupInput(groupId: \(String(describing: groupId)), roleArn: \(String(describing: roleArn)))"}
}

extension AssociateRoleToGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct AssociateRoleToGroupInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateRoleToGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateRoleToGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateRoleToGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateRoleToGroupInput>
    public typealias MOutput = OperationOutput<AssociateRoleToGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateRoleToGroupOutputError>
}

public struct AssociateRoleToGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateRoleToGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateRoleToGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateRoleToGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateRoleToGroupInput>
    public typealias MOutput = OperationOutput<AssociateRoleToGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateRoleToGroupOutputError>
}

public struct AssociateRoleToGroupInput: Equatable {
    /// The ID of the Greengrass group.
    public let groupId: String?
    /// The ARN of the role you wish to associate with this group. The existence of the role is not validated.
    public let roleArn: String?

    public init (
        groupId: String? = nil,
        roleArn: String? = nil
    )
    {
        self.groupId = groupId
        self.roleArn = roleArn
    }
}

struct AssociateRoleToGroupInputBody: Equatable {
    public let roleArn: String?
}

extension AssociateRoleToGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roleArn = "RoleArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension AssociateRoleToGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateRoleToGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateRoleToGroupOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateRoleToGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateRoleToGroupOutputResponse(associatedAt: \(String(describing: associatedAt)))"}
}

extension AssociateRoleToGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateRoleToGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associatedAt = output.associatedAt
        } else {
            self.associatedAt = nil
        }
    }
}

public struct AssociateRoleToGroupOutputResponse: Equatable {
    /// The time, in milliseconds since the epoch, when the role ARN was associated with the group.
    public let associatedAt: String?

    public init (
        associatedAt: String? = nil
    )
    {
        self.associatedAt = associatedAt
    }
}

struct AssociateRoleToGroupOutputResponseBody: Equatable {
    public let associatedAt: String?
}

extension AssociateRoleToGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associatedAt = "AssociatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associatedAt)
        associatedAt = associatedAtDecoded
    }
}

public struct AssociateServiceRoleToAccountInputBodyMiddleware: Middleware {
    public let id: String = "AssociateServiceRoleToAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateServiceRoleToAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateServiceRoleToAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateServiceRoleToAccountInput>
    public typealias MOutput = OperationOutput<AssociateServiceRoleToAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateServiceRoleToAccountOutputError>
}

extension AssociateServiceRoleToAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateServiceRoleToAccountInput(roleArn: \(String(describing: roleArn)))"}
}

extension AssociateServiceRoleToAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct AssociateServiceRoleToAccountInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateServiceRoleToAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateServiceRoleToAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateServiceRoleToAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateServiceRoleToAccountInput>
    public typealias MOutput = OperationOutput<AssociateServiceRoleToAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateServiceRoleToAccountOutputError>
}

public struct AssociateServiceRoleToAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateServiceRoleToAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateServiceRoleToAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateServiceRoleToAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateServiceRoleToAccountInput>
    public typealias MOutput = OperationOutput<AssociateServiceRoleToAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateServiceRoleToAccountOutputError>
}

public struct AssociateServiceRoleToAccountInput: Equatable {
    /// The ARN of the service role you wish to associate with your account.
    public let roleArn: String?

    public init (
        roleArn: String? = nil
    )
    {
        self.roleArn = roleArn
    }
}

struct AssociateServiceRoleToAccountInputBody: Equatable {
    public let roleArn: String?
}

extension AssociateServiceRoleToAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roleArn = "RoleArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension AssociateServiceRoleToAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateServiceRoleToAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateServiceRoleToAccountOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateServiceRoleToAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateServiceRoleToAccountOutputResponse(associatedAt: \(String(describing: associatedAt)))"}
}

extension AssociateServiceRoleToAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateServiceRoleToAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associatedAt = output.associatedAt
        } else {
            self.associatedAt = nil
        }
    }
}

public struct AssociateServiceRoleToAccountOutputResponse: Equatable {
    /// The time when the service role was associated with the account.
    public let associatedAt: String?

    public init (
        associatedAt: String? = nil
    )
    {
        self.associatedAt = associatedAt
    }
}

struct AssociateServiceRoleToAccountOutputResponseBody: Equatable {
    public let associatedAt: String?
}

extension AssociateServiceRoleToAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associatedAt = "AssociatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associatedAt)
        associatedAt = associatedAtDecoded
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(errorDetails: \(String(describing: errorDetails)), message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorDetails = output.errorDetails
            self.message = output.message
        } else {
            self.errorDetails = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// General error information.
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// Details about the error.
    public var errorDetails: [ErrorDetail]?
    /// A message containing information about the error.
    public var message: String?

    public init (
        errorDetails: [ErrorDetail]? = nil,
        message: String? = nil
    )
    {
        self.errorDetails = errorDetails
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let errorDetails: [ErrorDetail]?
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorDetails = "ErrorDetails"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDetailsContainer = try containerValues.decodeIfPresent([ErrorDetail?].self, forKey: .errorDetails)
        var errorDetailsDecoded0:[ErrorDetail]? = nil
        if let errorDetailsContainer = errorDetailsContainer {
            errorDetailsDecoded0 = [ErrorDetail]()
            for structure0 in errorDetailsContainer {
                if let structure0 = structure0 {
                    errorDetailsDecoded0?.append(structure0)
                }
            }
        }
        errorDetails = errorDetailsDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BulkDeployment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bulkDeploymentArn = "BulkDeploymentArn"
        case bulkDeploymentId = "BulkDeploymentId"
        case createdAt = "CreatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bulkDeploymentArn = bulkDeploymentArn {
            try encodeContainer.encode(bulkDeploymentArn, forKey: .bulkDeploymentArn)
        }
        if let bulkDeploymentId = bulkDeploymentId {
            try encodeContainer.encode(bulkDeploymentId, forKey: .bulkDeploymentId)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bulkDeploymentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bulkDeploymentArn)
        bulkDeploymentArn = bulkDeploymentArnDecoded
        let bulkDeploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bulkDeploymentId)
        bulkDeploymentId = bulkDeploymentIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension BulkDeployment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BulkDeployment(bulkDeploymentArn: \(String(describing: bulkDeploymentArn)), bulkDeploymentId: \(String(describing: bulkDeploymentId)), createdAt: \(String(describing: createdAt)))"}
}

/// Information about a bulk deployment. You cannot start a new bulk deployment while another one is still running or in a non-terminal state.
public struct BulkDeployment: Equatable {
    /// The ARN of the bulk deployment.
    public let bulkDeploymentArn: String?
    /// The ID of the bulk deployment.
    public let bulkDeploymentId: String?
    /// The time, in ISO format, when the deployment was created.
    public let createdAt: String?

    public init (
        bulkDeploymentArn: String? = nil,
        bulkDeploymentId: String? = nil,
        createdAt: String? = nil
    )
    {
        self.bulkDeploymentArn = bulkDeploymentArn
        self.bulkDeploymentId = bulkDeploymentId
        self.createdAt = createdAt
    }
}

extension BulkDeploymentMetrics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case invalidInputRecords = "InvalidInputRecords"
        case recordsProcessed = "RecordsProcessed"
        case retryAttempts = "RetryAttempts"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if invalidInputRecords != 0 {
            try encodeContainer.encode(invalidInputRecords, forKey: .invalidInputRecords)
        }
        if recordsProcessed != 0 {
            try encodeContainer.encode(recordsProcessed, forKey: .recordsProcessed)
        }
        if retryAttempts != 0 {
            try encodeContainer.encode(retryAttempts, forKey: .retryAttempts)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidInputRecordsDecoded = try containerValues.decode(Int.self, forKey: .invalidInputRecords)
        invalidInputRecords = invalidInputRecordsDecoded
        let recordsProcessedDecoded = try containerValues.decode(Int.self, forKey: .recordsProcessed)
        recordsProcessed = recordsProcessedDecoded
        let retryAttemptsDecoded = try containerValues.decode(Int.self, forKey: .retryAttempts)
        retryAttempts = retryAttemptsDecoded
    }
}

extension BulkDeploymentMetrics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BulkDeploymentMetrics(invalidInputRecords: \(String(describing: invalidInputRecords)), recordsProcessed: \(String(describing: recordsProcessed)), retryAttempts: \(String(describing: retryAttempts)))"}
}

/// Relevant metrics on input records processed during bulk deployment.
public struct BulkDeploymentMetrics: Equatable {
    /// The total number of records that returned a non-retryable error. For example, this can occur if a group record from the input file uses an invalid format or specifies a nonexistent group version, or if the execution role doesn't grant permission to deploy a group or group version.
    public let invalidInputRecords: Int
    /// The total number of group records from the input file that have been processed so far, or attempted.
    public let recordsProcessed: Int
    /// The total number of deployment attempts that returned a retryable error. For example, a retry is triggered if the attempt to deploy a group returns a throttling error. ''StartBulkDeployment'' retries a group deployment up to five times.
    public let retryAttempts: Int

    public init (
        invalidInputRecords: Int = 0,
        recordsProcessed: Int = 0,
        retryAttempts: Int = 0
    )
    {
        self.invalidInputRecords = invalidInputRecords
        self.recordsProcessed = recordsProcessed
        self.retryAttempts = retryAttempts
    }
}

extension BulkDeploymentResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case deploymentArn = "DeploymentArn"
        case deploymentId = "DeploymentId"
        case deploymentStatus = "DeploymentStatus"
        case deploymentType = "DeploymentType"
        case errorDetails = "ErrorDetails"
        case errorMessage = "ErrorMessage"
        case groupArn = "GroupArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let deploymentArn = deploymentArn {
            try encodeContainer.encode(deploymentArn, forKey: .deploymentArn)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentStatus = deploymentStatus {
            try encodeContainer.encode(deploymentStatus, forKey: .deploymentStatus)
        }
        if let deploymentType = deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let errorDetails = errorDetails {
            var errorDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errorDetails)
            for errordetails0 in errorDetails {
                try errorDetailsContainer.encode(errordetails0)
            }
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let groupArn = groupArn {
            try encodeContainer.encode(groupArn, forKey: .groupArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deploymentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentArn)
        deploymentArn = deploymentArnDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(DeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let errorDetailsContainer = try containerValues.decodeIfPresent([ErrorDetail?].self, forKey: .errorDetails)
        var errorDetailsDecoded0:[ErrorDetail]? = nil
        if let errorDetailsContainer = errorDetailsContainer {
            errorDetailsDecoded0 = [ErrorDetail]()
            for structure0 in errorDetailsContainer {
                if let structure0 = structure0 {
                    errorDetailsDecoded0?.append(structure0)
                }
            }
        }
        errorDetails = errorDetailsDecoded0
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let groupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupArn)
        groupArn = groupArnDecoded
    }
}

extension BulkDeploymentResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BulkDeploymentResult(createdAt: \(String(describing: createdAt)), deploymentArn: \(String(describing: deploymentArn)), deploymentId: \(String(describing: deploymentId)), deploymentStatus: \(String(describing: deploymentStatus)), deploymentType: \(String(describing: deploymentType)), errorDetails: \(String(describing: errorDetails)), errorMessage: \(String(describing: errorMessage)), groupArn: \(String(describing: groupArn)))"}
}

/// Information about an individual group deployment in a bulk deployment operation.
public struct BulkDeploymentResult: Equatable {
    /// The time, in ISO format, when the deployment was created.
    public let createdAt: String?
    /// The ARN of the group deployment.
    public let deploymentArn: String?
    /// The ID of the group deployment.
    public let deploymentId: String?
    /// The current status of the group deployment: ''InProgress'', ''Building'', ''Success'', or ''Failure''.
    public let deploymentStatus: String?
    /// The type of the deployment.
    public let deploymentType: DeploymentType?
    /// Details about the error.
    public let errorDetails: [ErrorDetail]?
    /// The error message for a failed deployment
    public let errorMessage: String?
    /// The ARN of the Greengrass group.
    public let groupArn: String?

    public init (
        createdAt: String? = nil,
        deploymentArn: String? = nil,
        deploymentId: String? = nil,
        deploymentStatus: String? = nil,
        deploymentType: DeploymentType? = nil,
        errorDetails: [ErrorDetail]? = nil,
        errorMessage: String? = nil,
        groupArn: String? = nil
    )
    {
        self.createdAt = createdAt
        self.deploymentArn = deploymentArn
        self.deploymentId = deploymentId
        self.deploymentStatus = deploymentStatus
        self.deploymentType = deploymentType
        self.errorDetails = errorDetails
        self.errorMessage = errorMessage
        self.groupArn = groupArn
    }
}

/// The current status of the bulk deployment.
public enum BulkDeploymentStatus {
    case completed
    case failed
    case initializing
    case running
    case stopped
    case stopping
    case sdkUnknown(String)
}

extension BulkDeploymentStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BulkDeploymentStatus] {
        return [
            .completed,
            .failed,
            .initializing,
            .running,
            .stopped,
            .stopping,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "Completed"
        case .failed: return "Failed"
        case .initializing: return "Initializing"
        case .running: return "Running"
        case .stopped: return "Stopped"
        case .stopping: return "Stopping"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BulkDeploymentStatus(rawValue: rawValue) ?? BulkDeploymentStatus.sdkUnknown(rawValue)
    }
}

public enum ConfigurationSyncStatus {
    case insync
    case outofsync
    case sdkUnknown(String)
}

extension ConfigurationSyncStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfigurationSyncStatus] {
        return [
            .insync,
            .outofsync,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .insync: return "InSync"
        case .outofsync: return "OutOfSync"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfigurationSyncStatus(rawValue: rawValue) ?? ConfigurationSyncStatus.sdkUnknown(rawValue)
    }
}

extension ConnectivityInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hostAddress = "HostAddress"
        case id = "Id"
        case metadata = "Metadata"
        case portNumber = "PortNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostAddress = hostAddress {
            try encodeContainer.encode(hostAddress, forKey: .hostAddress)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if portNumber != 0 {
            try encodeContainer.encode(portNumber, forKey: .portNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostAddress)
        hostAddress = hostAddressDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metadata)
        metadata = metadataDecoded
        let portNumberDecoded = try containerValues.decode(Int.self, forKey: .portNumber)
        portNumber = portNumberDecoded
    }
}

extension ConnectivityInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectivityInfo(hostAddress: \(String(describing: hostAddress)), id: \(String(describing: id)), metadata: \(String(describing: metadata)), portNumber: \(String(describing: portNumber)))"}
}

/// Information about a Greengrass core's connectivity.
public struct ConnectivityInfo: Equatable {
    /// The endpoint for the Greengrass core. Can be an IP address or DNS.
    public let hostAddress: String?
    /// The ID of the connectivity information.
    public let id: String?
    /// Metadata for this endpoint.
    public let metadata: String?
    /// The port of the Greengrass core. Usually 8883.
    public let portNumber: Int

    public init (
        hostAddress: String? = nil,
        id: String? = nil,
        metadata: String? = nil,
        portNumber: Int = 0
    )
    {
        self.hostAddress = hostAddress
        self.id = id
        self.metadata = metadata
        self.portNumber = portNumber
    }
}

extension Connector: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectorArn = "ConnectorArn"
        case id = "Id"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorArn = connectorArn {
            try encodeContainer.encode(connectorArn, forKey: .connectorArn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, __mapof__string0) in parameters {
                try parametersContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectorArn)
        connectorArn = connectorArnDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, __string0) in parametersContainer {
                if let __string0 = __string0 {
                    parametersDecoded0?[key0] = __string0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension Connector: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Connector(connectorArn: \(String(describing: connectorArn)), id: \(String(describing: id)), parameters: \(String(describing: parameters)))"}
}

/// Information about a connector. Connectors run on the Greengrass core and contain built-in integration with local infrastructure, device protocols, AWS, and other cloud services.
public struct Connector: Equatable {
    /// The ARN of the connector.
    public let connectorArn: String?
    /// A descriptive or arbitrary ID for the connector. This value must be unique within the connector definition version. Max length is 128 characters with pattern [a-zA-Z0-9:_-]+.
    public let id: String?
    /// The parameters or configuration that the connector uses.
    public let parameters: [String:String]?

    public init (
        connectorArn: String? = nil,
        id: String? = nil,
        parameters: [String:String]? = nil
    )
    {
        self.connectorArn = connectorArn
        self.id = id
        self.parameters = parameters
    }
}

extension ConnectorDefinitionVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectors = "Connectors"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectors = connectors {
            var connectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectors)
            for __listofconnector0 in connectors {
                try connectorsContainer.encode(__listofconnector0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorsContainer = try containerValues.decodeIfPresent([Connector?].self, forKey: .connectors)
        var connectorsDecoded0:[Connector]? = nil
        if let connectorsContainer = connectorsContainer {
            connectorsDecoded0 = [Connector]()
            for structure0 in connectorsContainer {
                if let structure0 = structure0 {
                    connectorsDecoded0?.append(structure0)
                }
            }
        }
        connectors = connectorsDecoded0
    }
}

extension ConnectorDefinitionVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectorDefinitionVersion(connectors: \(String(describing: connectors)))"}
}

/// Information about the connector definition version, which is a container for connectors.
public struct ConnectorDefinitionVersion: Equatable {
    /// A list of references to connectors in this version, with their corresponding configuration settings.
    public let connectors: [Connector]?

    public init (
        connectors: [Connector]? = nil
    )
    {
        self.connectors = connectors
    }
}

extension Core: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case id = "Id"
        case syncShadow = "SyncShadow"
        case thingArn = "ThingArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if syncShadow != false {
            try encodeContainer.encode(syncShadow, forKey: .syncShadow)
        }
        if let thingArn = thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let syncShadowDecoded = try containerValues.decode(Bool.self, forKey: .syncShadow)
        syncShadow = syncShadowDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension Core: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Core(certificateArn: \(String(describing: certificateArn)), id: \(String(describing: id)), syncShadow: \(String(describing: syncShadow)), thingArn: \(String(describing: thingArn)))"}
}

/// Information about a core.
public struct Core: Equatable {
    /// The ARN of the certificate associated with the core.
    public let certificateArn: String?
    /// A descriptive or arbitrary ID for the core. This value must be unique within the core definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
    public let id: String?
    /// If true, the core's local shadow is automatically synced with the cloud.
    public let syncShadow: Bool
    /// The ARN of the thing which is the core.
    public let thingArn: String?

    public init (
        certificateArn: String? = nil,
        id: String? = nil,
        syncShadow: Bool = false,
        thingArn: String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.id = id
        self.syncShadow = syncShadow
        self.thingArn = thingArn
    }
}

extension CoreDefinitionVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cores = "Cores"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cores = cores {
            var coresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cores)
            for __listofcore0 in cores {
                try coresContainer.encode(__listofcore0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coresContainer = try containerValues.decodeIfPresent([Core?].self, forKey: .cores)
        var coresDecoded0:[Core]? = nil
        if let coresContainer = coresContainer {
            coresDecoded0 = [Core]()
            for structure0 in coresContainer {
                if let structure0 = structure0 {
                    coresDecoded0?.append(structure0)
                }
            }
        }
        cores = coresDecoded0
    }
}

extension CoreDefinitionVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CoreDefinitionVersion(cores: \(String(describing: cores)))"}
}

/// Information about a core definition version.
public struct CoreDefinitionVersion: Equatable {
    /// A list of cores in the core definition version.
    public let cores: [Core]?

    public init (
        cores: [Core]? = nil
    )
    {
        self.cores = cores
    }
}

public struct CreateConnectorDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "CreateConnectorDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectorDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectorDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectorDefinitionInput>
    public typealias MOutput = OperationOutput<CreateConnectorDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectorDefinitionOutputError>
}

extension CreateConnectorDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectorDefinitionInput(amznClientToken: \(String(describing: amznClientToken)), initialVersion: \(String(describing: initialVersion)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateConnectorDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateConnectorDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConnectorDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectorDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectorDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectorDefinitionInput>
    public typealias MOutput = OperationOutput<CreateConnectorDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectorDefinitionOutputError>
}

public struct CreateConnectorDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConnectorDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectorDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectorDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectorDefinitionInput>
    public typealias MOutput = OperationOutput<CreateConnectorDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectorDefinitionOutputError>
}

public struct CreateConnectorDefinitionInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// Information about the initial version of the connector definition.
    public let initialVersion: ConnectorDefinitionVersion?
    /// The name of the connector definition.
    public let name: String?
    /// Tag(s) to add to the new resource.
    public let tags: [String:String]?

    public init (
        amznClientToken: String? = nil,
        initialVersion: ConnectorDefinitionVersion? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateConnectorDefinitionInputBody: Equatable {
    public let initialVersion: ConnectorDefinitionVersion?
    public let name: String?
    public let tags: [String:String]?
}

extension CreateConnectorDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(ConnectorDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConnectorDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectorDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectorDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectorDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectorDefinitionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), latestVersion: \(String(describing: latestVersion)), latestVersionArn: \(String(describing: latestVersionArn)), name: \(String(describing: name)))"}
}

extension CreateConnectorDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateConnectorDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateConnectorDefinitionOutputResponse: Equatable {
    /// The ARN of the definition.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public let creationTimestamp: String?
    /// The ID of the definition.
    public let id: String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public let lastUpdatedTimestamp: String?
    /// The ID of the latest version associated with the definition.
    public let latestVersion: String?
    /// The ARN of the latest version associated with the definition.
    public let latestVersionArn: String?
    /// The name of the definition.
    public let name: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        lastUpdatedTimestamp: String? = nil,
        latestVersion: String? = nil,
        latestVersionArn: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateConnectorDefinitionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let lastUpdatedTimestamp: String?
    public let latestVersion: String?
    public let latestVersionArn: String?
    public let name: String?
}

extension CreateConnectorDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct CreateConnectorDefinitionVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateConnectorDefinitionVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectorDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectorDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectorDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateConnectorDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectorDefinitionVersionOutputError>
}

extension CreateConnectorDefinitionVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectorDefinitionVersionInput(amznClientToken: \(String(describing: amznClientToken)), connectorDefinitionId: \(String(describing: connectorDefinitionId)), connectors: \(String(describing: connectors)))"}
}

extension CreateConnectorDefinitionVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectors = "Connectors"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectors = connectors {
            var connectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectors)
            for __listofconnector0 in connectors {
                try connectorsContainer.encode(__listofconnector0)
            }
        }
    }
}

public struct CreateConnectorDefinitionVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConnectorDefinitionVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectorDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectorDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectorDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateConnectorDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectorDefinitionVersionOutputError>
}

public struct CreateConnectorDefinitionVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConnectorDefinitionVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectorDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectorDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectorDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateConnectorDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectorDefinitionVersionOutputError>
}

public struct CreateConnectorDefinitionVersionInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// The ID of the connector definition.
    public let connectorDefinitionId: String?
    /// A list of references to connectors in this version, with their corresponding configuration settings.
    public let connectors: [Connector]?

    public init (
        amznClientToken: String? = nil,
        connectorDefinitionId: String? = nil,
        connectors: [Connector]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.connectorDefinitionId = connectorDefinitionId
        self.connectors = connectors
    }
}

struct CreateConnectorDefinitionVersionInputBody: Equatable {
    public let connectors: [Connector]?
}

extension CreateConnectorDefinitionVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectors = "Connectors"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorsContainer = try containerValues.decodeIfPresent([Connector?].self, forKey: .connectors)
        var connectorsDecoded0:[Connector]? = nil
        if let connectorsContainer = connectorsContainer {
            connectorsDecoded0 = [Connector]()
            for structure0 in connectorsContainer {
                if let structure0 = structure0 {
                    connectorsDecoded0?.append(structure0)
                }
            }
        }
        connectors = connectorsDecoded0
    }
}

extension CreateConnectorDefinitionVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectorDefinitionVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectorDefinitionVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectorDefinitionVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectorDefinitionVersionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), version: \(String(describing: version)))"}
}

extension CreateConnectorDefinitionVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateConnectorDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateConnectorDefinitionVersionOutputResponse: Equatable {
    /// The ARN of the version.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public let creationTimestamp: String?
    /// The ID of the parent definition that the version is associated with.
    public let id: String?
    /// The ID of the version.
    public let version: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateConnectorDefinitionVersionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let version: String?
}

extension CreateConnectorDefinitionVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

public struct CreateCoreDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "CreateCoreDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCoreDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCoreDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCoreDefinitionInput>
    public typealias MOutput = OperationOutput<CreateCoreDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCoreDefinitionOutputError>
}

extension CreateCoreDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCoreDefinitionInput(amznClientToken: \(String(describing: amznClientToken)), initialVersion: \(String(describing: initialVersion)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateCoreDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateCoreDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCoreDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCoreDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCoreDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCoreDefinitionInput>
    public typealias MOutput = OperationOutput<CreateCoreDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCoreDefinitionOutputError>
}

public struct CreateCoreDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCoreDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCoreDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCoreDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCoreDefinitionInput>
    public typealias MOutput = OperationOutput<CreateCoreDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCoreDefinitionOutputError>
}

/// Information needed to create a core definition.
public struct CreateCoreDefinitionInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// Information about the initial version of the core definition.
    public let initialVersion: CoreDefinitionVersion?
    /// The name of the core definition.
    public let name: String?
    /// Tag(s) to add to the new resource.
    public let tags: [String:String]?

    public init (
        amznClientToken: String? = nil,
        initialVersion: CoreDefinitionVersion? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateCoreDefinitionInputBody: Equatable {
    public let initialVersion: CoreDefinitionVersion?
    public let name: String?
    public let tags: [String:String]?
}

extension CreateCoreDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(CoreDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCoreDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCoreDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCoreDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCoreDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCoreDefinitionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), latestVersion: \(String(describing: latestVersion)), latestVersionArn: \(String(describing: latestVersionArn)), name: \(String(describing: name)))"}
}

extension CreateCoreDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCoreDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateCoreDefinitionOutputResponse: Equatable {
    /// The ARN of the definition.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public let creationTimestamp: String?
    /// The ID of the definition.
    public let id: String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public let lastUpdatedTimestamp: String?
    /// The ID of the latest version associated with the definition.
    public let latestVersion: String?
    /// The ARN of the latest version associated with the definition.
    public let latestVersionArn: String?
    /// The name of the definition.
    public let name: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        lastUpdatedTimestamp: String? = nil,
        latestVersion: String? = nil,
        latestVersionArn: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateCoreDefinitionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let lastUpdatedTimestamp: String?
    public let latestVersion: String?
    public let latestVersionArn: String?
    public let name: String?
}

extension CreateCoreDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct CreateCoreDefinitionVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateCoreDefinitionVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCoreDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCoreDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCoreDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateCoreDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCoreDefinitionVersionOutputError>
}

extension CreateCoreDefinitionVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCoreDefinitionVersionInput(amznClientToken: \(String(describing: amznClientToken)), coreDefinitionId: \(String(describing: coreDefinitionId)), cores: \(String(describing: cores)))"}
}

extension CreateCoreDefinitionVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cores = "Cores"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cores = cores {
            var coresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cores)
            for __listofcore0 in cores {
                try coresContainer.encode(__listofcore0)
            }
        }
    }
}

public struct CreateCoreDefinitionVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCoreDefinitionVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCoreDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCoreDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCoreDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateCoreDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCoreDefinitionVersionOutputError>
}

public struct CreateCoreDefinitionVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCoreDefinitionVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCoreDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCoreDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCoreDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateCoreDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCoreDefinitionVersionOutputError>
}

public struct CreateCoreDefinitionVersionInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// The ID of the core definition.
    public let coreDefinitionId: String?
    /// A list of cores in the core definition version.
    public let cores: [Core]?

    public init (
        amznClientToken: String? = nil,
        coreDefinitionId: String? = nil,
        cores: [Core]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.coreDefinitionId = coreDefinitionId
        self.cores = cores
    }
}

struct CreateCoreDefinitionVersionInputBody: Equatable {
    public let cores: [Core]?
}

extension CreateCoreDefinitionVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cores = "Cores"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coresContainer = try containerValues.decodeIfPresent([Core?].self, forKey: .cores)
        var coresDecoded0:[Core]? = nil
        if let coresContainer = coresContainer {
            coresDecoded0 = [Core]()
            for structure0 in coresContainer {
                if let structure0 = structure0 {
                    coresDecoded0?.append(structure0)
                }
            }
        }
        cores = coresDecoded0
    }
}

extension CreateCoreDefinitionVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCoreDefinitionVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCoreDefinitionVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCoreDefinitionVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCoreDefinitionVersionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), version: \(String(describing: version)))"}
}

extension CreateCoreDefinitionVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCoreDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateCoreDefinitionVersionOutputResponse: Equatable {
    /// The ARN of the version.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public let creationTimestamp: String?
    /// The ID of the parent definition that the version is associated with.
    public let id: String?
    /// The ID of the version.
    public let version: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateCoreDefinitionVersionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let version: String?
}

extension CreateCoreDefinitionVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

public struct CreateDeploymentInputBodyMiddleware: Middleware {
    public let id: String = "CreateDeploymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentOutputError>
}

extension CreateDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeploymentInput(amznClientToken: \(String(describing: amznClientToken)), deploymentId: \(String(describing: deploymentId)), deploymentType: \(String(describing: deploymentType)), groupId: \(String(describing: groupId)), groupVersionId: \(String(describing: groupVersionId)))"}
}

extension CreateDeploymentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deploymentId = "DeploymentId"
        case deploymentType = "DeploymentType"
        case groupVersionId = "GroupVersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentType = deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let groupVersionId = groupVersionId {
            try encodeContainer.encode(groupVersionId, forKey: .groupVersionId)
        }
    }
}

public struct CreateDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentOutputError>
}

public struct CreateDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentOutputError>
}

public struct CreateDeploymentInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// The ID of the deployment if you wish to redeploy a previous deployment.
    public let deploymentId: String?
    /// The type of deployment. When used for ''CreateDeployment'', only ''NewDeployment'' and ''Redeployment'' are valid.
    public let deploymentType: DeploymentType?
    /// The ID of the Greengrass group.
    public let groupId: String?
    /// The ID of the group version to be deployed.
    public let groupVersionId: String?

    public init (
        amznClientToken: String? = nil,
        deploymentId: String? = nil,
        deploymentType: DeploymentType? = nil,
        groupId: String? = nil,
        groupVersionId: String? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.deploymentId = deploymentId
        self.deploymentType = deploymentType
        self.groupId = groupId
        self.groupVersionId = groupVersionId
    }
}

struct CreateDeploymentInputBody: Equatable {
    public let deploymentId: String?
    public let deploymentType: DeploymentType?
    public let groupVersionId: String?
}

extension CreateDeploymentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deploymentId = "DeploymentId"
        case deploymentType = "DeploymentType"
        case groupVersionId = "GroupVersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(DeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let groupVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupVersionId)
        groupVersionId = groupVersionIdDecoded
    }
}

extension CreateDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeploymentOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeploymentOutputResponse(deploymentArn: \(String(describing: deploymentArn)), deploymentId: \(String(describing: deploymentId)))"}
}

extension CreateDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deploymentArn = output.deploymentArn
            self.deploymentId = output.deploymentId
        } else {
            self.deploymentArn = nil
            self.deploymentId = nil
        }
    }
}

public struct CreateDeploymentOutputResponse: Equatable {
    /// The ARN of the deployment.
    public let deploymentArn: String?
    /// The ID of the deployment.
    public let deploymentId: String?

    public init (
        deploymentArn: String? = nil,
        deploymentId: String? = nil
    )
    {
        self.deploymentArn = deploymentArn
        self.deploymentId = deploymentId
    }
}

struct CreateDeploymentOutputResponseBody: Equatable {
    public let deploymentArn: String?
    public let deploymentId: String?
}

extension CreateDeploymentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deploymentArn = "DeploymentArn"
        case deploymentId = "DeploymentId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentArn)
        deploymentArn = deploymentArnDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
    }
}

public struct CreateDeviceDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "CreateDeviceDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeviceDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeviceDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeviceDefinitionInput>
    public typealias MOutput = OperationOutput<CreateDeviceDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeviceDefinitionOutputError>
}

extension CreateDeviceDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeviceDefinitionInput(amznClientToken: \(String(describing: amznClientToken)), initialVersion: \(String(describing: initialVersion)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateDeviceDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDeviceDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDeviceDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeviceDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeviceDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeviceDefinitionInput>
    public typealias MOutput = OperationOutput<CreateDeviceDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeviceDefinitionOutputError>
}

public struct CreateDeviceDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDeviceDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeviceDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeviceDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeviceDefinitionInput>
    public typealias MOutput = OperationOutput<CreateDeviceDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeviceDefinitionOutputError>
}

public struct CreateDeviceDefinitionInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// Information about the initial version of the device definition.
    public let initialVersion: DeviceDefinitionVersion?
    /// The name of the device definition.
    public let name: String?
    /// Tag(s) to add to the new resource.
    public let tags: [String:String]?

    public init (
        amznClientToken: String? = nil,
        initialVersion: DeviceDefinitionVersion? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateDeviceDefinitionInputBody: Equatable {
    public let initialVersion: DeviceDefinitionVersion?
    public let name: String?
    public let tags: [String:String]?
}

extension CreateDeviceDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(DeviceDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDeviceDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeviceDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeviceDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeviceDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeviceDefinitionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), latestVersion: \(String(describing: latestVersion)), latestVersionArn: \(String(describing: latestVersionArn)), name: \(String(describing: name)))"}
}

extension CreateDeviceDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDeviceDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateDeviceDefinitionOutputResponse: Equatable {
    /// The ARN of the definition.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public let creationTimestamp: String?
    /// The ID of the definition.
    public let id: String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public let lastUpdatedTimestamp: String?
    /// The ID of the latest version associated with the definition.
    public let latestVersion: String?
    /// The ARN of the latest version associated with the definition.
    public let latestVersionArn: String?
    /// The name of the definition.
    public let name: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        lastUpdatedTimestamp: String? = nil,
        latestVersion: String? = nil,
        latestVersionArn: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateDeviceDefinitionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let lastUpdatedTimestamp: String?
    public let latestVersion: String?
    public let latestVersionArn: String?
    public let name: String?
}

extension CreateDeviceDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct CreateDeviceDefinitionVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateDeviceDefinitionVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeviceDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeviceDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeviceDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateDeviceDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeviceDefinitionVersionOutputError>
}

extension CreateDeviceDefinitionVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeviceDefinitionVersionInput(amznClientToken: \(String(describing: amznClientToken)), deviceDefinitionId: \(String(describing: deviceDefinitionId)), devices: \(String(describing: devices)))"}
}

extension CreateDeviceDefinitionVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case devices = "Devices"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devices = devices {
            var devicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .devices)
            for __listofdevice0 in devices {
                try devicesContainer.encode(__listofdevice0)
            }
        }
    }
}

public struct CreateDeviceDefinitionVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDeviceDefinitionVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeviceDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeviceDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeviceDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateDeviceDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeviceDefinitionVersionOutputError>
}

public struct CreateDeviceDefinitionVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDeviceDefinitionVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeviceDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeviceDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeviceDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateDeviceDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeviceDefinitionVersionOutputError>
}

public struct CreateDeviceDefinitionVersionInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// The ID of the device definition.
    public let deviceDefinitionId: String?
    /// A list of devices in the definition version.
    public let devices: [Device]?

    public init (
        amznClientToken: String? = nil,
        deviceDefinitionId: String? = nil,
        devices: [Device]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.deviceDefinitionId = deviceDefinitionId
        self.devices = devices
    }
}

struct CreateDeviceDefinitionVersionInputBody: Equatable {
    public let devices: [Device]?
}

extension CreateDeviceDefinitionVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case devices = "Devices"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([Device?].self, forKey: .devices)
        var devicesDecoded0:[Device]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [Device]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
    }
}

extension CreateDeviceDefinitionVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeviceDefinitionVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeviceDefinitionVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeviceDefinitionVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeviceDefinitionVersionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), version: \(String(describing: version)))"}
}

extension CreateDeviceDefinitionVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDeviceDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateDeviceDefinitionVersionOutputResponse: Equatable {
    /// The ARN of the version.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public let creationTimestamp: String?
    /// The ID of the parent definition that the version is associated with.
    public let id: String?
    /// The ID of the version.
    public let version: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateDeviceDefinitionVersionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let version: String?
}

extension CreateDeviceDefinitionVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

public struct CreateFunctionDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "CreateFunctionDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFunctionDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFunctionDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFunctionDefinitionInput>
    public typealias MOutput = OperationOutput<CreateFunctionDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFunctionDefinitionOutputError>
}

extension CreateFunctionDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFunctionDefinitionInput(amznClientToken: \(String(describing: amznClientToken)), initialVersion: \(String(describing: initialVersion)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateFunctionDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateFunctionDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFunctionDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFunctionDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFunctionDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFunctionDefinitionInput>
    public typealias MOutput = OperationOutput<CreateFunctionDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFunctionDefinitionOutputError>
}

public struct CreateFunctionDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFunctionDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFunctionDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFunctionDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFunctionDefinitionInput>
    public typealias MOutput = OperationOutput<CreateFunctionDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFunctionDefinitionOutputError>
}

public struct CreateFunctionDefinitionInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// Information about the initial version of the function definition.
    public let initialVersion: FunctionDefinitionVersion?
    /// The name of the function definition.
    public let name: String?
    /// Tag(s) to add to the new resource.
    public let tags: [String:String]?

    public init (
        amznClientToken: String? = nil,
        initialVersion: FunctionDefinitionVersion? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateFunctionDefinitionInputBody: Equatable {
    public let initialVersion: FunctionDefinitionVersion?
    public let name: String?
    public let tags: [String:String]?
}

extension CreateFunctionDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(FunctionDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFunctionDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFunctionDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFunctionDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFunctionDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFunctionDefinitionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), latestVersion: \(String(describing: latestVersion)), latestVersionArn: \(String(describing: latestVersionArn)), name: \(String(describing: name)))"}
}

extension CreateFunctionDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFunctionDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateFunctionDefinitionOutputResponse: Equatable {
    /// The ARN of the definition.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public let creationTimestamp: String?
    /// The ID of the definition.
    public let id: String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public let lastUpdatedTimestamp: String?
    /// The ID of the latest version associated with the definition.
    public let latestVersion: String?
    /// The ARN of the latest version associated with the definition.
    public let latestVersionArn: String?
    /// The name of the definition.
    public let name: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        lastUpdatedTimestamp: String? = nil,
        latestVersion: String? = nil,
        latestVersionArn: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateFunctionDefinitionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let lastUpdatedTimestamp: String?
    public let latestVersion: String?
    public let latestVersionArn: String?
    public let name: String?
}

extension CreateFunctionDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct CreateFunctionDefinitionVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateFunctionDefinitionVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFunctionDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFunctionDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFunctionDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateFunctionDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFunctionDefinitionVersionOutputError>
}

extension CreateFunctionDefinitionVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFunctionDefinitionVersionInput(amznClientToken: \(String(describing: amznClientToken)), defaultConfig: \(String(describing: defaultConfig)), functionDefinitionId: \(String(describing: functionDefinitionId)), functions: \(String(describing: functions)))"}
}

extension CreateFunctionDefinitionVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultConfig = "DefaultConfig"
        case functions = "Functions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultConfig = defaultConfig {
            try encodeContainer.encode(defaultConfig, forKey: .defaultConfig)
        }
        if let functions = functions {
            var functionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functions)
            for __listoffunction0 in functions {
                try functionsContainer.encode(__listoffunction0)
            }
        }
    }
}

public struct CreateFunctionDefinitionVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFunctionDefinitionVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFunctionDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFunctionDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFunctionDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateFunctionDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFunctionDefinitionVersionOutputError>
}

public struct CreateFunctionDefinitionVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFunctionDefinitionVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFunctionDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFunctionDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFunctionDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateFunctionDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFunctionDefinitionVersionOutputError>
}

/// Information needed to create a function definition version.
public struct CreateFunctionDefinitionVersionInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// The default configuration that applies to all Lambda functions in this function definition version. Individual Lambda functions can override these settings.
    public let defaultConfig: FunctionDefaultConfig?
    /// The ID of the Lambda function definition.
    public let functionDefinitionId: String?
    /// A list of Lambda functions in this function definition version.
    public let functions: [Function]?

    public init (
        amznClientToken: String? = nil,
        defaultConfig: FunctionDefaultConfig? = nil,
        functionDefinitionId: String? = nil,
        functions: [Function]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.defaultConfig = defaultConfig
        self.functionDefinitionId = functionDefinitionId
        self.functions = functions
    }
}

struct CreateFunctionDefinitionVersionInputBody: Equatable {
    public let defaultConfig: FunctionDefaultConfig?
    public let functions: [Function]?
}

extension CreateFunctionDefinitionVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultConfig = "DefaultConfig"
        case functions = "Functions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultConfigDecoded = try containerValues.decodeIfPresent(FunctionDefaultConfig.self, forKey: .defaultConfig)
        defaultConfig = defaultConfigDecoded
        let functionsContainer = try containerValues.decodeIfPresent([Function?].self, forKey: .functions)
        var functionsDecoded0:[Function]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [Function]()
            for structure0 in functionsContainer {
                if let structure0 = structure0 {
                    functionsDecoded0?.append(structure0)
                }
            }
        }
        functions = functionsDecoded0
    }
}

extension CreateFunctionDefinitionVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFunctionDefinitionVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFunctionDefinitionVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFunctionDefinitionVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFunctionDefinitionVersionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), version: \(String(describing: version)))"}
}

extension CreateFunctionDefinitionVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFunctionDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateFunctionDefinitionVersionOutputResponse: Equatable {
    /// The ARN of the version.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public let creationTimestamp: String?
    /// The ID of the parent definition that the version is associated with.
    public let id: String?
    /// The ID of the version.
    public let version: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateFunctionDefinitionVersionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let version: String?
}

extension CreateFunctionDefinitionVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension CreateGroupCertificateAuthorityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGroupCertificateAuthorityInput(amznClientToken: \(String(describing: amznClientToken)), groupId: \(String(describing: groupId)))"}
}

extension CreateGroupCertificateAuthorityInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CreateGroupCertificateAuthorityInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGroupCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<CreateGroupCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupCertificateAuthorityOutputError>
}

public struct CreateGroupCertificateAuthorityInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGroupCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<CreateGroupCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupCertificateAuthorityOutputError>
}

public struct CreateGroupCertificateAuthorityInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// The ID of the Greengrass group.
    public let groupId: String?

    public init (
        amznClientToken: String? = nil,
        groupId: String? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.groupId = groupId
    }
}

struct CreateGroupCertificateAuthorityInputBody: Equatable {
}

extension CreateGroupCertificateAuthorityInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreateGroupCertificateAuthorityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGroupCertificateAuthorityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGroupCertificateAuthorityOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupCertificateAuthorityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGroupCertificateAuthorityOutputResponse(groupCertificateAuthorityArn: \(String(describing: groupCertificateAuthorityArn)))"}
}

extension CreateGroupCertificateAuthorityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateGroupCertificateAuthorityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groupCertificateAuthorityArn = output.groupCertificateAuthorityArn
        } else {
            self.groupCertificateAuthorityArn = nil
        }
    }
}

public struct CreateGroupCertificateAuthorityOutputResponse: Equatable {
    /// The ARN of the group certificate authority.
    public let groupCertificateAuthorityArn: String?

    public init (
        groupCertificateAuthorityArn: String? = nil
    )
    {
        self.groupCertificateAuthorityArn = groupCertificateAuthorityArn
    }
}

struct CreateGroupCertificateAuthorityOutputResponseBody: Equatable {
    public let groupCertificateAuthorityArn: String?
}

extension CreateGroupCertificateAuthorityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupCertificateAuthorityArn = "GroupCertificateAuthorityArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupCertificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupCertificateAuthorityArn)
        groupCertificateAuthorityArn = groupCertificateAuthorityArnDecoded
    }
}

public struct CreateGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

extension CreateGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGroupInput(amznClientToken: \(String(describing: amznClientToken)), initialVersion: \(String(describing: initialVersion)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

public struct CreateGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

public struct CreateGroupInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// Information about the initial version of the group.
    public let initialVersion: GroupVersion?
    /// The name of the group.
    public let name: String?
    /// Tag(s) to add to the new resource.
    public let tags: [String:String]?

    public init (
        amznClientToken: String? = nil,
        initialVersion: GroupVersion? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateGroupInputBody: Equatable {
    public let initialVersion: GroupVersion?
    public let name: String?
    public let tags: [String:String]?
}

extension CreateGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(GroupVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGroupOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGroupOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), latestVersion: \(String(describing: latestVersion)), latestVersionArn: \(String(describing: latestVersionArn)), name: \(String(describing: name)))"}
}

extension CreateGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateGroupOutputResponse: Equatable {
    /// The ARN of the definition.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public let creationTimestamp: String?
    /// The ID of the definition.
    public let id: String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public let lastUpdatedTimestamp: String?
    /// The ID of the latest version associated with the definition.
    public let latestVersion: String?
    /// The ARN of the latest version associated with the definition.
    public let latestVersionArn: String?
    /// The name of the definition.
    public let name: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        lastUpdatedTimestamp: String? = nil,
        latestVersion: String? = nil,
        latestVersionArn: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateGroupOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let lastUpdatedTimestamp: String?
    public let latestVersion: String?
    public let latestVersionArn: String?
    public let name: String?
}

extension CreateGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct CreateGroupVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateGroupVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupVersionInput>
    public typealias MOutput = OperationOutput<CreateGroupVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupVersionOutputError>
}

extension CreateGroupVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGroupVersionInput(amznClientToken: \(String(describing: amznClientToken)), connectorDefinitionVersionArn: \(String(describing: connectorDefinitionVersionArn)), coreDefinitionVersionArn: \(String(describing: coreDefinitionVersionArn)), deviceDefinitionVersionArn: \(String(describing: deviceDefinitionVersionArn)), functionDefinitionVersionArn: \(String(describing: functionDefinitionVersionArn)), groupId: \(String(describing: groupId)), loggerDefinitionVersionArn: \(String(describing: loggerDefinitionVersionArn)), resourceDefinitionVersionArn: \(String(describing: resourceDefinitionVersionArn)), subscriptionDefinitionVersionArn: \(String(describing: subscriptionDefinitionVersionArn)))"}
}

extension CreateGroupVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectorDefinitionVersionArn = "ConnectorDefinitionVersionArn"
        case coreDefinitionVersionArn = "CoreDefinitionVersionArn"
        case deviceDefinitionVersionArn = "DeviceDefinitionVersionArn"
        case functionDefinitionVersionArn = "FunctionDefinitionVersionArn"
        case loggerDefinitionVersionArn = "LoggerDefinitionVersionArn"
        case resourceDefinitionVersionArn = "ResourceDefinitionVersionArn"
        case subscriptionDefinitionVersionArn = "SubscriptionDefinitionVersionArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorDefinitionVersionArn = connectorDefinitionVersionArn {
            try encodeContainer.encode(connectorDefinitionVersionArn, forKey: .connectorDefinitionVersionArn)
        }
        if let coreDefinitionVersionArn = coreDefinitionVersionArn {
            try encodeContainer.encode(coreDefinitionVersionArn, forKey: .coreDefinitionVersionArn)
        }
        if let deviceDefinitionVersionArn = deviceDefinitionVersionArn {
            try encodeContainer.encode(deviceDefinitionVersionArn, forKey: .deviceDefinitionVersionArn)
        }
        if let functionDefinitionVersionArn = functionDefinitionVersionArn {
            try encodeContainer.encode(functionDefinitionVersionArn, forKey: .functionDefinitionVersionArn)
        }
        if let loggerDefinitionVersionArn = loggerDefinitionVersionArn {
            try encodeContainer.encode(loggerDefinitionVersionArn, forKey: .loggerDefinitionVersionArn)
        }
        if let resourceDefinitionVersionArn = resourceDefinitionVersionArn {
            try encodeContainer.encode(resourceDefinitionVersionArn, forKey: .resourceDefinitionVersionArn)
        }
        if let subscriptionDefinitionVersionArn = subscriptionDefinitionVersionArn {
            try encodeContainer.encode(subscriptionDefinitionVersionArn, forKey: .subscriptionDefinitionVersionArn)
        }
    }
}

public struct CreateGroupVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGroupVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupVersionInput>
    public typealias MOutput = OperationOutput<CreateGroupVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupVersionOutputError>
}

public struct CreateGroupVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGroupVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupVersionInput>
    public typealias MOutput = OperationOutput<CreateGroupVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupVersionOutputError>
}

public struct CreateGroupVersionInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// The ARN of the connector definition version for this group.
    public let connectorDefinitionVersionArn: String?
    /// The ARN of the core definition version for this group.
    public let coreDefinitionVersionArn: String?
    /// The ARN of the device definition version for this group.
    public let deviceDefinitionVersionArn: String?
    /// The ARN of the function definition version for this group.
    public let functionDefinitionVersionArn: String?
    /// The ID of the Greengrass group.
    public let groupId: String?
    /// The ARN of the logger definition version for this group.
    public let loggerDefinitionVersionArn: String?
    /// The ARN of the resource definition version for this group.
    public let resourceDefinitionVersionArn: String?
    /// The ARN of the subscription definition version for this group.
    public let subscriptionDefinitionVersionArn: String?

    public init (
        amznClientToken: String? = nil,
        connectorDefinitionVersionArn: String? = nil,
        coreDefinitionVersionArn: String? = nil,
        deviceDefinitionVersionArn: String? = nil,
        functionDefinitionVersionArn: String? = nil,
        groupId: String? = nil,
        loggerDefinitionVersionArn: String? = nil,
        resourceDefinitionVersionArn: String? = nil,
        subscriptionDefinitionVersionArn: String? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.connectorDefinitionVersionArn = connectorDefinitionVersionArn
        self.coreDefinitionVersionArn = coreDefinitionVersionArn
        self.deviceDefinitionVersionArn = deviceDefinitionVersionArn
        self.functionDefinitionVersionArn = functionDefinitionVersionArn
        self.groupId = groupId
        self.loggerDefinitionVersionArn = loggerDefinitionVersionArn
        self.resourceDefinitionVersionArn = resourceDefinitionVersionArn
        self.subscriptionDefinitionVersionArn = subscriptionDefinitionVersionArn
    }
}

struct CreateGroupVersionInputBody: Equatable {
    public let connectorDefinitionVersionArn: String?
    public let coreDefinitionVersionArn: String?
    public let deviceDefinitionVersionArn: String?
    public let functionDefinitionVersionArn: String?
    public let loggerDefinitionVersionArn: String?
    public let resourceDefinitionVersionArn: String?
    public let subscriptionDefinitionVersionArn: String?
}

extension CreateGroupVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectorDefinitionVersionArn = "ConnectorDefinitionVersionArn"
        case coreDefinitionVersionArn = "CoreDefinitionVersionArn"
        case deviceDefinitionVersionArn = "DeviceDefinitionVersionArn"
        case functionDefinitionVersionArn = "FunctionDefinitionVersionArn"
        case loggerDefinitionVersionArn = "LoggerDefinitionVersionArn"
        case resourceDefinitionVersionArn = "ResourceDefinitionVersionArn"
        case subscriptionDefinitionVersionArn = "SubscriptionDefinitionVersionArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectorDefinitionVersionArn)
        connectorDefinitionVersionArn = connectorDefinitionVersionArnDecoded
        let coreDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .coreDefinitionVersionArn)
        coreDefinitionVersionArn = coreDefinitionVersionArnDecoded
        let deviceDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceDefinitionVersionArn)
        deviceDefinitionVersionArn = deviceDefinitionVersionArnDecoded
        let functionDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionDefinitionVersionArn)
        functionDefinitionVersionArn = functionDefinitionVersionArnDecoded
        let loggerDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loggerDefinitionVersionArn)
        loggerDefinitionVersionArn = loggerDefinitionVersionArnDecoded
        let resourceDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceDefinitionVersionArn)
        resourceDefinitionVersionArn = resourceDefinitionVersionArnDecoded
        let subscriptionDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionDefinitionVersionArn)
        subscriptionDefinitionVersionArn = subscriptionDefinitionVersionArnDecoded
    }
}

extension CreateGroupVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGroupVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGroupVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGroupVersionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), version: \(String(describing: version)))"}
}

extension CreateGroupVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateGroupVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateGroupVersionOutputResponse: Equatable {
    /// The ARN of the version.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public let creationTimestamp: String?
    /// The ID of the parent definition that the version is associated with.
    public let id: String?
    /// The ID of the version.
    public let version: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateGroupVersionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let version: String?
}

extension CreateGroupVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

public struct CreateLoggerDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "CreateLoggerDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoggerDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoggerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoggerDefinitionInput>
    public typealias MOutput = OperationOutput<CreateLoggerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoggerDefinitionOutputError>
}

extension CreateLoggerDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLoggerDefinitionInput(amznClientToken: \(String(describing: amznClientToken)), initialVersion: \(String(describing: initialVersion)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateLoggerDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateLoggerDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLoggerDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoggerDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoggerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoggerDefinitionInput>
    public typealias MOutput = OperationOutput<CreateLoggerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoggerDefinitionOutputError>
}

public struct CreateLoggerDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLoggerDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoggerDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoggerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoggerDefinitionInput>
    public typealias MOutput = OperationOutput<CreateLoggerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoggerDefinitionOutputError>
}

public struct CreateLoggerDefinitionInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// Information about the initial version of the logger definition.
    public let initialVersion: LoggerDefinitionVersion?
    /// The name of the logger definition.
    public let name: String?
    /// Tag(s) to add to the new resource.
    public let tags: [String:String]?

    public init (
        amznClientToken: String? = nil,
        initialVersion: LoggerDefinitionVersion? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateLoggerDefinitionInputBody: Equatable {
    public let initialVersion: LoggerDefinitionVersion?
    public let name: String?
    public let tags: [String:String]?
}

extension CreateLoggerDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(LoggerDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLoggerDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLoggerDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLoggerDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLoggerDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLoggerDefinitionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), latestVersion: \(String(describing: latestVersion)), latestVersionArn: \(String(describing: latestVersionArn)), name: \(String(describing: name)))"}
}

extension CreateLoggerDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateLoggerDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateLoggerDefinitionOutputResponse: Equatable {
    /// The ARN of the definition.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public let creationTimestamp: String?
    /// The ID of the definition.
    public let id: String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public let lastUpdatedTimestamp: String?
    /// The ID of the latest version associated with the definition.
    public let latestVersion: String?
    /// The ARN of the latest version associated with the definition.
    public let latestVersionArn: String?
    /// The name of the definition.
    public let name: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        lastUpdatedTimestamp: String? = nil,
        latestVersion: String? = nil,
        latestVersionArn: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateLoggerDefinitionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let lastUpdatedTimestamp: String?
    public let latestVersion: String?
    public let latestVersionArn: String?
    public let name: String?
}

extension CreateLoggerDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct CreateLoggerDefinitionVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateLoggerDefinitionVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoggerDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoggerDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoggerDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateLoggerDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoggerDefinitionVersionOutputError>
}

extension CreateLoggerDefinitionVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLoggerDefinitionVersionInput(amznClientToken: \(String(describing: amznClientToken)), loggerDefinitionId: \(String(describing: loggerDefinitionId)), loggers: \(String(describing: loggers)))"}
}

extension CreateLoggerDefinitionVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case loggers = "Loggers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggers = loggers {
            var loggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loggers)
            for __listoflogger0 in loggers {
                try loggersContainer.encode(__listoflogger0)
            }
        }
    }
}

public struct CreateLoggerDefinitionVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLoggerDefinitionVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoggerDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoggerDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoggerDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateLoggerDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoggerDefinitionVersionOutputError>
}

public struct CreateLoggerDefinitionVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLoggerDefinitionVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoggerDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoggerDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoggerDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateLoggerDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoggerDefinitionVersionOutputError>
}

public struct CreateLoggerDefinitionVersionInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// The ID of the logger definition.
    public let loggerDefinitionId: String?
    /// A list of loggers.
    public let loggers: [Logger]?

    public init (
        amznClientToken: String? = nil,
        loggerDefinitionId: String? = nil,
        loggers: [Logger]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.loggerDefinitionId = loggerDefinitionId
        self.loggers = loggers
    }
}

struct CreateLoggerDefinitionVersionInputBody: Equatable {
    public let loggers: [Logger]?
}

extension CreateLoggerDefinitionVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loggers = "Loggers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggersContainer = try containerValues.decodeIfPresent([Logger?].self, forKey: .loggers)
        var loggersDecoded0:[Logger]? = nil
        if let loggersContainer = loggersContainer {
            loggersDecoded0 = [Logger]()
            for structure0 in loggersContainer {
                if let structure0 = structure0 {
                    loggersDecoded0?.append(structure0)
                }
            }
        }
        loggers = loggersDecoded0
    }
}

extension CreateLoggerDefinitionVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLoggerDefinitionVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLoggerDefinitionVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLoggerDefinitionVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLoggerDefinitionVersionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), version: \(String(describing: version)))"}
}

extension CreateLoggerDefinitionVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateLoggerDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateLoggerDefinitionVersionOutputResponse: Equatable {
    /// The ARN of the version.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public let creationTimestamp: String?
    /// The ID of the parent definition that the version is associated with.
    public let id: String?
    /// The ID of the version.
    public let version: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateLoggerDefinitionVersionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let version: String?
}

extension CreateLoggerDefinitionVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

public struct CreateResourceDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "CreateResourceDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceDefinitionInput>
    public typealias MOutput = OperationOutput<CreateResourceDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceDefinitionOutputError>
}

extension CreateResourceDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResourceDefinitionInput(amznClientToken: \(String(describing: amznClientToken)), initialVersion: \(String(describing: initialVersion)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateResourceDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateResourceDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateResourceDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceDefinitionInput>
    public typealias MOutput = OperationOutput<CreateResourceDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceDefinitionOutputError>
}

public struct CreateResourceDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateResourceDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceDefinitionInput>
    public typealias MOutput = OperationOutput<CreateResourceDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceDefinitionOutputError>
}

public struct CreateResourceDefinitionInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// Information about the initial version of the resource definition.
    public let initialVersion: ResourceDefinitionVersion?
    /// The name of the resource definition.
    public let name: String?
    /// Tag(s) to add to the new resource.
    public let tags: [String:String]?

    public init (
        amznClientToken: String? = nil,
        initialVersion: ResourceDefinitionVersion? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateResourceDefinitionInputBody: Equatable {
    public let initialVersion: ResourceDefinitionVersion?
    public let name: String?
    public let tags: [String:String]?
}

extension CreateResourceDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(ResourceDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateResourceDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResourceDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResourceDefinitionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), latestVersion: \(String(describing: latestVersion)), latestVersionArn: \(String(describing: latestVersionArn)), name: \(String(describing: name)))"}
}

extension CreateResourceDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateResourceDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateResourceDefinitionOutputResponse: Equatable {
    /// The ARN of the definition.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public let creationTimestamp: String?
    /// The ID of the definition.
    public let id: String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public let lastUpdatedTimestamp: String?
    /// The ID of the latest version associated with the definition.
    public let latestVersion: String?
    /// The ARN of the latest version associated with the definition.
    public let latestVersionArn: String?
    /// The name of the definition.
    public let name: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        lastUpdatedTimestamp: String? = nil,
        latestVersion: String? = nil,
        latestVersionArn: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateResourceDefinitionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let lastUpdatedTimestamp: String?
    public let latestVersion: String?
    public let latestVersionArn: String?
    public let name: String?
}

extension CreateResourceDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct CreateResourceDefinitionVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateResourceDefinitionVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateResourceDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceDefinitionVersionOutputError>
}

extension CreateResourceDefinitionVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResourceDefinitionVersionInput(amznClientToken: \(String(describing: amznClientToken)), resourceDefinitionId: \(String(describing: resourceDefinitionId)), resources: \(String(describing: resources)))"}
}

extension CreateResourceDefinitionVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resources = "Resources"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for __listofresource0 in resources {
                try resourcesContainer.encode(__listofresource0)
            }
        }
    }
}

public struct CreateResourceDefinitionVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateResourceDefinitionVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateResourceDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceDefinitionVersionOutputError>
}

public struct CreateResourceDefinitionVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateResourceDefinitionVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateResourceDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceDefinitionVersionOutputError>
}

public struct CreateResourceDefinitionVersionInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// The ID of the resource definition.
    public let resourceDefinitionId: String?
    /// A list of resources.
    public let resources: [Resource]?

    public init (
        amznClientToken: String? = nil,
        resourceDefinitionId: String? = nil,
        resources: [Resource]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.resourceDefinitionId = resourceDefinitionId
        self.resources = resources
    }
}

struct CreateResourceDefinitionVersionInputBody: Equatable {
    public let resources: [Resource]?
}

extension CreateResourceDefinitionVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resources = "Resources"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension CreateResourceDefinitionVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceDefinitionVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResourceDefinitionVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceDefinitionVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResourceDefinitionVersionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), version: \(String(describing: version)))"}
}

extension CreateResourceDefinitionVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateResourceDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateResourceDefinitionVersionOutputResponse: Equatable {
    /// The ARN of the version.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public let creationTimestamp: String?
    /// The ID of the parent definition that the version is associated with.
    public let id: String?
    /// The ID of the version.
    public let version: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateResourceDefinitionVersionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let version: String?
}

extension CreateResourceDefinitionVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

public struct CreateSoftwareUpdateJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateSoftwareUpdateJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSoftwareUpdateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSoftwareUpdateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSoftwareUpdateJobInput>
    public typealias MOutput = OperationOutput<CreateSoftwareUpdateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSoftwareUpdateJobOutputError>
}

extension CreateSoftwareUpdateJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSoftwareUpdateJobInput(amznClientToken: \(String(describing: amznClientToken)), s3UrlSignerRole: \(String(describing: s3UrlSignerRole)), softwareToUpdate: \(String(describing: softwareToUpdate)), updateAgentLogLevel: \(String(describing: updateAgentLogLevel)), updateTargets: \(String(describing: updateTargets)), updateTargetsArchitecture: \(String(describing: updateTargetsArchitecture)), updateTargetsOperatingSystem: \(String(describing: updateTargetsOperatingSystem)))"}
}

extension CreateSoftwareUpdateJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3UrlSignerRole = "S3UrlSignerRole"
        case softwareToUpdate = "SoftwareToUpdate"
        case updateAgentLogLevel = "UpdateAgentLogLevel"
        case updateTargets = "UpdateTargets"
        case updateTargetsArchitecture = "UpdateTargetsArchitecture"
        case updateTargetsOperatingSystem = "UpdateTargetsOperatingSystem"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3UrlSignerRole = s3UrlSignerRole {
            try encodeContainer.encode(s3UrlSignerRole, forKey: .s3UrlSignerRole)
        }
        if let softwareToUpdate = softwareToUpdate {
            try encodeContainer.encode(softwareToUpdate.rawValue, forKey: .softwareToUpdate)
        }
        if let updateAgentLogLevel = updateAgentLogLevel {
            try encodeContainer.encode(updateAgentLogLevel.rawValue, forKey: .updateAgentLogLevel)
        }
        if let updateTargets = updateTargets {
            var updateTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updateTargets)
            for updatetargets0 in updateTargets {
                try updateTargetsContainer.encode(updatetargets0)
            }
        }
        if let updateTargetsArchitecture = updateTargetsArchitecture {
            try encodeContainer.encode(updateTargetsArchitecture.rawValue, forKey: .updateTargetsArchitecture)
        }
        if let updateTargetsOperatingSystem = updateTargetsOperatingSystem {
            try encodeContainer.encode(updateTargetsOperatingSystem.rawValue, forKey: .updateTargetsOperatingSystem)
        }
    }
}

public struct CreateSoftwareUpdateJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSoftwareUpdateJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSoftwareUpdateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSoftwareUpdateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSoftwareUpdateJobInput>
    public typealias MOutput = OperationOutput<CreateSoftwareUpdateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSoftwareUpdateJobOutputError>
}

public struct CreateSoftwareUpdateJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSoftwareUpdateJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSoftwareUpdateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSoftwareUpdateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSoftwareUpdateJobInput>
    public typealias MOutput = OperationOutput<CreateSoftwareUpdateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSoftwareUpdateJobOutputError>
}

public struct CreateSoftwareUpdateJobInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// The IAM Role that Greengrass will use to create pre-signed URLs pointing towards the update artifact.
    public let s3UrlSignerRole: String?
    /// The piece of software on the Greengrass core that will be updated.
    public let softwareToUpdate: SoftwareToUpdate?
    /// The minimum level of log statements that should be logged by the OTA Agent during an update.
    public let updateAgentLogLevel: UpdateAgentLogLevel?
    /// The ARNs of the targets (IoT things or IoT thing groups) that this update will be applied to.
    public let updateTargets: [String]?
    /// The architecture of the cores which are the targets of an update.
    public let updateTargetsArchitecture: UpdateTargetsArchitecture?
    /// The operating system of the cores which are the targets of an update.
    public let updateTargetsOperatingSystem: UpdateTargetsOperatingSystem?

    public init (
        amznClientToken: String? = nil,
        s3UrlSignerRole: String? = nil,
        softwareToUpdate: SoftwareToUpdate? = nil,
        updateAgentLogLevel: UpdateAgentLogLevel? = nil,
        updateTargets: [String]? = nil,
        updateTargetsArchitecture: UpdateTargetsArchitecture? = nil,
        updateTargetsOperatingSystem: UpdateTargetsOperatingSystem? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.s3UrlSignerRole = s3UrlSignerRole
        self.softwareToUpdate = softwareToUpdate
        self.updateAgentLogLevel = updateAgentLogLevel
        self.updateTargets = updateTargets
        self.updateTargetsArchitecture = updateTargetsArchitecture
        self.updateTargetsOperatingSystem = updateTargetsOperatingSystem
    }
}

struct CreateSoftwareUpdateJobInputBody: Equatable {
    public let s3UrlSignerRole: String?
    public let softwareToUpdate: SoftwareToUpdate?
    public let updateAgentLogLevel: UpdateAgentLogLevel?
    public let updateTargets: [String]?
    public let updateTargetsArchitecture: UpdateTargetsArchitecture?
    public let updateTargetsOperatingSystem: UpdateTargetsOperatingSystem?
}

extension CreateSoftwareUpdateJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case s3UrlSignerRole = "S3UrlSignerRole"
        case softwareToUpdate = "SoftwareToUpdate"
        case updateAgentLogLevel = "UpdateAgentLogLevel"
        case updateTargets = "UpdateTargets"
        case updateTargetsArchitecture = "UpdateTargetsArchitecture"
        case updateTargetsOperatingSystem = "UpdateTargetsOperatingSystem"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UrlSignerRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3UrlSignerRole)
        s3UrlSignerRole = s3UrlSignerRoleDecoded
        let softwareToUpdateDecoded = try containerValues.decodeIfPresent(SoftwareToUpdate.self, forKey: .softwareToUpdate)
        softwareToUpdate = softwareToUpdateDecoded
        let updateAgentLogLevelDecoded = try containerValues.decodeIfPresent(UpdateAgentLogLevel.self, forKey: .updateAgentLogLevel)
        updateAgentLogLevel = updateAgentLogLevelDecoded
        let updateTargetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .updateTargets)
        var updateTargetsDecoded0:[String]? = nil
        if let updateTargetsContainer = updateTargetsContainer {
            updateTargetsDecoded0 = [String]()
            for string0 in updateTargetsContainer {
                if let string0 = string0 {
                    updateTargetsDecoded0?.append(string0)
                }
            }
        }
        updateTargets = updateTargetsDecoded0
        let updateTargetsArchitectureDecoded = try containerValues.decodeIfPresent(UpdateTargetsArchitecture.self, forKey: .updateTargetsArchitecture)
        updateTargetsArchitecture = updateTargetsArchitectureDecoded
        let updateTargetsOperatingSystemDecoded = try containerValues.decodeIfPresent(UpdateTargetsOperatingSystem.self, forKey: .updateTargetsOperatingSystem)
        updateTargetsOperatingSystem = updateTargetsOperatingSystemDecoded
    }
}

extension CreateSoftwareUpdateJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSoftwareUpdateJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSoftwareUpdateJobOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSoftwareUpdateJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSoftwareUpdateJobOutputResponse(iotJobArn: \(String(describing: iotJobArn)), iotJobId: \(String(describing: iotJobId)), platformSoftwareVersion: \(String(describing: platformSoftwareVersion)))"}
}

extension CreateSoftwareUpdateJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSoftwareUpdateJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.iotJobArn = output.iotJobArn
            self.iotJobId = output.iotJobId
            self.platformSoftwareVersion = output.platformSoftwareVersion
        } else {
            self.iotJobArn = nil
            self.iotJobId = nil
            self.platformSoftwareVersion = nil
        }
    }
}

public struct CreateSoftwareUpdateJobOutputResponse: Equatable {
    /// The IoT Job ARN corresponding to this update.
    public let iotJobArn: String?
    /// The IoT Job Id corresponding to this update.
    public let iotJobId: String?
    /// The software version installed on the device or devices after the update.
    public let platformSoftwareVersion: String?

    public init (
        iotJobArn: String? = nil,
        iotJobId: String? = nil,
        platformSoftwareVersion: String? = nil
    )
    {
        self.iotJobArn = iotJobArn
        self.iotJobId = iotJobId
        self.platformSoftwareVersion = platformSoftwareVersion
    }
}

struct CreateSoftwareUpdateJobOutputResponseBody: Equatable {
    public let iotJobArn: String?
    public let iotJobId: String?
    public let platformSoftwareVersion: String?
}

extension CreateSoftwareUpdateJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case iotJobArn = "IotJobArn"
        case iotJobId = "IotJobId"
        case platformSoftwareVersion = "PlatformSoftwareVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iotJobArn)
        iotJobArn = iotJobArnDecoded
        let iotJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iotJobId)
        iotJobId = iotJobIdDecoded
        let platformSoftwareVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformSoftwareVersion)
        platformSoftwareVersion = platformSoftwareVersionDecoded
    }
}

public struct CreateSubscriptionDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "CreateSubscriptionDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSubscriptionDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSubscriptionDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSubscriptionDefinitionInput>
    public typealias MOutput = OperationOutput<CreateSubscriptionDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSubscriptionDefinitionOutputError>
}

extension CreateSubscriptionDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSubscriptionDefinitionInput(amznClientToken: \(String(describing: amznClientToken)), initialVersion: \(String(describing: initialVersion)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateSubscriptionDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateSubscriptionDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSubscriptionDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSubscriptionDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSubscriptionDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSubscriptionDefinitionInput>
    public typealias MOutput = OperationOutput<CreateSubscriptionDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSubscriptionDefinitionOutputError>
}

public struct CreateSubscriptionDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSubscriptionDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSubscriptionDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSubscriptionDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSubscriptionDefinitionInput>
    public typealias MOutput = OperationOutput<CreateSubscriptionDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSubscriptionDefinitionOutputError>
}

public struct CreateSubscriptionDefinitionInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// Information about the initial version of the subscription definition.
    public let initialVersion: SubscriptionDefinitionVersion?
    /// The name of the subscription definition.
    public let name: String?
    /// Tag(s) to add to the new resource.
    public let tags: [String:String]?

    public init (
        amznClientToken: String? = nil,
        initialVersion: SubscriptionDefinitionVersion? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateSubscriptionDefinitionInputBody: Equatable {
    public let initialVersion: SubscriptionDefinitionVersion?
    public let name: String?
    public let tags: [String:String]?
}

extension CreateSubscriptionDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(SubscriptionDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSubscriptionDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSubscriptionDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSubscriptionDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSubscriptionDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSubscriptionDefinitionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), latestVersion: \(String(describing: latestVersion)), latestVersionArn: \(String(describing: latestVersionArn)), name: \(String(describing: name)))"}
}

extension CreateSubscriptionDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSubscriptionDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateSubscriptionDefinitionOutputResponse: Equatable {
    /// The ARN of the definition.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public let creationTimestamp: String?
    /// The ID of the definition.
    public let id: String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public let lastUpdatedTimestamp: String?
    /// The ID of the latest version associated with the definition.
    public let latestVersion: String?
    /// The ARN of the latest version associated with the definition.
    public let latestVersionArn: String?
    /// The name of the definition.
    public let name: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        lastUpdatedTimestamp: String? = nil,
        latestVersion: String? = nil,
        latestVersionArn: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateSubscriptionDefinitionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let lastUpdatedTimestamp: String?
    public let latestVersion: String?
    public let latestVersionArn: String?
    public let name: String?
}

extension CreateSubscriptionDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct CreateSubscriptionDefinitionVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateSubscriptionDefinitionVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSubscriptionDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSubscriptionDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSubscriptionDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateSubscriptionDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSubscriptionDefinitionVersionOutputError>
}

extension CreateSubscriptionDefinitionVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSubscriptionDefinitionVersionInput(amznClientToken: \(String(describing: amznClientToken)), subscriptionDefinitionId: \(String(describing: subscriptionDefinitionId)), subscriptions: \(String(describing: subscriptions)))"}
}

extension CreateSubscriptionDefinitionVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case subscriptions = "Subscriptions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subscriptions = subscriptions {
            var subscriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscriptions)
            for __listofsubscription0 in subscriptions {
                try subscriptionsContainer.encode(__listofsubscription0)
            }
        }
    }
}

public struct CreateSubscriptionDefinitionVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSubscriptionDefinitionVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSubscriptionDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSubscriptionDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSubscriptionDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateSubscriptionDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSubscriptionDefinitionVersionOutputError>
}

public struct CreateSubscriptionDefinitionVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSubscriptionDefinitionVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSubscriptionDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSubscriptionDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSubscriptionDefinitionVersionInput>
    public typealias MOutput = OperationOutput<CreateSubscriptionDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSubscriptionDefinitionVersionOutputError>
}

public struct CreateSubscriptionDefinitionVersionInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// The ID of the subscription definition.
    public let subscriptionDefinitionId: String?
    /// A list of subscriptions.
    public let subscriptions: [Subscription]?

    public init (
        amznClientToken: String? = nil,
        subscriptionDefinitionId: String? = nil,
        subscriptions: [Subscription]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.subscriptionDefinitionId = subscriptionDefinitionId
        self.subscriptions = subscriptions
    }
}

struct CreateSubscriptionDefinitionVersionInputBody: Equatable {
    public let subscriptions: [Subscription]?
}

extension CreateSubscriptionDefinitionVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case subscriptions = "Subscriptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionsContainer = try containerValues.decodeIfPresent([Subscription?].self, forKey: .subscriptions)
        var subscriptionsDecoded0:[Subscription]? = nil
        if let subscriptionsContainer = subscriptionsContainer {
            subscriptionsDecoded0 = [Subscription]()
            for structure0 in subscriptionsContainer {
                if let structure0 = structure0 {
                    subscriptionsDecoded0?.append(structure0)
                }
            }
        }
        subscriptions = subscriptionsDecoded0
    }
}

extension CreateSubscriptionDefinitionVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSubscriptionDefinitionVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSubscriptionDefinitionVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSubscriptionDefinitionVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSubscriptionDefinitionVersionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), version: \(String(describing: version)))"}
}

extension CreateSubscriptionDefinitionVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSubscriptionDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateSubscriptionDefinitionVersionOutputResponse: Equatable {
    /// The ARN of the version.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public let creationTimestamp: String?
    /// The ID of the parent definition that the version is associated with.
    public let id: String?
    /// The ID of the version.
    public let version: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateSubscriptionDefinitionVersionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let version: String?
}

extension CreateSubscriptionDefinitionVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension DefinitionInformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp, forKey: .creationTimestamp)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp, forKey: .lastUpdatedTimestamp)
        }
        if let latestVersion = latestVersion {
            try encodeContainer.encode(latestVersion, forKey: .latestVersion)
        }
        if let latestVersionArn = latestVersionArn {
            try encodeContainer.encode(latestVersionArn, forKey: .latestVersionArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DefinitionInformation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefinitionInformation(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), latestVersion: \(String(describing: latestVersion)), latestVersionArn: \(String(describing: latestVersionArn)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

/// Information about a definition.
public struct DefinitionInformation: Equatable {
    /// The ARN of the definition.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public let creationTimestamp: String?
    /// The ID of the definition.
    public let id: String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public let lastUpdatedTimestamp: String?
    /// The ID of the latest version associated with the definition.
    public let latestVersion: String?
    /// The ARN of the latest version associated with the definition.
    public let latestVersionArn: String?
    /// The name of the definition.
    public let name: String?
    /// Tag(s) attached to the resource arn.
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        lastUpdatedTimestamp: String? = nil,
        latestVersion: String? = nil,
        latestVersionArn: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

extension DeleteConnectorDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConnectorDefinitionInput(connectorDefinitionId: \(String(describing: connectorDefinitionId)))"}
}

extension DeleteConnectorDefinitionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteConnectorDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConnectorDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectorDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectorDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectorDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteConnectorDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectorDefinitionOutputError>
}

public struct DeleteConnectorDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConnectorDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectorDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectorDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectorDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteConnectorDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectorDefinitionOutputError>
}

public struct DeleteConnectorDefinitionInput: Equatable {
    /// The ID of the connector definition.
    public let connectorDefinitionId: String?

    public init (
        connectorDefinitionId: String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
    }
}

struct DeleteConnectorDefinitionInputBody: Equatable {
}

extension DeleteConnectorDefinitionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteConnectorDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectorDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectorDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectorDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConnectorDefinitionOutputResponse()"}
}

extension DeleteConnectorDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConnectorDefinitionOutputResponse: Equatable {

    public init() {}
}

struct DeleteConnectorDefinitionOutputResponseBody: Equatable {
}

extension DeleteConnectorDefinitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCoreDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCoreDefinitionInput(coreDefinitionId: \(String(describing: coreDefinitionId)))"}
}

extension DeleteCoreDefinitionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteCoreDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCoreDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCoreDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCoreDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCoreDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteCoreDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCoreDefinitionOutputError>
}

public struct DeleteCoreDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCoreDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCoreDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCoreDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCoreDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteCoreDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCoreDefinitionOutputError>
}

public struct DeleteCoreDefinitionInput: Equatable {
    /// The ID of the core definition.
    public let coreDefinitionId: String?

    public init (
        coreDefinitionId: String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
    }
}

struct DeleteCoreDefinitionInputBody: Equatable {
}

extension DeleteCoreDefinitionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCoreDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCoreDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCoreDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCoreDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCoreDefinitionOutputResponse()"}
}

extension DeleteCoreDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCoreDefinitionOutputResponse: Equatable {

    public init() {}
}

struct DeleteCoreDefinitionOutputResponseBody: Equatable {
}

extension DeleteCoreDefinitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDeviceDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDeviceDefinitionInput(deviceDefinitionId: \(String(describing: deviceDefinitionId)))"}
}

extension DeleteDeviceDefinitionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDeviceDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDeviceDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeviceDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeviceDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeviceDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteDeviceDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeviceDefinitionOutputError>
}

public struct DeleteDeviceDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDeviceDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeviceDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeviceDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeviceDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteDeviceDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeviceDefinitionOutputError>
}

public struct DeleteDeviceDefinitionInput: Equatable {
    /// The ID of the device definition.
    public let deviceDefinitionId: String?

    public init (
        deviceDefinitionId: String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
    }
}

struct DeleteDeviceDefinitionInputBody: Equatable {
}

extension DeleteDeviceDefinitionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDeviceDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeviceDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDeviceDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeviceDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDeviceDefinitionOutputResponse()"}
}

extension DeleteDeviceDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDeviceDefinitionOutputResponse: Equatable {

    public init() {}
}

struct DeleteDeviceDefinitionOutputResponseBody: Equatable {
}

extension DeleteDeviceDefinitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFunctionDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFunctionDefinitionInput(functionDefinitionId: \(String(describing: functionDefinitionId)))"}
}

extension DeleteFunctionDefinitionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteFunctionDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFunctionDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFunctionDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFunctionDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFunctionDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteFunctionDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFunctionDefinitionOutputError>
}

public struct DeleteFunctionDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFunctionDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFunctionDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFunctionDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFunctionDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteFunctionDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFunctionDefinitionOutputError>
}

public struct DeleteFunctionDefinitionInput: Equatable {
    /// The ID of the Lambda function definition.
    public let functionDefinitionId: String?

    public init (
        functionDefinitionId: String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
    }
}

struct DeleteFunctionDefinitionInputBody: Equatable {
}

extension DeleteFunctionDefinitionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFunctionDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFunctionDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFunctionDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFunctionDefinitionOutputResponse()"}
}

extension DeleteFunctionDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionDefinitionOutputResponse: Equatable {

    public init() {}
}

struct DeleteFunctionDefinitionOutputResponseBody: Equatable {
}

extension DeleteFunctionDefinitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGroupInput(groupId: \(String(describing: groupId)))"}
}

extension DeleteGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupOutputError>
}

public struct DeleteGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupOutputError>
}

public struct DeleteGroupInput: Equatable {
    /// The ID of the Greengrass group.
    public let groupId: String?

    public init (
        groupId: String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct DeleteGroupInputBody: Equatable {
}

extension DeleteGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGroupOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGroupOutputResponse()"}
}

extension DeleteGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteGroupOutputResponseBody: Equatable {
}

extension DeleteGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteLoggerDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLoggerDefinitionInput(loggerDefinitionId: \(String(describing: loggerDefinitionId)))"}
}

extension DeleteLoggerDefinitionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteLoggerDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLoggerDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoggerDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoggerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoggerDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteLoggerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoggerDefinitionOutputError>
}

public struct DeleteLoggerDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLoggerDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoggerDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoggerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoggerDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteLoggerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoggerDefinitionOutputError>
}

public struct DeleteLoggerDefinitionInput: Equatable {
    /// The ID of the logger definition.
    public let loggerDefinitionId: String?

    public init (
        loggerDefinitionId: String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
    }
}

struct DeleteLoggerDefinitionInputBody: Equatable {
}

extension DeleteLoggerDefinitionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteLoggerDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLoggerDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLoggerDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLoggerDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLoggerDefinitionOutputResponse()"}
}

extension DeleteLoggerDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLoggerDefinitionOutputResponse: Equatable {

    public init() {}
}

struct DeleteLoggerDefinitionOutputResponseBody: Equatable {
}

extension DeleteLoggerDefinitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteResourceDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourceDefinitionInput(resourceDefinitionId: \(String(describing: resourceDefinitionId)))"}
}

extension DeleteResourceDefinitionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteResourceDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResourceDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteResourceDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceDefinitionOutputError>
}

public struct DeleteResourceDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResourceDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteResourceDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceDefinitionOutputError>
}

public struct DeleteResourceDefinitionInput: Equatable {
    /// The ID of the resource definition.
    public let resourceDefinitionId: String?

    public init (
        resourceDefinitionId: String? = nil
    )
    {
        self.resourceDefinitionId = resourceDefinitionId
    }
}

struct DeleteResourceDefinitionInputBody: Equatable {
}

extension DeleteResourceDefinitionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteResourceDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourceDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourceDefinitionOutputResponse()"}
}

extension DeleteResourceDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourceDefinitionOutputResponse: Equatable {

    public init() {}
}

struct DeleteResourceDefinitionOutputResponseBody: Equatable {
}

extension DeleteResourceDefinitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSubscriptionDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSubscriptionDefinitionInput(subscriptionDefinitionId: \(String(describing: subscriptionDefinitionId)))"}
}

extension DeleteSubscriptionDefinitionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteSubscriptionDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSubscriptionDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSubscriptionDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSubscriptionDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSubscriptionDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteSubscriptionDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSubscriptionDefinitionOutputError>
}

public struct DeleteSubscriptionDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSubscriptionDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSubscriptionDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSubscriptionDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSubscriptionDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteSubscriptionDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSubscriptionDefinitionOutputError>
}

public struct DeleteSubscriptionDefinitionInput: Equatable {
    /// The ID of the subscription definition.
    public let subscriptionDefinitionId: String?

    public init (
        subscriptionDefinitionId: String? = nil
    )
    {
        self.subscriptionDefinitionId = subscriptionDefinitionId
    }
}

struct DeleteSubscriptionDefinitionInputBody: Equatable {
}

extension DeleteSubscriptionDefinitionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSubscriptionDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSubscriptionDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSubscriptionDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSubscriptionDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSubscriptionDefinitionOutputResponse()"}
}

extension DeleteSubscriptionDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSubscriptionDefinitionOutputResponse: Equatable {

    public init() {}
}

struct DeleteSubscriptionDefinitionOutputResponseBody: Equatable {
}

extension DeleteSubscriptionDefinitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Deployment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case deploymentArn = "DeploymentArn"
        case deploymentId = "DeploymentId"
        case deploymentType = "DeploymentType"
        case groupArn = "GroupArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let deploymentArn = deploymentArn {
            try encodeContainer.encode(deploymentArn, forKey: .deploymentArn)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentType = deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let groupArn = groupArn {
            try encodeContainer.encode(groupArn, forKey: .groupArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deploymentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentArn)
        deploymentArn = deploymentArnDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(DeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let groupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupArn)
        groupArn = groupArnDecoded
    }
}

extension Deployment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Deployment(createdAt: \(String(describing: createdAt)), deploymentArn: \(String(describing: deploymentArn)), deploymentId: \(String(describing: deploymentId)), deploymentType: \(String(describing: deploymentType)), groupArn: \(String(describing: groupArn)))"}
}

/// Information about a deployment.
public struct Deployment: Equatable {
    /// The time, in milliseconds since the epoch, when the deployment was created.
    public let createdAt: String?
    /// The ARN of the deployment.
    public let deploymentArn: String?
    /// The ID of the deployment.
    public let deploymentId: String?
    /// The type of the deployment.
    public let deploymentType: DeploymentType?
    /// The ARN of the group for this deployment.
    public let groupArn: String?

    public init (
        createdAt: String? = nil,
        deploymentArn: String? = nil,
        deploymentId: String? = nil,
        deploymentType: DeploymentType? = nil,
        groupArn: String? = nil
    )
    {
        self.createdAt = createdAt
        self.deploymentArn = deploymentArn
        self.deploymentId = deploymentId
        self.deploymentType = deploymentType
        self.groupArn = groupArn
    }
}

/// The type of deployment. When used for ''CreateDeployment'', only ''NewDeployment'' and ''Redeployment'' are valid.
public enum DeploymentType {
    case forceresetdeployment
    case newdeployment
    case redeployment
    case resetdeployment
    case sdkUnknown(String)
}

extension DeploymentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeploymentType] {
        return [
            .forceresetdeployment,
            .newdeployment,
            .redeployment,
            .resetdeployment,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .forceresetdeployment: return "ForceResetDeployment"
        case .newdeployment: return "NewDeployment"
        case .redeployment: return "Redeployment"
        case .resetdeployment: return "ResetDeployment"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeploymentType(rawValue: rawValue) ?? DeploymentType.sdkUnknown(rawValue)
    }
}

extension Device: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case id = "Id"
        case syncShadow = "SyncShadow"
        case thingArn = "ThingArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if syncShadow != false {
            try encodeContainer.encode(syncShadow, forKey: .syncShadow)
        }
        if let thingArn = thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let syncShadowDecoded = try containerValues.decode(Bool.self, forKey: .syncShadow)
        syncShadow = syncShadowDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension Device: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Device(certificateArn: \(String(describing: certificateArn)), id: \(String(describing: id)), syncShadow: \(String(describing: syncShadow)), thingArn: \(String(describing: thingArn)))"}
}

/// Information about a device.
public struct Device: Equatable {
    /// The ARN of the certificate associated with the device.
    public let certificateArn: String?
    /// A descriptive or arbitrary ID for the device. This value must be unique within the device definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
    public let id: String?
    /// If true, the device's local shadow will be automatically synced with the cloud.
    public let syncShadow: Bool
    /// The thing ARN of the device.
    public let thingArn: String?

    public init (
        certificateArn: String? = nil,
        id: String? = nil,
        syncShadow: Bool = false,
        thingArn: String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.id = id
        self.syncShadow = syncShadow
        self.thingArn = thingArn
    }
}

extension DeviceDefinitionVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case devices = "Devices"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devices = devices {
            var devicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .devices)
            for __listofdevice0 in devices {
                try devicesContainer.encode(__listofdevice0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([Device?].self, forKey: .devices)
        var devicesDecoded0:[Device]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [Device]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
    }
}

extension DeviceDefinitionVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceDefinitionVersion(devices: \(String(describing: devices)))"}
}

/// Information about a device definition version.
public struct DeviceDefinitionVersion: Equatable {
    /// A list of devices in the definition version.
    public let devices: [Device]?

    public init (
        devices: [Device]? = nil
    )
    {
        self.devices = devices
    }
}

extension DisassociateRoleFromGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateRoleFromGroupInput(groupId: \(String(describing: groupId)))"}
}

extension DisassociateRoleFromGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateRoleFromGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateRoleFromGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateRoleFromGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateRoleFromGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateRoleFromGroupInput>
    public typealias MOutput = OperationOutput<DisassociateRoleFromGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateRoleFromGroupOutputError>
}

public struct DisassociateRoleFromGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateRoleFromGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateRoleFromGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateRoleFromGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateRoleFromGroupInput>
    public typealias MOutput = OperationOutput<DisassociateRoleFromGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateRoleFromGroupOutputError>
}

public struct DisassociateRoleFromGroupInput: Equatable {
    /// The ID of the Greengrass group.
    public let groupId: String?

    public init (
        groupId: String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct DisassociateRoleFromGroupInputBody: Equatable {
}

extension DisassociateRoleFromGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateRoleFromGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateRoleFromGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateRoleFromGroupOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateRoleFromGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateRoleFromGroupOutputResponse(disassociatedAt: \(String(describing: disassociatedAt)))"}
}

extension DisassociateRoleFromGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisassociateRoleFromGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.disassociatedAt = output.disassociatedAt
        } else {
            self.disassociatedAt = nil
        }
    }
}

public struct DisassociateRoleFromGroupOutputResponse: Equatable {
    /// The time, in milliseconds since the epoch, when the role was disassociated from the group.
    public let disassociatedAt: String?

    public init (
        disassociatedAt: String? = nil
    )
    {
        self.disassociatedAt = disassociatedAt
    }
}

struct DisassociateRoleFromGroupOutputResponseBody: Equatable {
    public let disassociatedAt: String?
}

extension DisassociateRoleFromGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case disassociatedAt = "DisassociatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disassociatedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .disassociatedAt)
        disassociatedAt = disassociatedAtDecoded
    }
}

extension DisassociateServiceRoleFromAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateServiceRoleFromAccountInput()"}
}

extension DisassociateServiceRoleFromAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateServiceRoleFromAccountInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateServiceRoleFromAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateServiceRoleFromAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateServiceRoleFromAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateServiceRoleFromAccountInput>
    public typealias MOutput = OperationOutput<DisassociateServiceRoleFromAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateServiceRoleFromAccountOutputError>
}

public struct DisassociateServiceRoleFromAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateServiceRoleFromAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateServiceRoleFromAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateServiceRoleFromAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateServiceRoleFromAccountInput>
    public typealias MOutput = OperationOutput<DisassociateServiceRoleFromAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateServiceRoleFromAccountOutputError>
}

public struct DisassociateServiceRoleFromAccountInput: Equatable {

    public init() {}
}

struct DisassociateServiceRoleFromAccountInputBody: Equatable {
}

extension DisassociateServiceRoleFromAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateServiceRoleFromAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateServiceRoleFromAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateServiceRoleFromAccountOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateServiceRoleFromAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateServiceRoleFromAccountOutputResponse(disassociatedAt: \(String(describing: disassociatedAt)))"}
}

extension DisassociateServiceRoleFromAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisassociateServiceRoleFromAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.disassociatedAt = output.disassociatedAt
        } else {
            self.disassociatedAt = nil
        }
    }
}

public struct DisassociateServiceRoleFromAccountOutputResponse: Equatable {
    /// The time when the service role was disassociated from the account.
    public let disassociatedAt: String?

    public init (
        disassociatedAt: String? = nil
    )
    {
        self.disassociatedAt = disassociatedAt
    }
}

struct DisassociateServiceRoleFromAccountOutputResponseBody: Equatable {
    public let disassociatedAt: String?
}

extension DisassociateServiceRoleFromAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case disassociatedAt = "DisassociatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disassociatedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .disassociatedAt)
        disassociatedAt = disassociatedAtDecoded
    }
}

public enum EncodingType {
    case binary
    case json
    case sdkUnknown(String)
}

extension EncodingType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncodingType] {
        return [
            .binary,
            .json,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .binary: return "binary"
        case .json: return "json"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncodingType(rawValue: rawValue) ?? EncodingType.sdkUnknown(rawValue)
    }
}

extension ErrorDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detailedErrorCode = "DetailedErrorCode"
        case detailedErrorMessage = "DetailedErrorMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detailedErrorCode = detailedErrorCode {
            try encodeContainer.encode(detailedErrorCode, forKey: .detailedErrorCode)
        }
        if let detailedErrorMessage = detailedErrorMessage {
            try encodeContainer.encode(detailedErrorMessage, forKey: .detailedErrorMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedErrorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detailedErrorCode)
        detailedErrorCode = detailedErrorCodeDecoded
        let detailedErrorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detailedErrorMessage)
        detailedErrorMessage = detailedErrorMessageDecoded
    }
}

extension ErrorDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorDetail(detailedErrorCode: \(String(describing: detailedErrorCode)), detailedErrorMessage: \(String(describing: detailedErrorMessage)))"}
}

/// Details about the error.
public struct ErrorDetail: Equatable {
    /// A detailed error code.
    public let detailedErrorCode: String?
    /// A detailed error message.
    public let detailedErrorMessage: String?

    public init (
        detailedErrorCode: String? = nil,
        detailedErrorMessage: String? = nil
    )
    {
        self.detailedErrorCode = detailedErrorCode
        self.detailedErrorMessage = detailedErrorMessage
    }
}

extension Function: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case functionArn = "FunctionArn"
        case functionConfiguration = "FunctionConfiguration"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let functionConfiguration = functionConfiguration {
            try encodeContainer.encode(functionConfiguration, forKey: .functionConfiguration)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let functionConfigurationDecoded = try containerValues.decodeIfPresent(FunctionConfiguration.self, forKey: .functionConfiguration)
        functionConfiguration = functionConfigurationDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension Function: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Function(functionArn: \(String(describing: functionArn)), functionConfiguration: \(String(describing: functionConfiguration)), id: \(String(describing: id)))"}
}

/// Information about a Lambda function.
public struct Function: Equatable {
    /// The ARN of the Lambda function.
    public let functionArn: String?
    /// The configuration of the Lambda function.
    public let functionConfiguration: FunctionConfiguration?
    /// A descriptive or arbitrary ID for the function. This value must be unique within the function definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
    public let id: String?

    public init (
        functionArn: String? = nil,
        functionConfiguration: FunctionConfiguration? = nil,
        id: String? = nil
    )
    {
        self.functionArn = functionArn
        self.functionConfiguration = functionConfiguration
        self.id = id
    }
}

extension FunctionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encodingType = "EncodingType"
        case environment = "Environment"
        case execArgs = "ExecArgs"
        case executable = "Executable"
        case memorySize = "MemorySize"
        case pinned = "Pinned"
        case timeout = "Timeout"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encodingType = encodingType {
            try encodeContainer.encode(encodingType.rawValue, forKey: .encodingType)
        }
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let execArgs = execArgs {
            try encodeContainer.encode(execArgs, forKey: .execArgs)
        }
        if let executable = executable {
            try encodeContainer.encode(executable, forKey: .executable)
        }
        if memorySize != 0 {
            try encodeContainer.encode(memorySize, forKey: .memorySize)
        }
        if pinned != false {
            try encodeContainer.encode(pinned, forKey: .pinned)
        }
        if timeout != 0 {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encodingTypeDecoded = try containerValues.decodeIfPresent(EncodingType.self, forKey: .encodingType)
        encodingType = encodingTypeDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(FunctionConfigurationEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let execArgsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .execArgs)
        execArgs = execArgsDecoded
        let executableDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executable)
        executable = executableDecoded
        let memorySizeDecoded = try containerValues.decode(Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let pinnedDecoded = try containerValues.decode(Bool.self, forKey: .pinned)
        pinned = pinnedDecoded
        let timeoutDecoded = try containerValues.decode(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
    }
}

extension FunctionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionConfiguration(encodingType: \(String(describing: encodingType)), environment: \(String(describing: environment)), execArgs: \(String(describing: execArgs)), executable: \(String(describing: executable)), memorySize: \(String(describing: memorySize)), pinned: \(String(describing: pinned)), timeout: \(String(describing: timeout)))"}
}

/// The configuration of the Lambda function.
public struct FunctionConfiguration: Equatable {
    /// The expected encoding type of the input payload for the function. The default is ''json''.
    public let encodingType: EncodingType?
    /// The environment configuration of the function.
    public let environment: FunctionConfigurationEnvironment?
    /// The execution arguments.
    public let execArgs: String?
    /// The name of the function executable.
    public let executable: String?
    /// The memory size, in KB, which the function requires. This setting is not applicable and should be cleared when you run the Lambda function without containerization.
    public let memorySize: Int
    /// True if the function is pinned. Pinned means the function is long-lived and starts when the core starts.
    public let pinned: Bool
    /// The allowed function execution time, after which Lambda should terminate the function. This timeout still applies to pinned Lambda functions for each request.
    public let timeout: Int

    public init (
        encodingType: EncodingType? = nil,
        environment: FunctionConfigurationEnvironment? = nil,
        execArgs: String? = nil,
        executable: String? = nil,
        memorySize: Int = 0,
        pinned: Bool = false,
        timeout: Int = 0
    )
    {
        self.encodingType = encodingType
        self.environment = environment
        self.execArgs = execArgs
        self.executable = executable
        self.memorySize = memorySize
        self.pinned = pinned
        self.timeout = timeout
    }
}

extension FunctionConfigurationEnvironment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessSysfs = "AccessSysfs"
        case execution = "Execution"
        case resourceAccessPolicies = "ResourceAccessPolicies"
        case variables = "Variables"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if accessSysfs != false {
            try encodeContainer.encode(accessSysfs, forKey: .accessSysfs)
        }
        if let execution = execution {
            try encodeContainer.encode(execution, forKey: .execution)
        }
        if let resourceAccessPolicies = resourceAccessPolicies {
            var resourceAccessPoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAccessPolicies)
            for __listofresourceaccesspolicy0 in resourceAccessPolicies {
                try resourceAccessPoliciesContainer.encode(__listofresourceaccesspolicy0)
            }
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .variables)
            for (dictKey0, __mapof__string0) in variables {
                try variablesContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessSysfsDecoded = try containerValues.decode(Bool.self, forKey: .accessSysfs)
        accessSysfs = accessSysfsDecoded
        let executionDecoded = try containerValues.decodeIfPresent(FunctionExecutionConfig.self, forKey: .execution)
        execution = executionDecoded
        let resourceAccessPoliciesContainer = try containerValues.decodeIfPresent([ResourceAccessPolicy?].self, forKey: .resourceAccessPolicies)
        var resourceAccessPoliciesDecoded0:[ResourceAccessPolicy]? = nil
        if let resourceAccessPoliciesContainer = resourceAccessPoliciesContainer {
            resourceAccessPoliciesDecoded0 = [ResourceAccessPolicy]()
            for structure0 in resourceAccessPoliciesContainer {
                if let structure0 = structure0 {
                    resourceAccessPoliciesDecoded0?.append(structure0)
                }
            }
        }
        resourceAccessPolicies = resourceAccessPoliciesDecoded0
        let variablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .variables)
        var variablesDecoded0: [String:String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [String:String]()
            for (key0, __string0) in variablesContainer {
                if let __string0 = __string0 {
                    variablesDecoded0?[key0] = __string0
                }
            }
        }
        variables = variablesDecoded0
    }
}

extension FunctionConfigurationEnvironment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionConfigurationEnvironment(accessSysfs: \(String(describing: accessSysfs)), execution: \(String(describing: execution)), resourceAccessPolicies: \(String(describing: resourceAccessPolicies)), variables: \(String(describing: variables)))"}
}

/// The environment configuration of the function.
public struct FunctionConfigurationEnvironment: Equatable {
    /// If true, the Lambda function is allowed to access the host's /sys folder. Use this when the Lambda function needs to read device information from /sys. This setting applies only when you run the Lambda function in a Greengrass container.
    public let accessSysfs: Bool
    /// Configuration related to executing the Lambda function
    public let execution: FunctionExecutionConfig?
    /// A list of the resources, with their permissions, to which the Lambda function will be granted access. A Lambda function can have at most 10 resources. ResourceAccessPolicies apply only when you run the Lambda function in a Greengrass container.
    public let resourceAccessPolicies: [ResourceAccessPolicy]?
    /// Environment variables for the Lambda function's configuration.
    public let variables: [String:String]?

    public init (
        accessSysfs: Bool = false,
        execution: FunctionExecutionConfig? = nil,
        resourceAccessPolicies: [ResourceAccessPolicy]? = nil,
        variables: [String:String]? = nil
    )
    {
        self.accessSysfs = accessSysfs
        self.execution = execution
        self.resourceAccessPolicies = resourceAccessPolicies
        self.variables = variables
    }
}

extension FunctionDefaultConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case execution = "Execution"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let execution = execution {
            try encodeContainer.encode(execution, forKey: .execution)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionDecoded = try containerValues.decodeIfPresent(FunctionDefaultExecutionConfig.self, forKey: .execution)
        execution = executionDecoded
    }
}

extension FunctionDefaultConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionDefaultConfig(execution: \(String(describing: execution)))"}
}

/// The default configuration that applies to all Lambda functions in the group. Individual Lambda functions can override these settings.
public struct FunctionDefaultConfig: Equatable {
    /// Configuration information that specifies how a Lambda function runs.
    public let execution: FunctionDefaultExecutionConfig?

    public init (
        execution: FunctionDefaultExecutionConfig? = nil
    )
    {
        self.execution = execution
    }
}

extension FunctionDefaultExecutionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isolationMode = "IsolationMode"
        case runAs = "RunAs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isolationMode = isolationMode {
            try encodeContainer.encode(isolationMode.rawValue, forKey: .isolationMode)
        }
        if let runAs = runAs {
            try encodeContainer.encode(runAs, forKey: .runAs)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isolationModeDecoded = try containerValues.decodeIfPresent(FunctionIsolationMode.self, forKey: .isolationMode)
        isolationMode = isolationModeDecoded
        let runAsDecoded = try containerValues.decodeIfPresent(FunctionRunAsConfig.self, forKey: .runAs)
        runAs = runAsDecoded
    }
}

extension FunctionDefaultExecutionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionDefaultExecutionConfig(isolationMode: \(String(describing: isolationMode)), runAs: \(String(describing: runAs)))"}
}

/// Configuration information that specifies how a Lambda function runs.
public struct FunctionDefaultExecutionConfig: Equatable {
    /// Specifies whether the Lambda function runs in a Greengrass container (default) or without containerization. Unless your scenario requires that you run without containerization, we recommend that you run in a Greengrass container. Omit this value to run the Lambda function with the default containerization for the group.
    public let isolationMode: FunctionIsolationMode?
    /// Specifies the user and group whose permissions are used when running the Lambda function. You can specify one or both values to override the default values. We recommend that you avoid running as root unless absolutely necessary to minimize the risk of unintended changes or malicious attacks. To run as root, you must set ''IsolationMode'' to ''NoContainer'' and update config.json in ''greengrass-root/config'' to set ''allowFunctionsToRunAsRoot'' to ''yes''.
    public let runAs: FunctionRunAsConfig?

    public init (
        isolationMode: FunctionIsolationMode? = nil,
        runAs: FunctionRunAsConfig? = nil
    )
    {
        self.isolationMode = isolationMode
        self.runAs = runAs
    }
}

extension FunctionDefinitionVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultConfig = "DefaultConfig"
        case functions = "Functions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultConfig = defaultConfig {
            try encodeContainer.encode(defaultConfig, forKey: .defaultConfig)
        }
        if let functions = functions {
            var functionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functions)
            for __listoffunction0 in functions {
                try functionsContainer.encode(__listoffunction0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultConfigDecoded = try containerValues.decodeIfPresent(FunctionDefaultConfig.self, forKey: .defaultConfig)
        defaultConfig = defaultConfigDecoded
        let functionsContainer = try containerValues.decodeIfPresent([Function?].self, forKey: .functions)
        var functionsDecoded0:[Function]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [Function]()
            for structure0 in functionsContainer {
                if let structure0 = structure0 {
                    functionsDecoded0?.append(structure0)
                }
            }
        }
        functions = functionsDecoded0
    }
}

extension FunctionDefinitionVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionDefinitionVersion(defaultConfig: \(String(describing: defaultConfig)), functions: \(String(describing: functions)))"}
}

/// Information about a function definition version.
public struct FunctionDefinitionVersion: Equatable {
    /// The default configuration that applies to all Lambda functions in this function definition version. Individual Lambda functions can override these settings.
    public let defaultConfig: FunctionDefaultConfig?
    /// A list of Lambda functions in this function definition version.
    public let functions: [Function]?

    public init (
        defaultConfig: FunctionDefaultConfig? = nil,
        functions: [Function]? = nil
    )
    {
        self.defaultConfig = defaultConfig
        self.functions = functions
    }
}

extension FunctionExecutionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isolationMode = "IsolationMode"
        case runAs = "RunAs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isolationMode = isolationMode {
            try encodeContainer.encode(isolationMode.rawValue, forKey: .isolationMode)
        }
        if let runAs = runAs {
            try encodeContainer.encode(runAs, forKey: .runAs)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isolationModeDecoded = try containerValues.decodeIfPresent(FunctionIsolationMode.self, forKey: .isolationMode)
        isolationMode = isolationModeDecoded
        let runAsDecoded = try containerValues.decodeIfPresent(FunctionRunAsConfig.self, forKey: .runAs)
        runAs = runAsDecoded
    }
}

extension FunctionExecutionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionExecutionConfig(isolationMode: \(String(describing: isolationMode)), runAs: \(String(describing: runAs)))"}
}

/// Configuration information that specifies how a Lambda function runs.
public struct FunctionExecutionConfig: Equatable {
    /// Specifies whether the Lambda function runs in a Greengrass container (default) or without containerization. Unless your scenario requires that you run without containerization, we recommend that you run in a Greengrass container. Omit this value to run the Lambda function with the default containerization for the group.
    public let isolationMode: FunctionIsolationMode?
    /// Specifies the user and group whose permissions are used when running the Lambda function. You can specify one or both values to override the default values. We recommend that you avoid running as root unless absolutely necessary to minimize the risk of unintended changes or malicious attacks. To run as root, you must set ''IsolationMode'' to ''NoContainer'' and update config.json in ''greengrass-root/config'' to set ''allowFunctionsToRunAsRoot'' to ''yes''.
    public let runAs: FunctionRunAsConfig?

    public init (
        isolationMode: FunctionIsolationMode? = nil,
        runAs: FunctionRunAsConfig? = nil
    )
    {
        self.isolationMode = isolationMode
        self.runAs = runAs
    }
}

/// Specifies whether the Lambda function runs in a Greengrass container (default) or without containerization. Unless your scenario requires that you run without containerization, we recommend that you run in a Greengrass container. Omit this value to run the Lambda function with the default containerization for the group.
public enum FunctionIsolationMode {
    case greengrasscontainer
    case nocontainer
    case sdkUnknown(String)
}

extension FunctionIsolationMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FunctionIsolationMode] {
        return [
            .greengrasscontainer,
            .nocontainer,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .greengrasscontainer: return "GreengrassContainer"
        case .nocontainer: return "NoContainer"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FunctionIsolationMode(rawValue: rawValue) ?? FunctionIsolationMode.sdkUnknown(rawValue)
    }
}

extension FunctionRunAsConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gid = "Gid"
        case uid = "Uid"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if gid != 0 {
            try encodeContainer.encode(gid, forKey: .gid)
        }
        if uid != 0 {
            try encodeContainer.encode(uid, forKey: .uid)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gidDecoded = try containerValues.decode(Int.self, forKey: .gid)
        gid = gidDecoded
        let uidDecoded = try containerValues.decode(Int.self, forKey: .uid)
        uid = uidDecoded
    }
}

extension FunctionRunAsConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionRunAsConfig(gid: \(String(describing: gid)), uid: \(String(describing: uid)))"}
}

/// Specifies the user and group whose permissions are used when running the Lambda function. You can specify one or both values to override the default values. We recommend that you avoid running as root unless absolutely necessary to minimize the risk of unintended changes or malicious attacks. To run as root, you must set ''IsolationMode'' to ''NoContainer'' and update config.json in ''greengrass-root/config'' to set ''allowFunctionsToRunAsRoot'' to ''yes''.
public struct FunctionRunAsConfig: Equatable {
    /// The group ID whose permissions are used to run a Lambda function.
    public let gid: Int
    /// The user ID whose permissions are used to run a Lambda function.
    public let uid: Int

    public init (
        gid: Int = 0,
        uid: Int = 0
    )
    {
        self.gid = gid
        self.uid = uid
    }
}

extension GetAssociatedRoleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssociatedRoleInput(groupId: \(String(describing: groupId)))"}
}

extension GetAssociatedRoleInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAssociatedRoleInputHeadersMiddleware: Middleware {
    public let id: String = "GetAssociatedRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssociatedRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssociatedRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssociatedRoleInput>
    public typealias MOutput = OperationOutput<GetAssociatedRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssociatedRoleOutputError>
}

public struct GetAssociatedRoleInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAssociatedRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssociatedRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssociatedRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssociatedRoleInput>
    public typealias MOutput = OperationOutput<GetAssociatedRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssociatedRoleOutputError>
}

public struct GetAssociatedRoleInput: Equatable {
    /// The ID of the Greengrass group.
    public let groupId: String?

    public init (
        groupId: String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct GetAssociatedRoleInputBody: Equatable {
}

extension GetAssociatedRoleInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAssociatedRoleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssociatedRoleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssociatedRoleOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssociatedRoleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssociatedRoleOutputResponse(associatedAt: \(String(describing: associatedAt)), roleArn: \(String(describing: roleArn)))"}
}

extension GetAssociatedRoleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAssociatedRoleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associatedAt = output.associatedAt
            self.roleArn = output.roleArn
        } else {
            self.associatedAt = nil
            self.roleArn = nil
        }
    }
}

public struct GetAssociatedRoleOutputResponse: Equatable {
    /// The time when the role was associated with the group.
    public let associatedAt: String?
    /// The ARN of the role that is associated with the group.
    public let roleArn: String?

    public init (
        associatedAt: String? = nil,
        roleArn: String? = nil
    )
    {
        self.associatedAt = associatedAt
        self.roleArn = roleArn
    }
}

struct GetAssociatedRoleOutputResponseBody: Equatable {
    public let associatedAt: String?
    public let roleArn: String?
}

extension GetAssociatedRoleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associatedAt = "AssociatedAt"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associatedAt)
        associatedAt = associatedAtDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension GetBulkDeploymentStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBulkDeploymentStatusInput(bulkDeploymentId: \(String(describing: bulkDeploymentId)))"}
}

extension GetBulkDeploymentStatusInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBulkDeploymentStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetBulkDeploymentStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBulkDeploymentStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBulkDeploymentStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBulkDeploymentStatusInput>
    public typealias MOutput = OperationOutput<GetBulkDeploymentStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBulkDeploymentStatusOutputError>
}

public struct GetBulkDeploymentStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBulkDeploymentStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBulkDeploymentStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBulkDeploymentStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBulkDeploymentStatusInput>
    public typealias MOutput = OperationOutput<GetBulkDeploymentStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBulkDeploymentStatusOutputError>
}

public struct GetBulkDeploymentStatusInput: Equatable {
    /// The ID of the bulk deployment.
    public let bulkDeploymentId: String?

    public init (
        bulkDeploymentId: String? = nil
    )
    {
        self.bulkDeploymentId = bulkDeploymentId
    }
}

struct GetBulkDeploymentStatusInputBody: Equatable {
}

extension GetBulkDeploymentStatusInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBulkDeploymentStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBulkDeploymentStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBulkDeploymentStatusOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBulkDeploymentStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBulkDeploymentStatusOutputResponse(bulkDeploymentMetrics: \(String(describing: bulkDeploymentMetrics)), bulkDeploymentStatus: \(String(describing: bulkDeploymentStatus)), createdAt: \(String(describing: createdAt)), errorDetails: \(String(describing: errorDetails)), errorMessage: \(String(describing: errorMessage)), tags: \(String(describing: tags)))"}
}

extension GetBulkDeploymentStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBulkDeploymentStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bulkDeploymentMetrics = output.bulkDeploymentMetrics
            self.bulkDeploymentStatus = output.bulkDeploymentStatus
            self.createdAt = output.createdAt
            self.errorDetails = output.errorDetails
            self.errorMessage = output.errorMessage
            self.tags = output.tags
        } else {
            self.bulkDeploymentMetrics = nil
            self.bulkDeploymentStatus = nil
            self.createdAt = nil
            self.errorDetails = nil
            self.errorMessage = nil
            self.tags = nil
        }
    }
}

public struct GetBulkDeploymentStatusOutputResponse: Equatable {
    /// Relevant metrics on input records processed during bulk deployment.
    public let bulkDeploymentMetrics: BulkDeploymentMetrics?
    /// The status of the bulk deployment.
    public let bulkDeploymentStatus: BulkDeploymentStatus?
    /// The time, in ISO format, when the deployment was created.
    public let createdAt: String?
    /// Error details
    public let errorDetails: [ErrorDetail]?
    /// Error message
    public let errorMessage: String?
    /// Tag(s) attached to the resource arn.
    public let tags: [String:String]?

    public init (
        bulkDeploymentMetrics: BulkDeploymentMetrics? = nil,
        bulkDeploymentStatus: BulkDeploymentStatus? = nil,
        createdAt: String? = nil,
        errorDetails: [ErrorDetail]? = nil,
        errorMessage: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.bulkDeploymentMetrics = bulkDeploymentMetrics
        self.bulkDeploymentStatus = bulkDeploymentStatus
        self.createdAt = createdAt
        self.errorDetails = errorDetails
        self.errorMessage = errorMessage
        self.tags = tags
    }
}

struct GetBulkDeploymentStatusOutputResponseBody: Equatable {
    public let bulkDeploymentMetrics: BulkDeploymentMetrics?
    public let bulkDeploymentStatus: BulkDeploymentStatus?
    public let createdAt: String?
    public let errorDetails: [ErrorDetail]?
    public let errorMessage: String?
    public let tags: [String:String]?
}

extension GetBulkDeploymentStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bulkDeploymentMetrics = "BulkDeploymentMetrics"
        case bulkDeploymentStatus = "BulkDeploymentStatus"
        case createdAt = "CreatedAt"
        case errorDetails = "ErrorDetails"
        case errorMessage = "ErrorMessage"
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bulkDeploymentMetricsDecoded = try containerValues.decodeIfPresent(BulkDeploymentMetrics.self, forKey: .bulkDeploymentMetrics)
        bulkDeploymentMetrics = bulkDeploymentMetricsDecoded
        let bulkDeploymentStatusDecoded = try containerValues.decodeIfPresent(BulkDeploymentStatus.self, forKey: .bulkDeploymentStatus)
        bulkDeploymentStatus = bulkDeploymentStatusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let errorDetailsContainer = try containerValues.decodeIfPresent([ErrorDetail?].self, forKey: .errorDetails)
        var errorDetailsDecoded0:[ErrorDetail]? = nil
        if let errorDetailsContainer = errorDetailsContainer {
            errorDetailsDecoded0 = [ErrorDetail]()
            for structure0 in errorDetailsContainer {
                if let structure0 = structure0 {
                    errorDetailsDecoded0?.append(structure0)
                }
            }
        }
        errorDetails = errorDetailsDecoded0
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetConnectivityInfoInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConnectivityInfoInput(thingName: \(String(describing: thingName)))"}
}

extension GetConnectivityInfoInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetConnectivityInfoInputHeadersMiddleware: Middleware {
    public let id: String = "GetConnectivityInfoInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectivityInfoInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectivityInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectivityInfoInput>
    public typealias MOutput = OperationOutput<GetConnectivityInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectivityInfoOutputError>
}

public struct GetConnectivityInfoInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConnectivityInfoInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectivityInfoInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectivityInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectivityInfoInput>
    public typealias MOutput = OperationOutput<GetConnectivityInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectivityInfoOutputError>
}

public struct GetConnectivityInfoInput: Equatable {
    /// The thing name.
    public let thingName: String?

    public init (
        thingName: String? = nil
    )
    {
        self.thingName = thingName
    }
}

struct GetConnectivityInfoInputBody: Equatable {
}

extension GetConnectivityInfoInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetConnectivityInfoOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectivityInfoOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConnectivityInfoOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectivityInfoOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConnectivityInfoOutputResponse(connectivityInfo: \(String(describing: connectivityInfo)), message: \(String(describing: message)))"}
}

extension GetConnectivityInfoOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetConnectivityInfoOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connectivityInfo = output.connectivityInfo
            self.message = output.message
        } else {
            self.connectivityInfo = nil
            self.message = nil
        }
    }
}

public struct GetConnectivityInfoOutputResponse: Equatable {
    /// Connectivity info list.
    public let connectivityInfo: [ConnectivityInfo]?
    /// A message about the connectivity info request.
    public let message: String?

    public init (
        connectivityInfo: [ConnectivityInfo]? = nil,
        message: String? = nil
    )
    {
        self.connectivityInfo = connectivityInfo
        self.message = message
    }
}

struct GetConnectivityInfoOutputResponseBody: Equatable {
    public let connectivityInfo: [ConnectivityInfo]?
    public let message: String?
}

extension GetConnectivityInfoOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectivityInfo = "ConnectivityInfo"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectivityInfoContainer = try containerValues.decodeIfPresent([ConnectivityInfo?].self, forKey: .connectivityInfo)
        var connectivityInfoDecoded0:[ConnectivityInfo]? = nil
        if let connectivityInfoContainer = connectivityInfoContainer {
            connectivityInfoDecoded0 = [ConnectivityInfo]()
            for structure0 in connectivityInfoContainer {
                if let structure0 = structure0 {
                    connectivityInfoDecoded0?.append(structure0)
                }
            }
        }
        connectivityInfo = connectivityInfoDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetConnectorDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConnectorDefinitionInput(connectorDefinitionId: \(String(describing: connectorDefinitionId)))"}
}

extension GetConnectorDefinitionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetConnectorDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "GetConnectorDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectorDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectorDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectorDefinitionInput>
    public typealias MOutput = OperationOutput<GetConnectorDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectorDefinitionOutputError>
}

public struct GetConnectorDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConnectorDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectorDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectorDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectorDefinitionInput>
    public typealias MOutput = OperationOutput<GetConnectorDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectorDefinitionOutputError>
}

public struct GetConnectorDefinitionInput: Equatable {
    /// The ID of the connector definition.
    public let connectorDefinitionId: String?

    public init (
        connectorDefinitionId: String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
    }
}

struct GetConnectorDefinitionInputBody: Equatable {
}

extension GetConnectorDefinitionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetConnectorDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectorDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConnectorDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectorDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConnectorDefinitionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), latestVersion: \(String(describing: latestVersion)), latestVersionArn: \(String(describing: latestVersionArn)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension GetConnectorDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetConnectorDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetConnectorDefinitionOutputResponse: Equatable {
    /// The ARN of the definition.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public let creationTimestamp: String?
    /// The ID of the definition.
    public let id: String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public let lastUpdatedTimestamp: String?
    /// The ID of the latest version associated with the definition.
    public let latestVersion: String?
    /// The ARN of the latest version associated with the definition.
    public let latestVersionArn: String?
    /// The name of the definition.
    public let name: String?
    /// Tag(s) attached to the resource arn.
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        lastUpdatedTimestamp: String? = nil,
        latestVersion: String? = nil,
        latestVersionArn: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetConnectorDefinitionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let lastUpdatedTimestamp: String?
    public let latestVersion: String?
    public let latestVersionArn: String?
    public let name: String?
    public let tags: [String:String]?
}

extension GetConnectorDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetConnectorDefinitionVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConnectorDefinitionVersionInput(connectorDefinitionId: \(String(describing: connectorDefinitionId)), connectorDefinitionVersionId: \(String(describing: connectorDefinitionVersionId)), nextToken: \(String(describing: nextToken)))"}
}

extension GetConnectorDefinitionVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetConnectorDefinitionVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetConnectorDefinitionVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectorDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectorDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectorDefinitionVersionInput>
    public typealias MOutput = OperationOutput<GetConnectorDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectorDefinitionVersionOutputError>
}

public struct GetConnectorDefinitionVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConnectorDefinitionVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectorDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectorDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectorDefinitionVersionInput>
    public typealias MOutput = OperationOutput<GetConnectorDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectorDefinitionVersionOutputError>
}

public struct GetConnectorDefinitionVersionInput: Equatable {
    /// The ID of the connector definition.
    public let connectorDefinitionId: String?
    /// The ID of the connector definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListConnectorDefinitionVersions'' requests. If the version is the last one that was associated with a connector definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    public let connectorDefinitionVersionId: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        connectorDefinitionId: String? = nil,
        connectorDefinitionVersionId: String? = nil,
        nextToken: String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
        self.connectorDefinitionVersionId = connectorDefinitionVersionId
        self.nextToken = nextToken
    }
}

struct GetConnectorDefinitionVersionInputBody: Equatable {
}

extension GetConnectorDefinitionVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetConnectorDefinitionVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectorDefinitionVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConnectorDefinitionVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectorDefinitionVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConnectorDefinitionVersionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), definition: \(String(describing: definition)), id: \(String(describing: id)), nextToken: \(String(describing: nextToken)), version: \(String(describing: version)))"}
}

extension GetConnectorDefinitionVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetConnectorDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.nextToken = output.nextToken
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.nextToken = nil
            self.version = nil
        }
    }
}

public struct GetConnectorDefinitionVersionOutputResponse: Equatable {
    /// The ARN of the connector definition version.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the connector definition version was created.
    public let creationTimestamp: String?
    /// Information about the connector definition version.
    public let definition: ConnectorDefinitionVersion?
    /// The ID of the connector definition version.
    public let id: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?
    /// The version of the connector definition version.
    public let version: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        definition: ConnectorDefinitionVersion? = nil,
        id: String? = nil,
        nextToken: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

struct GetConnectorDefinitionVersionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let definition: ConnectorDefinitionVersion?
    public let id: String?
    public let nextToken: String?
    public let version: String?
}

extension GetConnectorDefinitionVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case nextToken = "NextToken"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(ConnectorDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetCoreDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCoreDefinitionInput(coreDefinitionId: \(String(describing: coreDefinitionId)))"}
}

extension GetCoreDefinitionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCoreDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "GetCoreDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCoreDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCoreDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCoreDefinitionInput>
    public typealias MOutput = OperationOutput<GetCoreDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCoreDefinitionOutputError>
}

public struct GetCoreDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCoreDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCoreDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCoreDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCoreDefinitionInput>
    public typealias MOutput = OperationOutput<GetCoreDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCoreDefinitionOutputError>
}

public struct GetCoreDefinitionInput: Equatable {
    /// The ID of the core definition.
    public let coreDefinitionId: String?

    public init (
        coreDefinitionId: String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
    }
}

struct GetCoreDefinitionInputBody: Equatable {
}

extension GetCoreDefinitionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCoreDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCoreDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCoreDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCoreDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCoreDefinitionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), latestVersion: \(String(describing: latestVersion)), latestVersionArn: \(String(describing: latestVersionArn)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension GetCoreDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCoreDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetCoreDefinitionOutputResponse: Equatable {
    /// The ARN of the definition.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public let creationTimestamp: String?
    /// The ID of the definition.
    public let id: String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public let lastUpdatedTimestamp: String?
    /// The ID of the latest version associated with the definition.
    public let latestVersion: String?
    /// The ARN of the latest version associated with the definition.
    public let latestVersionArn: String?
    /// The name of the definition.
    public let name: String?
    /// Tag(s) attached to the resource arn.
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        lastUpdatedTimestamp: String? = nil,
        latestVersion: String? = nil,
        latestVersionArn: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetCoreDefinitionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let lastUpdatedTimestamp: String?
    public let latestVersion: String?
    public let latestVersionArn: String?
    public let name: String?
    public let tags: [String:String]?
}

extension GetCoreDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetCoreDefinitionVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCoreDefinitionVersionInput(coreDefinitionId: \(String(describing: coreDefinitionId)), coreDefinitionVersionId: \(String(describing: coreDefinitionVersionId)))"}
}

extension GetCoreDefinitionVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCoreDefinitionVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetCoreDefinitionVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCoreDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCoreDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCoreDefinitionVersionInput>
    public typealias MOutput = OperationOutput<GetCoreDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCoreDefinitionVersionOutputError>
}

public struct GetCoreDefinitionVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCoreDefinitionVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCoreDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCoreDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCoreDefinitionVersionInput>
    public typealias MOutput = OperationOutput<GetCoreDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCoreDefinitionVersionOutputError>
}

public struct GetCoreDefinitionVersionInput: Equatable {
    /// The ID of the core definition.
    public let coreDefinitionId: String?
    /// The ID of the core definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListCoreDefinitionVersions'' requests. If the version is the last one that was associated with a core definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    public let coreDefinitionVersionId: String?

    public init (
        coreDefinitionId: String? = nil,
        coreDefinitionVersionId: String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
        self.coreDefinitionVersionId = coreDefinitionVersionId
    }
}

struct GetCoreDefinitionVersionInputBody: Equatable {
}

extension GetCoreDefinitionVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCoreDefinitionVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCoreDefinitionVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCoreDefinitionVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCoreDefinitionVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCoreDefinitionVersionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), definition: \(String(describing: definition)), id: \(String(describing: id)), nextToken: \(String(describing: nextToken)), version: \(String(describing: version)))"}
}

extension GetCoreDefinitionVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCoreDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.nextToken = output.nextToken
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.nextToken = nil
            self.version = nil
        }
    }
}

public struct GetCoreDefinitionVersionOutputResponse: Equatable {
    /// The ARN of the core definition version.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the core definition version was created.
    public let creationTimestamp: String?
    /// Information about the core definition version.
    public let definition: CoreDefinitionVersion?
    /// The ID of the core definition version.
    public let id: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?
    /// The version of the core definition version.
    public let version: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        definition: CoreDefinitionVersion? = nil,
        id: String? = nil,
        nextToken: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

struct GetCoreDefinitionVersionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let definition: CoreDefinitionVersion?
    public let id: String?
    public let nextToken: String?
    public let version: String?
}

extension GetCoreDefinitionVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case nextToken = "NextToken"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(CoreDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetDeploymentStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeploymentStatusInput(deploymentId: \(String(describing: deploymentId)), groupId: \(String(describing: groupId)))"}
}

extension GetDeploymentStatusInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDeploymentStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeploymentStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeploymentStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeploymentStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeploymentStatusInput>
    public typealias MOutput = OperationOutput<GetDeploymentStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeploymentStatusOutputError>
}

public struct GetDeploymentStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeploymentStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeploymentStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeploymentStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeploymentStatusInput>
    public typealias MOutput = OperationOutput<GetDeploymentStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeploymentStatusOutputError>
}

public struct GetDeploymentStatusInput: Equatable {
    /// The ID of the deployment.
    public let deploymentId: String?
    /// The ID of the Greengrass group.
    public let groupId: String?

    public init (
        deploymentId: String? = nil,
        groupId: String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.groupId = groupId
    }
}

struct GetDeploymentStatusInputBody: Equatable {
}

extension GetDeploymentStatusInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDeploymentStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeploymentStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeploymentStatusOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeploymentStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeploymentStatusOutputResponse(deploymentStatus: \(String(describing: deploymentStatus)), deploymentType: \(String(describing: deploymentType)), errorDetails: \(String(describing: errorDetails)), errorMessage: \(String(describing: errorMessage)), updatedAt: \(String(describing: updatedAt)))"}
}

extension GetDeploymentStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDeploymentStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deploymentStatus = output.deploymentStatus
            self.deploymentType = output.deploymentType
            self.errorDetails = output.errorDetails
            self.errorMessage = output.errorMessage
            self.updatedAt = output.updatedAt
        } else {
            self.deploymentStatus = nil
            self.deploymentType = nil
            self.errorDetails = nil
            self.errorMessage = nil
            self.updatedAt = nil
        }
    }
}

public struct GetDeploymentStatusOutputResponse: Equatable {
    /// The status of the deployment: ''InProgress'', ''Building'', ''Success'', or ''Failure''.
    public let deploymentStatus: String?
    /// The type of the deployment.
    public let deploymentType: DeploymentType?
    /// Error details
    public let errorDetails: [ErrorDetail]?
    /// Error message
    public let errorMessage: String?
    /// The time, in milliseconds since the epoch, when the deployment status was updated.
    public let updatedAt: String?

    public init (
        deploymentStatus: String? = nil,
        deploymentType: DeploymentType? = nil,
        errorDetails: [ErrorDetail]? = nil,
        errorMessage: String? = nil,
        updatedAt: String? = nil
    )
    {
        self.deploymentStatus = deploymentStatus
        self.deploymentType = deploymentType
        self.errorDetails = errorDetails
        self.errorMessage = errorMessage
        self.updatedAt = updatedAt
    }
}

struct GetDeploymentStatusOutputResponseBody: Equatable {
    public let deploymentStatus: String?
    public let deploymentType: DeploymentType?
    public let errorDetails: [ErrorDetail]?
    public let errorMessage: String?
    public let updatedAt: String?
}

extension GetDeploymentStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deploymentStatus = "DeploymentStatus"
        case deploymentType = "DeploymentType"
        case errorDetails = "ErrorDetails"
        case errorMessage = "ErrorMessage"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(DeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let errorDetailsContainer = try containerValues.decodeIfPresent([ErrorDetail?].self, forKey: .errorDetails)
        var errorDetailsDecoded0:[ErrorDetail]? = nil
        if let errorDetailsContainer = errorDetailsContainer {
            errorDetailsDecoded0 = [ErrorDetail]()
            for structure0 in errorDetailsContainer {
                if let structure0 = structure0 {
                    errorDetailsDecoded0?.append(structure0)
                }
            }
        }
        errorDetails = errorDetailsDecoded0
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension GetDeviceDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeviceDefinitionInput(deviceDefinitionId: \(String(describing: deviceDefinitionId)))"}
}

extension GetDeviceDefinitionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDeviceDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeviceDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceDefinitionInput>
    public typealias MOutput = OperationOutput<GetDeviceDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceDefinitionOutputError>
}

public struct GetDeviceDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeviceDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceDefinitionInput>
    public typealias MOutput = OperationOutput<GetDeviceDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceDefinitionOutputError>
}

public struct GetDeviceDefinitionInput: Equatable {
    /// The ID of the device definition.
    public let deviceDefinitionId: String?

    public init (
        deviceDefinitionId: String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
    }
}

struct GetDeviceDefinitionInputBody: Equatable {
}

extension GetDeviceDefinitionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDeviceDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeviceDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeviceDefinitionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), latestVersion: \(String(describing: latestVersion)), latestVersionArn: \(String(describing: latestVersionArn)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension GetDeviceDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDeviceDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetDeviceDefinitionOutputResponse: Equatable {
    /// The ARN of the definition.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public let creationTimestamp: String?
    /// The ID of the definition.
    public let id: String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public let lastUpdatedTimestamp: String?
    /// The ID of the latest version associated with the definition.
    public let latestVersion: String?
    /// The ARN of the latest version associated with the definition.
    public let latestVersionArn: String?
    /// The name of the definition.
    public let name: String?
    /// Tag(s) attached to the resource arn.
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        lastUpdatedTimestamp: String? = nil,
        latestVersion: String? = nil,
        latestVersionArn: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetDeviceDefinitionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let lastUpdatedTimestamp: String?
    public let latestVersion: String?
    public let latestVersionArn: String?
    public let name: String?
    public let tags: [String:String]?
}

extension GetDeviceDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetDeviceDefinitionVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeviceDefinitionVersionInput(deviceDefinitionId: \(String(describing: deviceDefinitionId)), deviceDefinitionVersionId: \(String(describing: deviceDefinitionVersionId)), nextToken: \(String(describing: nextToken)))"}
}

extension GetDeviceDefinitionVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDeviceDefinitionVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeviceDefinitionVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceDefinitionVersionInput>
    public typealias MOutput = OperationOutput<GetDeviceDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceDefinitionVersionOutputError>
}

public struct GetDeviceDefinitionVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeviceDefinitionVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceDefinitionVersionInput>
    public typealias MOutput = OperationOutput<GetDeviceDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceDefinitionVersionOutputError>
}

public struct GetDeviceDefinitionVersionInput: Equatable {
    /// The ID of the device definition.
    public let deviceDefinitionId: String?
    /// The ID of the device definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListDeviceDefinitionVersions'' requests. If the version is the last one that was associated with a device definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    public let deviceDefinitionVersionId: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        deviceDefinitionId: String? = nil,
        deviceDefinitionVersionId: String? = nil,
        nextToken: String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
        self.deviceDefinitionVersionId = deviceDefinitionVersionId
        self.nextToken = nextToken
    }
}

struct GetDeviceDefinitionVersionInputBody: Equatable {
}

extension GetDeviceDefinitionVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDeviceDefinitionVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceDefinitionVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeviceDefinitionVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceDefinitionVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeviceDefinitionVersionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), definition: \(String(describing: definition)), id: \(String(describing: id)), nextToken: \(String(describing: nextToken)), version: \(String(describing: version)))"}
}

extension GetDeviceDefinitionVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDeviceDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.nextToken = output.nextToken
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.nextToken = nil
            self.version = nil
        }
    }
}

public struct GetDeviceDefinitionVersionOutputResponse: Equatable {
    /// The ARN of the device definition version.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the device definition version was created.
    public let creationTimestamp: String?
    /// Information about the device definition version.
    public let definition: DeviceDefinitionVersion?
    /// The ID of the device definition version.
    public let id: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?
    /// The version of the device definition version.
    public let version: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        definition: DeviceDefinitionVersion? = nil,
        id: String? = nil,
        nextToken: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

struct GetDeviceDefinitionVersionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let definition: DeviceDefinitionVersion?
    public let id: String?
    public let nextToken: String?
    public let version: String?
}

extension GetDeviceDefinitionVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case nextToken = "NextToken"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(DeviceDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetFunctionDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFunctionDefinitionInput(functionDefinitionId: \(String(describing: functionDefinitionId)))"}
}

extension GetFunctionDefinitionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFunctionDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "GetFunctionDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFunctionDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFunctionDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFunctionDefinitionInput>
    public typealias MOutput = OperationOutput<GetFunctionDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFunctionDefinitionOutputError>
}

public struct GetFunctionDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFunctionDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFunctionDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFunctionDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFunctionDefinitionInput>
    public typealias MOutput = OperationOutput<GetFunctionDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFunctionDefinitionOutputError>
}

public struct GetFunctionDefinitionInput: Equatable {
    /// The ID of the Lambda function definition.
    public let functionDefinitionId: String?

    public init (
        functionDefinitionId: String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
    }
}

struct GetFunctionDefinitionInputBody: Equatable {
}

extension GetFunctionDefinitionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFunctionDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFunctionDefinitionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), latestVersion: \(String(describing: latestVersion)), latestVersionArn: \(String(describing: latestVersionArn)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension GetFunctionDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFunctionDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetFunctionDefinitionOutputResponse: Equatable {
    /// The ARN of the definition.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public let creationTimestamp: String?
    /// The ID of the definition.
    public let id: String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public let lastUpdatedTimestamp: String?
    /// The ID of the latest version associated with the definition.
    public let latestVersion: String?
    /// The ARN of the latest version associated with the definition.
    public let latestVersionArn: String?
    /// The name of the definition.
    public let name: String?
    /// Tag(s) attached to the resource arn.
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        lastUpdatedTimestamp: String? = nil,
        latestVersion: String? = nil,
        latestVersionArn: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetFunctionDefinitionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let lastUpdatedTimestamp: String?
    public let latestVersion: String?
    public let latestVersionArn: String?
    public let name: String?
    public let tags: [String:String]?
}

extension GetFunctionDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetFunctionDefinitionVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFunctionDefinitionVersionInput(functionDefinitionId: \(String(describing: functionDefinitionId)), functionDefinitionVersionId: \(String(describing: functionDefinitionVersionId)), nextToken: \(String(describing: nextToken)))"}
}

extension GetFunctionDefinitionVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFunctionDefinitionVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetFunctionDefinitionVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFunctionDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFunctionDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFunctionDefinitionVersionInput>
    public typealias MOutput = OperationOutput<GetFunctionDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFunctionDefinitionVersionOutputError>
}

public struct GetFunctionDefinitionVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFunctionDefinitionVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFunctionDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFunctionDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFunctionDefinitionVersionInput>
    public typealias MOutput = OperationOutput<GetFunctionDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFunctionDefinitionVersionOutputError>
}

public struct GetFunctionDefinitionVersionInput: Equatable {
    /// The ID of the Lambda function definition.
    public let functionDefinitionId: String?
    /// The ID of the function definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListFunctionDefinitionVersions'' requests. If the version is the last one that was associated with a function definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    public let functionDefinitionVersionId: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        functionDefinitionId: String? = nil,
        functionDefinitionVersionId: String? = nil,
        nextToken: String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
        self.functionDefinitionVersionId = functionDefinitionVersionId
        self.nextToken = nextToken
    }
}

struct GetFunctionDefinitionVersionInputBody: Equatable {
}

extension GetFunctionDefinitionVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFunctionDefinitionVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionDefinitionVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionDefinitionVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionDefinitionVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFunctionDefinitionVersionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), definition: \(String(describing: definition)), id: \(String(describing: id)), nextToken: \(String(describing: nextToken)), version: \(String(describing: version)))"}
}

extension GetFunctionDefinitionVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFunctionDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.nextToken = output.nextToken
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.nextToken = nil
            self.version = nil
        }
    }
}

public struct GetFunctionDefinitionVersionOutputResponse: Equatable {
    /// The ARN of the function definition version.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the function definition version was created.
    public let creationTimestamp: String?
    /// Information on the definition.
    public let definition: FunctionDefinitionVersion?
    /// The ID of the function definition version.
    public let id: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?
    /// The version of the function definition version.
    public let version: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        definition: FunctionDefinitionVersion? = nil,
        id: String? = nil,
        nextToken: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

struct GetFunctionDefinitionVersionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let definition: FunctionDefinitionVersion?
    public let id: String?
    public let nextToken: String?
    public let version: String?
}

extension GetFunctionDefinitionVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case nextToken = "NextToken"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(FunctionDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetGroupCertificateAuthorityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupCertificateAuthorityInput(certificateAuthorityId: \(String(describing: certificateAuthorityId)), groupId: \(String(describing: groupId)))"}
}

extension GetGroupCertificateAuthorityInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetGroupCertificateAuthorityInputHeadersMiddleware: Middleware {
    public let id: String = "GetGroupCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<GetGroupCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupCertificateAuthorityOutputError>
}

public struct GetGroupCertificateAuthorityInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGroupCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<GetGroupCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupCertificateAuthorityOutputError>
}

public struct GetGroupCertificateAuthorityInput: Equatable {
    /// The ID of the certificate authority.
    public let certificateAuthorityId: String?
    /// The ID of the Greengrass group.
    public let groupId: String?

    public init (
        certificateAuthorityId: String? = nil,
        groupId: String? = nil
    )
    {
        self.certificateAuthorityId = certificateAuthorityId
        self.groupId = groupId
    }
}

struct GetGroupCertificateAuthorityInputBody: Equatable {
}

extension GetGroupCertificateAuthorityInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetGroupCertificateAuthorityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGroupCertificateAuthorityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGroupCertificateAuthorityOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGroupCertificateAuthorityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupCertificateAuthorityOutputResponse(groupCertificateAuthorityArn: \(String(describing: groupCertificateAuthorityArn)), groupCertificateAuthorityId: \(String(describing: groupCertificateAuthorityId)), pemEncodedCertificate: \(String(describing: pemEncodedCertificate)))"}
}

extension GetGroupCertificateAuthorityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetGroupCertificateAuthorityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groupCertificateAuthorityArn = output.groupCertificateAuthorityArn
            self.groupCertificateAuthorityId = output.groupCertificateAuthorityId
            self.pemEncodedCertificate = output.pemEncodedCertificate
        } else {
            self.groupCertificateAuthorityArn = nil
            self.groupCertificateAuthorityId = nil
            self.pemEncodedCertificate = nil
        }
    }
}

public struct GetGroupCertificateAuthorityOutputResponse: Equatable {
    /// The ARN of the certificate authority for the group.
    public let groupCertificateAuthorityArn: String?
    /// The ID of the certificate authority for the group.
    public let groupCertificateAuthorityId: String?
    /// The PEM encoded certificate for the group.
    public let pemEncodedCertificate: String?

    public init (
        groupCertificateAuthorityArn: String? = nil,
        groupCertificateAuthorityId: String? = nil,
        pemEncodedCertificate: String? = nil
    )
    {
        self.groupCertificateAuthorityArn = groupCertificateAuthorityArn
        self.groupCertificateAuthorityId = groupCertificateAuthorityId
        self.pemEncodedCertificate = pemEncodedCertificate
    }
}

struct GetGroupCertificateAuthorityOutputResponseBody: Equatable {
    public let groupCertificateAuthorityArn: String?
    public let groupCertificateAuthorityId: String?
    public let pemEncodedCertificate: String?
}

extension GetGroupCertificateAuthorityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupCertificateAuthorityArn = "GroupCertificateAuthorityArn"
        case groupCertificateAuthorityId = "GroupCertificateAuthorityId"
        case pemEncodedCertificate = "PemEncodedCertificate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupCertificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupCertificateAuthorityArn)
        groupCertificateAuthorityArn = groupCertificateAuthorityArnDecoded
        let groupCertificateAuthorityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupCertificateAuthorityId)
        groupCertificateAuthorityId = groupCertificateAuthorityIdDecoded
        let pemEncodedCertificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pemEncodedCertificate)
        pemEncodedCertificate = pemEncodedCertificateDecoded
    }
}

extension GetGroupCertificateConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupCertificateConfigurationInput(groupId: \(String(describing: groupId)))"}
}

extension GetGroupCertificateConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetGroupCertificateConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetGroupCertificateConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupCertificateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupCertificateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupCertificateConfigurationInput>
    public typealias MOutput = OperationOutput<GetGroupCertificateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupCertificateConfigurationOutputError>
}

public struct GetGroupCertificateConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGroupCertificateConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupCertificateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupCertificateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupCertificateConfigurationInput>
    public typealias MOutput = OperationOutput<GetGroupCertificateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupCertificateConfigurationOutputError>
}

public struct GetGroupCertificateConfigurationInput: Equatable {
    /// The ID of the Greengrass group.
    public let groupId: String?

    public init (
        groupId: String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct GetGroupCertificateConfigurationInputBody: Equatable {
}

extension GetGroupCertificateConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetGroupCertificateConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGroupCertificateConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGroupCertificateConfigurationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGroupCertificateConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupCertificateConfigurationOutputResponse(certificateAuthorityExpiryInMilliseconds: \(String(describing: certificateAuthorityExpiryInMilliseconds)), certificateExpiryInMilliseconds: \(String(describing: certificateExpiryInMilliseconds)), groupId: \(String(describing: groupId)))"}
}

extension GetGroupCertificateConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetGroupCertificateConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificateAuthorityExpiryInMilliseconds = output.certificateAuthorityExpiryInMilliseconds
            self.certificateExpiryInMilliseconds = output.certificateExpiryInMilliseconds
            self.groupId = output.groupId
        } else {
            self.certificateAuthorityExpiryInMilliseconds = nil
            self.certificateExpiryInMilliseconds = nil
            self.groupId = nil
        }
    }
}

public struct GetGroupCertificateConfigurationOutputResponse: Equatable {
    /// The amount of time remaining before the certificate authority expires, in milliseconds.
    public let certificateAuthorityExpiryInMilliseconds: String?
    /// The amount of time remaining before the certificate expires, in milliseconds.
    public let certificateExpiryInMilliseconds: String?
    /// The ID of the group certificate configuration.
    public let groupId: String?

    public init (
        certificateAuthorityExpiryInMilliseconds: String? = nil,
        certificateExpiryInMilliseconds: String? = nil,
        groupId: String? = nil
    )
    {
        self.certificateAuthorityExpiryInMilliseconds = certificateAuthorityExpiryInMilliseconds
        self.certificateExpiryInMilliseconds = certificateExpiryInMilliseconds
        self.groupId = groupId
    }
}

struct GetGroupCertificateConfigurationOutputResponseBody: Equatable {
    public let certificateAuthorityExpiryInMilliseconds: String?
    public let certificateExpiryInMilliseconds: String?
    public let groupId: String?
}

extension GetGroupCertificateConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityExpiryInMilliseconds = "CertificateAuthorityExpiryInMilliseconds"
        case certificateExpiryInMilliseconds = "CertificateExpiryInMilliseconds"
        case groupId = "GroupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityExpiryInMillisecondsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityExpiryInMilliseconds)
        certificateAuthorityExpiryInMilliseconds = certificateAuthorityExpiryInMillisecondsDecoded
        let certificateExpiryInMillisecondsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateExpiryInMilliseconds)
        certificateExpiryInMilliseconds = certificateExpiryInMillisecondsDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension GetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupInput(groupId: \(String(describing: groupId)))"}
}

extension GetGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "GetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupInput>
    public typealias MOutput = OperationOutput<GetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupOutputError>
}

public struct GetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupInput>
    public typealias MOutput = OperationOutput<GetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupOutputError>
}

public struct GetGroupInput: Equatable {
    /// The ID of the Greengrass group.
    public let groupId: String?

    public init (
        groupId: String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct GetGroupInputBody: Equatable {
}

extension GetGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGroupOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), latestVersion: \(String(describing: latestVersion)), latestVersionArn: \(String(describing: latestVersionArn)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension GetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetGroupOutputResponse: Equatable {
    /// The ARN of the definition.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public let creationTimestamp: String?
    /// The ID of the definition.
    public let id: String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public let lastUpdatedTimestamp: String?
    /// The ID of the latest version associated with the definition.
    public let latestVersion: String?
    /// The ARN of the latest version associated with the definition.
    public let latestVersionArn: String?
    /// The name of the definition.
    public let name: String?
    /// Tag(s) attached to the resource arn.
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        lastUpdatedTimestamp: String? = nil,
        latestVersion: String? = nil,
        latestVersionArn: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetGroupOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let lastUpdatedTimestamp: String?
    public let latestVersion: String?
    public let latestVersionArn: String?
    public let name: String?
    public let tags: [String:String]?
}

extension GetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetGroupVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupVersionInput(groupId: \(String(describing: groupId)), groupVersionId: \(String(describing: groupVersionId)))"}
}

extension GetGroupVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetGroupVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetGroupVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupVersionInput>
    public typealias MOutput = OperationOutput<GetGroupVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupVersionOutputError>
}

public struct GetGroupVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGroupVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupVersionInput>
    public typealias MOutput = OperationOutput<GetGroupVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupVersionOutputError>
}

public struct GetGroupVersionInput: Equatable {
    /// The ID of the Greengrass group.
    public let groupId: String?
    /// The ID of the group version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListGroupVersions'' requests. If the version is the last one that was associated with a group, the value also maps to the ''LatestVersion'' property of the corresponding ''GroupInformation'' object.
    public let groupVersionId: String?

    public init (
        groupId: String? = nil,
        groupVersionId: String? = nil
    )
    {
        self.groupId = groupId
        self.groupVersionId = groupVersionId
    }
}

struct GetGroupVersionInputBody: Equatable {
}

extension GetGroupVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetGroupVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGroupVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGroupVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGroupVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupVersionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), definition: \(String(describing: definition)), id: \(String(describing: id)), version: \(String(describing: version)))"}
}

extension GetGroupVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetGroupVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct GetGroupVersionOutputResponse: Equatable {
    /// The ARN of the group version.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the group version was created.
    public let creationTimestamp: String?
    /// Information about the group version definition.
    public let definition: GroupVersion?
    /// The ID of the group that the version is associated with.
    public let id: String?
    /// The ID of the group version.
    public let version: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        definition: GroupVersion? = nil,
        id: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.version = version
    }
}

struct GetGroupVersionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let definition: GroupVersion?
    public let id: String?
    public let version: String?
}

extension GetGroupVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(GroupVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetLoggerDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLoggerDefinitionInput(loggerDefinitionId: \(String(describing: loggerDefinitionId)))"}
}

extension GetLoggerDefinitionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetLoggerDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "GetLoggerDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLoggerDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLoggerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLoggerDefinitionInput>
    public typealias MOutput = OperationOutput<GetLoggerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLoggerDefinitionOutputError>
}

public struct GetLoggerDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLoggerDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLoggerDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLoggerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLoggerDefinitionInput>
    public typealias MOutput = OperationOutput<GetLoggerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLoggerDefinitionOutputError>
}

public struct GetLoggerDefinitionInput: Equatable {
    /// The ID of the logger definition.
    public let loggerDefinitionId: String?

    public init (
        loggerDefinitionId: String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
    }
}

struct GetLoggerDefinitionInputBody: Equatable {
}

extension GetLoggerDefinitionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetLoggerDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLoggerDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLoggerDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLoggerDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLoggerDefinitionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), latestVersion: \(String(describing: latestVersion)), latestVersionArn: \(String(describing: latestVersionArn)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension GetLoggerDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLoggerDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetLoggerDefinitionOutputResponse: Equatable {
    /// The ARN of the definition.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public let creationTimestamp: String?
    /// The ID of the definition.
    public let id: String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public let lastUpdatedTimestamp: String?
    /// The ID of the latest version associated with the definition.
    public let latestVersion: String?
    /// The ARN of the latest version associated with the definition.
    public let latestVersionArn: String?
    /// The name of the definition.
    public let name: String?
    /// Tag(s) attached to the resource arn.
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        lastUpdatedTimestamp: String? = nil,
        latestVersion: String? = nil,
        latestVersionArn: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetLoggerDefinitionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let lastUpdatedTimestamp: String?
    public let latestVersion: String?
    public let latestVersionArn: String?
    public let name: String?
    public let tags: [String:String]?
}

extension GetLoggerDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetLoggerDefinitionVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLoggerDefinitionVersionInput(loggerDefinitionId: \(String(describing: loggerDefinitionId)), loggerDefinitionVersionId: \(String(describing: loggerDefinitionVersionId)), nextToken: \(String(describing: nextToken)))"}
}

extension GetLoggerDefinitionVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetLoggerDefinitionVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetLoggerDefinitionVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLoggerDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLoggerDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLoggerDefinitionVersionInput>
    public typealias MOutput = OperationOutput<GetLoggerDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLoggerDefinitionVersionOutputError>
}

public struct GetLoggerDefinitionVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLoggerDefinitionVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLoggerDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLoggerDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLoggerDefinitionVersionInput>
    public typealias MOutput = OperationOutput<GetLoggerDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLoggerDefinitionVersionOutputError>
}

public struct GetLoggerDefinitionVersionInput: Equatable {
    /// The ID of the logger definition.
    public let loggerDefinitionId: String?
    /// The ID of the logger definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListLoggerDefinitionVersions'' requests. If the version is the last one that was associated with a logger definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    public let loggerDefinitionVersionId: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        loggerDefinitionId: String? = nil,
        loggerDefinitionVersionId: String? = nil,
        nextToken: String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
        self.loggerDefinitionVersionId = loggerDefinitionVersionId
        self.nextToken = nextToken
    }
}

struct GetLoggerDefinitionVersionInputBody: Equatable {
}

extension GetLoggerDefinitionVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetLoggerDefinitionVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLoggerDefinitionVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLoggerDefinitionVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLoggerDefinitionVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLoggerDefinitionVersionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), definition: \(String(describing: definition)), id: \(String(describing: id)), version: \(String(describing: version)))"}
}

extension GetLoggerDefinitionVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLoggerDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct GetLoggerDefinitionVersionOutputResponse: Equatable {
    /// The ARN of the logger definition version.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the logger definition version was created.
    public let creationTimestamp: String?
    /// Information about the logger definition version.
    public let definition: LoggerDefinitionVersion?
    /// The ID of the logger definition version.
    public let id: String?
    /// The version of the logger definition version.
    public let version: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        definition: LoggerDefinitionVersion? = nil,
        id: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.version = version
    }
}

struct GetLoggerDefinitionVersionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let definition: LoggerDefinitionVersion?
    public let id: String?
    public let version: String?
}

extension GetLoggerDefinitionVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(LoggerDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetResourceDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceDefinitionInput(resourceDefinitionId: \(String(describing: resourceDefinitionId)))"}
}

extension GetResourceDefinitionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetResourceDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourceDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceDefinitionInput>
    public typealias MOutput = OperationOutput<GetResourceDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceDefinitionOutputError>
}

public struct GetResourceDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourceDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceDefinitionInput>
    public typealias MOutput = OperationOutput<GetResourceDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceDefinitionOutputError>
}

public struct GetResourceDefinitionInput: Equatable {
    /// The ID of the resource definition.
    public let resourceDefinitionId: String?

    public init (
        resourceDefinitionId: String? = nil
    )
    {
        self.resourceDefinitionId = resourceDefinitionId
    }
}

struct GetResourceDefinitionInputBody: Equatable {
}

extension GetResourceDefinitionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetResourceDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceDefinitionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), latestVersion: \(String(describing: latestVersion)), latestVersionArn: \(String(describing: latestVersionArn)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension GetResourceDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResourceDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetResourceDefinitionOutputResponse: Equatable {
    /// The ARN of the definition.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public let creationTimestamp: String?
    /// The ID of the definition.
    public let id: String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public let lastUpdatedTimestamp: String?
    /// The ID of the latest version associated with the definition.
    public let latestVersion: String?
    /// The ARN of the latest version associated with the definition.
    public let latestVersionArn: String?
    /// The name of the definition.
    public let name: String?
    /// Tag(s) attached to the resource arn.
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        lastUpdatedTimestamp: String? = nil,
        latestVersion: String? = nil,
        latestVersionArn: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetResourceDefinitionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let lastUpdatedTimestamp: String?
    public let latestVersion: String?
    public let latestVersionArn: String?
    public let name: String?
    public let tags: [String:String]?
}

extension GetResourceDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetResourceDefinitionVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceDefinitionVersionInput(resourceDefinitionId: \(String(describing: resourceDefinitionId)), resourceDefinitionVersionId: \(String(describing: resourceDefinitionVersionId)))"}
}

extension GetResourceDefinitionVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetResourceDefinitionVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourceDefinitionVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceDefinitionVersionInput>
    public typealias MOutput = OperationOutput<GetResourceDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceDefinitionVersionOutputError>
}

public struct GetResourceDefinitionVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourceDefinitionVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceDefinitionVersionInput>
    public typealias MOutput = OperationOutput<GetResourceDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceDefinitionVersionOutputError>
}

public struct GetResourceDefinitionVersionInput: Equatable {
    /// The ID of the resource definition.
    public let resourceDefinitionId: String?
    /// The ID of the resource definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListResourceDefinitionVersions'' requests. If the version is the last one that was associated with a resource definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    public let resourceDefinitionVersionId: String?

    public init (
        resourceDefinitionId: String? = nil,
        resourceDefinitionVersionId: String? = nil
    )
    {
        self.resourceDefinitionId = resourceDefinitionId
        self.resourceDefinitionVersionId = resourceDefinitionVersionId
    }
}

struct GetResourceDefinitionVersionInputBody: Equatable {
}

extension GetResourceDefinitionVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetResourceDefinitionVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceDefinitionVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceDefinitionVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceDefinitionVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceDefinitionVersionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), definition: \(String(describing: definition)), id: \(String(describing: id)), version: \(String(describing: version)))"}
}

extension GetResourceDefinitionVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResourceDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct GetResourceDefinitionVersionOutputResponse: Equatable {
    /// Arn of the resource definition version.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the resource definition version was created.
    public let creationTimestamp: String?
    /// Information about the definition.
    public let definition: ResourceDefinitionVersion?
    /// The ID of the resource definition version.
    public let id: String?
    /// The version of the resource definition version.
    public let version: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        definition: ResourceDefinitionVersion? = nil,
        id: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.version = version
    }
}

struct GetResourceDefinitionVersionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let definition: ResourceDefinitionVersion?
    public let id: String?
    public let version: String?
}

extension GetResourceDefinitionVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(ResourceDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetServiceRoleForAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceRoleForAccountInput()"}
}

extension GetServiceRoleForAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetServiceRoleForAccountInputHeadersMiddleware: Middleware {
    public let id: String = "GetServiceRoleForAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceRoleForAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceRoleForAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceRoleForAccountInput>
    public typealias MOutput = OperationOutput<GetServiceRoleForAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceRoleForAccountOutputError>
}

public struct GetServiceRoleForAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "GetServiceRoleForAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceRoleForAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceRoleForAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceRoleForAccountInput>
    public typealias MOutput = OperationOutput<GetServiceRoleForAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceRoleForAccountOutputError>
}

public struct GetServiceRoleForAccountInput: Equatable {

    public init() {}
}

struct GetServiceRoleForAccountInputBody: Equatable {
}

extension GetServiceRoleForAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetServiceRoleForAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceRoleForAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceRoleForAccountOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceRoleForAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceRoleForAccountOutputResponse(associatedAt: \(String(describing: associatedAt)), roleArn: \(String(describing: roleArn)))"}
}

extension GetServiceRoleForAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetServiceRoleForAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associatedAt = output.associatedAt
            self.roleArn = output.roleArn
        } else {
            self.associatedAt = nil
            self.roleArn = nil
        }
    }
}

public struct GetServiceRoleForAccountOutputResponse: Equatable {
    /// The time when the service role was associated with the account.
    public let associatedAt: String?
    /// The ARN of the role which is associated with the account.
    public let roleArn: String?

    public init (
        associatedAt: String? = nil,
        roleArn: String? = nil
    )
    {
        self.associatedAt = associatedAt
        self.roleArn = roleArn
    }
}

struct GetServiceRoleForAccountOutputResponseBody: Equatable {
    public let associatedAt: String?
    public let roleArn: String?
}

extension GetServiceRoleForAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associatedAt = "AssociatedAt"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associatedAt)
        associatedAt = associatedAtDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension GetSubscriptionDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSubscriptionDefinitionInput(subscriptionDefinitionId: \(String(describing: subscriptionDefinitionId)))"}
}

extension GetSubscriptionDefinitionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSubscriptionDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "GetSubscriptionDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSubscriptionDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSubscriptionDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSubscriptionDefinitionInput>
    public typealias MOutput = OperationOutput<GetSubscriptionDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSubscriptionDefinitionOutputError>
}

public struct GetSubscriptionDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSubscriptionDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSubscriptionDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSubscriptionDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSubscriptionDefinitionInput>
    public typealias MOutput = OperationOutput<GetSubscriptionDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSubscriptionDefinitionOutputError>
}

public struct GetSubscriptionDefinitionInput: Equatable {
    /// The ID of the subscription definition.
    public let subscriptionDefinitionId: String?

    public init (
        subscriptionDefinitionId: String? = nil
    )
    {
        self.subscriptionDefinitionId = subscriptionDefinitionId
    }
}

struct GetSubscriptionDefinitionInputBody: Equatable {
}

extension GetSubscriptionDefinitionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSubscriptionDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSubscriptionDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSubscriptionDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSubscriptionDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSubscriptionDefinitionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), latestVersion: \(String(describing: latestVersion)), latestVersionArn: \(String(describing: latestVersionArn)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension GetSubscriptionDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSubscriptionDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetSubscriptionDefinitionOutputResponse: Equatable {
    /// The ARN of the definition.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public let creationTimestamp: String?
    /// The ID of the definition.
    public let id: String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public let lastUpdatedTimestamp: String?
    /// The ID of the latest version associated with the definition.
    public let latestVersion: String?
    /// The ARN of the latest version associated with the definition.
    public let latestVersionArn: String?
    /// The name of the definition.
    public let name: String?
    /// Tag(s) attached to the resource arn.
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        lastUpdatedTimestamp: String? = nil,
        latestVersion: String? = nil,
        latestVersionArn: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetSubscriptionDefinitionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let id: String?
    public let lastUpdatedTimestamp: String?
    public let latestVersion: String?
    public let latestVersionArn: String?
    public let name: String?
    public let tags: [String:String]?
}

extension GetSubscriptionDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetSubscriptionDefinitionVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSubscriptionDefinitionVersionInput(nextToken: \(String(describing: nextToken)), subscriptionDefinitionId: \(String(describing: subscriptionDefinitionId)), subscriptionDefinitionVersionId: \(String(describing: subscriptionDefinitionVersionId)))"}
}

extension GetSubscriptionDefinitionVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSubscriptionDefinitionVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetSubscriptionDefinitionVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSubscriptionDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSubscriptionDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSubscriptionDefinitionVersionInput>
    public typealias MOutput = OperationOutput<GetSubscriptionDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSubscriptionDefinitionVersionOutputError>
}

public struct GetSubscriptionDefinitionVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSubscriptionDefinitionVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSubscriptionDefinitionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSubscriptionDefinitionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSubscriptionDefinitionVersionInput>
    public typealias MOutput = OperationOutput<GetSubscriptionDefinitionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSubscriptionDefinitionVersionOutputError>
}

public struct GetSubscriptionDefinitionVersionInput: Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?
    /// The ID of the subscription definition.
    public let subscriptionDefinitionId: String?
    /// The ID of the subscription definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListSubscriptionDefinitionVersions'' requests. If the version is the last one that was associated with a subscription definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    public let subscriptionDefinitionVersionId: String?

    public init (
        nextToken: String? = nil,
        subscriptionDefinitionId: String? = nil,
        subscriptionDefinitionVersionId: String? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptionDefinitionId = subscriptionDefinitionId
        self.subscriptionDefinitionVersionId = subscriptionDefinitionVersionId
    }
}

struct GetSubscriptionDefinitionVersionInputBody: Equatable {
}

extension GetSubscriptionDefinitionVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSubscriptionDefinitionVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSubscriptionDefinitionVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSubscriptionDefinitionVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSubscriptionDefinitionVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSubscriptionDefinitionVersionOutputResponse(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), definition: \(String(describing: definition)), id: \(String(describing: id)), nextToken: \(String(describing: nextToken)), version: \(String(describing: version)))"}
}

extension GetSubscriptionDefinitionVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSubscriptionDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.nextToken = output.nextToken
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.nextToken = nil
            self.version = nil
        }
    }
}

public struct GetSubscriptionDefinitionVersionOutputResponse: Equatable {
    /// The ARN of the subscription definition version.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the subscription definition version was created.
    public let creationTimestamp: String?
    /// Information about the subscription definition version.
    public let definition: SubscriptionDefinitionVersion?
    /// The ID of the subscription definition version.
    public let id: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?
    /// The version of the subscription definition version.
    public let version: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        definition: SubscriptionDefinitionVersion? = nil,
        id: String? = nil,
        nextToken: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

struct GetSubscriptionDefinitionVersionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTimestamp: String?
    public let definition: SubscriptionDefinitionVersion?
    public let id: String?
    public let nextToken: String?
    public let version: String?
}

extension GetSubscriptionDefinitionVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case nextToken = "NextToken"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(SubscriptionDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetThingRuntimeConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetThingRuntimeConfigurationInput(thingName: \(String(describing: thingName)))"}
}

extension GetThingRuntimeConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetThingRuntimeConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetThingRuntimeConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetThingRuntimeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetThingRuntimeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetThingRuntimeConfigurationInput>
    public typealias MOutput = OperationOutput<GetThingRuntimeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetThingRuntimeConfigurationOutputError>
}

public struct GetThingRuntimeConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetThingRuntimeConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetThingRuntimeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetThingRuntimeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetThingRuntimeConfigurationInput>
    public typealias MOutput = OperationOutput<GetThingRuntimeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetThingRuntimeConfigurationOutputError>
}

public struct GetThingRuntimeConfigurationInput: Equatable {
    /// The thing name.
    public let thingName: String?

    public init (
        thingName: String? = nil
    )
    {
        self.thingName = thingName
    }
}

struct GetThingRuntimeConfigurationInputBody: Equatable {
}

extension GetThingRuntimeConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetThingRuntimeConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetThingRuntimeConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetThingRuntimeConfigurationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetThingRuntimeConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetThingRuntimeConfigurationOutputResponse(runtimeConfiguration: \(String(describing: runtimeConfiguration)))"}
}

extension GetThingRuntimeConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetThingRuntimeConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.runtimeConfiguration = output.runtimeConfiguration
        } else {
            self.runtimeConfiguration = nil
        }
    }
}

public struct GetThingRuntimeConfigurationOutputResponse: Equatable {
    /// Runtime configuration for a thing.
    public let runtimeConfiguration: RuntimeConfiguration?

    public init (
        runtimeConfiguration: RuntimeConfiguration? = nil
    )
    {
        self.runtimeConfiguration = runtimeConfiguration
    }
}

struct GetThingRuntimeConfigurationOutputResponseBody: Equatable {
    public let runtimeConfiguration: RuntimeConfiguration?
}

extension GetThingRuntimeConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case runtimeConfiguration = "RuntimeConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeConfigurationDecoded = try containerValues.decodeIfPresent(RuntimeConfiguration.self, forKey: .runtimeConfiguration)
        runtimeConfiguration = runtimeConfigurationDecoded
    }
}

extension GroupCertificateAuthorityProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupCertificateAuthorityArn = "GroupCertificateAuthorityArn"
        case groupCertificateAuthorityId = "GroupCertificateAuthorityId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupCertificateAuthorityArn = groupCertificateAuthorityArn {
            try encodeContainer.encode(groupCertificateAuthorityArn, forKey: .groupCertificateAuthorityArn)
        }
        if let groupCertificateAuthorityId = groupCertificateAuthorityId {
            try encodeContainer.encode(groupCertificateAuthorityId, forKey: .groupCertificateAuthorityId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupCertificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupCertificateAuthorityArn)
        groupCertificateAuthorityArn = groupCertificateAuthorityArnDecoded
        let groupCertificateAuthorityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupCertificateAuthorityId)
        groupCertificateAuthorityId = groupCertificateAuthorityIdDecoded
    }
}

extension GroupCertificateAuthorityProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupCertificateAuthorityProperties(groupCertificateAuthorityArn: \(String(describing: groupCertificateAuthorityArn)), groupCertificateAuthorityId: \(String(describing: groupCertificateAuthorityId)))"}
}

/// Information about a certificate authority for a group.
public struct GroupCertificateAuthorityProperties: Equatable {
    /// The ARN of the certificate authority for the group.
    public let groupCertificateAuthorityArn: String?
    /// The ID of the certificate authority for the group.
    public let groupCertificateAuthorityId: String?

    public init (
        groupCertificateAuthorityArn: String? = nil,
        groupCertificateAuthorityId: String? = nil
    )
    {
        self.groupCertificateAuthorityArn = groupCertificateAuthorityArn
        self.groupCertificateAuthorityId = groupCertificateAuthorityId
    }
}

extension GroupInformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp, forKey: .creationTimestamp)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp, forKey: .lastUpdatedTimestamp)
        }
        if let latestVersion = latestVersion {
            try encodeContainer.encode(latestVersion, forKey: .latestVersion)
        }
        if let latestVersionArn = latestVersionArn {
            try encodeContainer.encode(latestVersionArn, forKey: .latestVersionArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GroupInformation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupInformation(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), latestVersion: \(String(describing: latestVersion)), latestVersionArn: \(String(describing: latestVersionArn)), name: \(String(describing: name)))"}
}

/// Information about a group.
public struct GroupInformation: Equatable {
    /// The ARN of the group.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the group was created.
    public let creationTimestamp: String?
    /// The ID of the group.
    public let id: String?
    /// The time, in milliseconds since the epoch, when the group was last updated.
    public let lastUpdatedTimestamp: String?
    /// The ID of the latest version associated with the group.
    public let latestVersion: String?
    /// The ARN of the latest version associated with the group.
    public let latestVersionArn: String?
    /// The name of the group.
    public let name: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        lastUpdatedTimestamp: String? = nil,
        latestVersion: String? = nil,
        latestVersionArn: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

extension GroupOwnerSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoAddGroupOwner = "AutoAddGroupOwner"
        case groupOwner = "GroupOwner"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoAddGroupOwner != false {
            try encodeContainer.encode(autoAddGroupOwner, forKey: .autoAddGroupOwner)
        }
        if let groupOwner = groupOwner {
            try encodeContainer.encode(groupOwner, forKey: .groupOwner)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoAddGroupOwnerDecoded = try containerValues.decode(Bool.self, forKey: .autoAddGroupOwner)
        autoAddGroupOwner = autoAddGroupOwnerDecoded
        let groupOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupOwner)
        groupOwner = groupOwnerDecoded
    }
}

extension GroupOwnerSetting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupOwnerSetting(autoAddGroupOwner: \(String(describing: autoAddGroupOwner)), groupOwner: \(String(describing: groupOwner)))"}
}

/// Group owner related settings for local resources.
public struct GroupOwnerSetting: Equatable {
    /// If true, AWS IoT Greengrass automatically adds the specified Linux OS group owner of the resource to the Lambda process privileges. Thus the Lambda process will have the file access permissions of the added Linux group.
    public let autoAddGroupOwner: Bool
    /// The name of the Linux OS group whose privileges will be added to the Lambda process. This field is optional.
    public let groupOwner: String?

    public init (
        autoAddGroupOwner: Bool = false,
        groupOwner: String? = nil
    )
    {
        self.autoAddGroupOwner = autoAddGroupOwner
        self.groupOwner = groupOwner
    }
}

extension GroupVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectorDefinitionVersionArn = "ConnectorDefinitionVersionArn"
        case coreDefinitionVersionArn = "CoreDefinitionVersionArn"
        case deviceDefinitionVersionArn = "DeviceDefinitionVersionArn"
        case functionDefinitionVersionArn = "FunctionDefinitionVersionArn"
        case loggerDefinitionVersionArn = "LoggerDefinitionVersionArn"
        case resourceDefinitionVersionArn = "ResourceDefinitionVersionArn"
        case subscriptionDefinitionVersionArn = "SubscriptionDefinitionVersionArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorDefinitionVersionArn = connectorDefinitionVersionArn {
            try encodeContainer.encode(connectorDefinitionVersionArn, forKey: .connectorDefinitionVersionArn)
        }
        if let coreDefinitionVersionArn = coreDefinitionVersionArn {
            try encodeContainer.encode(coreDefinitionVersionArn, forKey: .coreDefinitionVersionArn)
        }
        if let deviceDefinitionVersionArn = deviceDefinitionVersionArn {
            try encodeContainer.encode(deviceDefinitionVersionArn, forKey: .deviceDefinitionVersionArn)
        }
        if let functionDefinitionVersionArn = functionDefinitionVersionArn {
            try encodeContainer.encode(functionDefinitionVersionArn, forKey: .functionDefinitionVersionArn)
        }
        if let loggerDefinitionVersionArn = loggerDefinitionVersionArn {
            try encodeContainer.encode(loggerDefinitionVersionArn, forKey: .loggerDefinitionVersionArn)
        }
        if let resourceDefinitionVersionArn = resourceDefinitionVersionArn {
            try encodeContainer.encode(resourceDefinitionVersionArn, forKey: .resourceDefinitionVersionArn)
        }
        if let subscriptionDefinitionVersionArn = subscriptionDefinitionVersionArn {
            try encodeContainer.encode(subscriptionDefinitionVersionArn, forKey: .subscriptionDefinitionVersionArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectorDefinitionVersionArn)
        connectorDefinitionVersionArn = connectorDefinitionVersionArnDecoded
        let coreDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .coreDefinitionVersionArn)
        coreDefinitionVersionArn = coreDefinitionVersionArnDecoded
        let deviceDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceDefinitionVersionArn)
        deviceDefinitionVersionArn = deviceDefinitionVersionArnDecoded
        let functionDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionDefinitionVersionArn)
        functionDefinitionVersionArn = functionDefinitionVersionArnDecoded
        let loggerDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loggerDefinitionVersionArn)
        loggerDefinitionVersionArn = loggerDefinitionVersionArnDecoded
        let resourceDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceDefinitionVersionArn)
        resourceDefinitionVersionArn = resourceDefinitionVersionArnDecoded
        let subscriptionDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionDefinitionVersionArn)
        subscriptionDefinitionVersionArn = subscriptionDefinitionVersionArnDecoded
    }
}

extension GroupVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupVersion(connectorDefinitionVersionArn: \(String(describing: connectorDefinitionVersionArn)), coreDefinitionVersionArn: \(String(describing: coreDefinitionVersionArn)), deviceDefinitionVersionArn: \(String(describing: deviceDefinitionVersionArn)), functionDefinitionVersionArn: \(String(describing: functionDefinitionVersionArn)), loggerDefinitionVersionArn: \(String(describing: loggerDefinitionVersionArn)), resourceDefinitionVersionArn: \(String(describing: resourceDefinitionVersionArn)), subscriptionDefinitionVersionArn: \(String(describing: subscriptionDefinitionVersionArn)))"}
}

/// Information about a group version.
public struct GroupVersion: Equatable {
    /// The ARN of the connector definition version for this group.
    public let connectorDefinitionVersionArn: String?
    /// The ARN of the core definition version for this group.
    public let coreDefinitionVersionArn: String?
    /// The ARN of the device definition version for this group.
    public let deviceDefinitionVersionArn: String?
    /// The ARN of the function definition version for this group.
    public let functionDefinitionVersionArn: String?
    /// The ARN of the logger definition version for this group.
    public let loggerDefinitionVersionArn: String?
    /// The ARN of the resource definition version for this group.
    public let resourceDefinitionVersionArn: String?
    /// The ARN of the subscription definition version for this group.
    public let subscriptionDefinitionVersionArn: String?

    public init (
        connectorDefinitionVersionArn: String? = nil,
        coreDefinitionVersionArn: String? = nil,
        deviceDefinitionVersionArn: String? = nil,
        functionDefinitionVersionArn: String? = nil,
        loggerDefinitionVersionArn: String? = nil,
        resourceDefinitionVersionArn: String? = nil,
        subscriptionDefinitionVersionArn: String? = nil
    )
    {
        self.connectorDefinitionVersionArn = connectorDefinitionVersionArn
        self.coreDefinitionVersionArn = coreDefinitionVersionArn
        self.deviceDefinitionVersionArn = deviceDefinitionVersionArn
        self.functionDefinitionVersionArn = functionDefinitionVersionArn
        self.loggerDefinitionVersionArn = loggerDefinitionVersionArn
        self.resourceDefinitionVersionArn = resourceDefinitionVersionArn
        self.subscriptionDefinitionVersionArn = subscriptionDefinitionVersionArn
    }
}

extension InternalServerErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerErrorException(errorDetails: \(String(describing: errorDetails)), message: \(String(describing: message)))"}
}

extension InternalServerErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorDetails = output.errorDetails
            self.message = output.message
        } else {
            self.errorDetails = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// General error information.
public struct InternalServerErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// Details about the error.
    public var errorDetails: [ErrorDetail]?
    /// A message containing information about the error.
    public var message: String?

    public init (
        errorDetails: [ErrorDetail]? = nil,
        message: String? = nil
    )
    {
        self.errorDetails = errorDetails
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Equatable {
    public let errorDetails: [ErrorDetail]?
    public let message: String?
}

extension InternalServerErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorDetails = "ErrorDetails"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDetailsContainer = try containerValues.decodeIfPresent([ErrorDetail?].self, forKey: .errorDetails)
        var errorDetailsDecoded0:[ErrorDetail]? = nil
        if let errorDetailsContainer = errorDetailsContainer {
            errorDetailsDecoded0 = [ErrorDetail]()
            for structure0 in errorDetailsContainer {
                if let structure0 = structure0 {
                    errorDetailsDecoded0?.append(structure0)
                }
            }
        }
        errorDetails = errorDetailsDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListBulkDeploymentDetailedReportsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBulkDeploymentDetailedReportsInput(bulkDeploymentId: \(String(describing: bulkDeploymentId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBulkDeploymentDetailedReportsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListBulkDeploymentDetailedReportsInputHeadersMiddleware: Middleware {
    public let id: String = "ListBulkDeploymentDetailedReportsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBulkDeploymentDetailedReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBulkDeploymentDetailedReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBulkDeploymentDetailedReportsInput>
    public typealias MOutput = OperationOutput<ListBulkDeploymentDetailedReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBulkDeploymentDetailedReportsOutputError>
}

public struct ListBulkDeploymentDetailedReportsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBulkDeploymentDetailedReportsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBulkDeploymentDetailedReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBulkDeploymentDetailedReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBulkDeploymentDetailedReportsInput>
    public typealias MOutput = OperationOutput<ListBulkDeploymentDetailedReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBulkDeploymentDetailedReportsOutputError>
}

public struct ListBulkDeploymentDetailedReportsInput: Equatable {
    /// The ID of the bulk deployment.
    public let bulkDeploymentId: String?
    /// The maximum number of results to be returned per request.
    public let maxResults: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        bulkDeploymentId: String? = nil,
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.bulkDeploymentId = bulkDeploymentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBulkDeploymentDetailedReportsInputBody: Equatable {
}

extension ListBulkDeploymentDetailedReportsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListBulkDeploymentDetailedReportsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBulkDeploymentDetailedReportsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBulkDeploymentDetailedReportsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBulkDeploymentDetailedReportsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBulkDeploymentDetailedReportsOutputResponse(deployments: \(String(describing: deployments)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBulkDeploymentDetailedReportsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBulkDeploymentDetailedReportsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deployments = output.deployments
            self.nextToken = output.nextToken
        } else {
            self.deployments = nil
            self.nextToken = nil
        }
    }
}

public struct ListBulkDeploymentDetailedReportsOutputResponse: Equatable {
    /// A list of the individual group deployments in the bulk deployment operation.
    public let deployments: [BulkDeploymentResult]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        deployments: [BulkDeploymentResult]? = nil,
        nextToken: String? = nil
    )
    {
        self.deployments = deployments
        self.nextToken = nextToken
    }
}

struct ListBulkDeploymentDetailedReportsOutputResponseBody: Equatable {
    public let deployments: [BulkDeploymentResult]?
    public let nextToken: String?
}

extension ListBulkDeploymentDetailedReportsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deployments = "Deployments"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentsContainer = try containerValues.decodeIfPresent([BulkDeploymentResult?].self, forKey: .deployments)
        var deploymentsDecoded0:[BulkDeploymentResult]? = nil
        if let deploymentsContainer = deploymentsContainer {
            deploymentsDecoded0 = [BulkDeploymentResult]()
            for structure0 in deploymentsContainer {
                if let structure0 = structure0 {
                    deploymentsDecoded0?.append(structure0)
                }
            }
        }
        deployments = deploymentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBulkDeploymentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBulkDeploymentsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBulkDeploymentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListBulkDeploymentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListBulkDeploymentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBulkDeploymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBulkDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBulkDeploymentsInput>
    public typealias MOutput = OperationOutput<ListBulkDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBulkDeploymentsOutputError>
}

public struct ListBulkDeploymentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBulkDeploymentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBulkDeploymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBulkDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBulkDeploymentsInput>
    public typealias MOutput = OperationOutput<ListBulkDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBulkDeploymentsOutputError>
}

public struct ListBulkDeploymentsInput: Equatable {
    /// The maximum number of results to be returned per request.
    public let maxResults: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBulkDeploymentsInputBody: Equatable {
}

extension ListBulkDeploymentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListBulkDeploymentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBulkDeploymentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBulkDeploymentsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBulkDeploymentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBulkDeploymentsOutputResponse(bulkDeployments: \(String(describing: bulkDeployments)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBulkDeploymentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBulkDeploymentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bulkDeployments = output.bulkDeployments
            self.nextToken = output.nextToken
        } else {
            self.bulkDeployments = nil
            self.nextToken = nil
        }
    }
}

public struct ListBulkDeploymentsOutputResponse: Equatable {
    /// A list of bulk deployments.
    public let bulkDeployments: [BulkDeployment]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        bulkDeployments: [BulkDeployment]? = nil,
        nextToken: String? = nil
    )
    {
        self.bulkDeployments = bulkDeployments
        self.nextToken = nextToken
    }
}

struct ListBulkDeploymentsOutputResponseBody: Equatable {
    public let bulkDeployments: [BulkDeployment]?
    public let nextToken: String?
}

extension ListBulkDeploymentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bulkDeployments = "BulkDeployments"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bulkDeploymentsContainer = try containerValues.decodeIfPresent([BulkDeployment?].self, forKey: .bulkDeployments)
        var bulkDeploymentsDecoded0:[BulkDeployment]? = nil
        if let bulkDeploymentsContainer = bulkDeploymentsContainer {
            bulkDeploymentsDecoded0 = [BulkDeployment]()
            for structure0 in bulkDeploymentsContainer {
                if let structure0 = structure0 {
                    bulkDeploymentsDecoded0?.append(structure0)
                }
            }
        }
        bulkDeployments = bulkDeploymentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConnectorDefinitionVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConnectorDefinitionVersionsInput(connectorDefinitionId: \(String(describing: connectorDefinitionId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConnectorDefinitionVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListConnectorDefinitionVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListConnectorDefinitionVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConnectorDefinitionVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConnectorDefinitionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConnectorDefinitionVersionsInput>
    public typealias MOutput = OperationOutput<ListConnectorDefinitionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConnectorDefinitionVersionsOutputError>
}

public struct ListConnectorDefinitionVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListConnectorDefinitionVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConnectorDefinitionVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConnectorDefinitionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConnectorDefinitionVersionsInput>
    public typealias MOutput = OperationOutput<ListConnectorDefinitionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConnectorDefinitionVersionsOutputError>
}

public struct ListConnectorDefinitionVersionsInput: Equatable {
    /// The ID of the connector definition.
    public let connectorDefinitionId: String?
    /// The maximum number of results to be returned per request.
    public let maxResults: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        connectorDefinitionId: String? = nil,
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConnectorDefinitionVersionsInputBody: Equatable {
}

extension ListConnectorDefinitionVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListConnectorDefinitionVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConnectorDefinitionVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConnectorDefinitionVersionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConnectorDefinitionVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConnectorDefinitionVersionsOutputResponse(nextToken: \(String(describing: nextToken)), versions: \(String(describing: versions)))"}
}

extension ListConnectorDefinitionVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListConnectorDefinitionVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListConnectorDefinitionVersionsOutputResponse: Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?
    /// Information about a version.
    public let versions: [VersionInformation]?

    public init (
        nextToken: String? = nil,
        versions: [VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListConnectorDefinitionVersionsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let versions: [VersionInformation]?
}

extension ListConnectorDefinitionVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension ListConnectorDefinitionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConnectorDefinitionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConnectorDefinitionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListConnectorDefinitionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListConnectorDefinitionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConnectorDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConnectorDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConnectorDefinitionsInput>
    public typealias MOutput = OperationOutput<ListConnectorDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConnectorDefinitionsOutputError>
}

public struct ListConnectorDefinitionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListConnectorDefinitionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConnectorDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConnectorDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConnectorDefinitionsInput>
    public typealias MOutput = OperationOutput<ListConnectorDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConnectorDefinitionsOutputError>
}

public struct ListConnectorDefinitionsInput: Equatable {
    /// The maximum number of results to be returned per request.
    public let maxResults: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConnectorDefinitionsInputBody: Equatable {
}

extension ListConnectorDefinitionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListConnectorDefinitionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConnectorDefinitionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConnectorDefinitionsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConnectorDefinitionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConnectorDefinitionsOutputResponse(definitions: \(String(describing: definitions)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConnectorDefinitionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListConnectorDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListConnectorDefinitionsOutputResponse: Equatable {
    /// Information about a definition.
    public let definitions: [DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        definitions: [DefinitionInformation]? = nil,
        nextToken: String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListConnectorDefinitionsOutputResponseBody: Equatable {
    public let definitions: [DefinitionInformation]?
    public let nextToken: String?
}

extension ListConnectorDefinitionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCoreDefinitionVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCoreDefinitionVersionsInput(coreDefinitionId: \(String(describing: coreDefinitionId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCoreDefinitionVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListCoreDefinitionVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListCoreDefinitionVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCoreDefinitionVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCoreDefinitionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCoreDefinitionVersionsInput>
    public typealias MOutput = OperationOutput<ListCoreDefinitionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCoreDefinitionVersionsOutputError>
}

public struct ListCoreDefinitionVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCoreDefinitionVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCoreDefinitionVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCoreDefinitionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCoreDefinitionVersionsInput>
    public typealias MOutput = OperationOutput<ListCoreDefinitionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCoreDefinitionVersionsOutputError>
}

public struct ListCoreDefinitionVersionsInput: Equatable {
    /// The ID of the core definition.
    public let coreDefinitionId: String?
    /// The maximum number of results to be returned per request.
    public let maxResults: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        coreDefinitionId: String? = nil,
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCoreDefinitionVersionsInputBody: Equatable {
}

extension ListCoreDefinitionVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListCoreDefinitionVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCoreDefinitionVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCoreDefinitionVersionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCoreDefinitionVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCoreDefinitionVersionsOutputResponse(nextToken: \(String(describing: nextToken)), versions: \(String(describing: versions)))"}
}

extension ListCoreDefinitionVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCoreDefinitionVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListCoreDefinitionVersionsOutputResponse: Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?
    /// Information about a version.
    public let versions: [VersionInformation]?

    public init (
        nextToken: String? = nil,
        versions: [VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListCoreDefinitionVersionsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let versions: [VersionInformation]?
}

extension ListCoreDefinitionVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension ListCoreDefinitionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCoreDefinitionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCoreDefinitionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListCoreDefinitionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListCoreDefinitionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCoreDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCoreDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCoreDefinitionsInput>
    public typealias MOutput = OperationOutput<ListCoreDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCoreDefinitionsOutputError>
}

public struct ListCoreDefinitionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCoreDefinitionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCoreDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCoreDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCoreDefinitionsInput>
    public typealias MOutput = OperationOutput<ListCoreDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCoreDefinitionsOutputError>
}

public struct ListCoreDefinitionsInput: Equatable {
    /// The maximum number of results to be returned per request.
    public let maxResults: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCoreDefinitionsInputBody: Equatable {
}

extension ListCoreDefinitionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListCoreDefinitionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCoreDefinitionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCoreDefinitionsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCoreDefinitionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCoreDefinitionsOutputResponse(definitions: \(String(describing: definitions)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCoreDefinitionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCoreDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListCoreDefinitionsOutputResponse: Equatable {
    /// Information about a definition.
    public let definitions: [DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        definitions: [DefinitionInformation]? = nil,
        nextToken: String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListCoreDefinitionsOutputResponseBody: Equatable {
    public let definitions: [DefinitionInformation]?
    public let nextToken: String?
}

extension ListCoreDefinitionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeploymentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeploymentsInput(groupId: \(String(describing: groupId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDeploymentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDeploymentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDeploymentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeploymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeploymentsInput>
    public typealias MOutput = OperationOutput<ListDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeploymentsOutputError>
}

public struct ListDeploymentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDeploymentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeploymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeploymentsInput>
    public typealias MOutput = OperationOutput<ListDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeploymentsOutputError>
}

public struct ListDeploymentsInput: Equatable {
    /// The ID of the Greengrass group.
    public let groupId: String?
    /// The maximum number of results to be returned per request.
    public let maxResults: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        groupId: String? = nil,
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.groupId = groupId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeploymentsInputBody: Equatable {
}

extension ListDeploymentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDeploymentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeploymentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeploymentsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeploymentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeploymentsOutputResponse(deployments: \(String(describing: deployments)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDeploymentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDeploymentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deployments = output.deployments
            self.nextToken = output.nextToken
        } else {
            self.deployments = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeploymentsOutputResponse: Equatable {
    /// A list of deployments for the requested groups.
    public let deployments: [Deployment]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        deployments: [Deployment]? = nil,
        nextToken: String? = nil
    )
    {
        self.deployments = deployments
        self.nextToken = nextToken
    }
}

struct ListDeploymentsOutputResponseBody: Equatable {
    public let deployments: [Deployment]?
    public let nextToken: String?
}

extension ListDeploymentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deployments = "Deployments"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentsContainer = try containerValues.decodeIfPresent([Deployment?].self, forKey: .deployments)
        var deploymentsDecoded0:[Deployment]? = nil
        if let deploymentsContainer = deploymentsContainer {
            deploymentsDecoded0 = [Deployment]()
            for structure0 in deploymentsContainer {
                if let structure0 = structure0 {
                    deploymentsDecoded0?.append(structure0)
                }
            }
        }
        deployments = deploymentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeviceDefinitionVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeviceDefinitionVersionsInput(deviceDefinitionId: \(String(describing: deviceDefinitionId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDeviceDefinitionVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDeviceDefinitionVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDeviceDefinitionVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeviceDefinitionVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeviceDefinitionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeviceDefinitionVersionsInput>
    public typealias MOutput = OperationOutput<ListDeviceDefinitionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeviceDefinitionVersionsOutputError>
}

public struct ListDeviceDefinitionVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDeviceDefinitionVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeviceDefinitionVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeviceDefinitionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeviceDefinitionVersionsInput>
    public typealias MOutput = OperationOutput<ListDeviceDefinitionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeviceDefinitionVersionsOutputError>
}

public struct ListDeviceDefinitionVersionsInput: Equatable {
    /// The ID of the device definition.
    public let deviceDefinitionId: String?
    /// The maximum number of results to be returned per request.
    public let maxResults: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        deviceDefinitionId: String? = nil,
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeviceDefinitionVersionsInputBody: Equatable {
}

extension ListDeviceDefinitionVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDeviceDefinitionVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeviceDefinitionVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeviceDefinitionVersionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeviceDefinitionVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeviceDefinitionVersionsOutputResponse(nextToken: \(String(describing: nextToken)), versions: \(String(describing: versions)))"}
}

extension ListDeviceDefinitionVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDeviceDefinitionVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListDeviceDefinitionVersionsOutputResponse: Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?
    /// Information about a version.
    public let versions: [VersionInformation]?

    public init (
        nextToken: String? = nil,
        versions: [VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListDeviceDefinitionVersionsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let versions: [VersionInformation]?
}

extension ListDeviceDefinitionVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension ListDeviceDefinitionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeviceDefinitionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDeviceDefinitionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDeviceDefinitionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDeviceDefinitionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeviceDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeviceDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeviceDefinitionsInput>
    public typealias MOutput = OperationOutput<ListDeviceDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeviceDefinitionsOutputError>
}

public struct ListDeviceDefinitionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDeviceDefinitionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeviceDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeviceDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeviceDefinitionsInput>
    public typealias MOutput = OperationOutput<ListDeviceDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeviceDefinitionsOutputError>
}

public struct ListDeviceDefinitionsInput: Equatable {
    /// The maximum number of results to be returned per request.
    public let maxResults: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeviceDefinitionsInputBody: Equatable {
}

extension ListDeviceDefinitionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDeviceDefinitionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeviceDefinitionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeviceDefinitionsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeviceDefinitionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeviceDefinitionsOutputResponse(definitions: \(String(describing: definitions)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDeviceDefinitionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDeviceDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeviceDefinitionsOutputResponse: Equatable {
    /// Information about a definition.
    public let definitions: [DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        definitions: [DefinitionInformation]? = nil,
        nextToken: String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListDeviceDefinitionsOutputResponseBody: Equatable {
    public let definitions: [DefinitionInformation]?
    public let nextToken: String?
}

extension ListDeviceDefinitionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFunctionDefinitionVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFunctionDefinitionVersionsInput(functionDefinitionId: \(String(describing: functionDefinitionId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFunctionDefinitionVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListFunctionDefinitionVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFunctionDefinitionVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFunctionDefinitionVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFunctionDefinitionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFunctionDefinitionVersionsInput>
    public typealias MOutput = OperationOutput<ListFunctionDefinitionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFunctionDefinitionVersionsOutputError>
}

public struct ListFunctionDefinitionVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFunctionDefinitionVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFunctionDefinitionVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFunctionDefinitionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFunctionDefinitionVersionsInput>
    public typealias MOutput = OperationOutput<ListFunctionDefinitionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFunctionDefinitionVersionsOutputError>
}

public struct ListFunctionDefinitionVersionsInput: Equatable {
    /// The ID of the Lambda function definition.
    public let functionDefinitionId: String?
    /// The maximum number of results to be returned per request.
    public let maxResults: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        functionDefinitionId: String? = nil,
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFunctionDefinitionVersionsInputBody: Equatable {
}

extension ListFunctionDefinitionVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListFunctionDefinitionVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFunctionDefinitionVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFunctionDefinitionVersionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFunctionDefinitionVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFunctionDefinitionVersionsOutputResponse(nextToken: \(String(describing: nextToken)), versions: \(String(describing: versions)))"}
}

extension ListFunctionDefinitionVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFunctionDefinitionVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListFunctionDefinitionVersionsOutputResponse: Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?
    /// Information about a version.
    public let versions: [VersionInformation]?

    public init (
        nextToken: String? = nil,
        versions: [VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListFunctionDefinitionVersionsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let versions: [VersionInformation]?
}

extension ListFunctionDefinitionVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension ListFunctionDefinitionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFunctionDefinitionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFunctionDefinitionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListFunctionDefinitionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFunctionDefinitionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFunctionDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFunctionDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFunctionDefinitionsInput>
    public typealias MOutput = OperationOutput<ListFunctionDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFunctionDefinitionsOutputError>
}

public struct ListFunctionDefinitionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFunctionDefinitionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFunctionDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFunctionDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFunctionDefinitionsInput>
    public typealias MOutput = OperationOutput<ListFunctionDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFunctionDefinitionsOutputError>
}

public struct ListFunctionDefinitionsInput: Equatable {
    /// The maximum number of results to be returned per request.
    public let maxResults: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFunctionDefinitionsInputBody: Equatable {
}

extension ListFunctionDefinitionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListFunctionDefinitionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFunctionDefinitionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFunctionDefinitionsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFunctionDefinitionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFunctionDefinitionsOutputResponse(definitions: \(String(describing: definitions)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFunctionDefinitionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFunctionDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListFunctionDefinitionsOutputResponse: Equatable {
    /// Information about a definition.
    public let definitions: [DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        definitions: [DefinitionInformation]? = nil,
        nextToken: String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListFunctionDefinitionsOutputResponseBody: Equatable {
    public let definitions: [DefinitionInformation]?
    public let nextToken: String?
}

extension ListFunctionDefinitionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGroupCertificateAuthoritiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupCertificateAuthoritiesInput(groupId: \(String(describing: groupId)))"}
}

extension ListGroupCertificateAuthoritiesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListGroupCertificateAuthoritiesInputHeadersMiddleware: Middleware {
    public let id: String = "ListGroupCertificateAuthoritiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupCertificateAuthoritiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupCertificateAuthoritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupCertificateAuthoritiesInput>
    public typealias MOutput = OperationOutput<ListGroupCertificateAuthoritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupCertificateAuthoritiesOutputError>
}

public struct ListGroupCertificateAuthoritiesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGroupCertificateAuthoritiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupCertificateAuthoritiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupCertificateAuthoritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupCertificateAuthoritiesInput>
    public typealias MOutput = OperationOutput<ListGroupCertificateAuthoritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupCertificateAuthoritiesOutputError>
}

public struct ListGroupCertificateAuthoritiesInput: Equatable {
    /// The ID of the Greengrass group.
    public let groupId: String?

    public init (
        groupId: String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct ListGroupCertificateAuthoritiesInputBody: Equatable {
}

extension ListGroupCertificateAuthoritiesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListGroupCertificateAuthoritiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupCertificateAuthoritiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroupCertificateAuthoritiesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupCertificateAuthoritiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupCertificateAuthoritiesOutputResponse(groupCertificateAuthorities: \(String(describing: groupCertificateAuthorities)))"}
}

extension ListGroupCertificateAuthoritiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGroupCertificateAuthoritiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groupCertificateAuthorities = output.groupCertificateAuthorities
        } else {
            self.groupCertificateAuthorities = nil
        }
    }
}

public struct ListGroupCertificateAuthoritiesOutputResponse: Equatable {
    /// A list of certificate authorities associated with the group.
    public let groupCertificateAuthorities: [GroupCertificateAuthorityProperties]?

    public init (
        groupCertificateAuthorities: [GroupCertificateAuthorityProperties]? = nil
    )
    {
        self.groupCertificateAuthorities = groupCertificateAuthorities
    }
}

struct ListGroupCertificateAuthoritiesOutputResponseBody: Equatable {
    public let groupCertificateAuthorities: [GroupCertificateAuthorityProperties]?
}

extension ListGroupCertificateAuthoritiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupCertificateAuthorities = "GroupCertificateAuthorities"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupCertificateAuthoritiesContainer = try containerValues.decodeIfPresent([GroupCertificateAuthorityProperties?].self, forKey: .groupCertificateAuthorities)
        var groupCertificateAuthoritiesDecoded0:[GroupCertificateAuthorityProperties]? = nil
        if let groupCertificateAuthoritiesContainer = groupCertificateAuthoritiesContainer {
            groupCertificateAuthoritiesDecoded0 = [GroupCertificateAuthorityProperties]()
            for structure0 in groupCertificateAuthoritiesContainer {
                if let structure0 = structure0 {
                    groupCertificateAuthoritiesDecoded0?.append(structure0)
                }
            }
        }
        groupCertificateAuthorities = groupCertificateAuthoritiesDecoded0
    }
}

extension ListGroupVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupVersionsInput(groupId: \(String(describing: groupId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGroupVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListGroupVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListGroupVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupVersionsInput>
    public typealias MOutput = OperationOutput<ListGroupVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupVersionsOutputError>
}

public struct ListGroupVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGroupVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupVersionsInput>
    public typealias MOutput = OperationOutput<ListGroupVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupVersionsOutputError>
}

public struct ListGroupVersionsInput: Equatable {
    /// The ID of the Greengrass group.
    public let groupId: String?
    /// The maximum number of results to be returned per request.
    public let maxResults: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        groupId: String? = nil,
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.groupId = groupId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGroupVersionsInputBody: Equatable {
}

extension ListGroupVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListGroupVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroupVersionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupVersionsOutputResponse(nextToken: \(String(describing: nextToken)), versions: \(String(describing: versions)))"}
}

extension ListGroupVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGroupVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListGroupVersionsOutputResponse: Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?
    /// Information about a version.
    public let versions: [VersionInformation]?

    public init (
        nextToken: String? = nil,
        versions: [VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListGroupVersionsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let versions: [VersionInformation]?
}

extension ListGroupVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension ListGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGroupsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupsInput>
    public typealias MOutput = OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupsOutputError>
}

public struct ListGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupsInput>
    public typealias MOutput = OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupsOutputError>
}

public struct ListGroupsInput: Equatable {
    /// The maximum number of results to be returned per request.
    public let maxResults: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGroupsInputBody: Equatable {
}

extension ListGroupsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroupsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupsOutputResponse(groups: \(String(describing: groups)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groups = output.groups
            self.nextToken = output.nextToken
        } else {
            self.groups = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupsOutputResponse: Equatable {
    /// Information about a group.
    public let groups: [GroupInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        groups: [GroupInformation]? = nil,
        nextToken: String? = nil
    )
    {
        self.groups = groups
        self.nextToken = nextToken
    }
}

struct ListGroupsOutputResponseBody: Equatable {
    public let groups: [GroupInformation]?
    public let nextToken: String?
}

extension ListGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groups = "Groups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([GroupInformation?].self, forKey: .groups)
        var groupsDecoded0:[GroupInformation]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [GroupInformation]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLoggerDefinitionVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLoggerDefinitionVersionsInput(loggerDefinitionId: \(String(describing: loggerDefinitionId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLoggerDefinitionVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListLoggerDefinitionVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListLoggerDefinitionVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLoggerDefinitionVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLoggerDefinitionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLoggerDefinitionVersionsInput>
    public typealias MOutput = OperationOutput<ListLoggerDefinitionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLoggerDefinitionVersionsOutputError>
}

public struct ListLoggerDefinitionVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLoggerDefinitionVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLoggerDefinitionVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLoggerDefinitionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLoggerDefinitionVersionsInput>
    public typealias MOutput = OperationOutput<ListLoggerDefinitionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLoggerDefinitionVersionsOutputError>
}

public struct ListLoggerDefinitionVersionsInput: Equatable {
    /// The ID of the logger definition.
    public let loggerDefinitionId: String?
    /// The maximum number of results to be returned per request.
    public let maxResults: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        loggerDefinitionId: String? = nil,
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLoggerDefinitionVersionsInputBody: Equatable {
}

extension ListLoggerDefinitionVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListLoggerDefinitionVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLoggerDefinitionVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLoggerDefinitionVersionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLoggerDefinitionVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLoggerDefinitionVersionsOutputResponse(nextToken: \(String(describing: nextToken)), versions: \(String(describing: versions)))"}
}

extension ListLoggerDefinitionVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLoggerDefinitionVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListLoggerDefinitionVersionsOutputResponse: Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?
    /// Information about a version.
    public let versions: [VersionInformation]?

    public init (
        nextToken: String? = nil,
        versions: [VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListLoggerDefinitionVersionsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let versions: [VersionInformation]?
}

extension ListLoggerDefinitionVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension ListLoggerDefinitionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLoggerDefinitionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLoggerDefinitionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListLoggerDefinitionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListLoggerDefinitionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLoggerDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLoggerDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLoggerDefinitionsInput>
    public typealias MOutput = OperationOutput<ListLoggerDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLoggerDefinitionsOutputError>
}

public struct ListLoggerDefinitionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLoggerDefinitionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLoggerDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLoggerDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLoggerDefinitionsInput>
    public typealias MOutput = OperationOutput<ListLoggerDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLoggerDefinitionsOutputError>
}

public struct ListLoggerDefinitionsInput: Equatable {
    /// The maximum number of results to be returned per request.
    public let maxResults: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLoggerDefinitionsInputBody: Equatable {
}

extension ListLoggerDefinitionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListLoggerDefinitionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLoggerDefinitionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLoggerDefinitionsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLoggerDefinitionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLoggerDefinitionsOutputResponse(definitions: \(String(describing: definitions)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLoggerDefinitionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLoggerDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListLoggerDefinitionsOutputResponse: Equatable {
    /// Information about a definition.
    public let definitions: [DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        definitions: [DefinitionInformation]? = nil,
        nextToken: String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListLoggerDefinitionsOutputResponseBody: Equatable {
    public let definitions: [DefinitionInformation]?
    public let nextToken: String?
}

extension ListLoggerDefinitionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourceDefinitionVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourceDefinitionVersionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceDefinitionId: \(String(describing: resourceDefinitionId)))"}
}

extension ListResourceDefinitionVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListResourceDefinitionVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListResourceDefinitionVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceDefinitionVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceDefinitionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceDefinitionVersionsInput>
    public typealias MOutput = OperationOutput<ListResourceDefinitionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceDefinitionVersionsOutputError>
}

public struct ListResourceDefinitionVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResourceDefinitionVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceDefinitionVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceDefinitionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceDefinitionVersionsInput>
    public typealias MOutput = OperationOutput<ListResourceDefinitionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceDefinitionVersionsOutputError>
}

public struct ListResourceDefinitionVersionsInput: Equatable {
    /// The maximum number of results to be returned per request.
    public let maxResults: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?
    /// The ID of the resource definition.
    public let resourceDefinitionId: String?

    public init (
        maxResults: String? = nil,
        nextToken: String? = nil,
        resourceDefinitionId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceDefinitionId = resourceDefinitionId
    }
}

struct ListResourceDefinitionVersionsInputBody: Equatable {
}

extension ListResourceDefinitionVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListResourceDefinitionVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceDefinitionVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceDefinitionVersionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceDefinitionVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourceDefinitionVersionsOutputResponse(nextToken: \(String(describing: nextToken)), versions: \(String(describing: versions)))"}
}

extension ListResourceDefinitionVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResourceDefinitionVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListResourceDefinitionVersionsOutputResponse: Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?
    /// Information about a version.
    public let versions: [VersionInformation]?

    public init (
        nextToken: String? = nil,
        versions: [VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListResourceDefinitionVersionsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let versions: [VersionInformation]?
}

extension ListResourceDefinitionVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension ListResourceDefinitionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourceDefinitionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListResourceDefinitionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListResourceDefinitionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListResourceDefinitionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceDefinitionsInput>
    public typealias MOutput = OperationOutput<ListResourceDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceDefinitionsOutputError>
}

public struct ListResourceDefinitionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResourceDefinitionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceDefinitionsInput>
    public typealias MOutput = OperationOutput<ListResourceDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceDefinitionsOutputError>
}

public struct ListResourceDefinitionsInput: Equatable {
    /// The maximum number of results to be returned per request.
    public let maxResults: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourceDefinitionsInputBody: Equatable {
}

extension ListResourceDefinitionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListResourceDefinitionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceDefinitionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceDefinitionsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceDefinitionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourceDefinitionsOutputResponse(definitions: \(String(describing: definitions)), nextToken: \(String(describing: nextToken)))"}
}

extension ListResourceDefinitionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResourceDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListResourceDefinitionsOutputResponse: Equatable {
    /// Information about a definition.
    public let definitions: [DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        definitions: [DefinitionInformation]? = nil,
        nextToken: String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListResourceDefinitionsOutputResponseBody: Equatable {
    public let definitions: [DefinitionInformation]?
    public let nextToken: String?
}

extension ListResourceDefinitionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSubscriptionDefinitionVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSubscriptionDefinitionVersionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), subscriptionDefinitionId: \(String(describing: subscriptionDefinitionId)))"}
}

extension ListSubscriptionDefinitionVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListSubscriptionDefinitionVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSubscriptionDefinitionVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSubscriptionDefinitionVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSubscriptionDefinitionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSubscriptionDefinitionVersionsInput>
    public typealias MOutput = OperationOutput<ListSubscriptionDefinitionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSubscriptionDefinitionVersionsOutputError>
}

public struct ListSubscriptionDefinitionVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSubscriptionDefinitionVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSubscriptionDefinitionVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSubscriptionDefinitionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSubscriptionDefinitionVersionsInput>
    public typealias MOutput = OperationOutput<ListSubscriptionDefinitionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSubscriptionDefinitionVersionsOutputError>
}

public struct ListSubscriptionDefinitionVersionsInput: Equatable {
    /// The maximum number of results to be returned per request.
    public let maxResults: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?
    /// The ID of the subscription definition.
    public let subscriptionDefinitionId: String?

    public init (
        maxResults: String? = nil,
        nextToken: String? = nil,
        subscriptionDefinitionId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subscriptionDefinitionId = subscriptionDefinitionId
    }
}

struct ListSubscriptionDefinitionVersionsInputBody: Equatable {
}

extension ListSubscriptionDefinitionVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListSubscriptionDefinitionVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSubscriptionDefinitionVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSubscriptionDefinitionVersionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSubscriptionDefinitionVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSubscriptionDefinitionVersionsOutputResponse(nextToken: \(String(describing: nextToken)), versions: \(String(describing: versions)))"}
}

extension ListSubscriptionDefinitionVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSubscriptionDefinitionVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListSubscriptionDefinitionVersionsOutputResponse: Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?
    /// Information about a version.
    public let versions: [VersionInformation]?

    public init (
        nextToken: String? = nil,
        versions: [VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListSubscriptionDefinitionVersionsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let versions: [VersionInformation]?
}

extension ListSubscriptionDefinitionVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension ListSubscriptionDefinitionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSubscriptionDefinitionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSubscriptionDefinitionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListSubscriptionDefinitionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSubscriptionDefinitionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSubscriptionDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSubscriptionDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSubscriptionDefinitionsInput>
    public typealias MOutput = OperationOutput<ListSubscriptionDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSubscriptionDefinitionsOutputError>
}

public struct ListSubscriptionDefinitionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSubscriptionDefinitionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSubscriptionDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSubscriptionDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSubscriptionDefinitionsInput>
    public typealias MOutput = OperationOutput<ListSubscriptionDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSubscriptionDefinitionsOutputError>
}

public struct ListSubscriptionDefinitionsInput: Equatable {
    /// The maximum number of results to be returned per request.
    public let maxResults: String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSubscriptionDefinitionsInputBody: Equatable {
}

extension ListSubscriptionDefinitionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListSubscriptionDefinitionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSubscriptionDefinitionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSubscriptionDefinitionsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSubscriptionDefinitionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSubscriptionDefinitionsOutputResponse(definitions: \(String(describing: definitions)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSubscriptionDefinitionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSubscriptionDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListSubscriptionDefinitionsOutputResponse: Equatable {
    /// Information about a definition.
    public let definitions: [DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public let nextToken: String?

    public init (
        definitions: [DefinitionInformation]? = nil,
        nextToken: String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListSubscriptionDefinitionsOutputResponseBody: Equatable {
    public let definitions: [DefinitionInformation]?
    public let nextToken: String?
}

extension ListSubscriptionDefinitionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// The key-value pair for the resource tag.
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LocalDeviceResourceData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupOwnerSetting = "GroupOwnerSetting"
        case sourcePath = "SourcePath"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupOwnerSetting = groupOwnerSetting {
            try encodeContainer.encode(groupOwnerSetting, forKey: .groupOwnerSetting)
        }
        if let sourcePath = sourcePath {
            try encodeContainer.encode(sourcePath, forKey: .sourcePath)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupOwnerSettingDecoded = try containerValues.decodeIfPresent(GroupOwnerSetting.self, forKey: .groupOwnerSetting)
        groupOwnerSetting = groupOwnerSettingDecoded
        let sourcePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourcePath)
        sourcePath = sourcePathDecoded
    }
}

extension LocalDeviceResourceData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LocalDeviceResourceData(groupOwnerSetting: \(String(describing: groupOwnerSetting)), sourcePath: \(String(describing: sourcePath)))"}
}

/// Attributes that define a local device resource.
public struct LocalDeviceResourceData: Equatable {
    /// Group/owner related settings for local resources.
    public let groupOwnerSetting: GroupOwnerSetting?
    /// The local absolute path of the device resource. The source path for a device resource can refer only to a character device or block device under ''/dev''.
    public let sourcePath: String?

    public init (
        groupOwnerSetting: GroupOwnerSetting? = nil,
        sourcePath: String? = nil
    )
    {
        self.groupOwnerSetting = groupOwnerSetting
        self.sourcePath = sourcePath
    }
}

extension LocalVolumeResourceData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationPath = "DestinationPath"
        case groupOwnerSetting = "GroupOwnerSetting"
        case sourcePath = "SourcePath"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationPath = destinationPath {
            try encodeContainer.encode(destinationPath, forKey: .destinationPath)
        }
        if let groupOwnerSetting = groupOwnerSetting {
            try encodeContainer.encode(groupOwnerSetting, forKey: .groupOwnerSetting)
        }
        if let sourcePath = sourcePath {
            try encodeContainer.encode(sourcePath, forKey: .sourcePath)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationPath)
        destinationPath = destinationPathDecoded
        let groupOwnerSettingDecoded = try containerValues.decodeIfPresent(GroupOwnerSetting.self, forKey: .groupOwnerSetting)
        groupOwnerSetting = groupOwnerSettingDecoded
        let sourcePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourcePath)
        sourcePath = sourcePathDecoded
    }
}

extension LocalVolumeResourceData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LocalVolumeResourceData(destinationPath: \(String(describing: destinationPath)), groupOwnerSetting: \(String(describing: groupOwnerSetting)), sourcePath: \(String(describing: sourcePath)))"}
}

/// Attributes that define a local volume resource.
public struct LocalVolumeResourceData: Equatable {
    /// The absolute local path of the resource inside the Lambda environment.
    public let destinationPath: String?
    /// Allows you to configure additional group privileges for the Lambda process. This field is optional.
    public let groupOwnerSetting: GroupOwnerSetting?
    /// The local absolute path of the volume resource on the host. The source path for a volume resource type cannot start with ''/sys''.
    public let sourcePath: String?

    public init (
        destinationPath: String? = nil,
        groupOwnerSetting: GroupOwnerSetting? = nil,
        sourcePath: String? = nil
    )
    {
        self.destinationPath = destinationPath
        self.groupOwnerSetting = groupOwnerSetting
        self.sourcePath = sourcePath
    }
}

extension Logger: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case component = "Component"
        case id = "Id"
        case level = "Level"
        case space = "Space"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let component = component {
            try encodeContainer.encode(component.rawValue, forKey: .component)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let level = level {
            try encodeContainer.encode(level.rawValue, forKey: .level)
        }
        if space != 0 {
            try encodeContainer.encode(space, forKey: .space)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentDecoded = try containerValues.decodeIfPresent(LoggerComponent.self, forKey: .component)
        component = componentDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let levelDecoded = try containerValues.decodeIfPresent(LoggerLevel.self, forKey: .level)
        level = levelDecoded
        let spaceDecoded = try containerValues.decode(Int.self, forKey: .space)
        space = spaceDecoded
        let typeDecoded = try containerValues.decodeIfPresent(LoggerType.self, forKey: .type)
        type = typeDecoded
    }
}

extension Logger: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Logger(component: \(String(describing: component)), id: \(String(describing: id)), level: \(String(describing: level)), space: \(String(describing: space)), type: \(String(describing: type)))"}
}

/// Information about a logger
public struct Logger: Equatable {
    /// The component that will be subject to logging.
    public let component: LoggerComponent?
    /// A descriptive or arbitrary ID for the logger. This value must be unique within the logger definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
    public let id: String?
    /// The level of the logs.
    public let level: LoggerLevel?
    /// The amount of file space, in KB, to use if the local file system is used for logging purposes.
    public let space: Int
    /// The type of log output which will be used.
    public let type: LoggerType?

    public init (
        component: LoggerComponent? = nil,
        id: String? = nil,
        level: LoggerLevel? = nil,
        space: Int = 0,
        type: LoggerType? = nil
    )
    {
        self.component = component
        self.id = id
        self.level = level
        self.space = space
        self.type = type
    }
}

public enum LoggerComponent {
    case greengrasssystem
    case lambda
    case sdkUnknown(String)
}

extension LoggerComponent : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LoggerComponent] {
        return [
            .greengrasssystem,
            .lambda,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .greengrasssystem: return "GreengrassSystem"
        case .lambda: return "Lambda"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LoggerComponent(rawValue: rawValue) ?? LoggerComponent.sdkUnknown(rawValue)
    }
}

extension LoggerDefinitionVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case loggers = "Loggers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggers = loggers {
            var loggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loggers)
            for __listoflogger0 in loggers {
                try loggersContainer.encode(__listoflogger0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggersContainer = try containerValues.decodeIfPresent([Logger?].self, forKey: .loggers)
        var loggersDecoded0:[Logger]? = nil
        if let loggersContainer = loggersContainer {
            loggersDecoded0 = [Logger]()
            for structure0 in loggersContainer {
                if let structure0 = structure0 {
                    loggersDecoded0?.append(structure0)
                }
            }
        }
        loggers = loggersDecoded0
    }
}

extension LoggerDefinitionVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoggerDefinitionVersion(loggers: \(String(describing: loggers)))"}
}

/// Information about a logger definition version.
public struct LoggerDefinitionVersion: Equatable {
    /// A list of loggers.
    public let loggers: [Logger]?

    public init (
        loggers: [Logger]? = nil
    )
    {
        self.loggers = loggers
    }
}

public enum LoggerLevel {
    case debug
    case error
    case fatal
    case info
    case warn
    case sdkUnknown(String)
}

extension LoggerLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LoggerLevel] {
        return [
            .debug,
            .error,
            .fatal,
            .info,
            .warn,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .debug: return "DEBUG"
        case .error: return "ERROR"
        case .fatal: return "FATAL"
        case .info: return "INFO"
        case .warn: return "WARN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LoggerLevel(rawValue: rawValue) ?? LoggerLevel.sdkUnknown(rawValue)
    }
}

public enum LoggerType {
    case awscloudwatch
    case filesystem
    case sdkUnknown(String)
}

extension LoggerType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LoggerType] {
        return [
            .awscloudwatch,
            .filesystem,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awscloudwatch: return "AWSCloudWatch"
        case .filesystem: return "FileSystem"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LoggerType(rawValue: rawValue) ?? LoggerType.sdkUnknown(rawValue)
    }
}

/// The type of permission a function has to access a resource.
public enum Permission {
    case ro
    case rw
    case sdkUnknown(String)
}

extension Permission : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Permission] {
        return [
            .ro,
            .rw,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ro: return "ro"
        case .rw: return "rw"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
    }
}

public struct ResetDeploymentsInputBodyMiddleware: Middleware {
    public let id: String = "ResetDeploymentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetDeploymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetDeploymentsInput>
    public typealias MOutput = OperationOutput<ResetDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetDeploymentsOutputError>
}

extension ResetDeploymentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetDeploymentsInput(amznClientToken: \(String(describing: amznClientToken)), force: \(String(describing: force)), groupId: \(String(describing: groupId)))"}
}

extension ResetDeploymentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case force = "Force"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if force != false {
            try encodeContainer.encode(force, forKey: .force)
        }
    }
}

public struct ResetDeploymentsInputHeadersMiddleware: Middleware {
    public let id: String = "ResetDeploymentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetDeploymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetDeploymentsInput>
    public typealias MOutput = OperationOutput<ResetDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetDeploymentsOutputError>
}

public struct ResetDeploymentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ResetDeploymentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetDeploymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetDeploymentsInput>
    public typealias MOutput = OperationOutput<ResetDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetDeploymentsOutputError>
}

/// Information needed to reset deployments.
public struct ResetDeploymentsInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// If true, performs a best-effort only core reset.
    public let force: Bool
    /// The ID of the Greengrass group.
    public let groupId: String?

    public init (
        amznClientToken: String? = nil,
        force: Bool = false,
        groupId: String? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.force = force
        self.groupId = groupId
    }
}

struct ResetDeploymentsInputBody: Equatable {
    public let force: Bool
}

extension ResetDeploymentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case force = "Force"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forceDecoded = try containerValues.decode(Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension ResetDeploymentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetDeploymentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetDeploymentsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetDeploymentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetDeploymentsOutputResponse(deploymentArn: \(String(describing: deploymentArn)), deploymentId: \(String(describing: deploymentId)))"}
}

extension ResetDeploymentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResetDeploymentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deploymentArn = output.deploymentArn
            self.deploymentId = output.deploymentId
        } else {
            self.deploymentArn = nil
            self.deploymentId = nil
        }
    }
}

public struct ResetDeploymentsOutputResponse: Equatable {
    /// The ARN of the deployment.
    public let deploymentArn: String?
    /// The ID of the deployment.
    public let deploymentId: String?

    public init (
        deploymentArn: String? = nil,
        deploymentId: String? = nil
    )
    {
        self.deploymentArn = deploymentArn
        self.deploymentId = deploymentId
    }
}

struct ResetDeploymentsOutputResponseBody: Equatable {
    public let deploymentArn: String?
    public let deploymentId: String?
}

extension ResetDeploymentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deploymentArn = "DeploymentArn"
        case deploymentId = "DeploymentId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentArn)
        deploymentArn = deploymentArnDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
    }
}

extension Resource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
        case resourceDataContainer = "ResourceDataContainer"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceDataContainer = resourceDataContainer {
            try encodeContainer.encode(resourceDataContainer, forKey: .resourceDataContainer)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let resourceDataContainerDecoded = try containerValues.decodeIfPresent(ResourceDataContainer.self, forKey: .resourceDataContainer)
        resourceDataContainer = resourceDataContainerDecoded
    }
}

extension Resource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Resource(id: \(String(describing: id)), name: \(String(describing: name)), resourceDataContainer: \(String(describing: resourceDataContainer)))"}
}

/// Information about a resource.
public struct Resource: Equatable {
    /// The resource ID, used to refer to a resource in the Lambda function configuration. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''. This must be unique within a Greengrass group.
    public let id: String?
    /// The descriptive resource name, which is displayed on the AWS IoT Greengrass console. Max length 128 characters with pattern ''[a-zA-Z0-9:_-]+''. This must be unique within a Greengrass group.
    public let name: String?
    /// A container of data for all resource types.
    public let resourceDataContainer: ResourceDataContainer?

    public init (
        id: String? = nil,
        name: String? = nil,
        resourceDataContainer: ResourceDataContainer? = nil
    )
    {
        self.id = id
        self.name = name
        self.resourceDataContainer = resourceDataContainer
    }
}

extension ResourceAccessPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case permission = "Permission"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permission = permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionDecoded = try containerValues.decodeIfPresent(Permission.self, forKey: .permission)
        permission = permissionDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension ResourceAccessPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAccessPolicy(permission: \(String(describing: permission)), resourceId: \(String(describing: resourceId)))"}
}

/// A policy used by the function to access a resource.
public struct ResourceAccessPolicy: Equatable {
    /// The permissions that the Lambda function has to the resource. Can be one of ''rw'' (read/write) or ''ro'' (read-only).
    public let permission: Permission?
    /// The ID of the resource. (This ID is assigned to the resource when you create the resource definiton.)
    public let resourceId: String?

    public init (
        permission: Permission? = nil,
        resourceId: String? = nil
    )
    {
        self.permission = permission
        self.resourceId = resourceId
    }
}

extension ResourceDataContainer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case localDeviceResourceData = "LocalDeviceResourceData"
        case localVolumeResourceData = "LocalVolumeResourceData"
        case s3MachineLearningModelResourceData = "S3MachineLearningModelResourceData"
        case sageMakerMachineLearningModelResourceData = "SageMakerMachineLearningModelResourceData"
        case secretsManagerSecretResourceData = "SecretsManagerSecretResourceData"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let localDeviceResourceData = localDeviceResourceData {
            try encodeContainer.encode(localDeviceResourceData, forKey: .localDeviceResourceData)
        }
        if let localVolumeResourceData = localVolumeResourceData {
            try encodeContainer.encode(localVolumeResourceData, forKey: .localVolumeResourceData)
        }
        if let s3MachineLearningModelResourceData = s3MachineLearningModelResourceData {
            try encodeContainer.encode(s3MachineLearningModelResourceData, forKey: .s3MachineLearningModelResourceData)
        }
        if let sageMakerMachineLearningModelResourceData = sageMakerMachineLearningModelResourceData {
            try encodeContainer.encode(sageMakerMachineLearningModelResourceData, forKey: .sageMakerMachineLearningModelResourceData)
        }
        if let secretsManagerSecretResourceData = secretsManagerSecretResourceData {
            try encodeContainer.encode(secretsManagerSecretResourceData, forKey: .secretsManagerSecretResourceData)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localDeviceResourceDataDecoded = try containerValues.decodeIfPresent(LocalDeviceResourceData.self, forKey: .localDeviceResourceData)
        localDeviceResourceData = localDeviceResourceDataDecoded
        let localVolumeResourceDataDecoded = try containerValues.decodeIfPresent(LocalVolumeResourceData.self, forKey: .localVolumeResourceData)
        localVolumeResourceData = localVolumeResourceDataDecoded
        let s3MachineLearningModelResourceDataDecoded = try containerValues.decodeIfPresent(S3MachineLearningModelResourceData.self, forKey: .s3MachineLearningModelResourceData)
        s3MachineLearningModelResourceData = s3MachineLearningModelResourceDataDecoded
        let sageMakerMachineLearningModelResourceDataDecoded = try containerValues.decodeIfPresent(SageMakerMachineLearningModelResourceData.self, forKey: .sageMakerMachineLearningModelResourceData)
        sageMakerMachineLearningModelResourceData = sageMakerMachineLearningModelResourceDataDecoded
        let secretsManagerSecretResourceDataDecoded = try containerValues.decodeIfPresent(SecretsManagerSecretResourceData.self, forKey: .secretsManagerSecretResourceData)
        secretsManagerSecretResourceData = secretsManagerSecretResourceDataDecoded
    }
}

extension ResourceDataContainer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceDataContainer(localDeviceResourceData: \(String(describing: localDeviceResourceData)), localVolumeResourceData: \(String(describing: localVolumeResourceData)), s3MachineLearningModelResourceData: \(String(describing: s3MachineLearningModelResourceData)), sageMakerMachineLearningModelResourceData: \(String(describing: sageMakerMachineLearningModelResourceData)), secretsManagerSecretResourceData: \(String(describing: secretsManagerSecretResourceData)))"}
}

/// A container for resource data. The container takes only one of the following supported resource data types: ''LocalDeviceResourceData'', ''LocalVolumeResourceData'', ''SageMakerMachineLearningModelResourceData'', ''S3MachineLearningModelResourceData'', ''SecretsManagerSecretResourceData''.
public struct ResourceDataContainer: Equatable {
    /// Attributes that define the local device resource.
    public let localDeviceResourceData: LocalDeviceResourceData?
    /// Attributes that define the local volume resource.
    public let localVolumeResourceData: LocalVolumeResourceData?
    /// Attributes that define an Amazon S3 machine learning resource.
    public let s3MachineLearningModelResourceData: S3MachineLearningModelResourceData?
    /// Attributes that define an Amazon SageMaker machine learning resource.
    public let sageMakerMachineLearningModelResourceData: SageMakerMachineLearningModelResourceData?
    /// Attributes that define a secret resource, which references a secret from AWS Secrets Manager.
    public let secretsManagerSecretResourceData: SecretsManagerSecretResourceData?

    public init (
        localDeviceResourceData: LocalDeviceResourceData? = nil,
        localVolumeResourceData: LocalVolumeResourceData? = nil,
        s3MachineLearningModelResourceData: S3MachineLearningModelResourceData? = nil,
        sageMakerMachineLearningModelResourceData: SageMakerMachineLearningModelResourceData? = nil,
        secretsManagerSecretResourceData: SecretsManagerSecretResourceData? = nil
    )
    {
        self.localDeviceResourceData = localDeviceResourceData
        self.localVolumeResourceData = localVolumeResourceData
        self.s3MachineLearningModelResourceData = s3MachineLearningModelResourceData
        self.sageMakerMachineLearningModelResourceData = sageMakerMachineLearningModelResourceData
        self.secretsManagerSecretResourceData = secretsManagerSecretResourceData
    }
}

extension ResourceDefinitionVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resources = "Resources"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for __listofresource0 in resources {
                try resourcesContainer.encode(__listofresource0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension ResourceDefinitionVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceDefinitionVersion(resources: \(String(describing: resources)))"}
}

/// Information about a resource definition version.
public struct ResourceDefinitionVersion: Equatable {
    /// A list of resources.
    public let resources: [Resource]?

    public init (
        resources: [Resource]? = nil
    )
    {
        self.resources = resources
    }
}

extension ResourceDownloadOwnerSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupOwner = "GroupOwner"
        case groupPermission = "GroupPermission"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupOwner = groupOwner {
            try encodeContainer.encode(groupOwner, forKey: .groupOwner)
        }
        if let groupPermission = groupPermission {
            try encodeContainer.encode(groupPermission.rawValue, forKey: .groupPermission)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupOwner)
        groupOwner = groupOwnerDecoded
        let groupPermissionDecoded = try containerValues.decodeIfPresent(Permission.self, forKey: .groupPermission)
        groupPermission = groupPermissionDecoded
    }
}

extension ResourceDownloadOwnerSetting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceDownloadOwnerSetting(groupOwner: \(String(describing: groupOwner)), groupPermission: \(String(describing: groupPermission)))"}
}

/// The owner setting for downloaded machine learning resources.
public struct ResourceDownloadOwnerSetting: Equatable {
    /// The group owner of the resource. This is the name of an existing Linux OS group on the system or a GID. The group's permissions are added to the Lambda process.
    public let groupOwner: String?
    /// The permissions that the group owner has to the resource. Valid values are ''rw'' (read/write) or ''ro'' (read-only).
    public let groupPermission: Permission?

    public init (
        groupOwner: String? = nil,
        groupPermission: Permission? = nil
    )
    {
        self.groupOwner = groupOwner
        self.groupPermission = groupPermission
    }
}

extension RuntimeConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case telemetryConfiguration = "TelemetryConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let telemetryConfiguration = telemetryConfiguration {
            try encodeContainer.encode(telemetryConfiguration, forKey: .telemetryConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let telemetryConfigurationDecoded = try containerValues.decodeIfPresent(TelemetryConfiguration.self, forKey: .telemetryConfiguration)
        telemetryConfiguration = telemetryConfigurationDecoded
    }
}

extension RuntimeConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuntimeConfiguration(telemetryConfiguration: \(String(describing: telemetryConfiguration)))"}
}

/// Runtime configuration for a thing.
public struct RuntimeConfiguration: Equatable {
    /// Configuration for telemetry service.
    public let telemetryConfiguration: TelemetryConfiguration?

    public init (
        telemetryConfiguration: TelemetryConfiguration? = nil
    )
    {
        self.telemetryConfiguration = telemetryConfiguration
    }
}

extension S3MachineLearningModelResourceData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationPath = "DestinationPath"
        case ownerSetting = "OwnerSetting"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationPath = destinationPath {
            try encodeContainer.encode(destinationPath, forKey: .destinationPath)
        }
        if let ownerSetting = ownerSetting {
            try encodeContainer.encode(ownerSetting, forKey: .ownerSetting)
        }
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationPath)
        destinationPath = destinationPathDecoded
        let ownerSettingDecoded = try containerValues.decodeIfPresent(ResourceDownloadOwnerSetting.self, forKey: .ownerSetting)
        ownerSetting = ownerSettingDecoded
        let s3UriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension S3MachineLearningModelResourceData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3MachineLearningModelResourceData(destinationPath: \(String(describing: destinationPath)), ownerSetting: \(String(describing: ownerSetting)), s3Uri: \(String(describing: s3Uri)))"}
}

/// Attributes that define an Amazon S3 machine learning resource.
public struct S3MachineLearningModelResourceData: Equatable {
    /// The absolute local path of the resource inside the Lambda environment.
    public let destinationPath: String?
    /// The owner setting for downloaded machine learning resources.
    public let ownerSetting: ResourceDownloadOwnerSetting?
    /// The URI of the source model in an S3 bucket. The model package must be in tar.gz or .zip format.
    public let s3Uri: String?

    public init (
        destinationPath: String? = nil,
        ownerSetting: ResourceDownloadOwnerSetting? = nil,
        s3Uri: String? = nil
    )
    {
        self.destinationPath = destinationPath
        self.ownerSetting = ownerSetting
        self.s3Uri = s3Uri
    }
}

extension SageMakerMachineLearningModelResourceData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationPath = "DestinationPath"
        case ownerSetting = "OwnerSetting"
        case sageMakerJobArn = "SageMakerJobArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationPath = destinationPath {
            try encodeContainer.encode(destinationPath, forKey: .destinationPath)
        }
        if let ownerSetting = ownerSetting {
            try encodeContainer.encode(ownerSetting, forKey: .ownerSetting)
        }
        if let sageMakerJobArn = sageMakerJobArn {
            try encodeContainer.encode(sageMakerJobArn, forKey: .sageMakerJobArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationPath)
        destinationPath = destinationPathDecoded
        let ownerSettingDecoded = try containerValues.decodeIfPresent(ResourceDownloadOwnerSetting.self, forKey: .ownerSetting)
        ownerSetting = ownerSettingDecoded
        let sageMakerJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sageMakerJobArn)
        sageMakerJobArn = sageMakerJobArnDecoded
    }
}

extension SageMakerMachineLearningModelResourceData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SageMakerMachineLearningModelResourceData(destinationPath: \(String(describing: destinationPath)), ownerSetting: \(String(describing: ownerSetting)), sageMakerJobArn: \(String(describing: sageMakerJobArn)))"}
}

/// Attributes that define an Amazon SageMaker machine learning resource.
public struct SageMakerMachineLearningModelResourceData: Equatable {
    /// The absolute local path of the resource inside the Lambda environment.
    public let destinationPath: String?
    /// The owner setting for downloaded machine learning resources.
    public let ownerSetting: ResourceDownloadOwnerSetting?
    /// The ARN of the Amazon SageMaker training job that represents the source model.
    public let sageMakerJobArn: String?

    public init (
        destinationPath: String? = nil,
        ownerSetting: ResourceDownloadOwnerSetting? = nil,
        sageMakerJobArn: String? = nil
    )
    {
        self.destinationPath = destinationPath
        self.ownerSetting = ownerSetting
        self.sageMakerJobArn = sageMakerJobArn
    }
}

extension SecretsManagerSecretResourceData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case additionalStagingLabelsToDownload = "AdditionalStagingLabelsToDownload"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let additionalStagingLabelsToDownload = additionalStagingLabelsToDownload {
            var additionalStagingLabelsToDownloadContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalStagingLabelsToDownload)
            for __listof__string0 in additionalStagingLabelsToDownload {
                try additionalStagingLabelsToDownloadContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let additionalStagingLabelsToDownloadContainer = try containerValues.decodeIfPresent([String?].self, forKey: .additionalStagingLabelsToDownload)
        var additionalStagingLabelsToDownloadDecoded0:[String]? = nil
        if let additionalStagingLabelsToDownloadContainer = additionalStagingLabelsToDownloadContainer {
            additionalStagingLabelsToDownloadDecoded0 = [String]()
            for string0 in additionalStagingLabelsToDownloadContainer {
                if let string0 = string0 {
                    additionalStagingLabelsToDownloadDecoded0?.append(string0)
                }
            }
        }
        additionalStagingLabelsToDownload = additionalStagingLabelsToDownloadDecoded0
    }
}

extension SecretsManagerSecretResourceData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SecretsManagerSecretResourceData(aRN: \(String(describing: aRN)), additionalStagingLabelsToDownload: \(String(describing: additionalStagingLabelsToDownload)))"}
}

/// Attributes that define a secret resource, which references a secret from AWS Secrets Manager. AWS IoT Greengrass stores a local, encrypted copy of the secret on the Greengrass core, where it can be securely accessed by connectors and Lambda functions.
public struct SecretsManagerSecretResourceData: Equatable {
    /// The ARN of the Secrets Manager secret to make available on the core. The value of the secret's latest version (represented by the ''AWSCURRENT'' staging label) is included by default.
    public let aRN: String?
    /// Optional. The staging labels whose values you want to make available on the core, in addition to ''AWSCURRENT''.
    public let additionalStagingLabelsToDownload: [String]?

    public init (
        aRN: String? = nil,
        additionalStagingLabelsToDownload: [String]? = nil
    )
    {
        self.aRN = aRN
        self.additionalStagingLabelsToDownload = additionalStagingLabelsToDownload
    }
}

/// The piece of software on the Greengrass core that will be updated.
public enum SoftwareToUpdate {
    case core
    case otaAgent
    case sdkUnknown(String)
}

extension SoftwareToUpdate : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SoftwareToUpdate] {
        return [
            .core,
            .otaAgent,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .core: return "core"
        case .otaAgent: return "ota_agent"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SoftwareToUpdate(rawValue: rawValue) ?? SoftwareToUpdate.sdkUnknown(rawValue)
    }
}

public struct StartBulkDeploymentInputBodyMiddleware: Middleware {
    public let id: String = "StartBulkDeploymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartBulkDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartBulkDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartBulkDeploymentInput>
    public typealias MOutput = OperationOutput<StartBulkDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartBulkDeploymentOutputError>
}

extension StartBulkDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartBulkDeploymentInput(amznClientToken: \(String(describing: amznClientToken)), executionRoleArn: \(String(describing: executionRoleArn)), inputFileUri: \(String(describing: inputFileUri)), tags: \(String(describing: tags)))"}
}

extension StartBulkDeploymentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case executionRoleArn = "ExecutionRoleArn"
        case inputFileUri = "InputFileUri"
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let inputFileUri = inputFileUri {
            try encodeContainer.encode(inputFileUri, forKey: .inputFileUri)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct StartBulkDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "StartBulkDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartBulkDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartBulkDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let amznClientToken = input.operationInput.amznClientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(amznClientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartBulkDeploymentInput>
    public typealias MOutput = OperationOutput<StartBulkDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartBulkDeploymentOutputError>
}

public struct StartBulkDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "StartBulkDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartBulkDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartBulkDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartBulkDeploymentInput>
    public typealias MOutput = OperationOutput<StartBulkDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartBulkDeploymentOutputError>
}

public struct StartBulkDeploymentInput: Equatable {
    /// A client token used to correlate requests and responses.
    public let amznClientToken: String?
    /// The ARN of the execution role to associate with the bulk deployment operation. This IAM role must allow the ''greengrass:CreateDeployment'' action for all group versions that are listed in the input file. This IAM role must have access to the S3 bucket containing the input file.
    public let executionRoleArn: String?
    /// The URI of the input file contained in the S3 bucket. The execution role must have ''getObject'' permissions on this bucket to access the input file. The input file is a JSON-serialized, line delimited file with UTF-8 encoding that provides a list of group and version IDs and the deployment type. This file must be less than 100 MB. Currently, AWS IoT Greengrass supports only ''NewDeployment'' deployment types.
    public let inputFileUri: String?
    /// Tag(s) to add to the new resource.
    public let tags: [String:String]?

    public init (
        amznClientToken: String? = nil,
        executionRoleArn: String? = nil,
        inputFileUri: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.executionRoleArn = executionRoleArn
        self.inputFileUri = inputFileUri
        self.tags = tags
    }
}

struct StartBulkDeploymentInputBody: Equatable {
    public let executionRoleArn: String?
    public let inputFileUri: String?
    public let tags: [String:String]?
}

extension StartBulkDeploymentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case executionRoleArn = "ExecutionRoleArn"
        case inputFileUri = "InputFileUri"
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let inputFileUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputFileUri)
        inputFileUri = inputFileUriDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartBulkDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartBulkDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartBulkDeploymentOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartBulkDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartBulkDeploymentOutputResponse(bulkDeploymentArn: \(String(describing: bulkDeploymentArn)), bulkDeploymentId: \(String(describing: bulkDeploymentId)))"}
}

extension StartBulkDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartBulkDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bulkDeploymentArn = output.bulkDeploymentArn
            self.bulkDeploymentId = output.bulkDeploymentId
        } else {
            self.bulkDeploymentArn = nil
            self.bulkDeploymentId = nil
        }
    }
}

public struct StartBulkDeploymentOutputResponse: Equatable {
    /// The ARN of the bulk deployment.
    public let bulkDeploymentArn: String?
    /// The ID of the bulk deployment.
    public let bulkDeploymentId: String?

    public init (
        bulkDeploymentArn: String? = nil,
        bulkDeploymentId: String? = nil
    )
    {
        self.bulkDeploymentArn = bulkDeploymentArn
        self.bulkDeploymentId = bulkDeploymentId
    }
}

struct StartBulkDeploymentOutputResponseBody: Equatable {
    public let bulkDeploymentArn: String?
    public let bulkDeploymentId: String?
}

extension StartBulkDeploymentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bulkDeploymentArn = "BulkDeploymentArn"
        case bulkDeploymentId = "BulkDeploymentId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bulkDeploymentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bulkDeploymentArn)
        bulkDeploymentArn = bulkDeploymentArnDecoded
        let bulkDeploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bulkDeploymentId)
        bulkDeploymentId = bulkDeploymentIdDecoded
    }
}

extension StopBulkDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopBulkDeploymentInput(bulkDeploymentId: \(String(describing: bulkDeploymentId)))"}
}

extension StopBulkDeploymentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StopBulkDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "StopBulkDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopBulkDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<StopBulkDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopBulkDeploymentInput>
    public typealias MOutput = OperationOutput<StopBulkDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopBulkDeploymentOutputError>
}

public struct StopBulkDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "StopBulkDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopBulkDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<StopBulkDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopBulkDeploymentInput>
    public typealias MOutput = OperationOutput<StopBulkDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopBulkDeploymentOutputError>
}

public struct StopBulkDeploymentInput: Equatable {
    /// The ID of the bulk deployment.
    public let bulkDeploymentId: String?

    public init (
        bulkDeploymentId: String? = nil
    )
    {
        self.bulkDeploymentId = bulkDeploymentId
    }
}

struct StopBulkDeploymentInputBody: Equatable {
}

extension StopBulkDeploymentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StopBulkDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopBulkDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopBulkDeploymentOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopBulkDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopBulkDeploymentOutputResponse()"}
}

extension StopBulkDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopBulkDeploymentOutputResponse: Equatable {

    public init() {}
}

struct StopBulkDeploymentOutputResponseBody: Equatable {
}

extension StopBulkDeploymentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Subscription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case source = "Source"
        case subject = "Subject"
        case target = "Target"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
    }
}

extension Subscription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Subscription(id: \(String(describing: id)), source: \(String(describing: source)), subject: \(String(describing: subject)), target: \(String(describing: target)))"}
}

/// Information about a subscription.
public struct Subscription: Equatable {
    /// A descriptive or arbitrary ID for the subscription. This value must be unique within the subscription definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
    public let id: String?
    /// The source of the subscription. Can be a thing ARN, a Lambda function ARN, a connector ARN, 'cloud' (which represents the AWS IoT cloud), or 'GGShadowService'.
    public let source: String?
    /// The MQTT topic used to route the message.
    public let subject: String?
    /// Where the message is sent to. Can be a thing ARN, a Lambda function ARN, a connector ARN, 'cloud' (which represents the AWS IoT cloud), or 'GGShadowService'.
    public let target: String?

    public init (
        id: String? = nil,
        source: String? = nil,
        subject: String? = nil,
        target: String? = nil
    )
    {
        self.id = id
        self.source = source
        self.subject = subject
        self.target = target
    }
}

extension SubscriptionDefinitionVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case subscriptions = "Subscriptions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subscriptions = subscriptions {
            var subscriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscriptions)
            for __listofsubscription0 in subscriptions {
                try subscriptionsContainer.encode(__listofsubscription0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionsContainer = try containerValues.decodeIfPresent([Subscription?].self, forKey: .subscriptions)
        var subscriptionsDecoded0:[Subscription]? = nil
        if let subscriptionsContainer = subscriptionsContainer {
            subscriptionsDecoded0 = [Subscription]()
            for structure0 in subscriptionsContainer {
                if let structure0 = structure0 {
                    subscriptionsDecoded0?.append(structure0)
                }
            }
        }
        subscriptions = subscriptionsDecoded0
    }
}

extension SubscriptionDefinitionVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscriptionDefinitionVersion(subscriptions: \(String(describing: subscriptions)))"}
}

/// Information about a subscription definition version.
public struct SubscriptionDefinitionVersion: Equatable {
    /// A list of subscriptions.
    public let subscriptions: [Subscription]?

    public init (
        subscriptions: [Subscription]? = nil
    )
    {
        self.subscriptions = subscriptions
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

/// A map of the key-value pairs for the resource tag.
public struct TagResourceInput: Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    public let resourceArn: String?
    /// The key-value pair for the resource tag.
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum Telemetry {
    case off
    case on
    case sdkUnknown(String)
}

extension Telemetry : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Telemetry] {
        return [
            .off,
            .on,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .off: return "Off"
        case .on: return "On"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Telemetry(rawValue: rawValue) ?? Telemetry.sdkUnknown(rawValue)
    }
}

extension TelemetryConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationSyncStatus = "ConfigurationSyncStatus"
        case telemetry = "Telemetry"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSyncStatus = configurationSyncStatus {
            try encodeContainer.encode(configurationSyncStatus.rawValue, forKey: .configurationSyncStatus)
        }
        if let telemetry = telemetry {
            try encodeContainer.encode(telemetry.rawValue, forKey: .telemetry)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSyncStatusDecoded = try containerValues.decodeIfPresent(ConfigurationSyncStatus.self, forKey: .configurationSyncStatus)
        configurationSyncStatus = configurationSyncStatusDecoded
        let telemetryDecoded = try containerValues.decodeIfPresent(Telemetry.self, forKey: .telemetry)
        telemetry = telemetryDecoded
    }
}

extension TelemetryConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TelemetryConfiguration(configurationSyncStatus: \(String(describing: configurationSyncStatus)), telemetry: \(String(describing: telemetry)))"}
}

/// Configuration settings for running telemetry.
public struct TelemetryConfiguration: Equatable {
    /// Synchronization status of the device reported configuration with the desired configuration.
    public let configurationSyncStatus: ConfigurationSyncStatus?
    /// Configure telemetry to be on or off.
    public let telemetry: Telemetry?

    public init (
        configurationSyncStatus: ConfigurationSyncStatus? = nil,
        telemetry: Telemetry? = nil
    )
    {
        self.configurationSyncStatus = configurationSyncStatus
        self.telemetry = telemetry
    }
}

extension TelemetryConfigurationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case telemetry = "Telemetry"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let telemetry = telemetry {
            try encodeContainer.encode(telemetry.rawValue, forKey: .telemetry)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let telemetryDecoded = try containerValues.decodeIfPresent(Telemetry.self, forKey: .telemetry)
        telemetry = telemetryDecoded
    }
}

extension TelemetryConfigurationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TelemetryConfigurationUpdate(telemetry: \(String(describing: telemetry)))"}
}

/// Configuration settings for running telemetry.
public struct TelemetryConfigurationUpdate: Equatable {
    /// Configure telemetry to be on or off.
    public let telemetry: Telemetry?

    public init (
        telemetry: Telemetry? = nil
    )
    {
        self.telemetry = telemetry
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    public let resourceArn: String?
    /// An array of tag keys to delete
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

/// The minimum level of log statements that should be logged by the OTA Agent during an update.
public enum UpdateAgentLogLevel {
    case debug
    case error
    case fatal
    case info
    case `none`
    case trace
    case verbose
    case warn
    case sdkUnknown(String)
}

extension UpdateAgentLogLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UpdateAgentLogLevel] {
        return [
            .debug,
            .error,
            .fatal,
            .info,
            .none,
            .trace,
            .verbose,
            .warn,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .debug: return "DEBUG"
        case .error: return "ERROR"
        case .fatal: return "FATAL"
        case .info: return "INFO"
        case .none: return "NONE"
        case .trace: return "TRACE"
        case .verbose: return "VERBOSE"
        case .warn: return "WARN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UpdateAgentLogLevel(rawValue: rawValue) ?? UpdateAgentLogLevel.sdkUnknown(rawValue)
    }
}

public struct UpdateConnectivityInfoInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConnectivityInfoInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectivityInfoInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectivityInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectivityInfoInput>
    public typealias MOutput = OperationOutput<UpdateConnectivityInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectivityInfoOutputError>
}

extension UpdateConnectivityInfoInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectivityInfoInput(connectivityInfo: \(String(describing: connectivityInfo)), thingName: \(String(describing: thingName)))"}
}

extension UpdateConnectivityInfoInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectivityInfo = "ConnectivityInfo"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectivityInfo = connectivityInfo {
            var connectivityInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectivityInfo)
            for __listofconnectivityinfo0 in connectivityInfo {
                try connectivityInfoContainer.encode(__listofconnectivityinfo0)
            }
        }
    }
}

public struct UpdateConnectivityInfoInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConnectivityInfoInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectivityInfoInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectivityInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectivityInfoInput>
    public typealias MOutput = OperationOutput<UpdateConnectivityInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectivityInfoOutputError>
}

public struct UpdateConnectivityInfoInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConnectivityInfoInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectivityInfoInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectivityInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectivityInfoInput>
    public typealias MOutput = OperationOutput<UpdateConnectivityInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectivityInfoOutputError>
}

/// Connectivity information.
public struct UpdateConnectivityInfoInput: Equatable {
    /// A list of connectivity info.
    public let connectivityInfo: [ConnectivityInfo]?
    /// The thing name.
    public let thingName: String?

    public init (
        connectivityInfo: [ConnectivityInfo]? = nil,
        thingName: String? = nil
    )
    {
        self.connectivityInfo = connectivityInfo
        self.thingName = thingName
    }
}

struct UpdateConnectivityInfoInputBody: Equatable {
    public let connectivityInfo: [ConnectivityInfo]?
}

extension UpdateConnectivityInfoInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectivityInfo = "ConnectivityInfo"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectivityInfoContainer = try containerValues.decodeIfPresent([ConnectivityInfo?].self, forKey: .connectivityInfo)
        var connectivityInfoDecoded0:[ConnectivityInfo]? = nil
        if let connectivityInfoContainer = connectivityInfoContainer {
            connectivityInfoDecoded0 = [ConnectivityInfo]()
            for structure0 in connectivityInfoContainer {
                if let structure0 = structure0 {
                    connectivityInfoDecoded0?.append(structure0)
                }
            }
        }
        connectivityInfo = connectivityInfoDecoded0
    }
}

extension UpdateConnectivityInfoOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectivityInfoOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConnectivityInfoOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectivityInfoOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectivityInfoOutputResponse(message: \(String(describing: message)), version: \(String(describing: version)))"}
}

extension UpdateConnectivityInfoOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateConnectivityInfoOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.version = output.version
        } else {
            self.message = nil
            self.version = nil
        }
    }
}

public struct UpdateConnectivityInfoOutputResponse: Equatable {
    /// A message about the connectivity info update request.
    public let message: String?
    /// The new version of the connectivity info.
    public let version: String?

    public init (
        message: String? = nil,
        version: String? = nil
    )
    {
        self.message = message
        self.version = version
    }
}

struct UpdateConnectivityInfoOutputResponseBody: Equatable {
    public let message: String?
    public let version: String?
}

extension UpdateConnectivityInfoOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

public struct UpdateConnectorDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConnectorDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectorDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectorDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectorDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateConnectorDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectorDefinitionOutputError>
}

extension UpdateConnectorDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectorDefinitionInput(connectorDefinitionId: \(String(describing: connectorDefinitionId)), name: \(String(describing: name)))"}
}

extension UpdateConnectorDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateConnectorDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConnectorDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectorDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectorDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectorDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateConnectorDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectorDefinitionOutputError>
}

public struct UpdateConnectorDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConnectorDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectorDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectorDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectorDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateConnectorDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectorDefinitionOutputError>
}

public struct UpdateConnectorDefinitionInput: Equatable {
    /// The ID of the connector definition.
    public let connectorDefinitionId: String?
    /// The name of the definition.
    public let name: String?

    public init (
        connectorDefinitionId: String? = nil,
        name: String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
        self.name = name
    }
}

struct UpdateConnectorDefinitionInputBody: Equatable {
    public let name: String?
}

extension UpdateConnectorDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateConnectorDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectorDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConnectorDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectorDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectorDefinitionOutputResponse()"}
}

extension UpdateConnectorDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateConnectorDefinitionOutputResponse: Equatable {

    public init() {}
}

struct UpdateConnectorDefinitionOutputResponseBody: Equatable {
}

extension UpdateConnectorDefinitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateCoreDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCoreDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCoreDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCoreDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCoreDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateCoreDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCoreDefinitionOutputError>
}

extension UpdateCoreDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCoreDefinitionInput(coreDefinitionId: \(String(describing: coreDefinitionId)), name: \(String(describing: name)))"}
}

extension UpdateCoreDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateCoreDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCoreDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCoreDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCoreDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCoreDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateCoreDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCoreDefinitionOutputError>
}

public struct UpdateCoreDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCoreDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCoreDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCoreDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCoreDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateCoreDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCoreDefinitionOutputError>
}

public struct UpdateCoreDefinitionInput: Equatable {
    /// The ID of the core definition.
    public let coreDefinitionId: String?
    /// The name of the definition.
    public let name: String?

    public init (
        coreDefinitionId: String? = nil,
        name: String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
        self.name = name
    }
}

struct UpdateCoreDefinitionInputBody: Equatable {
    public let name: String?
}

extension UpdateCoreDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateCoreDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCoreDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCoreDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCoreDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCoreDefinitionOutputResponse()"}
}

extension UpdateCoreDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateCoreDefinitionOutputResponse: Equatable {

    public init() {}
}

struct UpdateCoreDefinitionOutputResponseBody: Equatable {
}

extension UpdateCoreDefinitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDeviceDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDeviceDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeviceDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeviceDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeviceDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateDeviceDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeviceDefinitionOutputError>
}

extension UpdateDeviceDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDeviceDefinitionInput(deviceDefinitionId: \(String(describing: deviceDefinitionId)), name: \(String(describing: name)))"}
}

extension UpdateDeviceDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateDeviceDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDeviceDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeviceDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeviceDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeviceDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateDeviceDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeviceDefinitionOutputError>
}

public struct UpdateDeviceDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDeviceDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeviceDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeviceDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeviceDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateDeviceDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeviceDefinitionOutputError>
}

public struct UpdateDeviceDefinitionInput: Equatable {
    /// The ID of the device definition.
    public let deviceDefinitionId: String?
    /// The name of the definition.
    public let name: String?

    public init (
        deviceDefinitionId: String? = nil,
        name: String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
        self.name = name
    }
}

struct UpdateDeviceDefinitionInputBody: Equatable {
    public let name: String?
}

extension UpdateDeviceDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateDeviceDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeviceDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDeviceDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeviceDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDeviceDefinitionOutputResponse()"}
}

extension UpdateDeviceDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDeviceDefinitionOutputResponse: Equatable {

    public init() {}
}

struct UpdateDeviceDefinitionOutputResponseBody: Equatable {
}

extension UpdateDeviceDefinitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateFunctionDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFunctionDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFunctionDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFunctionDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFunctionDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateFunctionDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFunctionDefinitionOutputError>
}

extension UpdateFunctionDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFunctionDefinitionInput(functionDefinitionId: \(String(describing: functionDefinitionId)), name: \(String(describing: name)))"}
}

extension UpdateFunctionDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateFunctionDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFunctionDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFunctionDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFunctionDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFunctionDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateFunctionDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFunctionDefinitionOutputError>
}

public struct UpdateFunctionDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFunctionDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFunctionDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFunctionDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFunctionDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateFunctionDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFunctionDefinitionOutputError>
}

public struct UpdateFunctionDefinitionInput: Equatable {
    /// The ID of the Lambda function definition.
    public let functionDefinitionId: String?
    /// The name of the definition.
    public let name: String?

    public init (
        functionDefinitionId: String? = nil,
        name: String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
        self.name = name
    }
}

struct UpdateFunctionDefinitionInputBody: Equatable {
    public let name: String?
}

extension UpdateFunctionDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateFunctionDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFunctionDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFunctionDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFunctionDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFunctionDefinitionOutputResponse()"}
}

extension UpdateFunctionDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFunctionDefinitionOutputResponse: Equatable {

    public init() {}
}

struct UpdateFunctionDefinitionOutputResponseBody: Equatable {
}

extension UpdateFunctionDefinitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateGroupCertificateConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGroupCertificateConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupCertificateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupCertificateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupCertificateConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateGroupCertificateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupCertificateConfigurationOutputError>
}

extension UpdateGroupCertificateConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGroupCertificateConfigurationInput(certificateExpiryInMilliseconds: \(String(describing: certificateExpiryInMilliseconds)), groupId: \(String(describing: groupId)))"}
}

extension UpdateGroupCertificateConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateExpiryInMilliseconds = "CertificateExpiryInMilliseconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateExpiryInMilliseconds = certificateExpiryInMilliseconds {
            try encodeContainer.encode(certificateExpiryInMilliseconds, forKey: .certificateExpiryInMilliseconds)
        }
    }
}

public struct UpdateGroupCertificateConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGroupCertificateConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupCertificateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupCertificateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupCertificateConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateGroupCertificateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupCertificateConfigurationOutputError>
}

public struct UpdateGroupCertificateConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGroupCertificateConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupCertificateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupCertificateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupCertificateConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateGroupCertificateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupCertificateConfigurationOutputError>
}

public struct UpdateGroupCertificateConfigurationInput: Equatable {
    /// The amount of time remaining before the certificate expires, in milliseconds.
    public let certificateExpiryInMilliseconds: String?
    /// The ID of the Greengrass group.
    public let groupId: String?

    public init (
        certificateExpiryInMilliseconds: String? = nil,
        groupId: String? = nil
    )
    {
        self.certificateExpiryInMilliseconds = certificateExpiryInMilliseconds
        self.groupId = groupId
    }
}

struct UpdateGroupCertificateConfigurationInputBody: Equatable {
    public let certificateExpiryInMilliseconds: String?
}

extension UpdateGroupCertificateConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateExpiryInMilliseconds = "CertificateExpiryInMilliseconds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateExpiryInMillisecondsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateExpiryInMilliseconds)
        certificateExpiryInMilliseconds = certificateExpiryInMillisecondsDecoded
    }
}

extension UpdateGroupCertificateConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGroupCertificateConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGroupCertificateConfigurationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGroupCertificateConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGroupCertificateConfigurationOutputResponse(certificateAuthorityExpiryInMilliseconds: \(String(describing: certificateAuthorityExpiryInMilliseconds)), certificateExpiryInMilliseconds: \(String(describing: certificateExpiryInMilliseconds)), groupId: \(String(describing: groupId)))"}
}

extension UpdateGroupCertificateConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateGroupCertificateConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificateAuthorityExpiryInMilliseconds = output.certificateAuthorityExpiryInMilliseconds
            self.certificateExpiryInMilliseconds = output.certificateExpiryInMilliseconds
            self.groupId = output.groupId
        } else {
            self.certificateAuthorityExpiryInMilliseconds = nil
            self.certificateExpiryInMilliseconds = nil
            self.groupId = nil
        }
    }
}

public struct UpdateGroupCertificateConfigurationOutputResponse: Equatable {
    /// The amount of time remaining before the certificate authority expires, in milliseconds.
    public let certificateAuthorityExpiryInMilliseconds: String?
    /// The amount of time remaining before the certificate expires, in milliseconds.
    public let certificateExpiryInMilliseconds: String?
    /// The ID of the group certificate configuration.
    public let groupId: String?

    public init (
        certificateAuthorityExpiryInMilliseconds: String? = nil,
        certificateExpiryInMilliseconds: String? = nil,
        groupId: String? = nil
    )
    {
        self.certificateAuthorityExpiryInMilliseconds = certificateAuthorityExpiryInMilliseconds
        self.certificateExpiryInMilliseconds = certificateExpiryInMilliseconds
        self.groupId = groupId
    }
}

struct UpdateGroupCertificateConfigurationOutputResponseBody: Equatable {
    public let certificateAuthorityExpiryInMilliseconds: String?
    public let certificateExpiryInMilliseconds: String?
    public let groupId: String?
}

extension UpdateGroupCertificateConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityExpiryInMilliseconds = "CertificateAuthorityExpiryInMilliseconds"
        case certificateExpiryInMilliseconds = "CertificateExpiryInMilliseconds"
        case groupId = "GroupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityExpiryInMillisecondsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityExpiryInMilliseconds)
        certificateAuthorityExpiryInMilliseconds = certificateAuthorityExpiryInMillisecondsDecoded
        let certificateExpiryInMillisecondsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateExpiryInMilliseconds)
        certificateExpiryInMilliseconds = certificateExpiryInMillisecondsDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

public struct UpdateGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupInput>
    public typealias MOutput = OperationOutput<UpdateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupOutputError>
}

extension UpdateGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGroupInput(groupId: \(String(describing: groupId)), name: \(String(describing: name)))"}
}

extension UpdateGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupInput>
    public typealias MOutput = OperationOutput<UpdateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupOutputError>
}

public struct UpdateGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupInput>
    public typealias MOutput = OperationOutput<UpdateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupOutputError>
}

public struct UpdateGroupInput: Equatable {
    /// The ID of the Greengrass group.
    public let groupId: String?
    /// The name of the definition.
    public let name: String?

    public init (
        groupId: String? = nil,
        name: String? = nil
    )
    {
        self.groupId = groupId
        self.name = name
    }
}

struct UpdateGroupInputBody: Equatable {
    public let name: String?
}

extension UpdateGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGroupOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGroupOutputResponse()"}
}

extension UpdateGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateGroupOutputResponse: Equatable {

    public init() {}
}

struct UpdateGroupOutputResponseBody: Equatable {
}

extension UpdateGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateLoggerDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLoggerDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLoggerDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLoggerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLoggerDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateLoggerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLoggerDefinitionOutputError>
}

extension UpdateLoggerDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLoggerDefinitionInput(loggerDefinitionId: \(String(describing: loggerDefinitionId)), name: \(String(describing: name)))"}
}

extension UpdateLoggerDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateLoggerDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLoggerDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLoggerDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLoggerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLoggerDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateLoggerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLoggerDefinitionOutputError>
}

public struct UpdateLoggerDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLoggerDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLoggerDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLoggerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLoggerDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateLoggerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLoggerDefinitionOutputError>
}

public struct UpdateLoggerDefinitionInput: Equatable {
    /// The ID of the logger definition.
    public let loggerDefinitionId: String?
    /// The name of the definition.
    public let name: String?

    public init (
        loggerDefinitionId: String? = nil,
        name: String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
        self.name = name
    }
}

struct UpdateLoggerDefinitionInputBody: Equatable {
    public let name: String?
}

extension UpdateLoggerDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateLoggerDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLoggerDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLoggerDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLoggerDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLoggerDefinitionOutputResponse()"}
}

extension UpdateLoggerDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLoggerDefinitionOutputResponse: Equatable {

    public init() {}
}

struct UpdateLoggerDefinitionOutputResponseBody: Equatable {
}

extension UpdateLoggerDefinitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateResourceDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateResourceDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateResourceDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceDefinitionOutputError>
}

extension UpdateResourceDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResourceDefinitionInput(name: \(String(describing: name)), resourceDefinitionId: \(String(describing: resourceDefinitionId)))"}
}

extension UpdateResourceDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateResourceDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateResourceDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateResourceDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceDefinitionOutputError>
}

public struct UpdateResourceDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateResourceDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateResourceDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceDefinitionOutputError>
}

public struct UpdateResourceDefinitionInput: Equatable {
    /// The name of the definition.
    public let name: String?
    /// The ID of the resource definition.
    public let resourceDefinitionId: String?

    public init (
        name: String? = nil,
        resourceDefinitionId: String? = nil
    )
    {
        self.name = name
        self.resourceDefinitionId = resourceDefinitionId
    }
}

struct UpdateResourceDefinitionInputBody: Equatable {
    public let name: String?
}

extension UpdateResourceDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateResourceDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResourceDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResourceDefinitionOutputResponse()"}
}

extension UpdateResourceDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateResourceDefinitionOutputResponse: Equatable {

    public init() {}
}

struct UpdateResourceDefinitionOutputResponseBody: Equatable {
}

extension UpdateResourceDefinitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateSubscriptionDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSubscriptionDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSubscriptionDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSubscriptionDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSubscriptionDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateSubscriptionDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSubscriptionDefinitionOutputError>
}

extension UpdateSubscriptionDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSubscriptionDefinitionInput(name: \(String(describing: name)), subscriptionDefinitionId: \(String(describing: subscriptionDefinitionId)))"}
}

extension UpdateSubscriptionDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateSubscriptionDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSubscriptionDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSubscriptionDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSubscriptionDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSubscriptionDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateSubscriptionDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSubscriptionDefinitionOutputError>
}

public struct UpdateSubscriptionDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSubscriptionDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSubscriptionDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSubscriptionDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSubscriptionDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateSubscriptionDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSubscriptionDefinitionOutputError>
}

public struct UpdateSubscriptionDefinitionInput: Equatable {
    /// The name of the definition.
    public let name: String?
    /// The ID of the subscription definition.
    public let subscriptionDefinitionId: String?

    public init (
        name: String? = nil,
        subscriptionDefinitionId: String? = nil
    )
    {
        self.name = name
        self.subscriptionDefinitionId = subscriptionDefinitionId
    }
}

struct UpdateSubscriptionDefinitionInputBody: Equatable {
    public let name: String?
}

extension UpdateSubscriptionDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateSubscriptionDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSubscriptionDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSubscriptionDefinitionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSubscriptionDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSubscriptionDefinitionOutputResponse()"}
}

extension UpdateSubscriptionDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateSubscriptionDefinitionOutputResponse: Equatable {

    public init() {}
}

struct UpdateSubscriptionDefinitionOutputResponseBody: Equatable {
}

extension UpdateSubscriptionDefinitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

/// The architecture of the cores which are the targets of an update.
public enum UpdateTargetsArchitecture {
    case aarch64
    case armv6l
    case armv7l
    case x8664
    case sdkUnknown(String)
}

extension UpdateTargetsArchitecture : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UpdateTargetsArchitecture] {
        return [
            .aarch64,
            .armv6l,
            .armv7l,
            .x8664,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aarch64: return "aarch64"
        case .armv6l: return "armv6l"
        case .armv7l: return "armv7l"
        case .x8664: return "x86_64"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UpdateTargetsArchitecture(rawValue: rawValue) ?? UpdateTargetsArchitecture.sdkUnknown(rawValue)
    }
}

/// The operating system of the cores which are the targets of an update.
public enum UpdateTargetsOperatingSystem {
    case amazonLinux
    case openwrt
    case raspbian
    case ubuntu
    case sdkUnknown(String)
}

extension UpdateTargetsOperatingSystem : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UpdateTargetsOperatingSystem] {
        return [
            .amazonLinux,
            .openwrt,
            .raspbian,
            .ubuntu,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .amazonLinux: return "amazon_linux"
        case .openwrt: return "openwrt"
        case .raspbian: return "raspbian"
        case .ubuntu: return "ubuntu"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UpdateTargetsOperatingSystem(rawValue: rawValue) ?? UpdateTargetsOperatingSystem.sdkUnknown(rawValue)
    }
}

public struct UpdateThingRuntimeConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateThingRuntimeConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThingRuntimeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThingRuntimeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThingRuntimeConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateThingRuntimeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThingRuntimeConfigurationOutputError>
}

extension UpdateThingRuntimeConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateThingRuntimeConfigurationInput(telemetryConfiguration: \(String(describing: telemetryConfiguration)), thingName: \(String(describing: thingName)))"}
}

extension UpdateThingRuntimeConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case telemetryConfiguration = "TelemetryConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let telemetryConfiguration = telemetryConfiguration {
            try encodeContainer.encode(telemetryConfiguration, forKey: .telemetryConfiguration)
        }
    }
}

public struct UpdateThingRuntimeConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateThingRuntimeConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThingRuntimeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThingRuntimeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThingRuntimeConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateThingRuntimeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThingRuntimeConfigurationOutputError>
}

public struct UpdateThingRuntimeConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateThingRuntimeConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThingRuntimeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThingRuntimeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThingRuntimeConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateThingRuntimeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThingRuntimeConfigurationOutputError>
}

public struct UpdateThingRuntimeConfigurationInput: Equatable {
    /// Configuration for telemetry service.
    public let telemetryConfiguration: TelemetryConfigurationUpdate?
    /// The thing name.
    public let thingName: String?

    public init (
        telemetryConfiguration: TelemetryConfigurationUpdate? = nil,
        thingName: String? = nil
    )
    {
        self.telemetryConfiguration = telemetryConfiguration
        self.thingName = thingName
    }
}

struct UpdateThingRuntimeConfigurationInputBody: Equatable {
    public let telemetryConfiguration: TelemetryConfigurationUpdate?
}

extension UpdateThingRuntimeConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case telemetryConfiguration = "TelemetryConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let telemetryConfigurationDecoded = try containerValues.decodeIfPresent(TelemetryConfigurationUpdate.self, forKey: .telemetryConfiguration)
        telemetryConfiguration = telemetryConfigurationDecoded
    }
}

extension UpdateThingRuntimeConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThingRuntimeConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateThingRuntimeConfigurationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThingRuntimeConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateThingRuntimeConfigurationOutputResponse()"}
}

extension UpdateThingRuntimeConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateThingRuntimeConfigurationOutputResponse: Equatable {

    public init() {}
}

struct UpdateThingRuntimeConfigurationOutputResponseBody: Equatable {
}

extension UpdateThingRuntimeConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension VersionInformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp, forKey: .creationTimestamp)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension VersionInformation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VersionInformation(arn: \(String(describing: arn)), creationTimestamp: \(String(describing: creationTimestamp)), id: \(String(describing: id)), version: \(String(describing: version)))"}
}

/// Information about a version.
public struct VersionInformation: Equatable {
    /// The ARN of the version.
    public let arn: String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public let creationTimestamp: String?
    /// The ID of the parent definition that the version is associated with.
    public let id: String?
    /// The ID of the version.
    public let version: String?

    public init (
        arn: String? = nil,
        creationTimestamp: String? = nil,
        id: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}
